(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{396:function(e,t,o){"use strict";o.r(t);var a=o(2),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"阻塞队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列"}},[e._v("#")]),e._v(" 阻塞队列")]),e._v(" "),t("p",[e._v("队列：先进先出。排队买票。")]),e._v(" "),t("p",[e._v("栈：先进后出，后进先出。")]),e._v(" "),t("h2",{attrs:{id:"_1-blockingqueue-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-blockingqueue-简介"}},[e._v("#")]),e._v(" 1. BlockingQueue 简介")]),e._v(" "),t("h3",{attrs:{id:"api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/BlockingQueue.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("API"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("img",{attrs:{src:"https://chggx-typora.oss-cn-beijing.aliyuncs.com/typora/202303251758820.png",alt:""}})]),e._v(" "),t("p",[e._v("BlockingQueue 很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了 BlockingQueue 家庭中的所有成员，包括他们各自的功能以及常见使用场景。")]),e._v(" "),t("h3",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),t("p",[t("code",[e._v("阻塞队列")]),e._v("：首先它是一个队列, 通过一个共享的队列，可以使得"),t("code",[e._v("数据由队列的一端输入，从另外一端输出")]),e._v("；")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://chggx-typora.oss-cn-beijing.aliyuncs.com/typora/202303251746026.png",alt:""}})]),e._v(" "),t("ul",[t("li",[t("p",[e._v("当队列是空的，从队列中获取元素的操作将会被阻塞.")])]),e._v(" "),t("li",[t("p",[e._v("当队列是满的，从队列中添加元素的操作将会被阻塞")])]),e._v(" "),t("li",[t("p",[e._v("试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素")])]),e._v(" "),t("li",[t("p",[e._v("试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增")])])]),e._v(" "),t("p",[t("strong",[e._v("常用的队列主要有以下两种")]),e._v("：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性")])]),e._v(" "),t("li",[t("p",[e._v("后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)")])])]),e._v(" "),t("blockquote",[t("p",[e._v("在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列")])]),e._v(" "),t("li",[t("p",[e._v("当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒")])])])]),e._v(" "),t("h2",{attrs:{id:"_2-常见的blockingqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-常见的blockingqueue"}},[e._v("#")]),e._v(" 2. 常见的BlockingQueue")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/ArrayBlockingQueue.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ArrayBlockingQueue"),t("OutboundLink")],1),e._v(" : 由数组结构组成的有界阻塞队列")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/DelayQueue.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("DelayQueue"),t("OutboundLink")],1),e._v(" ：使用优先级队列实现的延迟无界阻塞队列")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/LinkedBlockingDeque.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("LinkedBlockingDeque"),t("OutboundLink")],1),e._v(" ：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/LinkedBlockingQueue.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("LinkedBlockingQueue"),t("OutboundLink")],1),e._v(" ：由链表组成的双向阻塞队列")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/LinkedTransferQueue.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("LinkedTransferQueue"),t("OutboundLink")],1),e._v(" ：由链表组成的无界阻塞队列")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/PriorityBlockingQueue.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("PriorityBlockingQueue"),t("OutboundLink")],1),e._v(" : 支持优先级排序的无界阻塞队列")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/SynchronousQueue.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("SynchronousQueue"),t("OutboundLink")],1),e._v(" ：不存储元素的阻塞队列，也即单个元素的队列")]),e._v(" "),t("h2",{attrs:{id:"_3-blockingqueue-核心方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-blockingqueue-核心方法"}},[e._v("#")]),e._v(" 3. "),t("strong",[e._v("BlockingQueue 核心方法")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://chggx-typora.oss-cn-beijing.aliyuncs.com/typora/202303251817260.png",alt:""}})]),e._v(" "),t("p",[t("img",{attrs:{src:"https://chggx-typora.oss-cn-beijing.aliyuncs.com/typora/202303251817197.png",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"放入数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#放入数据"}},[e._v("#")]),e._v(" 放入数据")]),e._v(" "),t("ul",[t("li",[t("p",[t("code",[e._v("offer(anObject)")]),e._v(":表示如果可能的话,将 anObject 加到 BlockingQueue 里,即如果 BlockingQueue 可以容纳,则返回 true,否则返回 false."),t("strong",[e._v("（本方法不阻塞当前执行方法的线程）")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("offer(E o, long timeout, TimeUnit unit)")]),e._v("：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("put(anObject):")]),e._v("把 anObject 加到 BlockingQueue 里,如果 BlockQueue 没有空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.")])])]),e._v(" "),t("h3",{attrs:{id:"获取数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取数据"}},[e._v("#")]),e._v(" 获取数据")]),e._v(" "),t("ul",[t("li",[t("p",[t("code",[e._v("poll(time)")]),e._v(": 取走 BlockingQueue 里排在首位的对象,若不能立即取出,"),t("strong",[e._v("则可以等time 参数规定的时间,取不到时返回 null")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("poll(long timeout, TimeUnit unit)")]),e._v("：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("take()")]),e._v(": 取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,"),t("strong",[e._v("阻断进入等待状态直到 BlockingQueue 有新的数据被加入")]),e._v(";")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("drainTo()")]),e._v(": 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);