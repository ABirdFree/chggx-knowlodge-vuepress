(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,s,l=e[0],o=e[1],c=e[2],u=0,d=[];u<l.length;u++)s=l[u],Object.prototype.hasOwnProperty.call(i,s)&&i[s]&&d.push(i[s][0]),i[s]=0;for(a in o)Object.prototype.hasOwnProperty.call(o,a)&&(n[a]=o[a]);for(p&&p(e);d.length;)d.shift()();return r.push.apply(r,c||[]),t()}function t(){for(var n,e=0;e<r.length;e++){for(var t=r[e],a=!0,l=1;l<t.length;l++){var o=t[l];0!==i[o]&&(a=!1)}a&&(r.splice(e--,1),n=s(s.s=t[0]))}return n}var a={},i={1:0},r=[];function s(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=i[n]=[e,a]}));e.push(t[2]=a);var r,l=document.createElement("script");l.charset="utf-8",l.timeout=120,s.nc&&l.setAttribute("nonce",s.nc),l.src=function(n){return s.p+"assets/js/"+({}[n]||n)+"."+{2:"796b80a3",3:"01456bc4",4:"1abb0fb3",5:"611bb8b1",6:"e7f06b65",7:"762ed83d",8:"ced0820d",9:"ecca8e62",10:"d561b0c2",11:"3129265d",12:"5d554c82",13:"1eb3a13b",14:"3bb7f88f",15:"a88fe488",16:"f2891599",17:"5004ec1a",18:"0f2acfd5",19:"609ddd1b",20:"0cdf72a8",21:"2fffdb25",22:"051c821f",23:"cf105080",24:"194183a1",25:"762027db",26:"a0bc2a1f",27:"07c2fe23",28:"315e22e9",29:"cb4dfbde",30:"fb707a33",31:"80f83812",32:"66db1d18",33:"38fa7296",34:"09051961",35:"95331102",36:"655702ff",37:"b07ea052",38:"9e10b6e3",39:"66bfc33c",40:"86c75672",41:"bb8509a0",42:"56d2a250",43:"107496d6",44:"f14e92a7",45:"ed72439f",46:"ba5c4fab",47:"1b11f990",48:"e367b7f8",49:"44f8592c",50:"54702ed4",51:"4b3429de",52:"09f727c1",53:"d7aeedda",54:"62028971",55:"b656e884",56:"3d337a41",57:"3c1800f1",58:"36f04c2f",59:"197050af",60:"db20c672",61:"a3e0a8a0",62:"f6613ace",63:"a1526602",64:"a33c3ce4",65:"6ac87fdf",66:"ecafb112",67:"e33194c5",68:"71bf6ba2",69:"3f6b8241",70:"db6255a7",71:"10b67be3",72:"7c8c8ad3",73:"74ddb7f3",74:"3ebd0429",75:"b16231fb",76:"defbb1b3",77:"f6092d16",78:"37bd4420",79:"b00452f3",80:"4aa729a2",81:"9703677f"}[n]+".js"}(n);var o=new Error;r=function(e){l.onerror=l.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),r=e&&e.target&&e.target.src;o.message="Loading chunk "+n+" failed.\n("+a+": "+r+")",o.name="ChunkLoadError",o.type=a,o.request=r,t[1](o)}i[n]=void 0}};var c=setTimeout((function(){r({type:"timeout",target:l})}),12e4);l.onerror=l.onload=r,document.head.appendChild(l)}return Promise.all(e)},s.m=n,s.c=a,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)s.d(t,a,function(e){return n[e]}.bind(null,a));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/chggx-knowlodge-vuepress/",s.oe=function(n){throw console.error(n),n};var l=window.webpackJsonp=window.webpackJsonp||[],o=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var p=o;r.push([102,0]),t()}([function(n,e,t){var a=t(55),i=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===i}:function(n){return"function"==typeof n}},function(n,e,t){var a=t(27),i=Function.prototype,r=i.call,s=a&&i.bind.bind(r,r);n.exports=a?s:function(n){return function(){return r.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var a=t(2);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(69),i="object"==typeof self&&self&&self.Object===Object&&self,r=a||i||Function("return this")();n.exports=r},function(n,e,t){"use strict";function a(n,e,t,a,i,r,s,l){var o,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),r&&(c._scopeId="data-v-"+r),s?(o=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=o):i&&(o=l?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),o)if(c.functional){c._injectStyles=o;var p=c.render;c.render=function(n,e){return o.call(e),p(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,o):[o]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(1),i=t(32),r=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return r(i(n),e)}},function(n,e,t){var a=t(0),i=t(55),r=i.all;n.exports=i.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===r}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(163),i=t(166);n.exports=function(n,e){var t=i(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return r})),t.d(e,"j",(function(){return s})),t.d(e,"g",(function(){return o})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return g})),t.d(e,"d",(function(){return v})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return y})),t.d(e,"a",(function(){return S}));t(16);const a=/#.*$/,i=/\.(md|html)$/,r=/\/$/,s=/^[a-z]+:/i;function l(n){return decodeURI(n).replace(a,"").replace(i,"")}function o(n){return s.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function u(n){if(o(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",i=l(n);return r.test(i)?n:i+".html"+t}function d(n,e){const t=n.hash,i=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(i&&t!==i)return!1;return l(n.path)===l(e)}function m(n,e,t){if(o(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const r=n.replace(/^\//,"").split("/");for(let n=0;n<r.length;n++){const e=r[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const a=l(e);for(let e=0;e<n.length;e++)if(l(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function g(n,e,t,a){const{pages:i,themeConfig:r}=t,s=a&&r.locales&&r.locales[a]||r;if("auto"===(n.frontmatter.sidebar||s.sidebar||r.sidebar))return h(n);const l=s.sidebar||r.sidebar;if(l){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,l);return"auto"===a?h(n):a?a.map(n=>function n(e,t,a,i=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const r=e.children||[];return 0===r.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:r.map(e=>n(e,t,a,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function h(n){const e=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function v(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function y(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function f(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function S(n,e){return f(e)-f(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(15),i=t(148),r=t(149),s=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?i(n):r(n)}},function(n,e,t){var a=t(4),i=t(17),r=t(35);n.exports=a?function(n,e,t){return i.f(n,e,r(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(6).Symbol;n.exports=a},function(n,e,t){"use strict";var a=t(26),i=t(32),r=t(33),s=t(127),l=t(129);a({target:"Array",proto:!0,arity:1,forced:t(2)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=i(this),t=r(e),a=arguments.length;l(t+a);for(var o=0;o<a;o++)e[t]=arguments[o],t++;return s(e,t),t}})},function(n,e,t){var a=t(4),i=t(64),r=t(98),s=t(25),l=t(54),o=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=a?r?function(n,e,t){if(s(n),e=l(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=p(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(s(n),e=l(e),s(t),i)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw o("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(1),i=a({}.toString),r=a("".slice);n.exports=function(n){return r(i(n),8,-1)}},function(n,e,t){var a=t(153),i=t(154),r=t(155),s=t(156),l=t(157);function o(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}o.prototype.clear=a,o.prototype.delete=i,o.prototype.get=r,o.prototype.has=s,o.prototype.set=l,n.exports=o},function(n,e,t){var a=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(175);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(45);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function r(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,a.minimum,1),t.status=1===n?null:n;var o=t.render(!e),c=o.querySelector(a.barSelector),p=a.speed,u=a.easing;return o.offsetWidth,s((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),l(c,function(n,e,t){var i;return(i="translate3d"===a.positionUsing?{transform:"translate3d("+r(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+r(n)+"%,0)"}:{"margin-left":r(n)+"%"}).transition="all "+e+"ms "+t,i}(n,p,u)),1===n?(l(o,{transition:"none",opacity:1}),o.offsetWidth,setTimeout((function(){l(o,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var i,s=e.querySelector(a.barSelector),o=n?"-100":r(t.status||0),p=document.querySelector(a.parent);return l(s,{transition:"all 0 linear",transform:"translate3d("+o+"%,0,0)"}),a.showSpinner||(i=e.querySelector(a.spinnerSelector))&&d(i),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),l=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,i=n.length,r=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((a=n[i]+r)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,i,r=arguments;if(2==r.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&a(n,t,i);else a(n,r[1],r[2])}}();function o(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),a=t+e;o(t,e)||(n.className=a.substring(1))}function p(n,e){var t,a=u(n);o(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=i)},function(n,e,t){var a=t(9),i=String,r=TypeError;n.exports=function(n){if(a(n))return n;throw r(i(n)+" is not an object")}},function(n,e,t){var a=t(3),i=t(51).f,r=t(14),s=t(110),l=t(37),o=t(65),c=t(123);n.exports=function(n,e){var t,p,u,d,m,g=n.target,h=n.global,v=n.stat;if(t=h?a:v?a[g]||l(g,{}):(a[g]||{}).prototype)for(p in e){if(d=e[p],u=n.dontCallGetSet?(m=i(t,p))&&m.value:t[p],!c(h?p:g+(v?".":"#")+p,n.forced)&&void 0!==u){if(typeof d==typeof u)continue;o(d,u)}(n.sham||u&&u.sham)&&r(d,"sham",!0),s(t,p,d,n)}}},function(n,e,t){var a=t(2);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(47),i=t(52);n.exports=function(n){return a(i(n))}},function(n,e,t){var a=t(3),i=t(0),r=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?r(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(0),i=t(108),r=TypeError;n.exports=function(n){if(a(n))return n;throw r(i(n)+" is not a function")}},function(n,e,t){var a=t(3),i=t(61),r=t(8),s=t(63),l=t(59),o=t(58),c=a.Symbol,p=i("wks"),u=o?c.for||c:c&&c.withoutSetter||s;n.exports=function(n){return r(p,n)||(p[n]=l&&r(c,n)?c[n]:u("Symbol."+n)),p[n]}},function(n,e,t){var a=t(52),i=Object;n.exports=function(n){return i(a(n))}},function(n,e,t){var a=t(121);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(27),i=Function.prototype.call;n.exports=a?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(3),i=t(37),r=a["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=r},function(n,e,t){var a=t(3),i=Object.defineProperty;n.exports=function(n,e){try{i(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(147),i=t(12),r=Object.prototype,s=r.hasOwnProperty,l=r.propertyIsEnumerable,o=a(function(){return arguments}())?a:function(n){return i(n)&&s.call(n,"callee")&&!l.call(n,"callee")};n.exports=o},function(n,e,t){var a=t(10)(t(6),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(167),i=t(174),r=t(176),s=t(177),l=t(178);function o(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}o.prototype.clear=a,o.prototype.delete=i,o.prototype.get=r,o.prototype.has=s,o.prototype.set=l,n.exports=o},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(5),i=t(45),r=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(s.test(n)||!r.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(13),i=t(12);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var a=t(1),i=t(2),r=t(18),s=Object,l=a("".split);n.exports=i((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==r(n)?l(n,""):s(n)}:s},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,r=/^0o[0-7]+$/i,s=parseInt,l="object"==typeof global&&global&&global.Object===Object&&global,o="object"==typeof self&&self&&self.Object===Object&&self,c=l||o||Function("return this")(),p=Object.prototype.toString,u=Math.max,d=Math.min,m=function(){return c.Date.now()};function g(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(g(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=g(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var l=i.test(n);return l||r.test(n)?s(n.slice(2),l?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,i,r,s,l,o,c=0,p=!1,v=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=a,r=i;return a=i=void 0,c=e,s=n.apply(r,t)}function f(n){return c=n,l=setTimeout(x,e),p?y(n):s}function S(n){var t=n-o;return void 0===o||t>=e||t<0||v&&n-c>=r}function x(){var n=m();if(S(n))return w(n);l=setTimeout(x,function(n){var t=e-(n-o);return v?d(t,r-(n-c)):t}(n))}function w(n){return l=void 0,b&&a?y(n):(a=i=void 0,s)}function j(){var n=m(),t=S(n);if(a=arguments,i=this,o=n,t){if(void 0===l)return f(o);if(v)return l=setTimeout(x,e),y(o)}return void 0===l&&(l=setTimeout(x,e)),s}return e=h(e)||0,g(t)&&(p=!!t.leading,r=(v="maxWait"in t)?u(h(t.maxWait)||0,e):r,b="trailing"in t?!!t.trailing:b),j.cancel=function(){void 0!==l&&clearTimeout(l),c=0,a=o=i=l=void 0},j.flush=function(){return void 0===l?s:w(m())},j}},function(n,e,t){var a=t(4),i=t(34),r=t(104),s=t(35),l=t(28),o=t(54),c=t(8),p=t(64),u=Object.getOwnPropertyDescriptor;e.f=a?u:function(n,e){if(n=l(n),e=o(e),p)try{return u(n,e)}catch(n){}if(c(n,e))return s(!i(r.f,n,e),n[e])}},function(n,e,t){var a=t(53),i=TypeError;n.exports=function(n){if(a(n))throw i("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(105),i=t(56);n.exports=function(n){var e=a(n,"string");return i(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(29),i=t(0),r=t(57),s=t(58),l=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return i(e)&&r(e.prototype,l(n))}},function(n,e,t){var a=t(1);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(59);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(60),i=t(2);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,i,r=t(3),s=t(106),l=r.process,o=r.Deno,c=l&&l.versions||o&&o.version,p=c&&c.v8;p&&(i=(a=p.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!i&&s&&(!(a=s.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=s.match(/Chrome\/(\d+)/))&&(i=+a[1]),n.exports=i},function(n,e,t){var a=t(62),i=t(36);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.28.0",mode:a?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.28.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(1),i=0,r=Math.random(),s=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++i+r,36)}},function(n,e,t){var a=t(4),i=t(2),r=t(97);n.exports=!a&&!i((function(){return 7!=Object.defineProperty(r("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(8),i=t(116),r=t(51),s=t(17);n.exports=function(n,e,t){for(var l=i(e),o=s.f,c=r.f,p=0;p<l.length;p++){var u=l[p];a(n,u)||t&&a(t,u)||o(n,u,c(e,u))}}},function(n,e,t){var a=t(120);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(133),i=t(25),r=t(134);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return i(t),r(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,i=n.length;++t<a;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(19),i=t(158),r=t(159),s=t(160),l=t(161),o=t(162);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=r,c.prototype.get=s,c.prototype.has=l,c.prototype.set=o,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(13),i=t(40);n.exports=function(n){if(!i(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(179),i=t(12);n.exports=function n(e,t,r,s,l){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:a(e,t,r,s,n,l))}},function(n,e,t){var a=t(76),i=t(182),r=t(77);n.exports=function(n,e,t,s,l,o){var c=1&t,p=n.length,u=e.length;if(p!=u&&!(c&&u>p))return!1;var d=o.get(n),m=o.get(e);if(d&&m)return d==e&&m==n;var g=-1,h=!0,v=2&t?new a:void 0;for(o.set(n,e),o.set(e,n);++g<p;){var b=n[g],y=e[g];if(s)var f=c?s(y,b,g,e,n,o):s(b,y,g,n,e,o);if(void 0!==f){if(f)continue;h=!1;break}if(v){if(!i(e,(function(n,e){if(!r(v,e)&&(b===n||l(b,n,t,s,o)))return v.push(e)}))){h=!1;break}}else if(b!==y&&!l(b,y,t,s,o)){h=!1;break}}return o.delete(n),o.delete(e),h}},function(n,e,t){var a=t(41),i=t(180),r=t(181);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=i,s.prototype.has=r,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(192),i=t(198),r=t(82);n.exports=function(n){return r(n)?a(n):i(n)}},function(n,e,t){(function(n){var a=t(6),i=t(194),r=e&&!e.nodeType&&e,s=r&&"object"==typeof n&&n&&!n.nodeType&&n,l=s&&s.exports===r?a.Buffer:void 0,o=(l?l.isBuffer:void 0)||i;n.exports=o}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(195),i=t(196),r=t(197),s=r&&r.isTypedArray,l=s?i(s):a;n.exports=l},function(n,e,t){var a=t(72),i=t(43);n.exports=function(n){return null!=n&&i(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(6),"Set");n.exports=a},function(n,e,t){var a=t(40);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(87),i=t(23);n.exports=function(n,e){for(var t=0,r=(e=a(e,n)).length;null!=n&&t<r;)n=n[i(e[t++])];return t&&t==r?n:void 0}},function(n,e,t){var a=t(5),i=t(44),r=t(209),s=t(212);n.exports=function(n,e){return a(n)?n:i(n,e)?[n]:r(s(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(145),i=t(150),r=t(221),s=t(229),l=t(238),o=t(101),c=r((function(n){var e=o(n);return l(e)&&(e=void 0),s(a(n,1,l,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=a.exec(t);if(!i)return t;var r="",s=0,l=0;for(s=i.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}l!==s&&(r+=t.substring(l,s)),l=s+1,r+=e}return l!==s?r+t.substring(l,s):r}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(241),t(7)),r=Object(i.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=r.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(242),t(7)),r=Object(i.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=r.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(3),i=t(9),r=a.document,s=i(r)&&i(r.createElement);n.exports=function(n){return s?r.createElement(n):{}}},function(n,e,t){var a=t(4),i=t(2);n.exports=a&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(61),i=t(63),r=a("keys");n.exports=function(n){return r[n]||(r[n]=i(n))}},function(n,e,t){var a=t(1),i=t(8),r=t(28),s=t(118).indexOf,l=t(48),o=a([].push);n.exports=function(n,e){var t,a=r(n),c=0,p=[];for(t in a)!i(l,t)&&i(a,t)&&o(p,t);for(;e.length>c;)i(a,t=e[c++])&&(~s(p,t)||o(p,t));return p}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(247)},function(n,e,t){"use strict";var a=t(26),i=t(124).left,r=t(125),s=t(60);a({target:"Array",proto:!0,forced:!t(126)&&s>79&&s<83||!r("reduce")},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,r=i&&!a.call({1:2},1);e.f=r?function(n){var e=i(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(34),i=t(9),r=t(56),s=t(107),l=t(109),o=t(31),c=TypeError,p=o("toPrimitive");n.exports=function(n,e){if(!i(n)||r(n))return n;var t,o=s(n,p);if(o){if(void 0===e&&(e="default"),t=a(o,n,e),!i(t)||r(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var a=t(30),i=t(53);n.exports=function(n,e){var t=n[e];return i(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(34),i=t(0),r=t(9),s=TypeError;n.exports=function(n,e){var t,l;if("string"===e&&i(t=n.toString)&&!r(l=a(t,n)))return l;if(i(t=n.valueOf)&&!r(l=a(t,n)))return l;if("string"!==e&&i(t=n.toString)&&!r(l=a(t,n)))return l;throw s("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),i=t(17),r=t(111),s=t(37);n.exports=function(n,e,t,l){l||(l={});var o=l.enumerable,c=void 0!==l.name?l.name:e;if(a(t)&&r(t,c,l),l.global)o?n[e]=t:s(e,t);else{try{l.unsafe?n[e]&&(o=!0):delete n[e]}catch(n){}o?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!l.nonConfigurable,writable:!l.nonWritable})}return n}},function(n,e,t){var a=t(1),i=t(2),r=t(0),s=t(8),l=t(4),o=t(112).CONFIGURABLE,c=t(113),p=t(114),u=p.enforce,d=p.get,m=String,g=Object.defineProperty,h=a("".slice),v=a("".replace),b=a([].join),y=l&&!i((function(){return 8!==g((function(){}),"length",{value:8}).length})),f=String(String).split("String"),S=n.exports=function(n,e,t){"Symbol("===h(m(e),0,7)&&(e="["+v(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!s(n,"name")||o&&n.name!==e)&&(l?g(n,"name",{value:e,configurable:!0}):n.name=e),y&&t&&s(t,"arity")&&n.length!==t.arity&&g(n,"length",{value:t.arity});try{t&&s(t,"constructor")&&t.constructor?l&&g(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=u(n);return s(a,"source")||(a.source=b(f,"string"==typeof e?e:"")),n};Function.prototype.toString=S((function(){return r(this)&&d(this).source||c(this)}),"toString")},function(n,e,t){var a=t(4),i=t(8),r=Function.prototype,s=a&&Object.getOwnPropertyDescriptor,l=i(r,"name"),o=l&&"something"===function(){}.name,c=l&&(!a||a&&s(r,"name").configurable);n.exports={EXISTS:l,PROPER:o,CONFIGURABLE:c}},function(n,e,t){var a=t(1),i=t(0),r=t(36),s=a(Function.toString);i(r.inspectSource)||(r.inspectSource=function(n){return s(n)}),n.exports=r.inspectSource},function(n,e,t){var a,i,r,s=t(115),l=t(3),o=t(9),c=t(14),p=t(8),u=t(36),d=t(99),m=t(48),g=l.TypeError,h=l.WeakMap;if(s||u.state){var v=u.state||(u.state=new h);v.get=v.get,v.has=v.has,v.set=v.set,a=function(n,e){if(v.has(n))throw g("Object already initialized");return e.facade=n,v.set(n,e),e},i=function(n){return v.get(n)||{}},r=function(n){return v.has(n)}}else{var b=d("state");m[b]=!0,a=function(n,e){if(p(n,b))throw g("Object already initialized");return e.facade=n,c(n,b,e),e},i=function(n){return p(n,b)?n[b]:{}},r=function(n){return p(n,b)}}n.exports={set:a,get:i,has:r,enforce:function(n){return r(n)?i(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!o(e)||(t=i(e)).type!==n)throw g("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(3),i=t(0),r=a.WeakMap;n.exports=i(r)&&/native code/.test(String(r))},function(n,e,t){var a=t(29),i=t(1),r=t(117),s=t(122),l=t(25),o=i([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=r.f(l(n)),t=s.f;return t?o(e,t(n)):e}},function(n,e,t){var a=t(100),i=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,i)}},function(n,e,t){var a=t(28),i=t(119),r=t(33),s=function(n){return function(e,t,s){var l,o=a(e),c=r(o),p=i(s,c);if(n&&t!=t){for(;c>p;)if((l=o[p++])!=l)return!0}else for(;c>p;p++)if((n||p in o)&&o[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){var a=t(66),i=Math.max,r=Math.min;n.exports=function(n,e){var t=a(n);return t<0?i(t+e,0):r(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(66),i=Math.min;n.exports=function(n){return n>0?i(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(2),i=t(0),r=/#|\.prototype\./,s=function(n,e){var t=o[l(n)];return t==p||t!=c&&(i(e)?a(e):!!e)},l=s.normalize=function(n){return String(n).replace(r,".").toLowerCase()},o=s.data={},c=s.NATIVE="N",p=s.POLYFILL="P";n.exports=s},function(n,e,t){var a=t(30),i=t(32),r=t(47),s=t(33),l=TypeError,o=function(n){return function(e,t,o,c){a(t);var p=i(e),u=r(p),d=s(p),m=n?d-1:0,g=n?-1:1;if(o<2)for(;;){if(m in u){c=u[m],m+=g;break}if(m+=g,n?m<0:d<=m)throw l("Reduce of empty array with no initial value")}for(;n?m>=0:d>m;m+=g)m in u&&(c=t(c,u[m],m,p));return c}};n.exports={left:o(!1),right:o(!0)}},function(n,e,t){"use strict";var a=t(2);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(18);n.exports="undefined"!=typeof process&&"process"==a(process)},function(n,e,t){"use strict";var a=t(4),i=t(128),r=TypeError,s=Object.getOwnPropertyDescriptor,l=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=l?function(n,e){if(i(n)&&!s(n,"length").writable)throw r("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(18);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(26),i=t(3),r=t(131),s=t(132),l=i.WebAssembly,o=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=s(n,e,o),a({global:!0,constructor:!0,arity:1,forced:o},t)},p=function(n,e){if(l&&l[n]){var t={};t[n]=s("WebAssembly."+n,e,o),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:o},t)}};c("Error",(function(n){return function(e){return r(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return r(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return r(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return r(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return r(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return r(n,this,arguments)}})),c("URIError",(function(n){return function(e){return r(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return r(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return r(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return r(n,this,arguments)}}))},function(n,e,t){var a=t(27),i=Function.prototype,r=i.apply,s=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?s.bind(r):function(){return s.apply(r,arguments)})},function(n,e,t){"use strict";var a=t(29),i=t(8),r=t(14),s=t(57),l=t(67),o=t(65),c=t(135),p=t(136),u=t(137),d=t(141),m=t(142),g=t(4),h=t(62);n.exports=function(n,e,t,v){var b=v?2:1,y=n.split("."),f=y[y.length-1],S=a.apply(null,y);if(S){var x=S.prototype;if(!h&&i(x,"cause")&&delete x.cause,!t)return S;var w=a("Error"),j=e((function(n,e){var t=u(v?e:n,void 0),a=v?new S(n):new S;return void 0!==t&&r(a,"message",t),m(a,j,a.stack,2),this&&s(x,this)&&p(a,this,j),arguments.length>b&&d(a,arguments[b]),a}));if(j.prototype=x,"Error"!==f?l?l(j,w):o(j,w,{name:!0}):g&&"stackTraceLimit"in S&&(c(j,S,"stackTraceLimit"),c(j,S,"prepareStackTrace")),o(j,S),!h)try{x.name!==f&&r(x,"name",f),x.constructor=j}catch(n){}return j}}},function(n,e,t){var a=t(1),i=t(30);n.exports=function(n,e,t){try{return a(i(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var a=t(0),i=String,r=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw r("Can't set "+i(n)+" as a prototype")}},function(n,e,t){var a=t(17).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),i=t(9),r=t(67);n.exports=function(n,e,t){var s,l;return r&&a(s=e.constructor)&&s!==t&&i(l=s.prototype)&&l!==t.prototype&&r(n,l),n}},function(n,e,t){var a=t(138);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(139),i=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var a=t(140),i=t(0),r=t(18),s=t(31)("toStringTag"),l=Object,o="Arguments"==r(function(){return arguments}());n.exports=a?r:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),s))?t:o?r(e):"Object"==(a=r(e))&&i(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(31)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),i=t(14);n.exports=function(n,e){a(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var a=t(14),i=t(143),r=t(144),s=Error.captureStackTrace;n.exports=function(n,e,t,l){r&&(s?s(n,e):a(n,"stack",i(t,l)))}},function(n,e,t){var a=t(1),i=Error,r=a("".replace),s=String(i("zxcasd").stack),l=/\n\s*at [^:]*:[^\n]*/,o=l.test(s);n.exports=function(n,e){if(o&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=r(n,l,"");return n}},function(n,e,t){var a=t(2),i=t(35);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(68),i=t(146);n.exports=function n(e,t,r,s,l){var o=-1,c=e.length;for(r||(r=i),l||(l=[]);++o<c;){var p=e[o];t>0&&r(p)?t>1?n(p,t-1,r,s,l):a(l,p):s||(l[l.length]=p)}return l}},function(n,e,t){var a=t(15),i=t(38),r=t(5),s=a?a.isConcatSpreadable:void 0;n.exports=function(n){return r(n)||i(n)||!!(s&&n&&n[s])}},function(n,e,t){var a=t(13),i=t(12);n.exports=function(n){return i(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(15),i=Object.prototype,r=i.hasOwnProperty,s=i.toString,l=a?a.toStringTag:void 0;n.exports=function(n){var e=r.call(n,l),t=n[l];try{n[l]=void 0;var a=!0}catch(n){}var i=s.call(n);return a&&(e?n[l]=t:delete n[l]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(151),i=t(207),r=t(46),s=t(5),l=t(218);n.exports=function(n){return"function"==typeof n?n:null==n?r:"object"==typeof n?s(n)?i(n[0],n[1]):a(n):l(n)}},function(n,e,t){var a=t(152),i=t(206),r=t(85);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?r(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(70),i=t(74);n.exports=function(n,e,t,r){var s=t.length,l=s,o=!r;if(null==n)return!l;for(n=Object(n);s--;){var c=t[s];if(o&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++s<l;){var p=(c=t[s])[0],u=n[p],d=c[1];if(o&&c[2]){if(void 0===u&&!(p in n))return!1}else{var m=new a;if(r)var g=r(u,d,p,n,e,m);if(!(void 0===g?i(d,u,3,r,m):g))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(20),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(20);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(20);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(20);n.exports=function(n,e){var t=this.__data__,i=a(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var a=t(19);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(19),i=t(39),r=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var s=t.__data__;if(!i||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new r(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(72),i=t(164),r=t(40),s=t(73),l=/^\[object .+?Constructor\]$/,o=Function.prototype,c=Object.prototype,p=o.toString,u=c.hasOwnProperty,d=RegExp("^"+p.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!r(n)||i(n))&&(a(n)?d:l).test(s(n))}},function(n,e,t){var a,i=t(165),r=(a=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!r&&r in n}},function(n,e,t){var a=t(6)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(168),i=t(19),r=t(39);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(r||i),string:new a}}},function(n,e,t){var a=t(169),i=t(170),r=t(171),s=t(172),l=t(173);function o(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}o.prototype.clear=a,o.prototype.delete=i,o.prototype.get=r,o.prototype.has=s,o.prototype.set=l,n.exports=o},function(n,e,t){var a=t(21);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(21),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(21),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var a=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(22);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=a(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var a=t(70),i=t(75),r=t(183),s=t(186),l=t(202),o=t(5),c=t(79),p=t(81),u="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,g,h){var v=o(n),b=o(e),y=v?"[object Array]":l(n),f=b?"[object Array]":l(e),S=(y="[object Arguments]"==y?u:y)==u,x=(f="[object Arguments]"==f?u:f)==u,w=y==f;if(w&&c(n)){if(!c(e))return!1;v=!0,S=!1}if(w&&!S)return h||(h=new a),v||p(n)?i(n,e,t,m,g,h):r(n,e,y,t,m,g,h);if(!(1&t)){var j=S&&d.call(n,"__wrapped__"),T=x&&d.call(e,"__wrapped__");if(j||T){var _=j?n.value():n,k=T?e.value():e;return h||(h=new a),g(_,k,t,m,h)}}return!!w&&(h||(h=new a),s(n,e,t,m,g,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(15),i=t(184),r=t(71),s=t(75),l=t(185),o=t(42),c=a?a.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,u,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return r(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=l;case"[object Set]":var g=1&a;if(m||(m=o),n.size!=e.size&&!g)return!1;var h=d.get(n);if(h)return h==e;a|=2,d.set(n,e);var v=s(m(n),m(e),a,c,u,d);return d.delete(n),v;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var a=t(6).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(187),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,r,s,l){var o=1&t,c=a(n),p=c.length;if(p!=a(e).length&&!o)return!1;for(var u=p;u--;){var d=c[u];if(!(o?d in e:i.call(e,d)))return!1}var m=l.get(n),g=l.get(e);if(m&&g)return m==e&&g==n;var h=!0;l.set(n,e),l.set(e,n);for(var v=o;++u<p;){var b=n[d=c[u]],y=e[d];if(r)var f=o?r(y,b,d,e,n,l):r(b,y,d,n,e,l);if(!(void 0===f?b===y||s(b,y,t,r,l):f)){h=!1;break}v||(v="constructor"==d)}if(h&&!v){var S=n.constructor,x=e.constructor;S==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof S&&S instanceof S&&"function"==typeof x&&x instanceof x||(h=!1)}return l.delete(n),l.delete(e),h}},function(n,e,t){var a=t(188),i=t(189),r=t(78);n.exports=function(n){return a(n,r,i)}},function(n,e,t){var a=t(68),i=t(5);n.exports=function(n,e,t){var r=e(n);return i(n)?r:a(r,t(n))}},function(n,e,t){var a=t(190),i=t(191),r=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,l=s?function(n){return null==n?[]:(n=Object(n),a(s(n),(function(e){return r.call(n,e)})))}:i;n.exports=l},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=0,r=[];++t<a;){var s=n[t];e(s,t,n)&&(r[i++]=s)}return r}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(193),i=t(38),r=t(5),s=t(79),l=t(80),o=t(81),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=r(n),p=!t&&i(n),u=!t&&!p&&s(n),d=!t&&!p&&!u&&o(n),m=t||p||u||d,g=m?a(n.length,String):[],h=g.length;for(var v in n)!e&&!c.call(n,v)||m&&("length"==v||u&&("offset"==v||"parent"==v)||d&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||l(v,h))||g.push(v);return g}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(13),i=t(43),r=t(12),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return r(n)&&i(n.length)&&!!s[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(69),i=e&&!e.nodeType&&e,r=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=r&&r.exports===i&&a.process,l=function(){try{var n=r&&r.require&&r.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=l}).call(this,t(49)(n))},function(n,e,t){var a=t(199),i=t(200),r=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return i(n);var e=[];for(var t in Object(n))r.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(201)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(203),i=t(39),r=t(204),s=t(83),l=t(205),o=t(13),c=t(73),p=c(a),u=c(i),d=c(r),m=c(s),g=c(l),h=o;(a&&"[object DataView]"!=h(new a(new ArrayBuffer(1)))||i&&"[object Map]"!=h(new i)||r&&"[object Promise]"!=h(r.resolve())||s&&"[object Set]"!=h(new s)||l&&"[object WeakMap]"!=h(new l))&&(h=function(n){var e=o(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case p:return"[object DataView]";case u:return"[object Map]";case d:return"[object Promise]";case m:return"[object Set]";case g:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var a=t(10)(t(6),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(6),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(6),"WeakMap");n.exports=a},function(n,e,t){var a=t(84),i=t(78);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var r=e[t],s=n[r];e[t]=[r,s,a(s)]}return e}},function(n,e,t){var a=t(74),i=t(208),r=t(215),s=t(44),l=t(84),o=t(85),c=t(23);n.exports=function(n,e){return s(n)&&l(e)?o(c(n),e):function(t){var s=i(t,n);return void 0===s&&s===e?r(t,n):a(e,s,3)}}},function(n,e,t){var a=t(86);n.exports=function(n,e,t){var i=null==n?void 0:a(n,e);return void 0===i?t:i}},function(n,e,t){var a=t(210),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,r=/\\(\\)?/g,s=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,a,i){e.push(a?i.replace(r,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var a=t(211);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(41);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,i=e?e.apply(this,a):a[0],r=t.cache;if(r.has(i))return r.get(i);var s=n.apply(this,a);return t.cache=r.set(i,s)||r,s};return t.cache=new(i.Cache||a),t}i.Cache=a,n.exports=i},function(n,e,t){var a=t(213);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(15),i=t(214),r=t(5),s=t(45),l=a?a.prototype:void 0,o=l?l.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(r(e))return i(e,n)+"";if(s(e))return o?o.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=Array(a);++t<a;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var a=t(216),i=t(217);n.exports=function(n,e){return null!=n&&i(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(87),i=t(38),r=t(5),s=t(80),l=t(43),o=t(23);n.exports=function(n,e,t){for(var c=-1,p=(e=a(e,n)).length,u=!1;++c<p;){var d=o(e[c]);if(!(u=null!=n&&t(n,d)))break;n=n[d]}return u||++c!=p?u:!!(p=null==n?0:n.length)&&l(p)&&s(d,p)&&(r(n)||i(n))}},function(n,e,t){var a=t(219),i=t(220),r=t(44),s=t(23);n.exports=function(n){return r(n)?a(s(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(86);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(46),i=t(222),r=t(224);n.exports=function(n,e){return r(i(n,e,a),n+"")}},function(n,e,t){var a=t(223),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var r=arguments,s=-1,l=i(r.length-e,0),o=Array(l);++s<l;)o[s]=r[e+s];s=-1;for(var c=Array(e+1);++s<e;)c[s]=r[s];return c[e]=t(o),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(225),i=t(228)(a);n.exports=i},function(n,e,t){var a=t(226),i=t(227),r=t(46),s=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:r;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),i=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var i=t(),r=16-(i-a);if(a=i,r>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(76),i=t(230),r=t(235),s=t(77),l=t(236),o=t(42);n.exports=function(n,e,t){var c=-1,p=i,u=n.length,d=!0,m=[],g=m;if(t)d=!1,p=r;else if(u>=200){var h=e?null:l(n);if(h)return o(h);d=!1,p=s,g=new a}else g=e?[]:m;n:for(;++c<u;){var v=n[c],b=e?e(v):v;if(v=t||0!==v?v:0,d&&b==b){for(var y=g.length;y--;)if(g[y]===b)continue n;e&&g.push(b),m.push(v)}else p(g,b,t)||(g!==m&&g.push(b),m.push(v))}return m}},function(n,e,t){var a=t(231);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(232),i=t(233),r=t(234);n.exports=function(n,e,t){return e==e?r(n,e,t):a(n,i,t)}},function(n,e){n.exports=function(n,e,t,a){for(var i=n.length,r=t+(a?1:-1);a?r--:++r<i;)if(e(n[r],r,n))return r;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,i=n.length;++a<i;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,i=null==n?0:n.length;++a<i;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(83),i=t(237),r=t(42),s=a&&1/r(new a([,-0]))[1]==1/0?function(n){return new a(n)}:i;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(82),i=t(12);n.exports=function(n){return i(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),i=Array.isArray;function r(n){return null==n}function s(n){return null!=n}function l(n){return!0===n}function o(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function g(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function v(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function y(n,e){for(var t=Object.create(null),a=n.split(","),i=0;i<a.length;i++)t[a[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}y("slot,component",!0);var f=y("key,ref,slot,slot-scope,is");function S(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function j(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,_=j((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),k=j((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),E=/\B([A-Z])/g,I=j((function(n){return n.replace(E,"-$1").toLowerCase()}));var z=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function C(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function A(n,e){for(var t in e)n[t]=e[t];return n}function L(n){for(var e={},t=0;t<n.length;t++)n[t]&&A(e,n[t]);return e}function O(n,e,t){}var D=function(n,e,t){return!1},M=function(n){return n};function R(n,e){if(n===e)return!0;var t=p(n),a=p(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var i=Array.isArray(n),r=Array.isArray(e);if(i&&r)return n.length===e.length&&n.every((function(n,t){return R(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||r)return!1;var s=Object.keys(n),l=Object.keys(e);return s.length===l.length&&s.every((function(t){return R(n[t],e[t])}))}catch(n){return!1}}function P(n,e){for(var t=0;t<n.length;t++)if(R(n[t],e))return t;return-1}function B(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function J(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var N=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:O,parsePlatformTagName:M,mustUseProp:D,async:!0,_lifecycleHooks:F},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function V(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function G(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var H=new RegExp("[^".concat(U.source,".$_\\d]"));var Q="__proto__"in{},$="undefined"!=typeof window,K=$&&window.navigator.userAgent.toLowerCase(),W=K&&/msie|trident/.test(K),X=K&&K.indexOf("msie 9.0")>0,Y=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var Z=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var nn,en=K&&K.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if($)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var sn=function(){return void 0===nn&&(nn=!$&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},ln=$&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function on(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,pn="undefined"!=typeof Symbol&&on(Symbol)&&"undefined"!=typeof Reflect&&on(Reflect.ownKeys);cn="undefined"!=typeof Set&&on(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function dn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,a,i,r,s,l){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=i,this.ns=void 0,this.context=r,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=l,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),gn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function hn(n){return new mn(void 0,void 0,void 0,String(n))}function vn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,yn=[],fn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,yn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();fn.target=null;var Sn=[];function xn(n){Sn.push(n),fn.target=n}function wn(){Sn.pop(),fn.target=Sn[Sn.length-1]}var jn=Array.prototype,Tn=Object.create(jn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=jn[n];G(Tn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var i,r=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&s.observeArray(i),s.dep.notify(),r}))}));var _n=Object.getOwnPropertyNames(Tn),kn={},En=!0;function In(n){En=n}var zn={notify:O,depend:O,addSub:O,removeSub:O},Cn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?zn:new fn,this.vmCount=0,G(n,"__ob__",this),i(n)){if(!t)if(Q)n.__proto__=Tn;else for(var a=0,r=_n.length;a<r;a++){G(n,l=_n[a],Tn[l])}e||this.observeArray(n)}else{var s=Object.keys(n);for(a=0;a<s.length;a++){var l;Ln(n,l=s[a],kn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)An(n[e],!1,this.mock)},n}();function An(n,e,t){return n&&w(n,"__ob__")&&n.__ob__ instanceof Cn?n.__ob__:!En||!t&&sn()||!i(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||Jn(n)||n instanceof mn?void 0:new Cn(n,e,t)}function Ln(n,e,t,a,r,s){var l=new fn,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var c=o&&o.get,p=o&&o.set;c&&!p||t!==kn&&2!==arguments.length||(t=n[e]);var u=!r&&An(t,!1,s);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return fn.target&&(l.depend(),u&&(u.dep.depend(),i(e)&&Mn(e))),Jn(e)&&!r?e.value:e},set:function(e){var a=c?c.call(n):t;if(J(a,e)){if(p)p.call(n,e);else{if(c)return;if(!r&&Jn(a)&&!Jn(e))return void(a.value=e);t=e}u=!r&&An(e,!1,s),l.notify()}}}),l}}function On(n,e,t){if(!Bn(n)){var a=n.__ob__;return i(n)&&g(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&An(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(Ln(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Dn(n,e){if(i(n)&&g(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Bn(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function Mn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&Mn(e)}function Rn(n){return Pn(n,!0),G(n,"__v_isShallow",!0),n}function Pn(n,e){if(!Bn(n)){An(n,e,sn());0}}function Bn(n){return!(!n||!n.__v_isReadonly)}function Jn(n){return!(!n||!0!==n.__v_isRef)}function Nn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Jn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Jn(a)&&!Jn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Fn;var qn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Fn,!n&&Fn&&(this.index=(Fn.scopes||(Fn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Fn;try{return Fn=this,n()}finally{Fn=e}}else 0},n.prototype.on=function(){Fn=this},n.prototype.off=function(){Fn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Un(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Vn=j((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Gn(n,e){function t(){var n=t.fns;if(!i(n))return Ee(n,null,arguments,e,"v-on handler");for(var a=n.slice(),r=0;r<a.length;r++)Ee(a[r],null,arguments,e,"v-on handler")}return t.fns=n,t}function Hn(n,e,t,a,i,s){var o,c,p,u;for(o in n)c=n[o],p=e[o],u=Vn(o),r(c)||(r(p)?(r(c.fns)&&(c=n[o]=Gn(c,s)),l(u.once)&&(c=n[o]=i(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==p&&(p.fns=c,n[o]=p));for(o in e)r(n[o])&&a((u=Vn(o)).name,e[o],u.capture)}function Qn(n,e,t){var a;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function o(){t.apply(this,arguments),S(a.fns,o)}r(i)?a=Gn([o]):s(i.fns)&&l(i.merged)?(a=i).fns.push(o):a=Gn([i,o]),a.merged=!0,n[e]=a}function $n(n,e,t,a,i){if(s(e)){if(w(e,t))return n[t]=e[t],i||delete e[t],!0;if(w(e,a))return n[t]=e[a],i||delete e[a],!0}return!1}function Kn(n){return o(n)?[hn(n)]:i(n)?function n(e,t){var a,c,p,u,d=[];for(a=0;a<e.length;a++)r(c=e[a])||"boolean"==typeof c||(p=d.length-1,u=d[p],i(c)?c.length>0&&(Wn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Wn(u)&&(d[p]=hn(u.text+c[0].text),c.shift()),d.push.apply(d,c)):o(c)?Wn(u)?d[p]=hn(u.text+c):""!==c&&d.push(hn(c)):Wn(c)&&Wn(u)?d[p]=hn(u.text+c.text):(l(e._isVList)&&s(c.tag)&&r(c.key)&&s(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),d.push(c)));return d}(n):void 0}function Wn(n){return s(n)&&s(n.text)&&!1===n.isComment}function Xn(n,e){var t,a,r,l,o=null;if(i(n)||"string"==typeof n)for(o=new Array(n.length),t=0,a=n.length;t<a;t++)o[t]=e(n[t],t);else if("number"==typeof n)for(o=new Array(n),t=0;t<n;t++)o[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){o=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)o.push(e(u.value,o.length)),u=c.next()}else for(r=Object.keys(n),o=new Array(r.length),t=0,a=r.length;t<a;t++)l=r[t],o[t]=e(n[l],l,t);return s(o)||(o=[]),o._isVList=!0,o}function Yn(n,e,t,a){var i,r=this.$scopedSlots[n];r?(t=t||{},a&&(t=A(A({},a),t)),i=r(t)||(c(e)?e():e)):i=this.$slots[n]||(c(e)?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},i):i}function Zn(n){return Ct(this.$options,"filters",n,!0)||M}function ne(n,e){return i(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,a,i){var r=q.keyCodes[e]||t;return i&&a&&!q.keyCodes[e]?ne(i,a):r?ne(r,n):a?I(a)!==e:void 0===n}function te(n,e,t,a,r){if(t)if(p(t)){i(t)&&(t=L(t));var s=void 0,l=function(i){if("class"===i||"style"===i||f(i))s=n;else{var l=n.attrs&&n.attrs.type;s=a||q.mustUseProp(e,l,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var o=_(i),c=I(i);o in s||c in s||(s[i]=t[i],r&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var o in t)l(o)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||re(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function ie(n,e,t){return re(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function re(n,e,t){if(i(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&se(n[a],"".concat(e,"_").concat(a),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(d(e)){var t=n.on=n.on?A({},n.on):{};for(var a in e){var i=t[a],r=e[a];t[a]=i?[].concat(i,r):r}}else;return n}function oe(n,e,t,a){e=e||{$stable:!t};for(var r=0;r<n.length;r++){var s=n[r];i(s)?oe(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return a&&(e.$key=a),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function pe(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=ie,n._n=b,n._s=v,n._l=Xn,n._t=Yn,n._q=R,n._i=P,n._m=ae,n._f=Zn,n._k=ee,n._b=te,n._v=hn,n._e=gn,n._u=oe,n._g=le,n._d=ce,n._p=pe}function de(n,e){if(!n||!n.length)return{};for(var t={},a=0,i=n.length;a<i;a++){var r=n[a],s=r.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,r.context!==e&&r.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(r);else{var l=s.slot,o=t[l]||(t[l]=[]);"template"===r.tag?o.push.apply(o,r.children||[]):o.push(r)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function he(n,e,t,i){var r,s=Object.keys(t).length>0,l=e?!!e.$stable:!s,o=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(l&&i&&i!==a&&o===i.$key&&!s&&!i.$hasNormal)return i;for(var c in r={},e)e[c]&&"$"!==c[0]&&(r[c]=ve(n,t,c,e[c]))}else r={};for(var p in t)p in r||(r[p]=be(t,p));return e&&Object.isExtensible(e)&&(e._normalized=r),G(r,"$stable",l),G(r,"$key",o),G(r,"$hasNormal",s),r}function ve(n,e,t,a){var r=function(){var e=un;dn(n);var t=arguments.length?a.apply(null,arguments):a({}),r=(t=t&&"object"==typeof t&&!i(t)?[t]:Kn(t))&&t[0];return dn(e),t&&(!r||1===t.length&&r.isComment&&!ge(r))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:r,enumerable:!0,configurable:!0}),r}function be(n,e){return function(){return n[e]}}function ye(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};G(e,"_v_attr_proxy",!0),fe(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||fe(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:z(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Nn(n,e,t)}))}}}function fe(n,e,t,a,i){var r=!1;for(var s in e)s in n?e[s]!==t[s]&&(r=!0):(r=!0,Se(n,s,a,i));for(var s in n)s in e||(r=!0,delete n[s]);return r}function Se(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var we=null;function je(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function Te(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||ge(t)))return t}}function _e(n,e,t,a,u,d){return(i(t)||o(t))&&(u=a,a=t,t=void 0),l(d)&&(u=2),function(n,e,t,a,o){if(s(t)&&s(t.__ob__))return gn();s(t)&&s(t.is)&&(e=t.is);if(!e)return gn();0;i(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===o?a=Kn(a):1===o&&(a=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var u,d;if("string"==typeof e){var m=void 0;d=n.$vnode&&n.$vnode.ns||q.getTagNamespace(e),u=q.isReservedTag(e)?new mn(q.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!s(m=Ct(n.$options,"components",e))?new mn(e,t,a,void 0,void 0,n):St(m,t,n,a,e)}else u=St(e,t,n,a);return i(u)?u:s(u)?(s(d)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(s(e.children))for(var i=0,o=e.children.length;i<o;i++){var c=e.children[i];s(c.tag)&&(r(c.ns)||l(a)&&"svg"!==c.tag)&&n(c,t,a)}}(u,d),s(t)&&function(n){p(n.style)&&qe(n.style);p(n.class)&&qe(n.class)}(t),u):gn()}(n,e,t,a,u)}function ke(n,e,t){xn();try{if(e)for(var a=e;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var r=0;r<i.length;r++)try{if(!1===i[r].call(a,n,e,t))return}catch(n){Ie(n,a,"errorCaptured hook")}}Ie(n,e,t)}finally{wn()}}function Ee(n,e,t,a,i){var r;try{(r=t?n.apply(e,t):n.call(e))&&!r._isVue&&h(r)&&!r._handled&&(r.catch((function(n){return ke(n,a,i+" (Promise/async)")})),r._handled=!0)}catch(n){ke(n,a,i)}return r}function Ie(n,e,t){if(q.errorHandler)try{return q.errorHandler.call(null,n,e,t)}catch(e){e!==n&&ze(e,null,"config.errorHandler")}ze(n,e,t)}function ze(n,e,t){if(!$||"undefined"==typeof console)throw n;console.error(n)}var Ce,Ae=!1,Le=[],Oe=!1;function De(){Oe=!1;var n=Le.slice(0);Le.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&on(Promise)){var Me=Promise.resolve();Ce=function(){Me.then(De),Z&&setTimeout(O)},Ae=!0}else if(W||"undefined"==typeof MutationObserver||!on(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ce="undefined"!=typeof setImmediate&&on(setImmediate)?function(){setImmediate(De)}:function(){setTimeout(De,0)};else{var Re=1,Pe=new MutationObserver(De),Be=document.createTextNode(String(Re));Pe.observe(Be,{characterData:!0}),Ce=function(){Re=(Re+1)%2,Be.data=String(Re)},Ae=!0}function Je(n,e){var t;if(Le.push((function(){if(n)try{n.call(e)}catch(n){ke(n,e,"nextTick")}else t&&t(e)})),Oe||(Oe=!0,Ce()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ne(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var a=n.$options;a[e]=kt(a[e],t)}(t,n,e)}}Ne("beforeMount"),Ne("mounted"),Ne("beforeUpdate"),Ne("updated"),Ne("beforeDestroy"),Ne("destroyed"),Ne("activated"),Ne("deactivated"),Ne("serverPrefetch"),Ne("renderTracked"),Ne("renderTriggered"),Ne("errorCaptured");var Fe=new cn;function qe(n){return function n(e,t){var a,r,s=i(e);if(!s&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var l=e.__ob__.dep.id;if(t.has(l))return;t.add(l)}if(s)for(a=e.length;a--;)n(e[a],t);else if(Jn(e))n(e.value,t);else for(r=Object.keys(e),a=r.length;a--;)n(e[r[a]],t)}(n,Fe),Fe.clear(),n}var Ue,Ve=0,Ge=function(){function n(n,e,t,a,i){var r,s;r=this,void 0===(s=Fn&&!Fn._vm?Fn:n?n._scope:void 0)&&(s=Fn),s&&s.active&&s.effects.push(r),(this.vm=n)&&i&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ve,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!H.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=O)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;ke(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&qe(n),wn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():dt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ee(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&S(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function He(n,e){Ue.$on(n,e)}function Qe(n,e){Ue.$off(n,e)}function $e(n,e){var t=Ue;return function a(){var i=e.apply(null,arguments);null!==i&&t.$off(n,a)}}function Ke(n,e,t){Ue=n,Hn(e,t||{},He,Qe,$e,n),Ue=void 0}var We=null;function Xe(n){var e=We;return We=n,function(){We=e}}function Ye(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ze(n,e){if(e){if(n._directInactive=!1,Ye(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ze(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,a){void 0===a&&(a=!0),xn();var i=un;a&&dn(n);var r=n.$options[e],s="".concat(e," hook");if(r)for(var l=0,o=r.length;l<o;l++)Ee(r[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),a&&dn(i),wn()}var et=[],tt=[],at={},it=!1,rt=!1,st=0;var lt=0,ot=Date.now;if($&&!W){var ct=window.performance;ct&&"function"==typeof ct.now&&ot()>document.createEvent("Event").timeStamp&&(ot=function(){return ct.now()})}var pt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(lt=ot(),rt=!0,et.sort(pt),st=0;st<et.length;st++)(n=et[st]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=tt.slice(),a=et.slice();st=et.length=tt.length=0,at={},it=rt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ze(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&nt(a,"updated")}}(a),function(){for(var n=0;n<yn.length;n++){var e=yn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}yn.length=0}(),ln&&q.devtools&&ln.emit("flush")}function dt(n){var e=n.id;if(null==at[e]&&(n!==fn.target||!n.noRecurse)){if(at[e]=!0,rt){for(var t=et.length-1;t>st&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);it||(it=!0,Je(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),a=pn?Reflect.ownKeys(n):Object.keys(n),i=0;i<a.length;i++){var r=a[i];if("__ob__"!==r){var s=n[r].from;if(s in e._provided)t[r]=e._provided[s];else if("default"in n[r]){var l=n[r].default;t[r]=c(l)?l.call(e):l}else 0}}return t}}function gt(n,e,t,r,s){var o,c=this,p=s.options;w(r,"_uid")?(o=Object.create(r))._original=r:(o=r,r=r._original);var u=l(p._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||a,this.injections=mt(p.inject,r),this.slots=function(){return c.$slots||he(r,n.scopedSlots,c.$slots=de(t,r)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return he(r,n.scopedSlots,this.slots())}}),u&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=he(r,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,a){var s=_e(o,n,e,t,a,d);return s&&!i(s)&&(s.fnScopeId=p._scopeId,s.fnContext=r),s}:this._c=function(n,e,t,a){return _e(o,n,e,t,a,d)}}function ht(n,e,t,a,i){var r=vn(n);return r.fnContext=t,r.fnOptions=a,e.slot&&((r.data||(r.data={})).slot=e.slot),r}function vt(n,e){for(var t in e)n[_(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}ue(gt.prototype);var yt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;yt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;s(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,We)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,r){var s=i.data.scopedSlots,l=n.$scopedSlots,o=!!(s&&!s.$stable||l!==a&&!l.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),c=!!(r||n.$options._renderChildren||o),p=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=r;var u=i.data.attrs||a;n._attrsProxy&&fe(n._attrsProxy,u,p.data&&p.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||a;var d=n.$options._parentListeners;if(n._listenersProxy&&fe(n._listenersProxy,t,d||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ke(n,t,d),e&&n.$options.props){In(!1);for(var m=n._props,g=n.$options._propKeys||[],h=0;h<g.length;h++){var v=g[h],b=n.$options.props;m[v]=At(v,b,e,n)}In(!0),n.$options.propsData=e}c&&(n.$slots=de(r,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,nt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,tt.push(e)):Ze(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ye(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},ft=Object.keys(yt);function St(n,e,t,o,c){if(!r(n)){var u=t.$options._base;if(p(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(r(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=we;if(t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),l(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var a=n.owners=[t],i=!0,o=null,c=null;t.$on("hook:destroyed",(function(){return S(a,t)}));var u=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==o&&(clearTimeout(o),o=null),null!==c&&(clearTimeout(c),c=null))},d=B((function(t){n.resolved=je(t,e),i?a.length=0:u(!0)})),m=B((function(e){s(n.errorComp)&&(n.error=!0,u(!0))})),g=n(d,m);return p(g)&&(h(g)?r(n.resolved)&&g.then(d,m):h(g.component)&&(g.component.then(d,m),s(g.error)&&(n.errorComp=je(g.error,e)),s(g.loading)&&(n.loadingComp=je(g.loading,e),0===g.delay?n.loading=!0:o=setTimeout((function(){o=null,r(n.resolved)&&r(n.error)&&(n.loading=!0,u(!1))}),g.delay||200)),s(g.timeout)&&(c=setTimeout((function(){c=null,r(n.resolved)&&m(null)}),g.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,a,i){var r=gn();return r.asyncFactory=n,r.asyncMeta={data:e,context:t,children:a,tag:i},r}(d,e,t,o,c);e=e||{},Gt(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var r=e.on||(e.on={}),l=r[a],o=e.model.callback;s(l)?(i(l)?-1===l.indexOf(o):l!==o)&&(r[a]=[o].concat(l)):r[a]=o}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!r(a)){var i={},l=n.attrs,o=n.props;if(s(l)||s(o))for(var c in a){var p=I(c);$n(i,o,c,p,!0)||$n(i,l,c,p,!1)}return i}}(e,n);if(l(n.options.functional))return function(n,e,t,r,l){var o=n.options,c={},p=o.props;if(s(p))for(var u in p)c[u]=At(u,p,e||a);else s(t.attrs)&&vt(c,t.attrs),s(t.props)&&vt(c,t.props);var d=new gt(t,c,l,r,n),m=o.render.call(null,d._c,d);if(m instanceof mn)return ht(m,t,d.parent,o,d);if(i(m)){for(var g=Kn(m)||[],h=new Array(g.length),v=0;v<g.length;v++)h[v]=ht(g[v],t,d.parent,o,d);return h}}(n,m,e,t,o);var g=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var v=e.slot;e={},v&&(e.slot=v)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<ft.length;t++){var a=ft[t],i=e[a],r=yt[a];i===r||i&&i._merged||(e[a]=i?xt(r,i):r)}}(e);var b=bt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:g,tag:c,children:o},d)}}}function xt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var wt=O,jt=q.optionMergeStrategies;function Tt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,i,r,s=pn?Reflect.ownKeys(e):Object.keys(e),l=0;l<s.length;l++)"__ob__"!==(a=s[l])&&(i=n[a],r=e[a],t&&w(n,a)?i!==r&&d(i)&&d(r)&&Tt(i,r):On(n,a,r));return n}function _t(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,i=c(n)?n.call(t,t):n;return a?Tt(a,i):i}:e?n?function(){return Tt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function kt(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Et(n,e,t,a){var i=Object.create(n||null);return e?A(i,e):i}jt.data=function(n,e,t){return t?_t(n,e,t):e&&"function"!=typeof e?n:_t(n,e)},F.forEach((function(n){jt[n]=kt})),N.forEach((function(n){jt[n+"s"]=Et})),jt.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var r={};for(var s in A(r,n),e){var l=r[s],o=e[s];l&&!i(l)&&(l=[l]),r[s]=l?l.concat(o):i(o)?o:[o]}return r},jt.props=jt.methods=jt.inject=jt.computed=function(n,e,t,a){if(!n)return e;var i=Object.create(null);return A(i,n),e&&A(i,e),i},jt.provide=function(n,e){return n?function(){var t=Object.create(null);return Tt(t,c(n)?n.call(this):n),e&&Tt(t,c(e)?e.call(this):e,!1),t}:e};var It=function(n,e){return void 0===e?n:e};function zt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,r,s={};if(i(t))for(a=t.length;a--;)"string"==typeof(r=t[a])&&(s[_(r)]={type:null});else if(d(t))for(var l in t)r=t[l],s[_(l)]=d(r)?r:{type:r};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(i(t))for(var r=0;r<t.length;r++)a[t[r]]={from:t[r]};else if(d(t))for(var s in t){var l=t[s];a[s]=d(l)?A({from:s},l):{from:l}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=zt(n,e.extends,t)),e.mixins))for(var a=0,r=e.mixins.length;a<r;a++)n=zt(n,e.mixins[a],t);var s,l={};for(s in n)o(s);for(s in e)w(n,s)||o(s);function o(a){var i=jt[a]||It;l[a]=i(n[a],e[a],t,a)}return l}function Ct(n,e,t,a){if("string"==typeof t){var i=n[e];if(w(i,t))return i[t];var r=_(t);if(w(i,r))return i[r];var s=k(r);return w(i,s)?i[s]:i[t]||i[r]||i[s]}}function At(n,e,t,a){var i=e[n],r=!w(t,n),s=t[n],l=Mt(Boolean,i.type);if(l>-1)if(r&&!w(i,"default"))s=!1;else if(""===s||s===I(n)){var o=Mt(String,i.type);(o<0||l<o)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!w(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Ot(e.type)?a.call(n):a}(a,i,n);var p=En;In(!0),An(s),In(p)}return s}var Lt=/^\s*function (\w+)/;function Ot(n){var e=n&&n.toString().match(Lt);return e?e[1]:""}function Dt(n,e){return Ot(n)===Ot(e)}function Mt(n,e){if(!i(e))return Dt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Dt(e[t],n))return t;return-1}var Rt={enumerable:!0,configurable:!0,get:O,set:O};function Pt(n,e,t){Rt.get=function(){return this[e][t]},Rt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Rt)}function Bt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=Rn({}),i=n.$options._propKeys=[];n.$parent&&In(!1);var r=function(r){i.push(r);var s=At(r,e,t,n);Ln(a,r,s),r in n||Pt(n,"_props",r)};for(var s in e)r(s);In(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=ye(n);dn(n),xn();var i=Ee(t,null,[n._props||Rn({}),a],n,"setup");if(wn(),dn(),c(i))e.render=i;else if(p(i))if(n._setupState=i,i.__sfc){var r=n._setupProxy={};for(var s in i)"__sfc"!==s&&Nn(r,i,s)}else for(var s in i)V(s)||Nn(n,i,s);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?O:z(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return ke(n,e,"data()"),{}}finally{wn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var r=t[i];0,a&&w(a,r)||V(r)||Pt(n,"_data",r)}var s=An(e);s&&s.vmCount++}(n);else{var t=An(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=sn();for(var i in e){var r=e[i],s=c(r)?r:r.get;0,a||(t[i]=new Ge(n,s||O,O,Jt)),i in n||Nt(n,i,r)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(i(a))for(var r=0;r<a.length;r++)Ut(n,t,a[r]);else Ut(n,t,a)}}(n,e.watch)}var Jt={lazy:!0};function Nt(n,e,t){var a=!sn();c(t)?(Rt.get=a?Ft(e):qt(t),Rt.set=O):(Rt.get=t.get?a&&!1!==t.cache?Ft(e):qt(t.get):O,Rt.set=t.set||O),Object.defineProperty(n,e,Rt)}function Ft(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),fn.target&&e.depend(),e.value}}function qt(n){return function(){return n.call(this,this)}}function Ut(n,e,t,a){return d(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Vt=0;function Gt(n){var e=n.options;if(n.super){var t=Gt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var i in t)t[i]!==a[i]&&(e||(e={}),e[i]=t[i]);return e}(n);a&&A(n.extendOptions,a),(e=n.options=zt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ht(n){this._init(n)}function Qt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,i=n._Ctor||(n._Ctor={});if(i[a])return i[a];var r=bt(n)||bt(t.options);var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=zt(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)Pt(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)Nt(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,N.forEach((function(n){s[n]=t[n]})),r&&(s.options.components[r]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=A({},s.options),i[a]=s,s}}function $t(n){return n&&(bt(n.Ctor.options)||n.tag)}function Kt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Wt(n,e){var t=n.cache,a=n.keys,i=n._vnode;for(var r in t){var s=t[r];if(s){var l=s.name;l&&!e(l)&&Xt(t,r,a,i)}}}function Xt(n,e,t,a){var i=n[e];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),n[e]=null,S(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Vt++,e._isVue=!0,e.__v_skip=!0,e._scope=new qn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var i=a.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=zt(Gt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=de(e._renderChildren,i),n.$scopedSlots=t?he(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,i){return _e(n,e,t,a,i,!1)},n.$createElement=function(e,t,a,i){return _e(n,e,t,a,i,!0)};var r=t&&t.data;Ln(n,"$attrs",r&&r.attrs||a,null,!0),Ln(n,"$listeners",e._parentListeners||a,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(In(!1),Object.keys(e).forEach((function(t){Ln(n,t,e[t])})),In(!0))}(e),Bt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var a=Un(n),i=pn?Reflect.ownKeys(t):Object.keys(t),r=0;r<i.length;r++){var s=i[r];Object.defineProperty(a,s,Object.getOwnPropertyDescriptor(t,s))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ht),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=On,n.prototype.$delete=Dn,n.prototype.$watch=function(n,e,t){if(d(e))return Ut(this,n,e,t);(t=t||{}).user=!0;var a=new Ge(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(a.expression,'"');xn(),Ee(e,this,[a.value],this,i),wn()}return function(){a.teardown()}}}(Ht),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(i(n))for(var r=0,s=n.length;r<s;r++)a.$on(n[r],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var a=0,r=n.length;a<r;a++)t.$off(n[a],e);return t}var s,l=t._events[n];if(!l)return t;if(!e)return t._events[n]=null,t;for(var o=l.length;o--;)if((s=l[o])===e||s.fn===e){l.splice(o,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?C(t):t;for(var a=C(arguments,1),i='event handler for "'.concat(n,'"'),r=0,s=t.length;r<s;r++)Ee(t[r],e,a,e,i)}return e}}(Ht),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,i=t._vnode,r=Xe(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),r(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var s=t;s&&s.$vnode&&s.$parent&&s.$vnode===s.$parent._vnode;)s.$parent.$el=s.$el,s=s.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||S(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ht),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Je(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,r=t._parentVnode;r&&e._isMounted&&(e.$scopedSlots=he(e.$parent,r.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=r;try{dn(e),we=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){ke(t,e,"render"),n=e._vnode}finally{we=null,dn()}return i(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=gn()),n.parent=r,n}}(Ht);var Yt=[String,RegExp,Array],Zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yt,exclude:Yt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var i=t.tag,r=t.componentInstance,s=t.componentOptions;n[a]={name:$t(s),tag:i,componentInstance:r},e.push(a),this.max&&e.length>parseInt(this.max)&&Xt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Xt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Wt(n,(function(n){return Kt(e,n)}))})),this.$watch("exclude",(function(e){Wt(n,(function(n){return!Kt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Te(n),t=e&&e.componentOptions;if(t){var a=$t(t),i=this.include,r=this.exclude;if(i&&(!a||!Kt(i,a))||r&&a&&Kt(r,a))return e;var s=this.cache,l=this.keys,o=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;s[o]?(e.componentInstance=s[o].componentInstance,S(l,o),l.push(o)):(this.vnodeToCache=e,this.keyToCache=o),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return q}};Object.defineProperty(n,"config",e),n.util={warn:wt,extend:A,mergeOptions:zt,defineReactive:Ln},n.set=On,n.delete=Dn,n.nextTick=Je,n.observable=function(n){return An(n),n},n.options=Object.create(null),N.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,A(n.options.components,Zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=C(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=zt(this.options,n),this}}(n),Qt(n),function(n){N.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ht),Object.defineProperty(Ht.prototype,"$isServer",{get:sn}),Object.defineProperty(Ht.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ht,"FunctionalRenderContext",{value:gt}),Ht.version="2.7.14";var na=y("style,class"),ea=y("input,textarea,option,select,progress"),ta=y("contenteditable,draggable,spellcheck"),aa=y("events,caret,typing,plaintext-only"),ia=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ra="http://www.w3.org/1999/xlink",sa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},la=function(n){return sa(n)?n.slice(6,n.length):""},oa=function(n){return null==n||!1===n};function ca(n){for(var e=n.data,t=n,a=n;s(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=pa(a.data,e));for(;s(t=t.parent);)t&&t.data&&(e=pa(e,t.data));return function(n,e){if(s(n)||s(e))return ua(n,da(e));return""}(e.staticClass,e.class)}function pa(n,e){return{staticClass:ua(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function ua(n,e){return n?e?n+" "+e:n:e||""}function da(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,i=n.length;a<i;a++)s(e=da(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ma={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ga=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ha=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),va=function(n){return ga(n)||ha(n)};var ba=Object.create(null);var ya=y("text,number,password,search,email,tel,url");var fa=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ma[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Sa={create:function(n,e){xa(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xa(n,!0),xa(e))},destroy:function(n){xa(n,!0)}};function xa(n,e){var t=n.data.ref;if(s(t)){var a=n.context,r=n.componentInstance||n.elm,l=e?null:r,o=e?void 0:r;if(c(t))Ee(t,a,[l],a,"template ref function");else{var p=n.data.refInFor,u="string"==typeof t||"number"==typeof t,d=Jn(t),m=a.$refs;if(u||d)if(p){var g=u?m[t]:t.value;e?i(g)&&S(g,r):i(g)?g.includes(r)||g.push(r):u?(m[t]=[r],wa(a,t,m[t])):t.value=[r]}else if(u){if(e&&m[t]!==r)return;m[t]=o,wa(a,t,l)}else if(d){if(e&&t.value!==r)return;t.value=l}else 0}}}function wa(n,e,t){var a=n._setupState;a&&w(a,e)&&(Jn(a[e])?a[e].value=t:a[e]=t)}var ja=new mn("",{},[]),Ta=["create","activate","update","remove","destroy"];function _a(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=s(t=n.data)&&s(t=t.attrs)&&t.type,i=s(t=e.data)&&s(t=t.attrs)&&t.type;return a===i||ya(a)&&ya(i)}(n,e)||l(n.isAsyncPlaceholder)&&r(e.asyncFactory.error))}function ka(n,e,t){var a,i,r={};for(a=e;a<=t;++a)s(i=n[a].key)&&(r[i]=a);return r}var Ea={create:Ia,update:Ia,destroy:function(n){Ia(n,ja)}};function Ia(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,i,r=n===ja,s=e===ja,l=Ca(n.data.directives,n.context),o=Ca(e.data.directives,e.context),c=[],p=[];for(t in o)a=l[t],i=o[t],a?(i.oldValue=a.value,i.oldArg=a.arg,La(i,"update",e,n),i.def&&i.def.componentUpdated&&p.push(i)):(La(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var u=function(){for(var t=0;t<c.length;t++)La(c[t],"inserted",e,n)};r?Qn(e,"insert",u):u()}p.length&&Qn(e,"postpatch",(function(){for(var t=0;t<p.length;t++)La(p[t],"componentUpdated",e,n)}));if(!r)for(t in l)o[t]||La(l[t],"unbind",n,n,s)}(n,e)}var za=Object.create(null);function Ca(n,e){var t,a,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=za),i[Aa(a)]=a,e._setupState&&e._setupState.__sfc){var r=a.def||Ct(e,"_setupState","v-"+a.name);a.def="function"==typeof r?{bind:r,update:r}:r}a.def=a.def||Ct(e.$options,"directives",a.name)}return i}function Aa(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function La(n,e,t,a,i){var r=n.def&&n.def[e];if(r)try{r(t.elm,n,t,a,i)}catch(a){ke(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Oa=[Sa,Ea];function Da(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||r(n.data.attrs)&&r(e.data.attrs))){var a,i,o=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(a in(s(p.__ob__)||l(p._v_attr_proxy))&&(p=e.data.attrs=A({},p)),p)i=p[a],c[a]!==i&&Ma(o,a,i,e.data.pre);for(a in(W||Y)&&p.value!==c.value&&Ma(o,"value",p.value),c)r(p[a])&&(sa(a)?o.removeAttributeNS(ra,la(a)):ta(a)||o.removeAttribute(a))}}function Ma(n,e,t,a){a||n.tagName.indexOf("-")>-1?Ra(n,e,t):ia(e)?oa(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ta(e)?n.setAttribute(e,function(n,e){return oa(e)||"false"===e?"false":"contenteditable"===n&&aa(e)?e:"true"}(e,t)):sa(e)?oa(t)?n.removeAttributeNS(ra,la(e)):n.setAttributeNS(ra,e,t):Ra(n,e,t)}function Ra(n,e,t){if(oa(t))n.removeAttribute(e);else{if(W&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Pa={create:Da,update:Da};function Ba(n,e){var t=e.elm,a=e.data,i=n.data;if(!(r(a.staticClass)&&r(a.class)&&(r(i)||r(i.staticClass)&&r(i.class)))){var l=ca(e),o=t._transitionClasses;s(o)&&(l=ua(l,da(o))),l!==t._prevClass&&(t.setAttribute("class",l),t._prevClass=l)}}var Ja,Na={create:Ba,update:Ba};function Fa(n,e,t){var a=Ja;return function i(){var r=e.apply(null,arguments);null!==r&&Va(n,i,t,a)}}var qa=Ae&&!(en&&Number(en[1])<=53);function Ua(n,e,t,a){if(qa){var i=lt,r=e;e=r._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return r.apply(this,arguments)}}Ja.addEventListener(n,e,an?{capture:t,passive:a}:t)}function Va(n,e,t,a){(a||Ja).removeEventListener(n,e._wrapper||e,t)}function Ga(n,e){if(!r(n.data.on)||!r(e.data.on)){var t=e.data.on||{},a=n.data.on||{};Ja=e.elm||n.elm,function(n){if(s(n.__r)){var e=W?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Hn(t,a,Ua,Va,Fa,e.context),Ja=void 0}}var Ha,Qa={create:Ga,update:Ga,destroy:function(n){return Ga(n,ja)}};function $a(n,e){if(!r(n.data.domProps)||!r(e.data.domProps)){var t,a,i=e.elm,o=n.data.domProps||{},c=e.data.domProps||{};for(t in(s(c.__ob__)||l(c._v_attr_proxy))&&(c=e.data.domProps=A({},c)),o)t in c||(i[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===o[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=a;var p=r(a)?"":String(a);Ka(i,p)&&(i.value=p)}else if("innerHTML"===t&&ha(i.tagName)&&r(i.innerHTML)){(Ha=Ha||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var u=Ha.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;u.firstChild;)i.appendChild(u.firstChild)}else if(a!==o[t])try{i[t]=a}catch(n){}}}}function Ka(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(s(a)){if(a.number)return b(t)!==b(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Wa={create:$a,update:$a},Xa=j((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Ya(n){var e=Za(n.style);return n.staticStyle?A(n.staticStyle,e):e}function Za(n){return Array.isArray(n)?L(n):"string"==typeof n?Xa(n):n}var ni,ei=/^--/,ti=/\s*!important$/,ai=function(n,e,t){if(ei.test(e))n.style.setProperty(e,t);else if(ti.test(t))n.style.setProperty(I(e),t.replace(ti,""),"important");else{var a=ri(e);if(Array.isArray(t))for(var i=0,r=t.length;i<r;i++)n.style[a]=t[i];else n.style[a]=t}},ii=["Webkit","Moz","ms"],ri=j((function(n){if(ni=ni||document.createElement("div").style,"filter"!==(n=_(n))&&n in ni)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ii.length;t++){var a=ii[t]+e;if(a in ni)return a}}));function si(n,e){var t=e.data,a=n.data;if(!(r(t.staticStyle)&&r(t.style)&&r(a.staticStyle)&&r(a.style))){var i,l,o=e.elm,c=a.staticStyle,p=a.normalizedStyle||a.style||{},u=c||p,d=Za(e.data.style)||{};e.data.normalizedStyle=s(d.__ob__)?A({},d):d;var m=function(n,e){var t,a={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Ya(i.data))&&A(a,t);(t=Ya(n.data))&&A(a,t);for(var r=n;r=r.parent;)r.data&&(t=Ya(r.data))&&A(a,t);return a}(e,!0);for(l in u)r(m[l])&&ai(o,l,"");for(l in m)(i=m[l])!==u[l]&&ai(o,l,null==i?"":i)}}var li={create:si,update:si},oi=/\s+/;function ci(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(oi).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function pi(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(oi).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ui(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&A(e,di(n.name||"v")),A(e,n),e}return"string"==typeof n?di(n):void 0}}var di=j((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mi=$&&!X,gi="transition",hi="transitionend",vi="animation",bi="animationend";mi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(gi="WebkitTransition",hi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(vi="WebkitAnimation",bi="webkitAnimationEnd"));var yi=$?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function fi(n){yi((function(){yi(n)}))}function Si(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ci(n,e))}function xi(n,e){n._transitionClasses&&S(n._transitionClasses,e),pi(n,e)}function wi(n,e,t){var a=Ti(n,e),i=a.type,r=a.timeout,s=a.propCount;if(!i)return t();var l="transition"===i?hi:bi,o=0,c=function(){n.removeEventListener(l,p),t()},p=function(e){e.target===n&&++o>=s&&c()};setTimeout((function(){o<s&&c()}),r+1),n.addEventListener(l,p)}var ji=/\b(transform|all)(,|$)/;function Ti(n,e){var t,a=window.getComputedStyle(n),i=(a[gi+"Delay"]||"").split(", "),r=(a[gi+"Duration"]||"").split(", "),s=_i(i,r),l=(a[vi+"Delay"]||"").split(", "),o=(a[vi+"Duration"]||"").split(", "),c=_i(l,o),p=0,u=0;return"transition"===e?s>0&&(t="transition",p=s,u=r.length):"animation"===e?c>0&&(t="animation",p=c,u=o.length):u=(t=(p=Math.max(s,c))>0?s>c?"transition":"animation":null)?"transition"===t?r.length:o.length:0,{type:t,timeout:p,propCount:u,hasTransform:"transition"===t&&ji.test(a[gi+"Property"])}}function _i(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ki(e)+ki(n[t])})))}function ki(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ei(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=ui(n.data.transition);if(!r(a)&&!s(t._enterCb)&&1===t.nodeType){for(var i=a.css,l=a.type,o=a.enterClass,u=a.enterToClass,d=a.enterActiveClass,m=a.appearClass,g=a.appearToClass,h=a.appearActiveClass,v=a.beforeEnter,y=a.enter,f=a.afterEnter,S=a.enterCancelled,x=a.beforeAppear,w=a.appear,j=a.afterAppear,T=a.appearCancelled,_=a.duration,k=We,E=We.$vnode;E&&E.parent;)k=E.context,E=E.parent;var I=!k._isMounted||!n.isRootInsert;if(!I||w||""===w){var z=I&&m?m:o,C=I&&h?h:d,A=I&&g?g:u,L=I&&x||v,O=I&&c(w)?w:y,D=I&&j||f,M=I&&T||S,R=b(p(_)?_.enter:_);0;var P=!1!==i&&!X,J=Ci(O),N=t._enterCb=B((function(){P&&(xi(t,A),xi(t,C)),N.cancelled?(P&&xi(t,z),M&&M(t)):D&&D(t),t._enterCb=null}));n.data.show||Qn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),O&&O(t,N)})),L&&L(t),P&&(Si(t,z),Si(t,C),fi((function(){xi(t,z),N.cancelled||(Si(t,A),J||(zi(R)?setTimeout(N,R):wi(t,l,N)))}))),n.data.show&&(e&&e(),O&&O(t,N)),P||J||N()}}}function Ii(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=ui(n.data.transition);if(r(a)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var i=a.css,l=a.type,o=a.leaveClass,c=a.leaveToClass,u=a.leaveActiveClass,d=a.beforeLeave,m=a.leave,g=a.afterLeave,h=a.leaveCancelled,v=a.delayLeave,y=a.duration,f=!1!==i&&!X,S=Ci(m),x=b(p(y)?y.leave:y);0;var w=t._leaveCb=B((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),f&&(xi(t,c),xi(t,u)),w.cancelled?(f&&xi(t,o),h&&h(t)):(e(),g&&g(t)),t._leaveCb=null}));v?v(j):j()}function j(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),f&&(Si(t,o),Si(t,u),fi((function(){xi(t,o),w.cancelled||(Si(t,c),S||(zi(x)?setTimeout(w,x):wi(t,l,w)))}))),m&&m(t,w),f||S||w())}}function zi(n){return"number"==typeof n&&!isNaN(n)}function Ci(n){if(r(n))return!1;var e=n.fns;return s(e)?Ci(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ai(n,e){!0!==e.data.show&&Ei(e)}var Li=function(n){var e,t,a={},c=n.modules,p=n.nodeOps;for(e=0;e<Ta.length;++e)for(a[Ta[e]]=[],t=0;t<c.length;++t)s(c[t][Ta[e]])&&a[Ta[e]].push(c[t][Ta[e]]);function u(n){var e=p.parentNode(n);s(e)&&p.removeChild(e,n)}function d(n,e,t,i,r,o,c){if(s(n.elm)&&s(o)&&(n=o[c]=vn(n)),n.isRootInsert=!r,!function(n,e,t,i){var r=n.data;if(s(r)){var o=s(n.componentInstance)&&r.keepAlive;if(s(r=r.hook)&&s(r=r.init)&&r(n,!1),s(n.componentInstance))return m(n,e),g(t,n.elm,i),l(o)&&function(n,e,t,i){var r,l=n;for(;l.componentInstance;)if(l=l.componentInstance._vnode,s(r=l.data)&&s(r=r.transition)){for(r=0;r<a.activate.length;++r)a.activate[r](ja,l);e.push(l);break}g(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var u=n.data,d=n.children,v=n.tag;s(v)?(n.elm=n.ns?p.createElementNS(n.ns,v):p.createElement(v,n),f(n),h(n,d,e),s(u)&&b(n,e),g(t,n.elm,i)):l(n.isComment)?(n.elm=p.createComment(n.text),g(t,n.elm,i)):(n.elm=p.createTextNode(n.text),g(t,n.elm,i))}}function m(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,v(n)?(b(n,e),f(n)):(xa(n),e.push(n))}function g(n,e,t){s(n)&&(s(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function h(n,e,t){if(i(e)){0;for(var a=0;a<e.length;++a)d(e[a],t,n.elm,null,!0,e,a)}else o(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function v(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function b(n,t){for(var i=0;i<a.create.length;++i)a.create[i](ja,n);s(e=n.data.hook)&&(s(e.create)&&e.create(ja,n),s(e.insert)&&t.push(n))}function f(n){var e;if(s(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;s(e=We)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function S(n,e,t,a,i,r){for(;a<=i;++a)d(t[a],r,n,e,!1,t,a)}function x(n){var e,t,i=n.data;if(s(i))for(s(e=i.hook)&&s(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];s(a)&&(s(a.tag)?(j(a),x(a)):u(a.elm))}}function j(n,e){if(s(e)||s(n.data)){var t,i=a.remove.length+1;for(s(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,i),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&j(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else u(n.elm)}function T(n,e,t,a){for(var i=t;i<a;i++){var r=e[i];if(s(r)&&_a(n,r))return i}}function _(n,e,t,i,o,c){if(n!==e){s(e.elm)&&s(i)&&(e=i[o]=vn(e));var u=e.elm=n.elm;if(l(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?I(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,g=e.data;s(g)&&s(m=g.hook)&&s(m=m.prepatch)&&m(n,e);var h=n.children,b=e.children;if(s(g)&&v(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);s(m=g.hook)&&s(m=m.update)&&m(n,e)}r(e.text)?s(h)&&s(b)?h!==b&&function(n,e,t,a,i){var l,o,c,u=0,m=0,g=e.length-1,h=e[0],v=e[g],b=t.length-1,y=t[0],f=t[b],x=!i;for(0;u<=g&&m<=b;)r(h)?h=e[++u]:r(v)?v=e[--g]:_a(h,y)?(_(h,y,a,t,m),h=e[++u],y=t[++m]):_a(v,f)?(_(v,f,a,t,b),v=e[--g],f=t[--b]):_a(h,f)?(_(h,f,a,t,b),x&&p.insertBefore(n,h.elm,p.nextSibling(v.elm)),h=e[++u],f=t[--b]):_a(v,y)?(_(v,y,a,t,m),x&&p.insertBefore(n,v.elm,h.elm),v=e[--g],y=t[++m]):(r(l)&&(l=ka(e,u,g)),r(o=s(y.key)?l[y.key]:T(y,e,u,g))?d(y,a,n,h.elm,!1,t,m):_a(c=e[o],y)?(_(c,y,a,t,m),e[o]=void 0,x&&p.insertBefore(n,c.elm,h.elm)):d(y,a,n,h.elm,!1,t,m),y=t[++m]);u>g?S(n,r(t[b+1])?null:t[b+1].elm,t,m,b,a):m>b&&w(e,u,g)}(u,h,b,t,c):s(b)?(s(n.text)&&p.setTextContent(u,""),S(u,null,b,0,b.length-1,t)):s(h)?w(h,0,h.length-1):s(n.text)&&p.setTextContent(u,""):n.text!==e.text&&p.setTextContent(u,e.text),s(g)&&s(m=g.hook)&&s(m=m.postpatch)&&m(n,e)}}}function k(n,e,t){if(l(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var E=y("attrs,class,staticClass,staticStyle,key");function I(n,e,t,a){var i,r=e.tag,o=e.data,c=e.children;if(a=a||o&&o.pre,e.elm=n,l(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(o)&&(s(i=o.hook)&&s(i=i.init)&&i(e,!0),s(i=e.componentInstance)))return m(e,t),!0;if(s(r)){if(s(c))if(n.hasChildNodes())if(s(i=o)&&s(i=i.domProps)&&s(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var p=!0,u=n.firstChild,d=0;d<c.length;d++){if(!u||!I(u,c[d],t,a)){p=!1;break}u=u.nextSibling}if(!p||u)return!1}else h(e,c,t);if(s(o)){var g=!1;for(var v in o)if(!E(v)){g=!0,b(e,t);break}!g&&o.class&&qe(o.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!r(e)){var o,c=!1,u=[];if(r(n))c=!0,d(e,u);else{var m=s(n.nodeType);if(!m&&_a(n,e))_(n,e,u,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&I(n,e,u))return k(e,u,!0),n;o=n,n=new mn(p.tagName(o).toLowerCase(),{},[],void 0,o)}var g=n.elm,h=p.parentNode(g);if(d(e,u,g._leaveCb?null:h,p.nextSibling(g)),s(e.parent))for(var b=e.parent,y=v(e);b;){for(var f=0;f<a.destroy.length;++f)a.destroy[f](b);if(b.elm=e.elm,y){for(var S=0;S<a.create.length;++S)a.create[S](ja,b);var j=b.data.hook.insert;if(j.merged)for(var T=1;T<j.fns.length;T++)j.fns[T]()}else xa(b);b=b.parent}s(h)?w([n],0,0):s(n.tag)&&x(n)}}return k(e,u,c),e.elm}s(n)&&x(n)}}({nodeOps:fa,modules:[Pa,Na,Qa,Wa,li,$?{create:Ai,activate:Ai,remove:function(n,e){!0!==n.data.show?Ii(n,e):e()}}:{}].concat(Oa)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ni(n,"input")}));var Oi={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Qn(t,"postpatch",(function(){Oi.componentUpdated(n,e,t)})):Di(n,e,t.context),n._vOptions=[].map.call(n.options,Pi)):("textarea"===t.tag||ya(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Bi),n.addEventListener("compositionend",Ji),n.addEventListener("change",Ji),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Di(n,e,t.context);var a=n._vOptions,i=n._vOptions=[].map.call(n.options,Pi);if(i.some((function(n,e){return!R(n,a[e])})))(n.multiple?e.value.some((function(n){return Ri(n,i)})):e.value!==e.oldValue&&Ri(e.value,i))&&Ni(n,"change")}}};function Di(n,e,t){Mi(n,e,t),(W||Y)&&setTimeout((function(){Mi(n,e,t)}),0)}function Mi(n,e,t){var a=e.value,i=n.multiple;if(!i||Array.isArray(a)){for(var r,s,l=0,o=n.options.length;l<o;l++)if(s=n.options[l],i)r=P(a,Pi(s))>-1,s.selected!==r&&(s.selected=r);else if(R(Pi(s),a))return void(n.selectedIndex!==l&&(n.selectedIndex=l));i||(n.selectedIndex=-1)}}function Ri(n,e){return e.every((function(e){return!R(e,n)}))}function Pi(n){return"_value"in n?n._value:n.value}function Bi(n){n.target.composing=!0}function Ji(n){n.target.composing&&(n.target.composing=!1,Ni(n.target,"input"))}function Ni(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fi(n){return!n.componentInstance||n.data&&n.data.transition?n:Fi(n.componentInstance._vnode)}var qi={model:Oi,show:{bind:function(n,e,t){var a=e.value,i=(t=Fi(t)).data&&t.data.transition,r=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&i?(t.data.show=!0,Ei(t,(function(){n.style.display=r}))):n.style.display=a?r:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Fi(t)).data&&t.data.transition?(t.data.show=!0,a?Ei(t,(function(){n.style.display=n.__vOriginalDisplay})):Ii(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,i){i||(n.style.display=n.__vOriginalDisplay)}}},Ui={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Vi(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Vi(Te(e.children)):n}function Gi(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var i=t._parentListeners;for(var a in i)e[_(a)]=i[a];return e}function Hi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Qi=function(n){return n.tag||ge(n)},$i=function(n){return"show"===n.name},Ki={name:"transition",props:Ui,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Qi)).length){0;var a=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var r=Vi(i);if(!r)return i;if(this._leaving)return Hi(n,i);var s="__transition-".concat(this._uid,"-");r.key=null==r.key?r.isComment?s+"comment":s+r.tag:o(r.key)?0===String(r.key).indexOf(s)?r.key:s+r.key:r.key;var l=(r.data||(r.data={})).transition=Gi(this),c=this._vnode,p=Vi(c);if(r.data.directives&&r.data.directives.some($i)&&(r.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(r,p)&&!ge(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var u=p.data.transition=A({},l);if("out-in"===a)return this._leaving=!0,Qn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Hi(n,i);if("in-out"===a){if(ge(r))return c;var d,m=function(){d()};Qn(l,"afterEnter",m),Qn(l,"enterCancelled",m),Qn(u,"delayLeave",(function(n){d=n}))}}return i}}},Wi=A({tag:String,moveClass:String},Ui);function Xi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Yi(n){n.data.newPos=n.elm.getBoundingClientRect()}function Zi(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,i=e.top-t.top;if(a||i){n.data.moved=!0;var r=n.elm.style;r.transform=r.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),r.transitionDuration="0s"}}delete Wi.mode;var nr={Transition:Ki,TransitionGroup:{props:Wi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var i=Xe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],r=this.children=[],s=Gi(this),l=0;l<i.length;l++){if((p=i[l]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))r.push(p),t[p.key]=p,(p.data||(p.data={})).transition=s;else;}if(a){var o=[],c=[];for(l=0;l<a.length;l++){var p;(p=a[l]).data.transition=s,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?o.push(p):c.push(p)}this.kept=n(e,null,o),this.removed=c}return n(e,null,r)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Xi),n.forEach(Yi),n.forEach(Zi),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;Si(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(hi,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(hi,n),t._moveCb=null,xi(t,e))})}})))},methods:{hasMove:function(n,e){if(!mi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){pi(t,n)})),ci(t,e),t.style.display="none",this.$el.appendChild(t);var a=Ti(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function er(n,e){for(var t in e)n[t]=e[t];return n}Ht.config.mustUseProp=function(n,e,t){return"value"===t&&ea(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ht.config.isReservedTag=va,Ht.config.isReservedAttr=na,Ht.config.getTagNamespace=function(n){return ha(n)?"svg":"math"===n?"math":void 0},Ht.config.isUnknownElement=function(n){if(!$)return!0;if(va(n))return!1;if(n=n.toLowerCase(),null!=ba[n])return ba[n];var e=document.createElement(n);return n.indexOf("-")>-1?ba[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ba[n]=/HTMLUnknownElement/.test(e.toString())},A(Ht.options.directives,qi),A(Ht.options.components,nr),Ht.prototype.__patch__=$?Li:O,Ht.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=gn),nt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new Ge(n,a,O,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var r=0;r<i.length;r++)i[r].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&$?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},$&&setTimeout((function(){q.devtools&&ln&&ln.emit("init",Ht)}),0);var tr=/[!'()*]/g,ar=function(n){return"%"+n.charCodeAt(0).toString(16)},ir=/%2C/g,rr=function(n){return encodeURIComponent(n).replace(tr,ar).replace(ir,",")};function sr(n){try{return decodeURIComponent(n)}catch(n){0}return n}var lr=function(n){return null==n||"object"==typeof n?n:String(n)};function or(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=sr(t.shift()),i=t.length>0?sr(t.join("=")):null;void 0===e[a]?e[a]=i:Array.isArray(e[a])?e[a].push(i):e[a]=[e[a],i]})),e):e}function cr(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return rr(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(rr(e)):a.push(rr(e)+"="+rr(n)))})),a.join("&")}return rr(e)+"="+rr(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var pr=/\/?$/;function ur(n,e,t,a){var i=a&&a.options.stringifyQuery,r=e.query||{};try{r=dr(r)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:r,params:e.params||{},fullPath:hr(e,i),matched:n?gr(n):[]};return t&&(s.redirectedFrom=hr(t,i)),Object.freeze(s)}function dr(n){if(Array.isArray(n))return n.map(dr);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=dr(n[t]);return e}return n}var mr=ur(null,{path:"/"});function gr(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function hr(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||cr)(a)+i}function vr(n,e,t){return e===mr?n===e:!!e&&(n.path&&e.path?n.path.replace(pr,"")===e.path.replace(pr,"")&&(t||n.hash===e.hash&&br(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&br(n.query,e.query)&&br(n.params,e.params))))}function br(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,i){var r=n[t];if(a[i]!==t)return!1;var s=e[t];return null==r||null==s?r===s:"object"==typeof r&&"object"==typeof s?br(r,s):String(r)===String(s)}))}function yr(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var i=t.instances[a],r=t.enteredCbs[a];if(i&&r){delete t.enteredCbs[a];for(var s=0;s<r.length;s++)i._isBeingDestroyed||r[s](i)}}}}var fr={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,i=e.parent,r=e.data;r.routerView=!0;for(var s=i.$createElement,l=t.name,o=i.$route,c=i._routerViewCache||(i._routerViewCache={}),p=0,u=!1;i&&i._routerRoot!==i;){var d=i.$vnode?i.$vnode.data:{};d.routerView&&p++,d.keepAlive&&i._directInactive&&i._inactive&&(u=!0),i=i.$parent}if(r.routerViewDepth=p,u){var m=c[l],g=m&&m.component;return g?(m.configProps&&Sr(g,r,m.route,m.configProps),s(g,r,a)):s()}var h=o.matched[p],v=h&&h.components[l];if(!h||!v)return c[l]=null,s();c[l]={component:v},r.registerRouteInstance=function(n,e){var t=h.instances[l];(e&&t!==n||!e&&t===n)&&(h.instances[l]=e)},(r.hook||(r.hook={})).prepatch=function(n,e){h.instances[l]=e.componentInstance},r.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[l]&&(h.instances[l]=n.componentInstance),yr(o)};var b=h.props&&h.props[l];return b&&(er(c[l],{route:o,configProps:b}),Sr(v,r,o,b)),s(v,r,a)}};function Sr(n,e,t,a){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(i){i=e.props=er({},i);var r=e.attrs=e.attrs||{};for(var s in i)n.props&&s in n.props||(r[s]=i[s],delete i[s])}}function xr(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var r=n.replace(/^\//,"").split("/"),s=0;s<r.length;s++){var l=r[s];".."===l?i.pop():"."!==l&&i.push(l)}return""!==i[0]&&i.unshift(""),i.join("/")}function wr(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var jr=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Tr=Br,_r=Cr,kr=function(n,e){return Lr(Cr(n,e),e)},Er=Lr,Ir=Pr,zr=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Cr(n,e){for(var t,a=[],i=0,r=0,s="",l=e&&e.delimiter||"/";null!=(t=zr.exec(n));){var o=t[0],c=t[1],p=t.index;if(s+=n.slice(r,p),r=p+o.length,c)s+=c[1];else{var u=n[r],d=t[2],m=t[3],g=t[4],h=t[5],v=t[6],b=t[7];s&&(a.push(s),s="");var y=null!=d&&null!=u&&u!==d,f="+"===v||"*"===v,S="?"===v||"*"===v,x=t[2]||l,w=g||h;a.push({name:m||i++,prefix:d||"",delimiter:x,optional:S,repeat:f,partial:y,asterisk:!!b,pattern:w?Dr(w):b?".*":"[^"+Or(x)+"]+?"})}}return r<n.length&&(s+=n.substr(r)),s&&a.push(s),a}function Ar(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Lr(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Rr(e)));return function(e,a){for(var i="",r=e||{},s=(a||{}).pretty?Ar:encodeURIComponent,l=0;l<n.length;l++){var o=n[l];if("string"!=typeof o){var c,p=r[o.name];if(null==p){if(o.optional){o.partial&&(i+=o.prefix);continue}throw new TypeError('Expected "'+o.name+'" to be defined')}if(jr(p)){if(!o.repeat)throw new TypeError('Expected "'+o.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(o.optional)continue;throw new TypeError('Expected "'+o.name+'" to not be empty')}for(var u=0;u<p.length;u++){if(c=s(p[u]),!t[l].test(c))throw new TypeError('Expected all "'+o.name+'" to match "'+o.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===u?o.prefix:o.delimiter)+c}}else{if(c=o.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(p),!t[l].test(c))throw new TypeError('Expected "'+o.name+'" to match "'+o.pattern+'", but received "'+c+'"');i+=o.prefix+c}}else i+=o}return i}}function Or(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Dr(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Mr(n,e){return n.keys=e,n}function Rr(n){return n&&n.sensitive?"":"i"}function Pr(n,e,t){jr(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,i=!1!==t.end,r="",s=0;s<n.length;s++){var l=n[s];if("string"==typeof l)r+=Or(l);else{var o=Or(l.prefix),c="(?:"+l.pattern+")";e.push(l),l.repeat&&(c+="(?:"+o+c+")*"),r+=c=l.optional?l.partial?o+"("+c+")?":"(?:"+o+"("+c+"))?":o+"("+c+")"}}var p=Or(t.delimiter||"/"),u=r.slice(-p.length)===p;return a||(r=(u?r.slice(0,-p.length):r)+"(?:"+p+"(?=$))?"),r+=i?"$":a&&u?"":"(?="+p+"|$)",Mr(new RegExp("^"+r,Rr(t)),e)}function Br(n,e,t){return jr(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Mr(n,e)}(n,e):jr(n)?function(n,e,t){for(var a=[],i=0;i<n.length;i++)a.push(Br(n[i],e,t).source);return Mr(new RegExp("(?:"+a.join("|")+")",Rr(t)),e)}(n,e,t):function(n,e,t){return Pr(Cr(n,t),e,t)}(n,e,t)}Tr.parse=_r,Tr.compile=kr,Tr.tokensToFunction=Er,Tr.tokensToRegExp=Ir;var Jr=Object.create(null);function Nr(n,e,t){e=e||{};try{var a=Jr[n]||(Jr[n]=Tr.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Fr(n,e,t,a){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var r=(i=er({},n)).params;return r&&"object"==typeof r&&(i.params=er({},r)),i}if(!i.path&&i.params&&e){(i=er({},i))._normalized=!0;var s=er(er({},e.params),i.params);if(e.name)i.name=e.name,i.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;i.path=Nr(l,s,e.path)}else 0;return i}var o=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",p=o.path?xr(o.path,c,t||i.append):c,u=function(n,e,t){void 0===e&&(e={});var a,i=t||or;try{a=i(n||"")}catch(n){a={}}for(var r in e){var s=e[r];a[r]=Array.isArray(s)?s.map(lr):lr(s)}return a}(o.query,i.query,a&&a.options.parseQuery),d=i.hash||o.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:p,query:u,hash:d}}var qr,Ur=function(){},Vr={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,i=t.resolve(this.to,a,this.append),r=i.location,s=i.route,l=i.href,o={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,d=null==p?"router-link-exact-active":p,m=null==this.activeClass?u:this.activeClass,g=null==this.exactActiveClass?d:this.exactActiveClass,h=s.redirectedFrom?ur(null,Fr(s.redirectedFrom),null,t):s;o[g]=vr(a,h,this.exactPath),o[m]=this.exact||this.exactPath?o[g]:function(n,e){return 0===n.path.replace(pr,"/").indexOf(e.path.replace(pr,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,h);var v=o[g]?this.ariaCurrentValue:null,b=function(n){Gr(n)&&(e.replace?t.replace(r,Ur):t.push(r,Ur))},y={click:Gr};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=b})):y[this.event]=b;var f={class:o},S=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:b,isActive:o[m],isExactActive:o[g]});if(S){if(1===S.length)return S[0];if(S.length>1||!S.length)return 0===S.length?n():n("span",{},S)}if("a"===this.tag)f.on=y,f.attrs={href:l,"aria-current":v};else{var x=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=er({},x.data);for(var j in w.on=w.on||{},w.on){var T=w.on[j];j in y&&(w.on[j]=Array.isArray(T)?T:[T])}for(var _ in y)_ in w.on?w.on[_].push(y[_]):w.on[_]=b;var k=x.data.attrs=er({},x.data.attrs);k.href=l,k["aria-current"]=v}else f.on=y}return n(this.tag,f,this.$slots.default)}};function Gr(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Hr="undefined"!=typeof window;function Qr(n,e,t,a,i){var r=e||[],s=t||Object.create(null),l=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,i,r,s){var l=i.path,o=i.name;0;var c=i.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return wr(e.path+"/"+n)}(l,r,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var u={path:p,regex:$r(p,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:o,parent:r,matchAs:s,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var r=s?wr(s+"/"+i.path):void 0;n(e,t,a,i,u,r)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==i.alias)for(var d=Array.isArray(i.alias)?i.alias:[i.alias],m=0;m<d.length;++m){0;var g={path:d[m],children:i.children};n(e,t,a,g,r,u.path||"/")}o&&(a[o]||(a[o]=u))}(r,s,l,n,i)}));for(var o=0,c=r.length;o<c;o++)"*"===r[o]&&(r.push(r.splice(o,1)[0]),c--,o--);return{pathList:r,pathMap:s,nameMap:l}}function $r(n,e){return Tr(n,[],e)}function Kr(n,e){var t=Qr(n),a=t.pathList,i=t.pathMap,r=t.nameMap;function s(n,t,s){var l=Fr(n,t,!1,e),c=l.name;if(c){var p=r[c];if(!p)return o(null,l);var u=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof l.params&&(l.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in l.params)&&u.indexOf(d)>-1&&(l.params[d]=t.params[d]);return l.path=Nr(p.path,l.params),o(p,l,s)}if(l.path){l.params={};for(var m=0;m<a.length;m++){var g=a[m],h=i[g];if(Wr(h.regex,l.path,l.params))return o(h,l,s)}}return o(null,l)}function l(n,t){var a=n.redirect,i="function"==typeof a?a(ur(n,t,null,e)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return o(null,t);var l=i,c=l.name,p=l.path,u=t.query,d=t.hash,m=t.params;if(u=l.hasOwnProperty("query")?l.query:u,d=l.hasOwnProperty("hash")?l.hash:d,m=l.hasOwnProperty("params")?l.params:m,c){r[c];return s({_normalized:!0,name:c,query:u,hash:d,params:m},void 0,t)}if(p){var g=function(n,e){return xr(n,e.parent?e.parent.path:"/",!0)}(p,n);return s({_normalized:!0,path:Nr(g,m),query:u,hash:d},void 0,t)}return o(null,t)}function o(n,t,a){return n&&n.redirect?l(n,a||t):n&&n.matchAs?function(n,e,t){var a=s({_normalized:!0,path:Nr(t,e.params)});if(a){var i=a.matched,r=i[i.length-1];return e.params=a.params,o(r,e)}return o(null,e)}(0,t,n.matchAs):ur(n,t,a,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?r[n]:void 0;Qr([e||n],a,i,r,t),t&&t.alias.length&&Qr(t.alias.map((function(n){return{path:n,children:[e]}})),a,i,r,t)},getRoutes:function(){return a.map((function(n){return i[n]}))},addRoutes:function(n){Qr(n,a,i,r)}}}function Wr(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var i=1,r=a.length;i<r;++i){var s=n.keys[i-1];s&&(t[s.name||"pathMatch"]="string"==typeof a[i]?sr(a[i]):a[i])}return!0}var Xr=Hr&&window.performance&&window.performance.now?window.performance:Date;function Yr(){return Xr.now().toFixed(3)}var Zr=Yr();function ns(){return Zr}function es(n){return Zr=n}var ts=Object.create(null);function as(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=er({},window.history.state);return t.key=ns(),window.history.replaceState(t,"",e),window.addEventListener("popstate",ss),function(){window.removeEventListener("popstate",ss)}}function is(n,e,t,a){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var r=function(){var n=ns();if(n)return ts[n]}(),s=i.call(n,e,t,a?r:null);s&&("function"==typeof s.then?s.then((function(n){us(n,r)})).catch((function(n){0})):us(s,r))}))}}function rs(){var n=ns();n&&(ts[n]={x:window.pageXOffset,y:window.pageYOffset})}function ss(n){rs(),n.state&&n.state.key&&es(n.state.key)}function ls(n){return cs(n.x)||cs(n.y)}function os(n){return{x:cs(n.x)?n.x:window.pageXOffset,y:cs(n.y)?n.y:window.pageYOffset}}function cs(n){return"number"==typeof n}var ps=/^#\d/;function us(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var i=ps.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var r=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(i,r={x:cs((t=r).x)?t.x:0,y:cs(t.y)?t.y:0})}else ls(n)&&(e=os(n))}else a&&ls(n)&&(e=os(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ds,ms=Hr&&((-1===(ds=window.navigator.userAgent).indexOf("Android 2.")&&-1===ds.indexOf("Android 4.0")||-1===ds.indexOf("Mobile Safari")||-1!==ds.indexOf("Chrome")||-1!==ds.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function gs(n,e){rs();var t=window.history;try{if(e){var a=er({},t.state);a.key=ns(),t.replaceState(a,"",n)}else t.pushState({key:es(Yr())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function hs(n){gs(n,!0)}var vs={redirected:2,aborted:4,cancelled:8,duplicated:16};function bs(n,e){return fs(n,e,vs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Ss.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function ys(n,e){return fs(n,e,vs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function fs(n,e,t,a){var i=new Error(a);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var Ss=["params","query","hash"];function xs(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ws(n,e){return xs(n)&&n._isRouter&&(null==e||n.type===e)}function js(n,e,t){var a=function(i){i>=n.length?t():n[i]?e(n[i],(function(){a(i+1)})):a(i+1)};a(0)}function Ts(n){return function(e,t,a){var i=!1,r=0,s=null;_s(n,(function(n,e,t,l){if("function"==typeof n&&void 0===n.cid){i=!0,r++;var o,c=Is((function(e){var i;((i=e).__esModule||Es&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:qr.extend(e),t.components[l]=e,--r<=0&&a()})),p=Is((function(n){var e="Failed to resolve async component "+l+": "+n;s||(s=xs(n)?n:new Error(e),a(s))}));try{o=n(c,p)}catch(n){p(n)}if(o)if("function"==typeof o.then)o.then(c,p);else{var u=o.component;u&&"function"==typeof u.then&&u.then(c,p)}}})),i||a()}}function _s(n,e){return ks(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function ks(n){return Array.prototype.concat.apply([],n)}var Es="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Is(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var zs=function(n,e){this.router=n,this.base=function(n){if(!n)if(Hr){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=mr,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Cs(n,e,t,a){var i=_s(n,(function(n,a,i,r){var s=function(n,e){"function"!=typeof n&&(n=qr.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,a,i,r)})):t(s,a,i,r)}));return ks(a?i.reverse():i)}function As(n,e){if(e)return function(){return n.apply(e,arguments)}}zs.prototype.listen=function(n){this.cb=n},zs.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},zs.prototype.onError=function(n){this.errorCbs.push(n)},zs.prototype.transitionTo=function(n,e,t){var a,i=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var r=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),e&&e(a),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(a,r)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!i.ready&&(ws(n,vs.redirected)&&r===mr||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},zs.prototype.confirmTransition=function(n,e,t){var a=this,i=this.current;this.pending=n;var r,s,l=function(n){!ws(n)&&xs(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},o=n.matched.length-1,c=i.matched.length-1;if(vr(n,i)&&o===c&&n.matched[o]===i.matched[c])return this.ensureURL(),n.hash&&is(this.router,i,n,!1),l(((s=fs(r=i,n,vs.duplicated,'Avoided redundant navigation to current location: "'+r.fullPath+'".')).name="NavigationDuplicated",s));var p=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=p.updated,d=p.deactivated,m=p.activated,g=[].concat(function(n){return Cs(n,"beforeRouteLeave",As,!0)}(d),this.router.beforeHooks,function(n){return Cs(n,"beforeRouteUpdate",As)}(u),m.map((function(n){return n.beforeEnter})),Ts(m)),h=function(e,t){if(a.pending!==n)return l(ys(i,n));try{e(n,i,(function(e){!1===e?(a.ensureURL(!0),l(function(n,e){return fs(n,e,vs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):xs(e)?(a.ensureURL(!0),l(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(l(bs(i,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){l(n)}};js(g,h,(function(){js(function(n){return Cs(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,i,r){return n(a,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),r(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),h,(function(){if(a.pending!==n)return l(ys(i,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){yr(n)}))}))}))},zs.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},zs.prototype.setupListeners=function(){},zs.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=mr,this.pending=null};var Ls=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Os(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=ms&&t;a&&this.listeners.push(as());var i=function(){var t=n.current,i=Os(n.base);n.current===mr&&i===n._startLocation||n.transitionTo(i,(function(n){a&&is(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){gs(wr(a.base+n.fullPath)),is(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){hs(wr(a.base+n.fullPath)),is(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Os(this.base)!==this.current.fullPath){var e=wr(this.base+this.current.fullPath);n?gs(e):hs(e)}},e.prototype.getCurrentLocation=function(){return Os(this.base)},e}(zs);function Os(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(wr(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ds=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Os(n);if(!/^\/#/.test(e))return window.location.replace(wr(n+"/#"+e)),!0}(this.base)||Ms()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ms&&e;t&&this.listeners.push(as());var a=function(){var e=n.current;Ms()&&n.transitionTo(Rs(),(function(a){t&&is(n.router,a,e,!0),ms||Js(a.fullPath)}))},i=ms?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Bs(n.fullPath),is(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Js(n.fullPath),is(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Rs()!==e&&(n?Bs(e):Js(e))},e.prototype.getCurrentLocation=function(){return Rs()},e}(zs);function Ms(){var n=Rs();return"/"===n.charAt(0)||(Js("/"+n),!1)}function Rs(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ps(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Bs(n){ms?gs(Ps(n)):window.location.hash=n}function Js(n){ms?hs(Ps(n)):window.location.replace(Ps(n))}var Ns=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){ws(n,vs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(zs),Fs=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Kr(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ms&&!1!==n.fallback,this.fallback&&(e="hash"),Hr||(e="abstract"),this.mode=e,e){case"history":this.history=new Ls(this,n.base);break;case"hash":this.history=new Ds(this,n.base,this.fallback);break;case"abstract":this.history=new Ns(this,n.base);break;default:0}},qs={currentRoute:{configurable:!0}};Fs.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},qs.currentRoute.get=function(){return this.history&&this.history.current},Fs.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Ls||t instanceof Ds){var a=function(n){t.setupListeners(),function(n){var a=t.current,i=e.options.scrollBehavior;ms&&i&&"fullPath"in n&&is(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Fs.prototype.beforeEach=function(n){return Vs(this.beforeHooks,n)},Fs.prototype.beforeResolve=function(n){return Vs(this.resolveHooks,n)},Fs.prototype.afterEach=function(n){return Vs(this.afterHooks,n)},Fs.prototype.onReady=function(n,e){this.history.onReady(n,e)},Fs.prototype.onError=function(n){this.history.onError(n)},Fs.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Fs.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Fs.prototype.go=function(n){this.history.go(n)},Fs.prototype.back=function(){this.go(-1)},Fs.prototype.forward=function(){this.go(1)},Fs.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Fs.prototype.resolve=function(n,e,t){var a=Fr(n,e=e||this.history.current,t,this),i=this.match(a,e),r=i.redirectedFrom||i.fullPath;return{location:a,route:i,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?wr(n+"/"+a):a}(this.history.base,r,this.mode),normalizedTo:a,resolved:i}},Fs.prototype.getRoutes=function(){return this.matcher.getRoutes()},Fs.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==mr&&this.history.transitionTo(this.history.getCurrentLocation())},Fs.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==mr&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Fs.prototype,qs);var Us=Fs;function Vs(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Fs.install=function n(e){if(!n.installed||qr!==e){n.installed=!0,qr=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",fr),e.component("RouterLink",Vr);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Fs.version="3.6.5",Fs.isNavigationFailure=ws,Fs.NavigationFailureType=vs,Fs.START_LOCATION=mr,Hr&&window.Vue&&window.Vue.use(Fs);t(103);t(16),t(130);var Gs={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,328)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,327))},Hs={"v-6b5e3b9e":()=>t.e(5).then(t.bind(null,329)),"v-9767263a":()=>t.e(7).then(t.bind(null,330)),"v-4a930d01":()=>t.e(6).then(t.bind(null,331)),"v-4a83f009":()=>t.e(8).then(t.bind(null,332)),"v-f9f336e8":()=>t.e(9).then(t.bind(null,333)),"v-526b6042":()=>t.e(10).then(t.bind(null,334)),"v-74b46c48":()=>t.e(12).then(t.bind(null,335)),"v-684ba736":()=>t.e(11).then(t.bind(null,336)),"v-4508e630":()=>t.e(13).then(t.bind(null,337)),"v-4855977e":()=>t.e(15).then(t.bind(null,338)),"v-3ed4795a":()=>t.e(14).then(t.bind(null,339)),"v-9bb40838":()=>t.e(16).then(t.bind(null,340)),"v-6c582e6a":()=>t.e(17).then(t.bind(null,341)),"v-026fe816":()=>t.e(18).then(t.bind(null,342)),"v-b545df88":()=>t.e(20).then(t.bind(null,343)),"v-d4b0e508":()=>t.e(21).then(t.bind(null,344)),"v-397f7974":()=>t.e(22).then(t.bind(null,345)),"v-eca6f7ba":()=>t.e(19).then(t.bind(null,346)),"v-7e4c890f":()=>t.e(23).then(t.bind(null,347)),"v-4c1c2380":()=>t.e(24).then(t.bind(null,348)),"v-0ba597e9":()=>t.e(25).then(t.bind(null,349)),"v-4fb73d7d":()=>t.e(26).then(t.bind(null,350)),"v-659791a7":()=>t.e(28).then(t.bind(null,351)),"v-74277329":()=>t.e(27).then(t.bind(null,352)),"v-f3069b4a":()=>t.e(29).then(t.bind(null,353)),"v-f7888516":()=>t.e(31).then(t.bind(null,354)),"v-6b7e9ccd":()=>t.e(30).then(t.bind(null,355)),"v-6d5c62aa":()=>t.e(32).then(t.bind(null,356)),"v-0658261e":()=>t.e(33).then(t.bind(null,357)),"v-53e281ba":()=>t.e(34).then(t.bind(null,358)),"v-412cb168":()=>t.e(35).then(t.bind(null,359)),"v-0cff2ea9":()=>t.e(36).then(t.bind(null,360)),"v-25ae2882":()=>t.e(37).then(t.bind(null,361)),"v-5b433015":()=>t.e(38).then(t.bind(null,362)),"v-178980de":()=>t.e(39).then(t.bind(null,363)),"v-7d6ccb43":()=>t.e(40).then(t.bind(null,364)),"v-5fb0e4a0":()=>t.e(41).then(t.bind(null,365)),"v-322162e0":()=>t.e(43).then(t.bind(null,366)),"v-6aaaa430":()=>t.e(42).then(t.bind(null,367)),"v-ebfbb4aa":()=>t.e(44).then(t.bind(null,368)),"v-7d4ea15e":()=>t.e(45).then(t.bind(null,369)),"v-611843b4":()=>t.e(46).then(t.bind(null,370)),"v-5320d5b4":()=>t.e(47).then(t.bind(null,371)),"v-771f7249":()=>t.e(48).then(t.bind(null,372)),"v-7e01f4b7":()=>t.e(50).then(t.bind(null,373)),"v-70fa0b4f":()=>t.e(51).then(t.bind(null,374)),"v-0f364269":()=>t.e(52).then(t.bind(null,375)),"v-44588890":()=>t.e(49).then(t.bind(null,376)),"v-73b1812c":()=>t.e(53).then(t.bind(null,377)),"v-73345ea5":()=>t.e(54).then(t.bind(null,378)),"v-f3a4d5ce":()=>t.e(55).then(t.bind(null,379)),"v-3e5f36c2":()=>t.e(57).then(t.bind(null,380)),"v-46869018":()=>t.e(56).then(t.bind(null,381)),"v-c97358b4":()=>t.e(58).then(t.bind(null,382)),"v-4ccda259":()=>t.e(59).then(t.bind(null,383)),"v-d0c08d72":()=>t.e(60).then(t.bind(null,384)),"v-2ee64fb9":()=>t.e(61).then(t.bind(null,385)),"v-030c0378":()=>t.e(62).then(t.bind(null,386)),"v-08e3a87c":()=>t.e(63).then(t.bind(null,387)),"v-d6d27a90":()=>t.e(65).then(t.bind(null,388)),"v-704229bc":()=>t.e(64).then(t.bind(null,389)),"v-fd1a5854":()=>t.e(66).then(t.bind(null,390)),"v-d8e4d184":()=>t.e(67).then(t.bind(null,391)),"v-57027c60":()=>t.e(69).then(t.bind(null,392)),"v-0eceab46":()=>t.e(68).then(t.bind(null,393)),"v-085168b4":()=>t.e(70).then(t.bind(null,394)),"v-eaf3101a":()=>t.e(71).then(t.bind(null,395)),"v-789a3d66":()=>t.e(72).then(t.bind(null,396)),"v-123e5264":()=>t.e(73).then(t.bind(null,397)),"v-1b4ef6fe":()=>t.e(75).then(t.bind(null,398)),"v-c4256d48":()=>t.e(74).then(t.bind(null,399)),"v-639d5c4c":()=>t.e(76).then(t.bind(null,400)),"v-1f0508fd":()=>t.e(77).then(t.bind(null,401)),"v-31c7e04c":()=>t.e(78).then(t.bind(null,402)),"v-2836490b":()=>t.e(79).then(t.bind(null,403)),"v-79cae889":()=>t.e(80).then(t.bind(null,404)),"v-2572d8b5":()=>t.e(81).then(t.bind(null,405))};function Qs(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const $s=/-(\w)/g,Ks=Qs(n=>n.replace($s,(n,e)=>e?e.toUpperCase():"")),Ws=/\B([A-Z])/g,Xs=Qs(n=>n.replace(Ws,"-$1").toLowerCase()),Ys=Qs(n=>n.charAt(0).toUpperCase()+n.slice(1));function Zs(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Ys(Ks(e))):n(Ys(e))||n(Xs(e))}const nl=Object.assign({},Gs,Hs),el=n=>nl[n],tl=n=>Hs[n],al=n=>Gs[n],il=n=>Ht.component(n);function rl(n){return Zs(tl,n)}function sl(n){return Zs(al,n)}function ll(n){return Zs(el,n)}function ol(n){return Zs(il,n)}function cl(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!ol(n)&&ll(n)){const e=await ll(n)();Ht.component(n,e.default)}}))}function pl(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ul=t(92),dl=t.n(ul),ml=t(93),gl=t.n(ml),hl={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${gl()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bl(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=yl(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return dl()([{name:"description",content:this.$description}],n,this.siteMeta,fl)},updateCanonicalLink(){vl(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bl(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){yl(null,this.currentMetaTags),vl()}};function vl(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bl(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function yl(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function fl(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Sl=t(50),xl={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Sl)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const r=e[n],s=e[n+1],l=0===n&&0===t||t>=r.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),o=decodeURIComponent(this.$route.hash);if(l&&o!==decodeURIComponent(r.hash)){const t=r;if(i===a)for(let t=n+1;t<e.length;t++)if(o===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},wl=t(24),jl=t.n(wl),Tl={mounted(){jl.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Ht.component(n.name)||jl.a.start(),t()}),this.$router.afterEach(()=>{jl.a.done(),this.isSidebarOpen=!1})}};t(239),t(240);class _l{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var kl={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new _l).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&a.firstChild?a.insertBefore(i,a.firstChild):a.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var El={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Il={},zl=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Cl=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:El[n]},Al=function n(e,t,a){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,r=e.children;i.appendChild(n(t,a,r))})),i},Ll=function(n,e,t){var a,i=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==i.length||t?i:i[0]},Ol=function(n,e){var t,a,i=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<template>([\s\S]+)<\/template>/),s=n.match(/<script>([\s\S]+)<\/script>/),l={css:i&&i[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:s&&s[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};l.htmlTpl=zl(l.html),l.jsTpl=(t=l.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),l.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,r=[eval][0](i);return r.template=e,r}(l.js,l.html);var o=Cl("vue");return l.jsLib.unshift(o),l},Dl=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),r=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:r&&r[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return s.htmlTpl=s.html,s.jsTpl=s.js,s.script=(t=s.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),s},Ml=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Rl(){var n=Ll(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Ll(n,"vuepress-plugin-demo-block__code"),t=Ll(n,"vuepress-plugin-demo-block__display"),a=Ll(n,"vuepress-plugin-demo-block__footer"),i=Ll(t,"vuepress-plugin-demo-block__app"),r=decodeURIComponent(n.dataset.code),s=decodeURIComponent(n.dataset.config),l=decodeURIComponent(n.dataset.type);s=s?JSON.parse(s):{};var o=e.querySelector("div").clientHeight,c="react"===l?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(a))(),r={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ml(n),htmlTpl:zl("")},s=Cl("react"),l=Cl("reactDOM");return r.jsLib.unshift(s,l),r}(r,s):"vanilla"===l?Dl(r,s):Ol(r,s),p=Al("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(p),p.addEventListener("click",Pl.bind(null,p,o,e,a)),Cl("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,i=n.jsLib,r=n.cssLib,s=i.concat(r).concat(Cl("cssLib")).concat(Cl("jsLib")).join(",");return Al("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:s}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Cl("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,i=n.jsLib,r=n.cssLib,s=JSON.stringify({css:e,html:t,js:a,js_external:i.concat(Cl("jsLib")).join(";"),css_external:r.concat(Cl("cssLib")).join(";"),layout:Cl("codepenLayout"),js_pre_processor:Cl("codepenJsProcessor"),editors:Cl("codepenEditors")});return Al("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:s}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==s.horizontal?s.horizontal:Cl("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!Il[n]){var e=Al("style",{innerHTML:n});document.body.appendChild(e),Il[n]=!0}}(c.css),"react"===l)ReactDOM.render(React.createElement(c.js),i);else if("vue"===l){var d=(new(Vue.extend(c.script))).$mount();i.appendChild(d.$el)}else"vanilla"===l&&(i.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Rl()}),300)}function Pl(n,e,t,a){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var Bl={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Rl()},updated:function(){Rl()}},Jl="auto",Nl="zoom-in",Fl="zoom-out",ql="grab",Ul="move";function Vl(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};a?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Gl(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Hl(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ql(n,e,t){!function(n){var e=$l,t=Kl;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var a=n.style,i={};for(var r in e)t&&(i[r]=a[r]||""),a[r]=e[r];return i}var $l="transition",Kl="transform",Wl="transform",Xl="transitionend";var Yl=function(){},Zl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Yl,onClose:Yl,onGrab:Yl,onMove:Yl,onRelease:Yl,onBeforeOpen:Yl,onBeforeClose:Yl,onBeforeGrab:Yl,onBeforeRelease:Yl,onImageLoading:Yl,onImageLoaded:Yl},no={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),to(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,r=this.options.scrollThreshold;(Math.abs(i)>=r||Math.abs(a)>=r)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(eo(n)&&!to(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){eo(n)&&!to(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function eo(n){return 0===n.button}function to(n){return n.metaKey||n.ctrlKey}var ao={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ql(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Vl(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ql(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},io="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ro=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),so=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},lo={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Hl(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?ql:Fl,transition:Wl+"\n        "+a+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ql(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ql(this.el,{transform:"none"})},grab:function(n,e,t){var a=oo(),i=a.x-n,r=a.y-e;Ql(this.el,{cursor:Ul,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+r)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=oo(),i=a.x-n,r=a.y-e;Ql(this.el,{transition:Wl,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+r)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ql(this.el,this.styleClose)},restoreOpenStyle:function(){Ql(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=oo(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,i=a.customSize,r=a.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":io(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var s=this.rect.width/2,l=this.rect.height/2,o=oo(),c={x:o.x-s,y:o.y-l},p=c.x/s,u=c.y/l,d=r+Math.min(p,u);if(i&&"string"==typeof i){var m=t||this.el.naturalWidth,g=e||this.el.naturalHeight,h=parseFloat(i)*m/(100*this.rect.width),v=parseFloat(i)*g/(100*this.rect.height);if(d>h||d>v)return{x:h,y:v}}return{x:d,y:d}}};function oo(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function co(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Vl(n,a,e[a],t)}))}var po=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(lo),this.overlay=Object.create(ao),this.handler=Object.create(no),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=so({},Zl,e),this.overlay.init(this),this.handler.init(this)}return ro(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Nl,Vl(n,"click",this.handler.click),this.options.preloadImage&&Gl(Hl(n)));return this}},{key:"config",value:function(n){return n?(so(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(a),Gl(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Vl(document,"scroll",this.handler.scroll),Vl(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Vl(window,"resize",this.handler.resizeWindow);var r=function n(){Vl(a,Xl,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&co(document,e.handler,!0),t(a)};return Vl(a,Xl,r),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Jl,this.overlay.fadeOut(),this.target.zoomOut(),Vl(document,"scroll",this.handler.scroll,!1),Vl(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Vl(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Vl(t,Xl,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&co(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Vl(t,Xl,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var r=function n(){Vl(i,Xl,n,!1),a(i)};return Vl(i,Xl,r),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ul,this.target.move(n,e,t);var i=this.target.el,r=function n(){Vl(i,Xl,n,!1),a(i)};return Vl(i,Xl,r),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Jl,this.target.restoreOpenStyle();var a=function a(){Vl(t,Xl,a,!1),n.lock=!1,n.released=!0,e(t)};return Vl(t,Xl,a),this}}}]),n}();const uo=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),mo=Number("500");class go{constructor(){this.instance=new po(uo)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=mo){setTimeout(()=>this.update(n),e)}}var ho=[hl,xl,Tl,kl,Bl,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new go,this.$vuepress.zooming.updateDelay()}}],vo={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return pl("layout",n),Ht.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},bo=t(7),yo=Object(bo.a)(vo,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(yo,"mixins",ho);const fo=[{name:"v-6b5e3b9e",path:"/pages/ec1391/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-6b5e3b9e").then(t)}},{path:"/pages/ec1391/index.html",redirect:"/pages/ec1391/"},{path:"/01.语言/01.JAVA语言/01.语言基础/01.基础语法.html",redirect:"/pages/ec1391/"},{name:"v-9767263a",path:"/pages/8e5736/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-9767263a").then(t)}},{path:"/pages/8e5736/index.html",redirect:"/pages/8e5736/"},{path:"/01.语言/01.JAVA语言/01.语言基础/03.访问控制权限.html",redirect:"/pages/8e5736/"},{name:"v-4a930d01",path:"/pages/2876f0/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-4a930d01").then(t)}},{path:"/pages/2876f0/index.html",redirect:"/pages/2876f0/"},{path:"/01.语言/01.JAVA语言/01.语言基础/02.面向对象.html",redirect:"/pages/2876f0/"},{name:"v-4a83f009",path:"/pages/8ae350/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-4a83f009").then(t)}},{path:"/pages/8ae350/index.html",redirect:"/pages/8ae350/"},{path:"/01.语言/01.JAVA语言/01.语言基础/04.接口和抽象类.html",redirect:"/pages/8ae350/"},{name:"v-f9f336e8",path:"/pages/646bcb/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-f9f336e8").then(t)}},{path:"/pages/646bcb/index.html",redirect:"/pages/646bcb/"},{path:"/01.语言/01.JAVA语言/01.语言基础/05.内部类.html",redirect:"/pages/646bcb/"},{name:"v-526b6042",path:"/pages/98887c/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-526b6042").then(t)}},{path:"/pages/98887c/index.html",redirect:"/pages/98887c/"},{path:"/01.语言/01.JAVA语言/01.语言基础/06.异常.html",redirect:"/pages/98887c/"},{name:"v-74b46c48",path:"/pages/5a582f/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-74b46c48").then(t)}},{path:"/pages/5a582f/index.html",redirect:"/pages/5a582f/"},{path:"/01.语言/01.JAVA语言/01.语言基础/08.数组.html",redirect:"/pages/5a582f/"},{name:"v-684ba736",path:"/pages/27a8e1/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-684ba736").then(t)}},{path:"/pages/27a8e1/index.html",redirect:"/pages/27a8e1/"},{path:"/01.语言/01.JAVA语言/01.语言基础/07.集合.html",redirect:"/pages/27a8e1/"},{name:"v-4508e630",path:"/pages/1ca5ad/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-4508e630").then(t)}},{path:"/pages/1ca5ad/index.html",redirect:"/pages/1ca5ad/"},{path:"/01.语言/01.JAVA语言/01.语言基础/09.枚举.html",redirect:"/pages/1ca5ad/"},{name:"v-4855977e",path:"/pages/5d20e5/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-4855977e").then(t)}},{path:"/pages/5d20e5/index.html",redirect:"/pages/5d20e5/"},{path:"/01.语言/01.JAVA语言/01.语言基础/100.常用API.html",redirect:"/pages/5d20e5/"},{name:"v-3ed4795a",path:"/pages/07d6bb/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-3ed4795a").then(t)}},{path:"/pages/07d6bb/index.html",redirect:"/pages/07d6bb/"},{path:"/01.语言/01.JAVA语言/01.语言基础/10.反射.html",redirect:"/pages/07d6bb/"},{name:"v-9bb40838",path:"/pages/539c95/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-9bb40838").then(t)}},{path:"/pages/539c95/index.html",redirect:"/pages/539c95/"},{path:"/01.语言/01.JAVA语言/01.语言基础/11.IO流.html",redirect:"/pages/539c95/"},{name:"v-6c582e6a",path:"/pages/2e167c/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-6c582e6a").then(t)}},{path:"/pages/2e167c/index.html",redirect:"/pages/2e167c/"},{path:"/01.语言/01.JAVA语言/01.语言基础/12.IO流案例.html",redirect:"/pages/2e167c/"},{name:"v-026fe816",path:"/pages/704cf9/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-026fe816").then(t)}},{path:"/pages/704cf9/index.html",redirect:"/pages/704cf9/"},{path:"/01.语言/01.JAVA语言/01.语言基础/13.注解.html",redirect:"/pages/704cf9/"},{name:"v-b545df88",path:"/pages/9faa36/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-b545df88").then(t)}},{path:"/pages/9faa36/index.html",redirect:"/pages/9faa36/"},{path:"/01.语言/01.JAVA语言/02.JVM/1.JVM-JVM与Java体系结构.html",redirect:"/pages/9faa36/"},{name:"v-d4b0e508",path:"/pages/9fa953/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-d4b0e508").then(t)}},{path:"/pages/9fa953/index.html",redirect:"/pages/9fa953/"},{path:"/01.语言/01.JAVA语言/02.JVM/10.JVM-对象的实例化内存布局与访问定位.html",redirect:"/pages/9fa953/"},{name:"v-397f7974",path:"/pages/64de09/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-397f7974").then(t)}},{path:"/pages/64de09/index.html",redirect:"/pages/64de09/"},{path:"/01.语言/01.JAVA语言/02.JVM/12.JVM-执行引擎.html",redirect:"/pages/64de09/"},{name:"v-eca6f7ba",path:"/pages/e31263/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-eca6f7ba").then(t)}},{path:"/pages/e31263/index.html",redirect:"/pages/e31263/"},{path:"/01.语言/01.JAVA语言/01.语言基础/20.Java8新特性.html",redirect:"/pages/e31263/"},{name:"v-7e4c890f",path:"/pages/6cfffc/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-7e4c890f").then(t)}},{path:"/pages/6cfffc/index.html",redirect:"/pages/6cfffc/"},{path:"/01.语言/01.JAVA语言/02.JVM/13.JVM-StringTable.html",redirect:"/pages/6cfffc/"},{name:"v-4c1c2380",path:"/pages/a75cf5/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-4c1c2380").then(t)}},{path:"/pages/a75cf5/index.html",redirect:"/pages/a75cf5/"},{path:"/01.语言/01.JAVA语言/02.JVM/14.JVM-垃圾回收概述.html",redirect:"/pages/a75cf5/"},{name:"v-0ba597e9",path:"/pages/c0a9b6/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-0ba597e9").then(t)}},{path:"/pages/c0a9b6/index.html",redirect:"/pages/c0a9b6/"},{path:"/01.语言/01.JAVA语言/02.JVM/15.JVM-垃圾回收相关算法.html",redirect:"/pages/c0a9b6/"},{name:"v-4fb73d7d",path:"/pages/e20df8/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-4fb73d7d").then(t)}},{path:"/pages/e20df8/index.html",redirect:"/pages/e20df8/"},{path:"/01.语言/01.JAVA语言/02.JVM/16.JVM-垃圾回收相关概念.html",redirect:"/pages/e20df8/"},{name:"v-659791a7",path:"/pages/c15e11/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-659791a7").then(t)}},{path:"/pages/c15e11/index.html",redirect:"/pages/c15e11/"},{path:"/01.语言/01.JAVA语言/02.JVM/3.JVM-运行时数据区概述及线程.html",redirect:"/pages/c15e11/"},{name:"v-74277329",path:"/pages/bac2fa/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-74277329").then(t)}},{path:"/pages/bac2fa/index.html",redirect:"/pages/bac2fa/"},{path:"/01.语言/01.JAVA语言/02.JVM/2.JVM-类加载子系统.html",redirect:"/pages/bac2fa/"},{name:"v-f3069b4a",path:"/pages/797fac/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-f3069b4a").then(t)}},{path:"/pages/797fac/index.html",redirect:"/pages/797fac/"},{path:"/01.语言/01.JAVA语言/02.JVM/4.JVM-程序计数器(PC寄存器).html",redirect:"/pages/797fac/"},{name:"v-f7888516",path:"/pages/38174c/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-f7888516").then(t)}},{path:"/pages/38174c/index.html",redirect:"/pages/38174c/"},{path:"/01.语言/01.JAVA语言/02.JVM/6.JVM-本地方法接口.html",redirect:"/pages/38174c/"},{name:"v-6b7e9ccd",path:"/pages/42fe7b/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-6b7e9ccd").then(t)}},{path:"/pages/42fe7b/index.html",redirect:"/pages/42fe7b/"},{path:"/01.语言/01.JAVA语言/02.JVM/5.JVM-虚拟机栈.html",redirect:"/pages/42fe7b/"},{name:"v-6d5c62aa",path:"/pages/ba6197/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-6d5c62aa").then(t)}},{path:"/pages/ba6197/index.html",redirect:"/pages/ba6197/"},{path:"/01.语言/01.JAVA语言/02.JVM/7.JVM-本地方法栈.html",redirect:"/pages/ba6197/"},{name:"v-0658261e",path:"/pages/32d7be/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-0658261e").then(t)}},{path:"/pages/32d7be/index.html",redirect:"/pages/32d7be/"},{path:"/01.语言/01.JAVA语言/02.JVM/8.JVM-堆.html",redirect:"/pages/32d7be/"},{name:"v-53e281ba",path:"/pages/2f74c5/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-53e281ba").then(t)}},{path:"/pages/2f74c5/index.html",redirect:"/pages/2f74c5/"},{path:"/01.语言/01.JAVA语言/02.JVM/9.JVM-方法区.html",redirect:"/pages/2f74c5/"},{name:"v-412cb168",path:"/pages/29740f/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-412cb168").then(t)}},{path:"/pages/29740f/index.html",redirect:"/pages/29740f/"},{path:"/01.语言/04.数据库/01.MySQL基础/01.MySQL基础-数据库概述.html",redirect:"/pages/29740f/"},{name:"v-0cff2ea9",path:"/pages/274d31/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-0cff2ea9").then(t)}},{path:"/pages/274d31/index.html",redirect:"/pages/274d31/"},{path:"/01.语言/04.数据库/01.MySQL基础/02.MySQL基础-MySQL环境搭建(windows版).html",redirect:"/pages/274d31/"},{name:"v-25ae2882",path:"/pages/10beff/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-25ae2882").then(t)}},{path:"/pages/10beff/index.html",redirect:"/pages/10beff/"},{path:"/01.语言/04.数据库/01.MySQL基础/03.MySQL基础-SQL语句.html",redirect:"/pages/10beff/"},{name:"v-5b433015",path:"/pages/a5b5c4/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-5b433015").then(t)}},{path:"/pages/a5b5c4/index.html",redirect:"/pages/a5b5c4/"},{path:"/01.语言/04.数据库/01.MySQL基础/04.MySQL基础-基础语句.html",redirect:"/pages/a5b5c4/"},{name:"v-178980de",path:"/pages/d5d2c6/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-178980de").then(t)}},{path:"/pages/d5d2c6/index.html",redirect:"/pages/d5d2c6/"},{path:"/01.语言/04.数据库/01.MySQL基础/05.MySQL基础-运算符.html",redirect:"/pages/d5d2c6/"},{name:"v-7d6ccb43",path:"/pages/9ed39a/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-7d6ccb43").then(t)}},{path:"/pages/9ed39a/index.html",redirect:"/pages/9ed39a/"},{path:"/01.语言/04.数据库/01.MySQL基础/06.MySQL基础-多表查询.html",redirect:"/pages/9ed39a/"},{name:"v-5fb0e4a0",path:"/pages/333675/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-5fb0e4a0").then(t)}},{path:"/pages/333675/index.html",redirect:"/pages/333675/"},{path:"/01.语言/04.数据库/01.MySQL基础/07.MySQL基础-单行函数.html",redirect:"/pages/333675/"},{name:"v-322162e0",path:"/pages/febdf1/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-322162e0").then(t)}},{path:"/pages/febdf1/index.html",redirect:"/pages/febdf1/"},{path:"/02.编程基础/01.数据结构和算法/01.数据结构/01.数据结构.html",redirect:"/pages/febdf1/"},{name:"v-6aaaa430",path:"/pages/ff9a50/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-6aaaa430").then(t)}},{path:"/pages/ff9a50/index.html",redirect:"/pages/ff9a50/"},{path:"/01.语言/04.数据库/03.Influxdb/21.时序数据库-influxdb.html",redirect:"/pages/ff9a50/"},{name:"v-ebfbb4aa",path:"/pages/391852/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-ebfbb4aa").then(t)}},{path:"/pages/391852/index.html",redirect:"/pages/391852/"},{path:"/02.编程基础/04.设计模式/0.Java设计模式-内容介绍.html",redirect:"/pages/391852/"},{name:"v-7d4ea15e",path:"/pages/f21426/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-7d4ea15e").then(t)}},{path:"/pages/f21426/index.html",redirect:"/pages/f21426/"},{path:"/02.编程基础/04.设计模式/1.Java设计模式-设计模式七大原则.html",redirect:"/pages/f21426/"},{name:"v-611843b4",path:"/pages/5247a4/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-611843b4").then(t)}},{path:"/pages/5247a4/index.html",redirect:"/pages/5247a4/"},{path:"/02.编程基础/04.设计模式/2.Java设计模式-UML类图.html",redirect:"/pages/5247a4/"},{name:"v-5320d5b4",path:"/pages/d2284f/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-5320d5b4").then(t)}},{path:"/pages/d2284f/index.html",redirect:"/pages/d2284f/"},{path:"/02.编程基础/04.设计模式/3.Java设计模式-设计模式概述.html",redirect:"/pages/d2284f/"},{name:"v-771f7249",path:"/pages/4c822c/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-771f7249").then(t)}},{path:"/pages/4c822c/index.html",redirect:"/pages/4c822c/"},{path:"/02.编程基础/04.设计模式/4.Java设计模式-单例模式.html",redirect:"/pages/4c822c/"},{name:"v-7e01f4b7",path:"/pages/9814ac/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-7e01f4b7").then(t)}},{path:"/pages/9814ac/index.html",redirect:"/pages/9814ac/"},{path:"/02.编程基础/04.设计模式/6.Java设计模式-原型模式.html",redirect:"/pages/9814ac/"},{name:"v-70fa0b4f",path:"/pages/85ff30/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-70fa0b4f").then(t)}},{path:"/pages/85ff30/index.html",redirect:"/pages/85ff30/"},{path:"/02.编程基础/04.设计模式/7.Java设计模式-建造者模式.html",redirect:"/pages/85ff30/"},{name:"v-0f364269",path:"/pages/6ad6ad/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-0f364269").then(t)}},{path:"/pages/6ad6ad/index.html",redirect:"/pages/6ad6ad/"},{path:"/03.开发工具/01.集成开发环境/01.IDEA/01.IDEA配置.html",redirect:"/pages/6ad6ad/"},{name:"v-44588890",path:"/pages/40d394/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-44588890").then(t)}},{path:"/pages/40d394/index.html",redirect:"/pages/40d394/"},{path:"/02.编程基础/04.设计模式/5.Java设计模式-工厂模式.html",redirect:"/pages/40d394/"},{name:"v-73b1812c",path:"/pages/9f28c6/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-73b1812c").then(t)}},{path:"/pages/9f28c6/index.html",redirect:"/pages/9f28c6/"},{path:"/03.开发工具/01.集成开发环境/01.IDEA/02.IDEA快捷键(windows).html",redirect:"/pages/9f28c6/"},{name:"v-73345ea5",path:"/pages/17fe21/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-73345ea5").then(t)}},{path:"/pages/17fe21/index.html",redirect:"/pages/17fe21/"},{path:"/03.开发工具/01.集成开发环境/01.IDEA/03.IDEA必备插件.html",redirect:"/pages/17fe21/"},{name:"v-f3a4d5ce",path:"/pages/e4d5d1/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-f3a4d5ce").then(t)}},{path:"/pages/e4d5d1/index.html",redirect:"/pages/e4d5d1/"},{path:"/03.开发工具/01.集成开发环境/02.VSCode/01.VSCode.html",redirect:"/pages/e4d5d1/"},{name:"v-3e5f36c2",path:"/pages/5082de/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-3e5f36c2").then(t)}},{path:"/pages/5082de/index.html",redirect:"/pages/5082de/"},{path:"/03.开发工具/01.集成开发环境/04.接口测试工具/01.接口测试工具.html",redirect:"/pages/5082de/"},{name:"v-46869018",path:"/pages/17afa5/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-46869018").then(t)}},{path:"/pages/17afa5/index.html",redirect:"/pages/17afa5/"},{path:"/03.开发工具/01.集成开发环境/03.数据库工具/01.MySQL图形化管理工具.html",redirect:"/pages/17afa5/"},{name:"v-c97358b4",path:"/pages/00b1bb/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-c97358b4").then(t)}},{path:"/pages/00b1bb/index.html",redirect:"/pages/00b1bb/"},{path:"/03.开发工具/03.代码管理工具/01.Svn/1.SVN基础.html",redirect:"/pages/00b1bb/"},{name:"v-4ccda259",path:"/pages/d486f7/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-4ccda259").then(t)}},{path:"/pages/d486f7/index.html",redirect:"/pages/d486f7/"},{path:"/03.开发工具/03.代码管理工具/02.Git/1.Git安装.html",redirect:"/pages/d486f7/"},{name:"v-d0c08d72",path:"/pages/8e6be6/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-d0c08d72").then(t)}},{path:"/pages/8e6be6/index.html",redirect:"/pages/8e6be6/"},{path:"/03.开发工具/03.代码管理工具/02.Git/2.Git常用命令.html",redirect:"/pages/8e6be6/"},{name:"v-2ee64fb9",path:"/pages/502fb9/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-2ee64fb9").then(t)}},{path:"/pages/502fb9/index.html",redirect:"/pages/502fb9/"},{path:"/03.开发工具/03.代码管理工具/02.Git/3.Git配置用户信息和SSH免密.html",redirect:"/pages/502fb9/"},{name:"v-030c0378",path:"/pages/020d30/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-030c0378").then(t)}},{path:"/pages/020d30/index.html",redirect:"/pages/020d30/"},{path:"/03.开发工具/04.项目管理&构建工具/01.Maven/01.Maven下载安装与配置.html",redirect:"/pages/020d30/"},{name:"v-08e3a87c",path:"/pages/0705f0/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-08e3a87c").then(t)}},{path:"/pages/0705f0/index.html",redirect:"/pages/0705f0/"},{path:"/04.后端应用框架/01.Spring家族/01.Spring/0.反射&注解.html",redirect:"/pages/0705f0/"},{name:"v-d6d27a90",path:"/pages/c71dea/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-d6d27a90").then(t)}},{path:"/pages/c71dea/index.html",redirect:"/pages/c71dea/"},{path:"/04.后端应用框架/01.Spring家族/03.SpringBoot/1.SpringBoot基础.html",redirect:"/pages/c71dea/"},{name:"v-704229bc",path:"/pages/cb7d50/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-704229bc").then(t)}},{path:"/pages/cb7d50/index.html",redirect:"/pages/cb7d50/"},{path:"/04.后端应用框架/01.Spring家族/01.Spring/1.Spring基础.html",redirect:"/pages/cb7d50/"},{name:"v-fd1a5854",path:"/pages/9c9eda/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-fd1a5854").then(t)}},{path:"/pages/9c9eda/index.html",redirect:"/pages/9c9eda/"},{path:"/04.后端应用框架/01.Spring家族/03.SpringBoot/2.SpringBoot整合RabbitMQ.html",redirect:"/pages/9c9eda/"},{name:"v-d8e4d184",path:"/pages/1db5d1/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-d8e4d184").then(t)}},{path:"/pages/1db5d1/index.html",redirect:"/pages/1db5d1/"},{path:"/04.后端应用框架/03.中间件/01.缓存/1.Redis入门.html",redirect:"/pages/1db5d1/"},{name:"v-57027c60",path:"/pages/83c6d3/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-57027c60").then(t)}},{path:"/pages/83c6d3/index.html",redirect:"/pages/83c6d3/"},{path:"/04.后端应用框架/03.中间件/01.缓存/3.Redis事务.html",redirect:"/pages/83c6d3/"},{name:"v-0eceab46",path:"/pages/f64944/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-0eceab46").then(t)}},{path:"/pages/f64944/index.html",redirect:"/pages/f64944/"},{path:"/04.后端应用框架/03.中间件/01.缓存/2.Redis数据类型.html",redirect:"/pages/f64944/"},{name:"v-085168b4",path:"/pages/1d5ebe/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-085168b4").then(t)}},{path:"/pages/1d5ebe/index.html",redirect:"/pages/1d5ebe/"},{path:"/04.后端应用框架/03.中间件/01.缓存/4.Redis实现乐观锁.html",redirect:"/pages/1d5ebe/"},{name:"v-eaf3101a",path:"/pages/4fbc1c/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-eaf3101a").then(t)}},{path:"/pages/4fbc1c/index.html",redirect:"/pages/4fbc1c/"},{path:"/04.后端应用框架/03.中间件/01.缓存/5.Redis-Jedis.html",redirect:"/pages/4fbc1c/"},{name:"v-789a3d66",path:"/pages/315078/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-789a3d66").then(t)}},{path:"/pages/315078/index.html",redirect:"/pages/315078/"},{path:"/04.后端应用框架/03.中间件/01.缓存/6.SpringBoot整合.html",redirect:"/pages/315078/"},{name:"v-123e5264",path:"/pages/255a13/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-123e5264").then(t)}},{path:"/pages/255a13/index.html",redirect:"/pages/255a13/"},{path:"/04.后端应用框架/03.中间件/01.缓存/7.Redis的配置文件详解.html",redirect:"/pages/255a13/"},{name:"v-1b4ef6fe",path:"/pages/3ae290/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-1b4ef6fe").then(t)}},{path:"/pages/3ae290/index.html",redirect:"/pages/3ae290/"},{path:"/05.前端应用框架/01.基础套餐/01.三大件/01.HTML.html",redirect:"/pages/3ae290/"},{name:"v-c4256d48",path:"/pages/6641bc/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-c4256d48").then(t)}},{path:"/pages/6641bc/index.html",redirect:"/pages/6641bc/"},{path:"/04.后端应用框架/05.搜索引擎/01.ElasticSearch/01.ElasticSearch7.6.1快速入门.html",redirect:"/pages/6641bc/"},{name:"v-639d5c4c",path:"/pages/abd7cf/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-639d5c4c").then(t)}},{path:"/pages/abd7cf/index.html",redirect:"/pages/abd7cf/"},{path:"/05.前端应用框架/03.组件化框架/01.Node/01.下载node.html",redirect:"/pages/abd7cf/"},{name:"v-1f0508fd",path:"/pages/5ca64b/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-1f0508fd").then(t)}},{path:"/pages/5ca64b/index.html",redirect:"/pages/5ca64b/"},{path:"/05.前端应用框架/03.组件化框架/01.Node/02.yarn常用命令.html",redirect:"/pages/5ca64b/"},{name:"v-31c7e04c",path:"/pages/bcb9d3/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-31c7e04c").then(t)}},{path:"/pages/bcb9d3/index.html",redirect:"/pages/bcb9d3/"},{path:"/06.运维知识/01.Web服务器/01.Nginx.html",redirect:"/pages/bcb9d3/"},{name:"v-2836490b",path:"/pages/e8fc76/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-2836490b").then(t)}},{path:"/pages/e8fc76/index.html",redirect:"/pages/e8fc76/"},{path:"/06.运维知识/05.代码质量检查/01..代码质量检查平台-SonarQube.html",redirect:"/pages/e8fc76/"},{name:"v-79cae889",path:"/blog/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-79cae889").then(t)}},{path:"/blog/index.html",redirect:"/blog/"},{path:"/@pages/archivesPage.html",redirect:"/blog/"},{name:"v-2572d8b5",path:"/",component:yo,beforeEnter:(n,e,t)=>{cl("Layout","v-2572d8b5").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:yo}],So={title:"chggx-knowledge",description:"一个基于VuePress的 知识管理&博客 主题",base:"/chggx-knowlodge-vuepress/",headTags:[["link",{rel:"icon",href:"/chggx-knowlodge-vuepress/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"wwads-cn-verify",content:"6c4b761a28b734fe93831e3fb400ce87"}],["script",{src:"https://cdn.wwads.cn/js/makemoney.js",type:"text/javascript"}]],pages:[{title:"基础语法",frontmatter:{title:"基础语法",date:"2023-02-25T12:49:46.000Z",permalink:"/pages/ec1391/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/01.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/01.基础语法.md",key:"v-6b5e3b9e",path:"/pages/ec1391/",headers:[{level:2,title:"1. Java概述",slug:"_1-java概述",normalizedTitle:"1. java概述",charIndex:11},{level:3,title:"1.1 什么是Java?",slug:"_1-1-什么是java",normalizedTitle:"1.1 什么是java?",charIndex:25},{level:3,title:"1.2 Java的特点",slug:"_1-2-java的特点",normalizedTitle:"1.2 java的特点",charIndex:436},{level:4,title:"特征一：面向对象的编程语言",slug:"特征一-面向对象的编程语言",normalizedTitle:"特征一：面向对象的编程语言",charIndex:451},{level:4,title:"特征二",slug:"特征二",normalizedTitle:"特征二",charIndex:1070},{level:4,title:"特征三",slug:"特征三",normalizedTitle:"特征三",charIndex:1125},{level:4,title:"特征四：静态语言",slug:"特征四-静态语言",normalizedTitle:"特征四：静态语言",charIndex:1200},{level:4,title:"特征五：平台独立性和可移植性",slug:"特征五-平台独立性和可移植性",normalizedTitle:"特征五：平台独立性和可移植性",charIndex:1645},{level:4,title:"特征六：多线程",slug:"特征六-多线程",normalizedTitle:"特征六：多线程",charIndex:2086},{level:4,title:"特征七：高性能",slug:"特征七-高性能",normalizedTitle:"特征七：高性能",charIndex:2266},{level:4,title:"特征八：健壮性",slug:"特征八-健壮性",normalizedTitle:"特征八：健壮性",charIndex:2491},{level:4,title:"特征九：Java很容易开发分布式项目",slug:"特征九-java很容易开发分布式项目",normalizedTitle:"特征九：java很容易开发分布式项目",charIndex:2580},{level:3,title:"1.3 Java开发环境",slug:"_1-3-java开发环境",normalizedTitle:"1.3 java开发环境",charIndex:2740},{level:4,title:"JDK",slug:"jdk",normalizedTitle:"jdk",charIndex:2756},{level:4,title:"JRE",slug:"jre",normalizedTitle:"jre",charIndex:3138},{level:4,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3381},{level:2,title:"2. Java开发环境配置",slug:"_2-java开发环境配置",normalizedTitle:"2. java开发环境配置",charIndex:3581},{level:2,title:"3. Java基本语法",slug:"_3-java基本语法",normalizedTitle:"3. java基本语法",charIndex:3677},{level:3,title:"3.1 数据类型",slug:"_3-1-数据类型",normalizedTitle:"3.1 数据类型",charIndex:3693},{level:3,title:"3.2 基础语法",slug:"_3-2-基础语法",normalizedTitle:"3.2 基础语法",charIndex:4486},{level:3,title:"3.3 运算符",slug:"_3-3-运算符",normalizedTitle:"3.3 运算符",charIndex:4688},{level:4,title:"1. 赋值运算符",slug:"_1-赋值运算符",normalizedTitle:"1. 赋值运算符",charIndex:4963},{level:4,title:"2. 算数运算符",slug:"_2-算数运算符",normalizedTitle:"2. 算数运算符",charIndex:5134},{level:4,title:"3. 自增、自减运算符",slug:"_3-自增、自减运算符",normalizedTitle:"3. 自增、自减运算符",charIndex:5570},{level:4,title:"4. 比较运算符",slug:"_4-比较运算符",normalizedTitle:"4. 比较运算符",charIndex:5701},{level:4,title:"5. 逻辑运算符",slug:"_5-逻辑运算符",normalizedTitle:"5. 逻辑运算符",charIndex:5839},{level:4,title:"6. 按位运算符",slug:"_6-按位运算符",normalizedTitle:"6. 按位运算符",charIndex:6206},{level:4,title:"7. 移位运算符",slug:"_7-移位运算符",normalizedTitle:"7. 移位运算符",charIndex:6520},{level:4,title:"8. 三元运算符😄",slug:"_8-三元运算符",normalizedTitle:"8. 三元运算符😄",charIndex:6629},{level:2,title:"4. Java执行控制流程",slug:"_4-java执行控制流程",normalizedTitle:"4. java执行控制流程",charIndex:6832},{level:3,title:"4.1 条件语句",slug:"_4-1-条件语句",normalizedTitle:"4.1 条件语句",charIndex:6948},{level:4,title:"if条件语句",slug:"if条件语句",normalizedTitle:"if条件语句",charIndex:6980},{level:4,title:"if...else条件语句",slug:"if-else条件语句",normalizedTitle:"if...else条件语句",charIndex:7112},{level:4,title:"if...else if多分支语句",slug:"if-else-if多分支语句",normalizedTitle:"if...else if多分支语句",charIndex:7373},{level:4,title:"switch多分支语句",slug:"switch多分支语句",normalizedTitle:"switch多分支语句",charIndex:6987},{level:3,title:"4.2 循环语句",slug:"_4-2-循环语句",normalizedTitle:"4.2 循环语句",charIndex:8666},{level:4,title:"while循环语句",slug:"while循环语句",normalizedTitle:"while循环语句",charIndex:8755},{level:4,title:"do...while 循环",slug:"do-while-循环",normalizedTitle:"do...while 循环",charIndex:8964},{level:4,title:"for循环语句",slug:"for循环语句",normalizedTitle:"for循环语句",charIndex:9227},{level:3,title:"4.3 跳转语句",slug:"_4-3-跳转语句",normalizedTitle:"4.3 跳转语句",charIndex:9746},{level:4,title:"break语句",slug:"break语句",normalizedTitle:"break语句",charIndex:9797},{level:4,title:"continue 语句",slug:"continue-语句",normalizedTitle:"continue 语句",charIndex:9962},{level:4,title:"return语句",slug:"return语句",normalizedTitle:"return语句",charIndex:10200},{level:2,title:"5.包装类",slug:"_5-包装类",normalizedTitle:"5.包装类",charIndex:10297},{level:3,title:"5.1基本类型包装类",slug:"_5-1基本类型包装类",normalizedTitle:"5.1基本类型包装类",charIndex:10307},{level:3,title:"5.2Integer类",slug:"_5-2integer类",normalizedTitle:"5.2integer类",charIndex:10610},{level:3,title:"5.3int和String类型的相互转换",slug:"_5-3int和string类型的相互转换",normalizedTitle:"5.3int和string类型的相互转换",charIndex:11994},{level:3,title:"5.4字符串数据排序案例",slug:"_5-4字符串数据排序案例",normalizedTitle:"5.4字符串数据排序案例",charIndex:13489},{level:3,title:"5.5 自动拆箱和自动装箱",slug:"_5-5-自动拆箱和自动装箱",normalizedTitle:"5.5 自动拆箱和自动装箱",charIndex:14888},{level:2,title:"6. 扩展",slug:"_6-扩展",normalizedTitle:"6. 扩展",charIndex:15110},{level:3,title:"Random",slug:"random",normalizedTitle:"random",charIndex:15120}],headersStr:"1. Java概述 1.1 什么是Java? 1.2 Java的特点 特征一：面向对象的编程语言 特征二 特征三 特征四：静态语言 特征五：平台独立性和可移植性 特征六：多线程 特征七：高性能 特征八：健壮性 特征九：Java很容易开发分布式项目 1.3 Java开发环境 JDK JRE 总结 2. Java开发环境配置 3. Java基本语法 3.1 数据类型 3.2 基础语法 3.3 运算符 1. 赋值运算符 2. 算数运算符 3. 自增、自减运算符 4. 比较运算符 5. 逻辑运算符 6. 按位运算符 7. 移位运算符 8. 三元运算符😄 4. Java执行控制流程 4.1 条件语句 if条件语句 if...else条件语句 if...else if多分支语句 switch多分支语句 4.2 循环语句 while循环语句 do...while 循环 for循环语句 4.3 跳转语句 break语句 continue 语句 return语句 5.包装类 5.1基本类型包装类 5.2Integer类 5.3int和String类型的相互转换 5.4字符串数据排序案例 5.5 自动拆箱和自动装箱 6. 扩展 Random",content:'# 基础语法\n\n\n# 1. Java概述\n\n\n# 1.1 什么是Java?\n\nJava是Sun Microsystems于1995年首次发布的一种编程语言和计算平台。编程语言还比较好理 解，那么什么是计算平台呢？\n\n> 计算平台是在电脑中运行应用程序(软件)的环境，包括硬件环境和软件环境。一般系统平台 包括一台电脑的硬件体系结构、操作系统、运行时库。\n\nJava是快速，安全和可靠的。从笔记本电脑到数据中心，从游戏机到科学超级计算机，从手机到互联 网，Java无处不在！ Java主要分为三个版本\n\n• JavaSE(J2SE)(Java2 Platform Standard Edition, java平台标准版)\n\n• JavaEE(J2EE)(Java 2 Platform,Enterprise Edition, java平台企业版)\n\n• JavaME(J2ME)(Java 2 Platform Micro Edition, java平台微型版)。\n\n\n# 1.2 Java的特点\n\n# 特征一：面向对象的编程语言\n\nJava是一门面向对象的编程语言。什么是面向对象？面向对象(Object Oriented)是一种软件开发思想。它是对现实世界的一种抽象, 面向对象会把相关的数据和方法组织为一个整体来看待。\n\n相对的另外一种开发思想就是面向过程的开发思想，什么面向过程？面向过程(Procedure Oriented)是一种以过程为中心的编程思想。\n\n举个例子：比如你是个学生，你每天去上学需要做几件 事情？\n\n起床、穿衣服、洗脸刷牙，吃饭，去学校。一般是顺序性的完成一系列动作。\n\nclass student {\n void student_wakeUp(){...}\n void student_cloth(){...}\n void student_wash(){...}\n void student_eating(){...}\n void student_gotoSchool(){...}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n而面向对象可以把学生进行抽象，所以这个例子就会变为\n\nclass student(){\n void wakeUp(){...}\n void cloth(){...}\n void wash(){...}\n void eating(){...}\n void gotoSchool(){...}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以不用严格按照顺序来执行每个动作。这是特点一。\n\n# 特征二\n\nJava摒弃了 C++中难以理解的多继承、指针、内存管理等概念；不用手动管理对象的生命周期。\n\n# 特征三\n\nJava语言具有功能强大和简单易用两个特征，现在企业级开发，快速敏捷开发，尤其是各种框架 的出现，使Java成为越来越火的一门语言。\n\n# 特征四：静态语言\n\nJava是一门静态语言。静态语言指的就是在编译期间就能够知道数据类型的语言，在运行前就能 够检查类型的正确性，一旦类型确定后就不能再更改，比如下面这个例子。\n\npublic void foo() {\n int x = 5;\n boolean b = x;\n}\n\n\n1\n2\n3\n4\n\n\n静态语言主要有 Pascal, Perl, C/C++, JAVA, C#, Scala 等。\n\n相对应的，动态语言没有任何特定的情况需要指定变量的类型，在运行时确定的数据类型。比如有Lisp, Perl, Python、Ruby、JavaScript 等。\n\n从设计的角度上来说，所有的语言都是设计用来把人类可读的代码转换为机器指令。动态语言是为了能 够让程序员提高编码效率，因此你可以使用更少的代码来实现功能。静态语言设计是用来让硬件执行的 更高效，因此需要程序员编写准确无误的代码，以此来让你的代码尽快的执行。从这个角度来说，静态 语言的执行效率要比动态语言高，速度更快。\n\n# 特征五：平台独立性和可移植性\n\nJava具有平台独立性和可移植性。Java有一句非常著名的口号：Write once, run anywhere，也就是一次编写、到处运行。为什么 Java能够吹出这种牛批的口号来？核心就是JVM。我们知道，计算机应用程序和硬件之间会屏蔽很多 细节，它们之间依靠操作系统完成调度和协调，大致的体系结构如下\n\n那么加上Java应用、JVM的体系结构会变为如下\n\nJava是跨平台的，已编译的Java程序可以在任何带有JVM的平台上运行。你可以在Windows平台 下编写代码，然后拿到Linux平台下运行，该如何实现呢？\n\n首先你需要在应用中编写Java代码；用IDEA或者javac把Java代码编译为.class文件；然后把你的.class文件打成.jar文件；然后你的.jar文件就能够在Windows*、* Mac OS X*、*Linux系统下运行了。不同的操作系统有不同的 JVM实现，切换平台时，不需要再次编译你的Java代码了。\n\n# 特征六：多线程\n\nJava是一门高级语言，高级语言会对用户屏蔽很多底层实现细节。比如Java是如何实现多线程的。从操作系统的角度来说，实现多线程的方式主要有下面这几种\n\n * 在用户空间中实现多线程\n\n * 在内核空间中实现多线程\n\n * 在用户和内核空间中混合实现线程\n\nJava应该是在用户空间实现的多线程，内核是感知不到Java存在多线程机制的。\n\n# 特征七：高性能\n\nJava具有高性能。我们编写的代码，经过javac编译器编译称为字节码(bytecode)，经过JVM内嵌的解释器将字节码 转换为机器代码，这是解释执行，这种转换过程效率较低。但是部分JVM的实现比如Hotspot JVM 都提供了JIT(Just-In-Time)编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代 码编译机器码，这种方式运行效率比较高，这是编译执行。所以Java不仅仅只是一种解释执行的语言。\n\n# 特征八：健壮性\n\nJava语言具有健壮性。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。这也是Java与C 语言的重要区别。这是特点八。\n\n# 特征九：Java很容易开发分布式项目\n\nJava语言支持Internet应用的开发，Java中有net api，它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket等。Java的RMI (远程方法激活)机制也是开发分布 式应用的重要手段。这是特点九。\n\n\n# 1.3 Java开发环境\n\n# JDK\n\nJDK (Java Development Kit)称为Java开发包或Java开发工具，是一个编写Java的Applet 小程序和应用程序的程序开发环境。JDK是整个Java的核心，包括了 Java运行环境(Java Runtime Environment),—些 Java 工具和 Java 的核心类库(Java API)。\n\nJava Platform Standard Edition 8 Documentation\n\n我们可以认真研究一下这张图，它几乎包括了 Java中所有的概念，此处是jdk1.8，可以点进去 Description of Java Conceptual Diagram ,可以发现这里面包括了所有关于Java的描述.\n\nOracle提供了两种Java平台的实现，一种是我们上面说的JDK, Java开发标准工具包，一种是 JRE,叫做Java Runtime Environment, Java运行时环境。JDK的功能要比JRE全很多。\n\n# JRE\n\nJRE是个运行环境，JDK是个开发环境。因此写Java程序的时候需要JDK，而运行Java程序的时候 就需要JRE。而JDK里面已经包含了JRE，因此只要安装了JDK,就可以编辑Java程序，也可以正常 运行Java程序。但由于JDK包含了许多与运行无关的内容，占用的空间较大，因此运行普通的Java 程序无须安装JDK，而只需要安装JRE即可。\n\n# 总结\n\nJVM （Java Virtual Machine） , Java虚拟机\n\nJRE （Java Runtime Environment） , Java运行环境,包含了JVM和Java的核心类库（Java API）\n\nJDK （Java Development Kit）称为Java开发工具，包含了JRE和开发工具\n\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。\n\n\n# 2. Java开发环境配置\n\n这个地方不再多说了，网上有很多教程配置的资料可供参考。\n\nWin10配置Java环境（手把手从零搭建Java开发环境）_火石桥霍建华的博客-CSDN博客\n\n\n# 3. Java基本语法\n\n\n# 3.1 数据类型\n\n在Java中，数据类型只有四类八种\n\n * 整数型：byte、short、int、long\n\nbyte也就是字节，1 byte = 8 bits, byte的默认值是0 ；\n\nshort占用两个字节，也就是16位，1 short = 16 bits，它的默认值也是0 ；\n\nint占用四个字节，也就是32位，1 int = 32 bits，默认值是0 ；\n\nlong占用八个字节，也就是64位，1 long = 64 bits,默认值是0L；\n\n所以整数型的占用字节大小空间为long > int > short > byte\n\n * 浮点型\n\n浮点型有两种数据类型：float和double\n\nfloat是单精度浮点型，占用4位，1 float = 32 bits,默认值是0.0f；\n\ndouble是双精度浮点型，占用8位，1 double = 64 bits，默认值是0.0d；\n\n * 字符型\n\n字符型就是char, char类型是一个单一的16位Unicode字符，最小值是\\u0000 （也就是0 ） 最大值是\\uffff （即为65535） , char数据类型可以存储任何字符，例如char a = \'A\'。\n\n * 布尔型\n\n布尔型指的就是boolean, boolean只有两种值，true或者是false,只表示1位，默认值是false。\n\n以上x位都指的是在内存中的占用。\n\n数据类型      内存    默认值\nbyte      8位    0\nshort     16位   0\nint       32位   0\nlong      64位   0L\nfloat     32位   O.Of\ndouble    64位   O.Od\nchar      16位   \\u0000\nboolean   8位    fals\n\n\n# 3.2 基础语法\n\n * 大小写敏感：Java是对大小写敏感的语言，例如Hello与hello是不同的，这其实就是Java的字 符串表示方式\n\n * 类名：对于所有的类来说，首字母应该大写，例如MyFirstClass\n\n * 包名：包名应该尽量保证小写，例如my.first.package\n\n * 方法名：方法名首字母需要小写，后面每个单词字母都需要大写，例如myFirstMethod()\n\n\n# 3.3 运算符\n\n运算符不只Java中有，其他语言也有运算符，运算符是一些特殊的符号，主要用于数学函数、一些类 型的赋值语句和逻辑比较方面。\n\n运算符：对常量或者变量进行操作的符号。\n\n表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。\n\n不同运算符连接的表达式体现的是不同类型的表达式。\n\n举例说明：\n\nint a = 10; \nint b = 20; \nint c = a + b;\n\n\n1\n2\n3\n\n\n+：是运算符，并且是算术运算符。\n\na + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。\n\n# 1. 赋值运算符\n\n赋值运算符使用操作符=来表示，它的意思是把=号右边的值复制给左边，右边的值可以是任何常 数、变量或者表达式，但左边的值必须是一个明确的，已经定义的变量。比如int a = 4\n\n但是对于对象来说，复制的不是对象的值，而是对象的引用，所以如果说将一个对象复制给另一个对 象，实际上是将一个对象的引用赋值给另一个对象。\n\n# 2. 算数运算符\n\n算数运算符就和数学中的数值计算差不多，主要有\n\n符号   作用   说明\n+    加    参看小学一年级\n-    减    参看小学一年级\n*    乘    参看小学二年级，与“×”相同\n/    除    参看小学二年级，与“÷”相同\n%    取余   获取的是两个数据做除法的余数\n\n * /和%的区别：两个数据做除法，/取结果的商，%取结果的余数。整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。\n\nint a = 10; int b = 3;\nSystem.out.println(a / b); // 输出结果3\nSystem.out.println(a % b); // 输出结果1\n\n\n1\n2\n3\n\n\n算数运算符需要注意的就是优先级问题，当一个表达式中存在多个操作符时，操作符的优先级顺序就 决定了计算顺序，最简单的规则就是先乘除后加减，（）的优先级最高，没必要记住所有的优先级顺序，不确定的直接用0就可以了。\n\n# 3. 自增、自减运算符\n\n符号   作用   说明\n++   自增   变量的值加1\n--   自减   变量的值减1\n\n这个就不文字解释了，解释不如直接看例子明白\n\nint a = 5;\nb =   ++a;\nc =   a++;  \n\n\n1\n2\n3\n\n\n# 4. 比较运算符\n\n比较运算符用于程序中的变量之间，变量和自变量之间以及其他类型的信息之间的比较。\n\n比较运算符的运算结果是boolean型。当运算符对应的关系成立时，运算的结果为true,否则为 false。比较运算符共有6个，通常作为判断的依据用于条件语句中。\n\n\n\n# 5. 逻辑运算符\n\n逻辑运算符主要有三种：与、或、非\n\n\n\n下面是逻辑运算符对应的true/false符号表\n\nA       B       A & B   A&&B    A | B   A||B    !A      A A B\ntrue    true    true    true    true    true    false   false\ntrue    false   false   false   true    true    false   true\nfalse   true    false   false   true    true    true    true\nfalse   false   false   false   false   false   true    false\n\n# 6. 按位运算符\n\n按位运算符用来操作整数基本类型中的每个比特位，也就是二进制位。按位操作符会对两个参数中对 应的位执行布尔代数运算，并最终生成一个结果。\n\n\n\n如果进行比较的双方是数字的话，那么进行比较就会变为按位运算。\n\n按位与：按位进行与运算（AND），两个操作数中位都为1,结果才为1,否则结果为0。需要首先把比 较双方转换成二进制再按每个位进行比较\n\n按位或：按位进行或运算（OR）,两个位只要有一个为1,那么结果就是1,否则就为0。\n\n按位非：按位进行异或运算（XOR）,如果位为0,结果是1,如果位为1,结果是0。\n\n按位异或：按位进行取反运算（NOT），两个操作数的位中，相同则结果为0,不同则结果为1。\n\n# 7. 移位运算符\n\n移位运算符用来将操作数向某个方向（向左或者右）移动指定的二进制位数。\n\n运算符   含义\n»     右移运算符eg: 8 » 1 = 4\n«     左移运算符eg: 9 « 2 = 36\n\n# 8. 三元运算符😄\n\n三元运算符是类似if...else...这种的操作符，语法为：条件表达式？表达式1：表达式2。问号前面的位置是判断的条件，判断结果为布尔型，为true时调用表达式1,为false时调用表达式2。\n\nint a = 10; int b = 20;\nint c = a > b ? a : b; // 判断 a>b 是否为真，如果为真取a的值，如果为假，取b的值\n\n\n1\n2\n\n\n\n# 4. Java执行控制流程\n\nJava中的控制流程其实和C —样，在Java中，流程控制会涉及到包括if-else、while、do-while、 for、return、break以及选择语句switch。下面以此进行分析\n\n\n# 4.1 条件语句\n\n条件语句可根据不同的条件执行不同的语句。包括if条件语句与switch多分支语句。\n\n# if条件语句\n\nif语句可以单独判断表达式的结果，表示表达的执行结果，例如\n\nint a = 10;\nif(a > 10){\n return true;\n}\nreturn false;\n\n\n1\n2\n3\n4\n5\n\n\n# if...else条件语句\n\nif语句还可以与else连用，通常表现为如果满足某种条件，就进行某种处理，否则就进行另一种处 理。\n\nint a = 10;\nint b = 11;\nif(a >= b){\n System.out.println("a >= b");\n}else{\n System.out.println("a < b");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nif后的0内的表达式必须是boolean型的。如果为true,则执行if后的复合语句；如果为false,则执 行else后的复合语句。\n\n# if...else if多分支语句\n\n上面中的if...else是单分支和两个分支的判断，如果有多个判断条件，就需要使用if...else if\n\nint x = 40;\nif(x > 60) {\n\tSystem .out. println("x 的值大于 60");\n} else if (x > 30) {\n\tSystem.out.println("x 的值大于 30 但小于 60");\n} else if (x > 0) {\n\tSystem.out.println("x 的值大于 0 但小于 30");\n} else {\n\tSystem.out.println("x 的值小于等于 0”);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# switch多分支语句\n\n一种比if...else if语句更优雅的方式是使用switch多分支语句，\n\n格式：\n\nswitch (表达式) {\n    case 1:\n        语句体1;\n        break; \n    case 2:\n        语句体2;\n        break;\n    ...\n    default:\n    \t语句体n+1; break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n执行流程：\n\n * 首先计算出表达式的值\n\n * 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。\n\n * 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。\n\n示例:\n\n switch (week) {\n     case 1:\n     \tSystem.out.println("Monday");\n    \tbreak;\n     case 2:\n     \tSystem.out.println("Tuesday");\n     \tbreak;\n     case 3:\n     \tSystem.out.println("Wednesday");\n     \tbreak;\n     case 4:\n     \tSystem.out.println("Thursday");\n     \tbreak;\n     case 5:\n     \tSystem.out.println("Friday");\n     \tbreak;\n     case 6:\n     \tSystem.out.println("Saturday");\n     \tbreak;\n     case 7:\n     \tSystem.out.println("Sunday");\n     \tbreak;\n     default:\n     \tSystem.out.println("No Else");\n     \tbreak;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4.2 循环语句\n\n循环语句就是在满足一定的条件下反复执行某一表达式的操作，直到满足循环语句的要求。使用的循环语句主要有 for、do...while()、while ,\n\n# while循环语句\n\nwhile循环语句的循环方式为利用一个条件来控制是否要继续反复执行这个语句。while循环语句的格式 如下\n\nwhile(布尔值){\n 表达式\n}\n\n\n1\n2\n3\n\n\n它的含义是，当(布尔值)为true的时候，执行下面的表达式，布尔值为false的时候，结束循环，布尔 值其实也是一个表达式，比如\n\nint a = 10;\nwhile(a > 5){\n a--;\n}\n\n\n1\n2\n3\n4\n\n\n# do...while 循环\n\nwhile与do...while循环的唯一区别是do...while语句至少执行一次，即使第一次的表达式为false。而 在while循环中，如果第一次条件为false,那么其中的语句根本不会执行。在实际应用中，while要比 do...while应用的更广。它的一般形式如下\n\nint b = 10;\n// do···while循环\ndo {\n System.out.println("b == " + b);\n b--;\n} while(b == 1);\n\n\n1\n2\n3\n4\n5\n6\n\n\n# for循环语句\n\nfor循环是我们经常使用的循环方式，这种形式会在第一次迭代前进行初始化。它的形式如下\n\nfor(初始化；布尔表达式；步进){}\n\n\n1\n\n\n每次迭代前会测试布尔表达式。如果获得的结果是false，就会执行for语句后面的代码；每次循环结 束，会按照步进的值执行下一次循环。\n\n * 迭代器\n\n * 逗号操作符\n\n这里不可忽略的一个就是逗号操作符，Java里唯一用到逗号操作符的就是for循环控制语句。在表达式 的初始化部分，可以使用一系列的逗号分隔的语句；通过逗号操作符，可以在f。r语句内定义多个变 量，但它们必须具有相同的类型\n\nfor(int i = 1;j = i + 10;i < 5;i++, j = j * 2){\n    \n}\n\n\n1\n2\n3\n\n * for-each 语句 (增强for循环)\n\n在Java JDK 1.5中还引入了一种更加简洁的、方便对数组和集合进行遍历的方法，即for-each语 句，例子如下\n\nint array[] = {7, 8, 9};\nfor (int arr : array) {\n System.out.println(arr);\n}\n\n\n1\n2\n3\n4\n\n\n\n# 4.3 跳转语句\n\nJava语言中，有三种跳转语句：break、continue和return\n\n# break语句\n\nbreak语句我们在switch中已经见到了，它是用于终止循环的操作，实际上break语句在for、while、 do-whil e循环语句中，用于强行退出当前循环，例如\n\nfor(int i = 0;i < 10;i++){\n if(i == 5){\n break;\n }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# continue 语句\n\ncontinue也可以放在循环语句中，它与break语句具有相反的效果，它的作用：用于执行下一次循环， 而不是退出当前循环，还以上面的例子为主：\n\nfor(int i = 0;i < 10;i++){\n \n System.out.printl(" i = " + i );\n if(i == 5){\n System.out.printl("continue ... ");\n continue;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# return语句\n\nreturn语句可以从一个方法返回，并把控制权交给调用它的语句。\n\npublic void getName() {\n return name;\n}\n\n\n1\n2\n3\n\n\n\n# 5.包装类\n\n\n# 5.1基本类型包装类\n\n * 基本类型包装类的作用\n   \n   将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据\n   \n   常用的操作之一：用于基本数据类型与字符串之间的转换\n\n * 基本类型对应的包装类\n   \n   基本数据类型    包装类\n   byte      Byte\n   short     Short\n   int       Integer\n   long      Long\n   float     Float\n   double    Double\n   char      Character\n   boolean   Boolean\n\n\n# 5.2Integer类\n\n * Integer类概述\n   \n   包装一个对象中的原始类型 int 的值\n\n * Integer类构造方法\n   \n   方法名                                       说明\n   public Integer(int value)                 根据 int 值创建 Integer 对象(过时)\n   public Integer(String s)                  根据 String 值创建 Integer 对象(过时)\n   public static Integer valueOf(int i)      返回表示指定的 int 值的 Integer 实例\n   public static Integer valueOf(String s)   返回一个保存指定值的 Integer 对象 String\n\n * 示例代码\n   \n   public class IntegerDemo {\n       public static void main(String[] args) {\n           //public Integer(int value)：根据 int 值创建 Integer 对象(过时)\n           Integer i1 = new Integer(100);\n           System.out.println(i1);\n   \n           //public Integer(String s)：根据 String 值创建 Integer 对象(过时)\n           Integer i2 = new Integer("100");\n   //        Integer i2 = new Integer("abc"); //NumberFormatException\n           System.out.println(i2);\n           System.out.println("--------");\n   \n           //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例\n           Integer i3 = Integer.valueOf(100);\n           System.out.println(i3);\n   \n           //public static Integer valueOf(String s)：返回一个保存指定值的Integer对象 String\n           Integer i4 = Integer.valueOf("100");\n           System.out.println(i4);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 5.3int和String类型的相互转换\n\n * int转换为String\n   \n   * 转换方式\n     \n     * 方式一：直接在数字后加一个空字符串\n     * 方式二：通过String类静态方法valueOf()\n   \n   * 示例代码\n     \n     public class IntegerDemo {\n         public static void main(String[] args) {\n             //int --- String\n             int number = 100;\n             //方式1\n             String s1 = number + "";\n             System.out.println(s1);\n             //方式2\n             //public static String valueOf(int i)\n             String s2 = String.valueOf(number);\n             System.out.println(s2);\n             System.out.println("--------");\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     \n\n * String转换为int\n   \n   * 转换方式\n     \n     * 方式一：先将字符串数字转成Integer，再调用valueOf()方法\n     * 方式二：通过Integer静态方法parseInt()进行转换\n   \n   * 示例代码\n     \n     public class IntegerDemo {\n         public static void main(String[] args) {\n             //String --- int\n             String s = "100";\n             //方式1：String --- Integer --- int\n             Integer i = Integer.valueOf(s);\n             //public int intValue()\n             int x = i.intValue();\n             System.out.println(x);\n             //方式2\n             //public static int parseInt(String s)\n             int y = Integer.parseInt(s);\n             System.out.println(y);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n\n# 5.4字符串数据排序案例\n\n * 案例需求\n   \n   有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：“27 38 46 50 91”\n\n * 代码实现\n   \n   public class IntegerTest {\n       public static void main(String[] args) {\n           //定义一个字符串\n           String s = "91 27 46 38 50";\n   \n           //把字符串中的数字数据存储到一个int类型的数组中\n           String[] strArray = s.split(" ");\n   //        for(int i=0; i<strArray.length; i++) {\n   //            System.out.println(strArray[i]);\n   //        }\n   \n           //定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中\n           int[] arr = new int[strArray.length];\n           for(int i=0; i<arr.length; i++) {\n               arr[i] = Integer.parseInt(strArray[i]);\n           }\n   \n           //对 int 数组进行排序\n           Arrays.sort(arr);\n   \n           //把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现\n           StringBuilder sb = new StringBuilder();\n           for(int i=0; i<arr.length; i++) {\n               if(i == arr.length - 1) {\n                   sb.append(arr[i]);\n               } else {\n                   sb.append(arr[i]).append(" ");\n               }\n           }\n           String result = sb.toString();\n   \n           //输出结果\n           System.out.println(result);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   \n\n\n# 5.5 自动拆箱和自动装箱\n\n * 自动装箱\n   \n   把基本数据类型转换为对应的包装类类型\n\n * 自动拆箱\n   \n   把包装类类型转换为对应的基本数据类型\n\n * 示例代码\n   \n   Integer i = 100;  // 自动装箱\n   i += 200;         // i = i + 200;  i + 200 自动拆箱；i = i + 200; 是自动装箱\n   \n   \n   1\n   2\n   \n\n\n# 6. 扩展\n\n\n# Random\n\nRandom产生随机数（掌握）\n\n概述：\n\nRandom类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能\n\nAPI后续课程详细讲解，现在可以简单理解为Java已经写好的代码 使用步骤：\n\n1. 导入包\nimport java.util.Random;\n\n2. 创建对象\nRandom r = new Random();\n\n3.  产生随机数\nint num = r.nextInt(10);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0- 19\n\n示例代码：\n\nimport java.util.Random; \n\npublic class RandomDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Random r = new Random();\n        //用循环获取10个随机数\n        for(int i=0; i<10; i++) {\n        //获取随机数\n        \tint number = r.nextInt(10); System.out.println("number:" + number);\n        }\n        //需求：获取一个1-100之间的随机数\n        int x = r.nextInt(100) + 1; System.out.println(x);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'# 基础语法\n\n\n# 1. java概述\n\n\n# 1.1 什么是java?\n\njava是sun microsystems于1995年首次发布的一种编程语言和计算平台。编程语言还比较好理 解，那么什么是计算平台呢？\n\n> 计算平台是在电脑中运行应用程序(软件)的环境，包括硬件环境和软件环境。一般系统平台 包括一台电脑的硬件体系结构、操作系统、运行时库。\n\njava是快速，安全和可靠的。从笔记本电脑到数据中心，从游戏机到科学超级计算机，从手机到互联 网，java无处不在！ java主要分为三个版本\n\n• javase(j2se)(java2 platform standard edition, java平台标准版)\n\n• javaee(j2ee)(java 2 platform,enterprise edition, java平台企业版)\n\n• javame(j2me)(java 2 platform micro edition, java平台微型版)。\n\n\n# 1.2 java的特点\n\n# 特征一：面向对象的编程语言\n\njava是一门面向对象的编程语言。什么是面向对象？面向对象(object oriented)是一种软件开发思想。它是对现实世界的一种抽象, 面向对象会把相关的数据和方法组织为一个整体来看待。\n\n相对的另外一种开发思想就是面向过程的开发思想，什么面向过程？面向过程(procedure oriented)是一种以过程为中心的编程思想。\n\n举个例子：比如你是个学生，你每天去上学需要做几件 事情？\n\n起床、穿衣服、洗脸刷牙，吃饭，去学校。一般是顺序性的完成一系列动作。\n\nclass student {\n void student_wakeup(){...}\n void student_cloth(){...}\n void student_wash(){...}\n void student_eating(){...}\n void student_gotoschool(){...}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n而面向对象可以把学生进行抽象，所以这个例子就会变为\n\nclass student(){\n void wakeup(){...}\n void cloth(){...}\n void wash(){...}\n void eating(){...}\n void gotoschool(){...}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以不用严格按照顺序来执行每个动作。这是特点一。\n\n# 特征二\n\njava摒弃了 c++中难以理解的多继承、指针、内存管理等概念；不用手动管理对象的生命周期。\n\n# 特征三\n\njava语言具有功能强大和简单易用两个特征，现在企业级开发，快速敏捷开发，尤其是各种框架 的出现，使java成为越来越火的一门语言。\n\n# 特征四：静态语言\n\njava是一门静态语言。静态语言指的就是在编译期间就能够知道数据类型的语言，在运行前就能 够检查类型的正确性，一旦类型确定后就不能再更改，比如下面这个例子。\n\npublic void foo() {\n int x = 5;\n boolean b = x;\n}\n\n\n1\n2\n3\n4\n\n\n静态语言主要有 pascal, perl, c/c++, java, c#, scala 等。\n\n相对应的，动态语言没有任何特定的情况需要指定变量的类型，在运行时确定的数据类型。比如有lisp, perl, python、ruby、javascript 等。\n\n从设计的角度上来说，所有的语言都是设计用来把人类可读的代码转换为机器指令。动态语言是为了能 够让程序员提高编码效率，因此你可以使用更少的代码来实现功能。静态语言设计是用来让硬件执行的 更高效，因此需要程序员编写准确无误的代码，以此来让你的代码尽快的执行。从这个角度来说，静态 语言的执行效率要比动态语言高，速度更快。\n\n# 特征五：平台独立性和可移植性\n\njava具有平台独立性和可移植性。java有一句非常著名的口号：write once, run anywhere，也就是一次编写、到处运行。为什么 java能够吹出这种牛批的口号来？核心就是jvm。我们知道，计算机应用程序和硬件之间会屏蔽很多 细节，它们之间依靠操作系统完成调度和协调，大致的体系结构如下\n\n那么加上java应用、jvm的体系结构会变为如下\n\njava是跨平台的，已编译的java程序可以在任何带有jvm的平台上运行。你可以在windows平台 下编写代码，然后拿到linux平台下运行，该如何实现呢？\n\n首先你需要在应用中编写java代码；用idea或者javac把java代码编译为.class文件；然后把你的.class文件打成.jar文件；然后你的.jar文件就能够在windows*、* mac os x*、*linux系统下运行了。不同的操作系统有不同的 jvm实现，切换平台时，不需要再次编译你的java代码了。\n\n# 特征六：多线程\n\njava是一门高级语言，高级语言会对用户屏蔽很多底层实现细节。比如java是如何实现多线程的。从操作系统的角度来说，实现多线程的方式主要有下面这几种\n\n * 在用户空间中实现多线程\n\n * 在内核空间中实现多线程\n\n * 在用户和内核空间中混合实现线程\n\njava应该是在用户空间实现的多线程，内核是感知不到java存在多线程机制的。\n\n# 特征七：高性能\n\njava具有高性能。我们编写的代码，经过javac编译器编译称为字节码(bytecode)，经过jvm内嵌的解释器将字节码 转换为机器代码，这是解释执行，这种转换过程效率较低。但是部分jvm的实现比如hotspot jvm 都提供了jit(just-in-time)编译器，也就是通常所说的动态编译器，jit能够在运行时将热点代 码编译机器码，这种方式运行效率比较高，这是编译执行。所以java不仅仅只是一种解释执行的语言。\n\n# 特征八：健壮性\n\njava语言具有健壮性。java的强类型机制、异常处理、垃圾的自动收集等是java程序健壮性的重要保证。这也是java与c 语言的重要区别。这是特点八。\n\n# 特征九：java很容易开发分布式项目\n\njava语言支持internet应用的开发，java中有net api，它提供了用于网络应用编程的类库，包括 url、urlconnection、socket、serversocket等。java的rmi (远程方法激活)机制也是开发分布 式应用的重要手段。这是特点九。\n\n\n# 1.3 java开发环境\n\n# jdk\n\njdk (java development kit)称为java开发包或java开发工具，是一个编写java的applet 小程序和应用程序的程序开发环境。jdk是整个java的核心，包括了 java运行环境(java runtime environment),—些 java 工具和 java 的核心类库(java api)。\n\njava platform standard edition 8 documentation\n\n我们可以认真研究一下这张图，它几乎包括了 java中所有的概念，此处是jdk1.8，可以点进去 description of java conceptual diagram ,可以发现这里面包括了所有关于java的描述.\n\noracle提供了两种java平台的实现，一种是我们上面说的jdk, java开发标准工具包，一种是 jre,叫做java runtime environment, java运行时环境。jdk的功能要比jre全很多。\n\n# jre\n\njre是个运行环境，jdk是个开发环境。因此写java程序的时候需要jdk，而运行java程序的时候 就需要jre。而jdk里面已经包含了jre，因此只要安装了jdk,就可以编辑java程序，也可以正常 运行java程序。但由于jdk包含了许多与运行无关的内容，占用的空间较大，因此运行普通的java 程序无须安装jdk，而只需要安装jre即可。\n\n# 总结\n\njvm （java virtual machine） , java虚拟机\n\njre （java runtime environment） , java运行环境,包含了jvm和java的核心类库（java api）\n\njdk （java development kit）称为java开发工具，包含了jre和开发工具\n\n总结：我们只需安装jdk即可，它包含了java的运行环境和虚拟机。\n\n\n# 2. java开发环境配置\n\n这个地方不再多说了，网上有很多教程配置的资料可供参考。\n\nwin10配置java环境（手把手从零搭建java开发环境）_火石桥霍建华的博客-csdn博客\n\n\n# 3. java基本语法\n\n\n# 3.1 数据类型\n\n在java中，数据类型只有四类八种\n\n * 整数型：byte、short、int、long\n\nbyte也就是字节，1 byte = 8 bits, byte的默认值是0 ；\n\nshort占用两个字节，也就是16位，1 short = 16 bits，它的默认值也是0 ；\n\nint占用四个字节，也就是32位，1 int = 32 bits，默认值是0 ；\n\nlong占用八个字节，也就是64位，1 long = 64 bits,默认值是0l；\n\n所以整数型的占用字节大小空间为long > int > short > byte\n\n * 浮点型\n\n浮点型有两种数据类型：float和double\n\nfloat是单精度浮点型，占用4位，1 float = 32 bits,默认值是0.0f；\n\ndouble是双精度浮点型，占用8位，1 double = 64 bits，默认值是0.0d；\n\n * 字符型\n\n字符型就是char, char类型是一个单一的16位unicode字符，最小值是\\u0000 （也就是0 ） 最大值是\\uffff （即为65535） , char数据类型可以存储任何字符，例如char a = \'a\'。\n\n * 布尔型\n\n布尔型指的就是boolean, boolean只有两种值，true或者是false,只表示1位，默认值是false。\n\n以上x位都指的是在内存中的占用。\n\n数据类型      内存    默认值\nbyte      8位    0\nshort     16位   0\nint       32位   0\nlong      64位   0l\nfloat     32位   o.of\ndouble    64位   o.od\nchar      16位   \\u0000\nboolean   8位    fals\n\n\n# 3.2 基础语法\n\n * 大小写敏感：java是对大小写敏感的语言，例如hello与hello是不同的，这其实就是java的字 符串表示方式\n\n * 类名：对于所有的类来说，首字母应该大写，例如myfirstclass\n\n * 包名：包名应该尽量保证小写，例如my.first.package\n\n * 方法名：方法名首字母需要小写，后面每个单词字母都需要大写，例如myfirstmethod()\n\n\n# 3.3 运算符\n\n运算符不只java中有，其他语言也有运算符，运算符是一些特殊的符号，主要用于数学函数、一些类 型的赋值语句和逻辑比较方面。\n\n运算符：对常量或者变量进行操作的符号。\n\n表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。\n\n不同运算符连接的表达式体现的是不同类型的表达式。\n\n举例说明：\n\nint a = 10; \nint b = 20; \nint c = a + b;\n\n\n1\n2\n3\n\n\n+：是运算符，并且是算术运算符。\n\na + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。\n\n# 1. 赋值运算符\n\n赋值运算符使用操作符=来表示，它的意思是把=号右边的值复制给左边，右边的值可以是任何常 数、变量或者表达式，但左边的值必须是一个明确的，已经定义的变量。比如int a = 4\n\n但是对于对象来说，复制的不是对象的值，而是对象的引用，所以如果说将一个对象复制给另一个对 象，实际上是将一个对象的引用赋值给另一个对象。\n\n# 2. 算数运算符\n\n算数运算符就和数学中的数值计算差不多，主要有\n\n符号   作用   说明\n+    加    参看小学一年级\n-    减    参看小学一年级\n*    乘    参看小学二年级，与“×”相同\n/    除    参看小学二年级，与“÷”相同\n%    取余   获取的是两个数据做除法的余数\n\n * /和%的区别：两个数据做除法，/取结果的商，%取结果的余数。整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。\n\nint a = 10; int b = 3;\nsystem.out.println(a / b); // 输出结果3\nsystem.out.println(a % b); // 输出结果1\n\n\n1\n2\n3\n\n\n算数运算符需要注意的就是优先级问题，当一个表达式中存在多个操作符时，操作符的优先级顺序就 决定了计算顺序，最简单的规则就是先乘除后加减，（）的优先级最高，没必要记住所有的优先级顺序，不确定的直接用0就可以了。\n\n# 3. 自增、自减运算符\n\n符号   作用   说明\n++   自增   变量的值加1\n--   自减   变量的值减1\n\n这个就不文字解释了，解释不如直接看例子明白\n\nint a = 5;\nb =   ++a;\nc =   a++;  \n\n\n1\n2\n3\n\n\n# 4. 比较运算符\n\n比较运算符用于程序中的变量之间，变量和自变量之间以及其他类型的信息之间的比较。\n\n比较运算符的运算结果是boolean型。当运算符对应的关系成立时，运算的结果为true,否则为 false。比较运算符共有6个，通常作为判断的依据用于条件语句中。\n\n\n\n# 5. 逻辑运算符\n\n逻辑运算符主要有三种：与、或、非\n\n\n\n下面是逻辑运算符对应的true/false符号表\n\na       b       a & b   a&&b    a | b   a||b    !a      a a b\ntrue    true    true    true    true    true    false   false\ntrue    false   false   false   true    true    false   true\nfalse   true    false   false   true    true    true    true\nfalse   false   false   false   false   false   true    false\n\n# 6. 按位运算符\n\n按位运算符用来操作整数基本类型中的每个比特位，也就是二进制位。按位操作符会对两个参数中对 应的位执行布尔代数运算，并最终生成一个结果。\n\n\n\n如果进行比较的双方是数字的话，那么进行比较就会变为按位运算。\n\n按位与：按位进行与运算（and），两个操作数中位都为1,结果才为1,否则结果为0。需要首先把比 较双方转换成二进制再按每个位进行比较\n\n按位或：按位进行或运算（or）,两个位只要有一个为1,那么结果就是1,否则就为0。\n\n按位非：按位进行异或运算（xor）,如果位为0,结果是1,如果位为1,结果是0。\n\n按位异或：按位进行取反运算（not），两个操作数的位中，相同则结果为0,不同则结果为1。\n\n# 7. 移位运算符\n\n移位运算符用来将操作数向某个方向（向左或者右）移动指定的二进制位数。\n\n运算符   含义\n»     右移运算符eg: 8 » 1 = 4\n«     左移运算符eg: 9 « 2 = 36\n\n# 8. 三元运算符😄\n\n三元运算符是类似if...else...这种的操作符，语法为：条件表达式？表达式1：表达式2。问号前面的位置是判断的条件，判断结果为布尔型，为true时调用表达式1,为false时调用表达式2。\n\nint a = 10; int b = 20;\nint c = a > b ? a : b; // 判断 a>b 是否为真，如果为真取a的值，如果为假，取b的值\n\n\n1\n2\n\n\n\n# 4. java执行控制流程\n\njava中的控制流程其实和c —样，在java中，流程控制会涉及到包括if-else、while、do-while、 for、return、break以及选择语句switch。下面以此进行分析\n\n\n# 4.1 条件语句\n\n条件语句可根据不同的条件执行不同的语句。包括if条件语句与switch多分支语句。\n\n# if条件语句\n\nif语句可以单独判断表达式的结果，表示表达的执行结果，例如\n\nint a = 10;\nif(a > 10){\n return true;\n}\nreturn false;\n\n\n1\n2\n3\n4\n5\n\n\n# if...else条件语句\n\nif语句还可以与else连用，通常表现为如果满足某种条件，就进行某种处理，否则就进行另一种处 理。\n\nint a = 10;\nint b = 11;\nif(a >= b){\n system.out.println("a >= b");\n}else{\n system.out.println("a < b");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nif后的0内的表达式必须是boolean型的。如果为true,则执行if后的复合语句；如果为false,则执 行else后的复合语句。\n\n# if...else if多分支语句\n\n上面中的if...else是单分支和两个分支的判断，如果有多个判断条件，就需要使用if...else if\n\nint x = 40;\nif(x > 60) {\n\tsystem .out. println("x 的值大于 60");\n} else if (x > 30) {\n\tsystem.out.println("x 的值大于 30 但小于 60");\n} else if (x > 0) {\n\tsystem.out.println("x 的值大于 0 但小于 30");\n} else {\n\tsystem.out.println("x 的值小于等于 0”);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# switch多分支语句\n\n一种比if...else if语句更优雅的方式是使用switch多分支语句，\n\n格式：\n\nswitch (表达式) {\n    case 1:\n        语句体1;\n        break; \n    case 2:\n        语句体2;\n        break;\n    ...\n    default:\n    \t语句体n+1; break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n执行流程：\n\n * 首先计算出表达式的值\n\n * 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。\n\n * 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。\n\n示例:\n\n switch (week) {\n     case 1:\n     \tsystem.out.println("monday");\n    \tbreak;\n     case 2:\n     \tsystem.out.println("tuesday");\n     \tbreak;\n     case 3:\n     \tsystem.out.println("wednesday");\n     \tbreak;\n     case 4:\n     \tsystem.out.println("thursday");\n     \tbreak;\n     case 5:\n     \tsystem.out.println("friday");\n     \tbreak;\n     case 6:\n     \tsystem.out.println("saturday");\n     \tbreak;\n     case 7:\n     \tsystem.out.println("sunday");\n     \tbreak;\n     default:\n     \tsystem.out.println("no else");\n     \tbreak;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4.2 循环语句\n\n循环语句就是在满足一定的条件下反复执行某一表达式的操作，直到满足循环语句的要求。使用的循环语句主要有 for、do...while()、while ,\n\n# while循环语句\n\nwhile循环语句的循环方式为利用一个条件来控制是否要继续反复执行这个语句。while循环语句的格式 如下\n\nwhile(布尔值){\n 表达式\n}\n\n\n1\n2\n3\n\n\n它的含义是，当(布尔值)为true的时候，执行下面的表达式，布尔值为false的时候，结束循环，布尔 值其实也是一个表达式，比如\n\nint a = 10;\nwhile(a > 5){\n a--;\n}\n\n\n1\n2\n3\n4\n\n\n# do...while 循环\n\nwhile与do...while循环的唯一区别是do...while语句至少执行一次，即使第一次的表达式为false。而 在while循环中，如果第一次条件为false,那么其中的语句根本不会执行。在实际应用中，while要比 do...while应用的更广。它的一般形式如下\n\nint b = 10;\n// do···while循环\ndo {\n system.out.println("b == " + b);\n b--;\n} while(b == 1);\n\n\n1\n2\n3\n4\n5\n6\n\n\n# for循环语句\n\nfor循环是我们经常使用的循环方式，这种形式会在第一次迭代前进行初始化。它的形式如下\n\nfor(初始化；布尔表达式；步进){}\n\n\n1\n\n\n每次迭代前会测试布尔表达式。如果获得的结果是false，就会执行for语句后面的代码；每次循环结 束，会按照步进的值执行下一次循环。\n\n * 迭代器\n\n * 逗号操作符\n\n这里不可忽略的一个就是逗号操作符，java里唯一用到逗号操作符的就是for循环控制语句。在表达式 的初始化部分，可以使用一系列的逗号分隔的语句；通过逗号操作符，可以在f。r语句内定义多个变 量，但它们必须具有相同的类型\n\nfor(int i = 1;j = i + 10;i < 5;i++, j = j * 2){\n    \n}\n\n\n1\n2\n3\n\n * for-each 语句 (增强for循环)\n\n在java jdk 1.5中还引入了一种更加简洁的、方便对数组和集合进行遍历的方法，即for-each语 句，例子如下\n\nint array[] = {7, 8, 9};\nfor (int arr : array) {\n system.out.println(arr);\n}\n\n\n1\n2\n3\n4\n\n\n\n# 4.3 跳转语句\n\njava语言中，有三种跳转语句：break、continue和return\n\n# break语句\n\nbreak语句我们在switch中已经见到了，它是用于终止循环的操作，实际上break语句在for、while、 do-whil e循环语句中，用于强行退出当前循环，例如\n\nfor(int i = 0;i < 10;i++){\n if(i == 5){\n break;\n }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# continue 语句\n\ncontinue也可以放在循环语句中，它与break语句具有相反的效果，它的作用：用于执行下一次循环， 而不是退出当前循环，还以上面的例子为主：\n\nfor(int i = 0;i < 10;i++){\n \n system.out.printl(" i = " + i );\n if(i == 5){\n system.out.printl("continue ... ");\n continue;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# return语句\n\nreturn语句可以从一个方法返回，并把控制权交给调用它的语句。\n\npublic void getname() {\n return name;\n}\n\n\n1\n2\n3\n\n\n\n# 5.包装类\n\n\n# 5.1基本类型包装类\n\n * 基本类型包装类的作用\n   \n   将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据\n   \n   常用的操作之一：用于基本数据类型与字符串之间的转换\n\n * 基本类型对应的包装类\n   \n   基本数据类型    包装类\n   byte      byte\n   short     short\n   int       integer\n   long      long\n   float     float\n   double    double\n   char      character\n   boolean   boolean\n\n\n# 5.2integer类\n\n * integer类概述\n   \n   包装一个对象中的原始类型 int 的值\n\n * integer类构造方法\n   \n   方法名                                       说明\n   public integer(int value)                 根据 int 值创建 integer 对象(过时)\n   public integer(string s)                  根据 string 值创建 integer 对象(过时)\n   public static integer valueof(int i)      返回表示指定的 int 值的 integer 实例\n   public static integer valueof(string s)   返回一个保存指定值的 integer 对象 string\n\n * 示例代码\n   \n   public class integerdemo {\n       public static void main(string[] args) {\n           //public integer(int value)：根据 int 值创建 integer 对象(过时)\n           integer i1 = new integer(100);\n           system.out.println(i1);\n   \n           //public integer(string s)：根据 string 值创建 integer 对象(过时)\n           integer i2 = new integer("100");\n   //        integer i2 = new integer("abc"); //numberformatexception\n           system.out.println(i2);\n           system.out.println("--------");\n   \n           //public static integer valueof(int i)：返回表示指定的 int 值的 integer 实例\n           integer i3 = integer.valueof(100);\n           system.out.println(i3);\n   \n           //public static integer valueof(string s)：返回一个保存指定值的integer对象 string\n           integer i4 = integer.valueof("100");\n           system.out.println(i4);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 5.3int和string类型的相互转换\n\n * int转换为string\n   \n   * 转换方式\n     \n     * 方式一：直接在数字后加一个空字符串\n     * 方式二：通过string类静态方法valueof()\n   \n   * 示例代码\n     \n     public class integerdemo {\n         public static void main(string[] args) {\n             //int --- string\n             int number = 100;\n             //方式1\n             string s1 = number + "";\n             system.out.println(s1);\n             //方式2\n             //public static string valueof(int i)\n             string s2 = string.valueof(number);\n             system.out.println(s2);\n             system.out.println("--------");\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     \n\n * string转换为int\n   \n   * 转换方式\n     \n     * 方式一：先将字符串数字转成integer，再调用valueof()方法\n     * 方式二：通过integer静态方法parseint()进行转换\n   \n   * 示例代码\n     \n     public class integerdemo {\n         public static void main(string[] args) {\n             //string --- int\n             string s = "100";\n             //方式1：string --- integer --- int\n             integer i = integer.valueof(s);\n             //public int intvalue()\n             int x = i.intvalue();\n             system.out.println(x);\n             //方式2\n             //public static int parseint(string s)\n             int y = integer.parseint(s);\n             system.out.println(y);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n\n# 5.4字符串数据排序案例\n\n * 案例需求\n   \n   有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：“27 38 46 50 91”\n\n * 代码实现\n   \n   public class integertest {\n       public static void main(string[] args) {\n           //定义一个字符串\n           string s = "91 27 46 38 50";\n   \n           //把字符串中的数字数据存储到一个int类型的数组中\n           string[] strarray = s.split(" ");\n   //        for(int i=0; i<strarray.length; i++) {\n   //            system.out.println(strarray[i]);\n   //        }\n   \n           //定义一个int数组，把 string[] 数组中的每一个元素存储到 int 数组中\n           int[] arr = new int[strarray.length];\n           for(int i=0; i<arr.length; i++) {\n               arr[i] = integer.parseint(strarray[i]);\n           }\n   \n           //对 int 数组进行排序\n           arrays.sort(arr);\n   \n           //把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用stringbuilder来实现\n           stringbuilder sb = new stringbuilder();\n           for(int i=0; i<arr.length; i++) {\n               if(i == arr.length - 1) {\n                   sb.append(arr[i]);\n               } else {\n                   sb.append(arr[i]).append(" ");\n               }\n           }\n           string result = sb.tostring();\n   \n           //输出结果\n           system.out.println(result);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   \n\n\n# 5.5 自动拆箱和自动装箱\n\n * 自动装箱\n   \n   把基本数据类型转换为对应的包装类类型\n\n * 自动拆箱\n   \n   把包装类类型转换为对应的基本数据类型\n\n * 示例代码\n   \n   integer i = 100;  // 自动装箱\n   i += 200;         // i = i + 200;  i + 200 自动拆箱；i = i + 200; 是自动装箱\n   \n   \n   1\n   2\n   \n\n\n# 6. 扩展\n\n\n# random\n\nrandom产生随机数（掌握）\n\n概述：\n\nrandom类似scanner，也是java提供好的api，内部提供了产生随机数的功能\n\napi后续课程详细讲解，现在可以简单理解为java已经写好的代码 使用步骤：\n\n1. 导入包\nimport java.util.random;\n\n2. 创建对象\nrandom r = new random();\n\n3.  产生随机数\nint num = r.nextint(10);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0- 19\n\n示例代码：\n\nimport java.util.random; \n\npublic class randomdemo {\n    public static void main(string[] args) {\n        //创建对象\n        random r = new random();\n        //用循环获取10个随机数\n        for(int i=0; i<10; i++) {\n        //获取随机数\n        \tint number = r.nextint(10); system.out.println("number:" + number);\n        }\n        //需求：获取一个1-100之间的随机数\n        int x = r.nextint(100) + 1; system.out.println(x);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"访问控制权限",frontmatter:{title:"访问控制权限",date:"2023-02-25T12:49:46.000Z",permalink:"/pages/8e5736/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/03.%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/03.访问控制权限.md",key:"v-9767263a",path:"/pages/8e5736/",headers:[{level:2,title:"1. 继承",slug:"_1-继承",normalizedTitle:"1. 继承",charIndex:454},{level:3,title:"1.1 继承的实现",slug:"_1-1-继承的实现",normalizedTitle:"1.1 继承的实现",charIndex:656},{level:4,title:"1. 继承的概念",slug:"_1-继承的概念",normalizedTitle:"1. 继承的概念",charIndex:669},{level:4,title:"2. 继承的好处和弊端",slug:"_2-继承的好处和弊端",normalizedTitle:"2. 继承的好处和弊端",charIndex:1319},{level:3,title:"1.2 继承中的成员访问特点",slug:"_1-2-继承中的成员访问特点",normalizedTitle:"1.2 继承中的成员访问特点",charIndex:1571},{level:4,title:"1. 继承中变量的访问特点",slug:"_1-继承中变量的访问特点",normalizedTitle:"1. 继承中变量的访问特点",charIndex:1589},{level:4,title:"2. super",slug:"_2-super",normalizedTitle:"2. super",charIndex:2023},{level:4,title:"3. 继承中构造方法的访问特点",slug:"_3-继承中构造方法的访问特点",normalizedTitle:"3. 继承中构造方法的访问特点",charIndex:2333},{level:4,title:"4. 继承中成员方法的访问特点",slug:"_4-继承中成员方法的访问特点",normalizedTitle:"4. 继承中成员方法的访问特点",charIndex:2566},{level:4,title:"5. super内存图",slug:"_5-super内存图",normalizedTitle:"5. super内存图",charIndex:2647},{level:4,title:"6. 方法重写",slug:"_6-方法重写",normalizedTitle:"6. 方法重写",charIndex:2699},{level:3,title:"1.3.  继承的注意事项",slug:"_1-3-继承的注意事项",normalizedTitle:"1.3.  继承的注意事项",charIndex:null},{level:2,title:"2. 多态",slug:"_2-多态",normalizedTitle:"2. 多态",charIndex:4141},{level:3,title:"2.1 多态的概述",slug:"_2-1-多态的概述",normalizedTitle:"2.1 多态的概述",charIndex:4151},{level:4,title:"1. 什么是多态?",slug:"_1-什么是多态",normalizedTitle:"1. 什么是多态?",charIndex:4164},{level:4,title:"2. 多态的前提",slug:"_2-多态的前提",normalizedTitle:"2. 多态的前提",charIndex:4284},{level:3,title:"2.2 多态中的成员访问特点",slug:"_2-2-多态中的成员访问特点",normalizedTitle:"2.2 多态中的成员访问特点",charIndex:4346},{level:4,title:"1. 成员访问特点",slug:"_1-成员访问特点",normalizedTitle:"1. 成员访问特点",charIndex:4364},{level:4,title:"2. 示例",slug:"_2-示例",normalizedTitle:"2. 示例",charIndex:4421},{level:3,title:"2.3 多态的好处和弊端",slug:"_2-3-多态的好处和弊端",normalizedTitle:"2.3 多态的好处和弊端",charIndex:5117},{level:4,title:"好处",slug:"好处",normalizedTitle:"好处",charIndex:799},{level:4,title:"弊端",slug:"弊端",normalizedTitle:"弊端",charIndex:1328},{level:3,title:"2.4 多态中的转型",slug:"_2-4-多态中的转型",normalizedTitle:"2.4 多态中的转型",charIndex:5207},{level:4,title:"1. 向上转型",slug:"_1-向上转型",normalizedTitle:"1. 向上转型",charIndex:5221},{level:4,title:"2. 向下转型",slug:"_2-向下转型",normalizedTitle:"2. 向下转型",charIndex:5250},{level:4,title:"3. 示例",slug:"_3-示例",normalizedTitle:"3. 示例",charIndex:5286},{level:3,title:"2.5 多态的案例",slug:"_2-5-多态的案例",normalizedTitle:"2.5 多态的案例",charIndex:5999},{level:2,title:"3. 组合",slug:"_3-组合",normalizedTitle:"3. 组合",charIndex:7525},{level:2,title:"4. 代理",slug:"_4-代理",normalizedTitle:"4. 代理",charIndex:8166},{level:2,title:"5. 向上转型",slug:"_5-向上转型",normalizedTitle:"5. 向上转型",charIndex:8822},{level:2,title:"6. 修饰符",slug:"_6-修饰符",normalizedTitle:"6. 修饰符",charIndex:8995},{level:3,title:"6.1  package",slug:"_6-1-package",normalizedTitle:"6.1  package",charIndex:null},{level:4,title:"1. 包的概念",slug:"_1-包的概念",normalizedTitle:"1. 包的概念",charIndex:9021},{level:4,title:"2. 包的定义格式",slug:"_2-包的定义格式",normalizedTitle:"2. 包的定义格式",charIndex:9049},{level:4,title:"3. 带包编译&带包运行",slug:"_3-带包编译-带包运行",normalizedTitle:"3. 带包编译&amp;带包运行",charIndex:null},{level:3,title:"6.2 import",slug:"_6-2-import",normalizedTitle:"6.2 import",charIndex:9259},{level:3,title:"6.3 final",slug:"_6-3-final",normalizedTitle:"6.3 final",charIndex:9861},{level:3,title:"6.4 static",slug:"_6-4-static",normalizedTitle:"6.4 static",charIndex:10150},{level:4,title:"1. 修饰属性和方法",slug:"_1-修饰属性和方法",normalizedTitle:"1. 修饰属性和方法",charIndex:10164},{level:4,title:"2. 静态代码块",slug:"_2-静态代码块",normalizedTitle:"2. 静态代码块",charIndex:10578}],headersStr:"1. 继承 1.1 继承的实现 1. 继承的概念 2. 继承的好处和弊端 1.2 继承中的成员访问特点 1. 继承中变量的访问特点 2. super 3. 继承中构造方法的访问特点 4. 继承中成员方法的访问特点 5. super内存图 6. 方法重写 1.3.  继承的注意事项 2. 多态 2.1 多态的概述 1. 什么是多态? 2. 多态的前提 2.2 多态中的成员访问特点 1. 成员访问特点 2. 示例 2.3 多态的好处和弊端 好处 弊端 2.4 多态中的转型 1. 向上转型 2. 向下转型 3. 示例 2.5 多态的案例 3. 组合 4. 代理 5. 向上转型 6. 修饰符 6.1  package 1. 包的概念 2. 包的定义格式 3. 带包编译&带包运行 6.2 import 6.3 final 6.4 static 1. 修饰属性和方法 2. 静态代码块",content:'# 访问控制权限(封装)\n\n访问控制权限又称为封装，它是面向对象三大特性中的一种，我之前在学习过程中经常会忽略封装， 心想这不就是一个访问修饰符么，怎么就是三大特性的必要条件了？后来我才知道，如果你信任的下属 对你隐瞒bug，你是根本不知道的。\n\n访问控制权限其实最核心就是一点：只对需要的类可见。\n\nJava中成员的访问权限共有四种，分别是public、protecteds、default、private，它们的可见性如下\n\n         PRIVATE   DEFAULT   PROTECTED   PUBLIC\n同一类      √         √         √           √\n同一包中的类             √         √           √\n子类                           √           √\n其他包中的类                                   √\n\n√ 表示的是可以进行访问。\n\n\n# 1. 继承\n\n继承是所有OOP(Object Oriented Programming)语言和Java语言都不可或缺的一部分。只要我们创建了一个类，就隐式的继承自Object父类，只不过没有指定。如果你显示指定了父类，那么你继承于父类，而你的父类继承于Object类。\n\n，如上图所示，如果使用了 extends显示指定了继承，那么我们可以说 Father是父类，而Son是子类，用代码表示如下\n\n\n# 1.1 继承的实现\n\n# 1. 继承的概念\n\n继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法\n\n * 实现继承的格式\n\n继承的关键字是extends;\n\n格式：class 子类 extends 父类 { };\n\n * 继承带来的好处\n\n继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。\n\n * 示例\n\npublic class Fu {\n    public void show() {\n        System.out.println("show方法被调用");\n    }\n}\n// Zi继承Fu\npublic class Zi extends Fu {\n    public void method() {\n        System.out.println("method方法被调用");\n    }\n}\npublic class Demo {\n    public static void main(String[] args) {\n\t\t//创建对象，调用方法\n        Fu f = new Fu();\n        f.show();\n        Zi z = new Zi();\n        z.method();\n        z.show();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 2. 继承的好处和弊端\n\n * 继承好处\n\n提高了代码的复用性(多个类相同的成员可以放到同一个类中)。\n\n提高了代码的维护性(如果方法的代码需要修改，修改一处即可)。\n\n * 继承弊端\n\n继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性。\n\n * 继承的应用场景：\n\n使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承。\n\nis..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类\n\n\n# 1.2 继承中的成员访问特点\n\n# 1. 继承中变量的访问特点\n\n在子类方法中访问一个变量，采用的是就近原则。\n\n * 子类局部范围找\n\n * 子类成员范围找\n\n * 父类成员范围找\n\n * 如果都没有就报错(不考虑父亲的父亲…)\n\n示例代码\n\nclass Fu {\n    int num = 10;\n}\nclass Zi {\n    int num = 20;\n    public void show(){\n        int num = 30;\n        System.out.println(num);\n    }\n}\npublic class Demo1 {\n    public static void main(String[] args) {\n        Zi z = new Zi();\n        z.show(); // 输出show方法中的局部变量30\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 2. super\n\n * this&super关键字：\n\nthis：代表本类对象的引用\n\nsuper：代表父类存储空间的标识(可以理解为父类对象引用)\n\n * this和super的使用分别\n   \n   * 成员变量：\n     \n     this.成员变量 - 访问本类成员变量\n     \n     super.成员变量 - 访问父类成员变量\n   \n   * 成员方法：\n     \n     this.成员方法 - 访问本类成员方法\n     \n     super.成员方法 - 访问父类成员方法\n\n * 构造方法：\n\nthis(…) - 访问本类构造方法\n\nsuper(…) - 访问父类构造方法\n\n# 3. 继承中构造方法的访问特点\n\n> 注意：子类中所有的构造方法默认都会访问父类中无参的构造方法。\n\n子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super()。\n\n问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？\n\n 1. 通过使用super关键字去显示的调用父类的带参构造方法。\n\n 2. 在父类中自己提供一个无参构造方法。【推荐】\n\n# 4. 继承中成员方法的访问特点\n\n通过子类对象访问一个方法\n\n * 子类成员范围找\n\n * 父类成员范围找\n\n * 如果都没有就报错(不考虑父亲的父亲…)\n\n# 5. super内存图\n\n对象在堆内存中，会单独存在一块super区域，用来存放父类的数据。\n\n\n\n# 6. 方法重写\n\n * 方法重写概念\n\n子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样）。\n\n * 方法重写的应用场景\n\n当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。\n\n * Override注解\n\n用来检测当前的方法，是否是重写的方法，起到【校验】的作用\n\n * 方法重写的注意事项\n   * 私有方法不能被重写(父类私有成员子类是不能继承的)\n   * 子类方法访问权限不能更低(public > 默认 > 私有)\n\npublic class Fu {\n    private void show() {\n        System.out.println("Fu中show()方法被调用");\n    }\n    void method() {\n        System.out.println("Fu中method()方法被调用");\n    }\n}\npublic class Zi extends Fu {\n    /* 编译【出错】，子类不能重写父类私有的方法*/\n    @Override\n    private void show() {\n        System.out.println("Zi中show()方法被调用");\n    }\n    /* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @Override\n    private void method() {\n        System.out.println("Zi中method()方法被调用");\n    }\n    /* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @Override\n    public void method() {\n        System.out.println("Zi中method()方法被调用");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 1.3. 继承的注意事项\n\n * Java中类只支持单继承，不支持多继承。\n\n错误范例：class A extends B, C { }\n\n * Java中类支持多层继承\n\npublic class Granddad {\n    public void drink() {\n        System.out.println("爷爷爱喝酒");\n    }\n}\npublic class Father extends Granddad {\n    public void smoke() {\n        System.out.println("爸爸爱抽烟");\n    }\n}\npublic class Mother {\n    public void dance() {\n        System.out.println("妈妈爱跳舞");\n    }\n}\npublic class Son extends Father {\n// 此时，Son类中就同时拥有drink方法以及smoke方法\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2. 多态\n\n\n# 2.1 多态的概述\n\n# 1. 什么是多态?\n\n同一个对象，在不同时刻表现出来的不同形态\n\n多态指的是同一个行为具有多个不同表现形式。是指一个类实例（对象）的相同方法在不同情形下具有 不同表现形式。封装和继承是多态的基础，也就是说，多态只是一种表现形式而已。\n\n# 2. 多态的前提\n\n * 要有继承或实现关系\n\n * 要有方法的重写(父类方法)\n\n * 要有父类引用指向子类对象\n\n\n# 2.2 多态中的成员访问特点\n\n# 1. 成员访问特点\n\n * 成员变量\n\n编译看父类，运行看父类\n\n * 成员方法\n\n编译看父类，运行看子类\n\n# 2. 示例\n\n动物类\n\npublic class Animal {\n    public int age = 40;\n    public void eat() {\n        System.out.println("动物吃东西");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n猫\n\npublic class Cat extends Animal {\n    public int age = 20;\n    public int weight = 10;\n    @Override\n    public void eat() {\n        System.out.println("猫吃鱼");\n    }\n    public void playGame() {\n        System.out.println("猫捉迷藏");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试类\n\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        //有父类引用指向子类对象\n        Animal a = new Cat();\n        System.out.println(a.age);\n        // System.out.println(a.weight);\n        a.eat();\n        // a.playGame();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.3 多态的好处和弊端\n\n# 好处\n\n提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作\n\n# 弊端\n\n不能使用子类的特有成员。\n\n\n# 2.4 多态中的转型\n\n# 1. 向上转型\n\n父类引用指向子类对象就是向上转型\n\n# 2. 向下转型\n\n格式：子类型 对象名 = (子类型)父类引用;\n\n# 3. 示例\n\n动物类\n\npublic class Animal {\n    public int age = 40;\n    public void eat() {\n        System.out.println("动物吃东西");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n猫\n\npublic class Cat extends Animal {\n    public int age = 20;\n    public int weight = 10;\n    @Override\n    public void eat() {\n        System.out.println("猫吃鱼");\n    }\n    public void playGame() {\n        System.out.println("猫捉迷藏");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试类\n\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        //多态\n        //向上转型\n        Animal a = new Cat();\n        a.eat();\n        // a.playGame();\n        //向下转型\n        Cat c = (Cat)a;\n        c.eat();\n        c.playGame();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.5 多态的案例\n\n请采用多态的思想实现猫和狗的案例，并在测试类中进行测试。\n\n动物类\n\npublic class Animal {\n    private String name;\n    private int age;\n    public Animal() {\n    }\n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public void eat() {\n        System.out.println("动物吃东西");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n猫\n\npublic class Cat extends Animal {\n    public Cat() {\n    }\n    public Cat(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void eat() {\n        System.out.println("猫吃鱼");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n狗\n\npublic class Dog extends Animal {\n    public Dog() {\n    }\n\n    public Dog(String name, int age) {\n        super(name, age);\n    }\n\n    @Override\n    public void eat() {\n        System.out.println("狗吃骨头");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n测试类\n\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        //创建猫类对象进行测试\n        Animal a = new Cat();\n        a.setName("加菲");\n        a.setAge(5);\n        System.out.println(a.getName() + "," + a.getAge());\n        a.eat();\n        a = new Cat("加菲", 5);\n        System.out.println(a.getName() + "," + a.getAge());\n        a.eat();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3. 组合\n\n组合其实不难理解，就是将对象引用置于新类中即可。组合也是一种提高类的复用性的一种方式。如果 你想让类具有更多的扩展功能，你需要记住一句话多用组合，少用继承。\n\npublic class SoccerPlayer {\n\n    private String name;\n    private Soccer soccer;\n\n}\npublic class Soccer {\n\n    private String soccerName;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n代码中SoccerPlayer引用了 Soccer类，通过引用Soccer类，来达到调用soccer中的属性和方法。\n\n组合和继承是有区别的，它们的主要区别如下。\n\n特征        组合                        继承\n关系        组合是一种has-a的关系，可以理解为有一 个   继承是一种is-a的关系，可以理解为是一 个\n耦合性       组合的双方是一种松耦合的关系            继承双方紧耦合\n是否具有多 态   组合不具备多态和向上转型              继承是多态的基础，可以实现向上转型\n时期        组合是运行期绑定                  继承是编译期绑定\n\n关于继承和组合孰优孰劣的争论没有结果，只要发挥各自的长处和优点即可，一般情况下，组合和继承 也是一对可以连用的好兄弟。\n\n\n# 4. 代理\n\n除了继承和组合外，另外一种值得探讨的关系模型称为代理。代理的大致描述是，A想要调用B类 的方法，A不直接调用，A会在自己的类中创建一个B对象的代理，再由代理调用B的方法。例如如下代码\n\npublic class Destination {\n    public void todo(){\n        System.out.println("control...");\n    }\n}\npublic class Device {\n    private String name;\n    private Destination destination;\n    private DeviceController deviceController;\n    public void control(Destination destination){\n        destination.todo();\n    }\n}\npublic class DeviceController {\n    private Device name;\n    private Destination destination;\n    public void control(Destination destination){\n        destination.todo();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 5. 向上转型\n\n向上转型代表了父类与子类之间的关系，其实父类和子类之间不仅仅有向上转型，还有向下转型，它们 的转型后的范围不一样\n\n * 向上转型：通过子类对象（小范围）转化为父类对象（大范围），这种转换是自动完成的，不用强制。\n\n * 向下转型：通过父类对象（大范围）实例化子类对象（小范围），这种转换不是自动完成的，需要强制指定。\n\n\n# 6. 修饰符\n\n\n# 6.1 package\n\n# 1. 包的概念\n\n包就是文件夹，用来管理类文件的\n\n# 2. 包的定义格式\n\npackage 包名; (多级包用.分开)\n\n例如：package com.heima.demo;\n\n# 3. 带包编译&带包运行\n\n带包编译：javac –d . 类名.java\n\n * 例如：javac -d . com.heima.demo.HelloWorld.java\n\n带包运行：java 包名+类名\n\n * 例如：java com.heima.demo.HelloWorld\n\n\n# 6.2 import\n\n * 导包的意义\n\n使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了。为了简化带包的操作，Java就提供了导包的功能。\n\n * 导包的格式\n\n格式：import 包名;\n\n范例：import java.util.Scanner;\n\n * 示例\n\n没有使用导包，创建的Scanner对象\n\npackage com.heima;\n\npublic class Demo {\n\tpublic static void main(String[] args) {\n        // 1. 没有导包，创建Scnaner对象\n        java.util.Scanner sc = new java.util.Scanner(System.in);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用导包后，创建的Scanner对象\n\npackage com.heima;\nimport java.util.Scanner;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 1. 没有导包，创建Scnaner对象\n        Scanner sc = new Scanner(System.in);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 6.3 final\n\nfinal的意思是最后的、最终的，它可以修饰类、属性和方法。\n\n * final修饰类时，表明这个类不能被继承。final类中的成员变量可以根据需要设为final，但是要注 意final类中的所有成员方法都会被隐式地指定为final方法。\n\n * final修饰方法时，表明这个方法不能被任何子类重写，因此，如果只有在想明确禁止该方法在子 类中被覆盖的情况下才将方法设置为final。\n\n * final修饰变量分为两种情况，一种是修饰基本数据类型，表示数据类型的值不能被修改；一种是 修饰引用类型，表示对其初始化之后便不能再让其指向另一个对象。\n\n\n# 6.4 static\n\n# 1. 修饰属性和方法\n\nstatic是Java中的关键字，它的意思是静态的，static可以用来修饰成员变量和方法，static用在没有创建对象的情况下调用方法/变量。\n\n * 用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应 用程序执行期间都有效。\n\nstatic String name = "cxuan"; \n\n\n1\n\n * 使用static修饰的方法称为静态方法，静态方法能够直接使用类名.方法名进行调用。由于静态方 法不依赖于任何对象就可以直接访问，因此对于静态方法来说，是没有this关键字的，实例变量 都会有this关键字。在静态方法中不能访问类的非静态成员变量和非静态方法，\n\nstatic void printMessage(){\n System.out.println("cxuan is writing the article");\n}\n\n\n1\n2\n3\n\n\n# 2. 静态代码块\n\nstatic除了修饰属性和方法外，还有静态代码块的功能，可用于类的初始化操作。进而提升程序的性 能。\n\npublic class StaicBlock {\n static{\n System.out.println("I\'m A static code block");\n }\n}\n\n\n1\n2\n3\n4\n5\n\n\n由于静态代码块随着类的加载而执行，因此，很多时候会将只需要进行一次的初始化操作放在static代 码块中进行。',normalizedContent:'# 访问控制权限(封装)\n\n访问控制权限又称为封装，它是面向对象三大特性中的一种，我之前在学习过程中经常会忽略封装， 心想这不就是一个访问修饰符么，怎么就是三大特性的必要条件了？后来我才知道，如果你信任的下属 对你隐瞒bug，你是根本不知道的。\n\n访问控制权限其实最核心就是一点：只对需要的类可见。\n\njava中成员的访问权限共有四种，分别是public、protecteds、default、private，它们的可见性如下\n\n         private   default   protected   public\n同一类      √         √         √           √\n同一包中的类             √         √           √\n子类                           √           √\n其他包中的类                                   √\n\n√ 表示的是可以进行访问。\n\n\n# 1. 继承\n\n继承是所有oop(object oriented programming)语言和java语言都不可或缺的一部分。只要我们创建了一个类，就隐式的继承自object父类，只不过没有指定。如果你显示指定了父类，那么你继承于父类，而你的父类继承于object类。\n\n，如上图所示，如果使用了 extends显示指定了继承，那么我们可以说 father是父类，而son是子类，用代码表示如下\n\n\n# 1.1 继承的实现\n\n# 1. 继承的概念\n\n继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法\n\n * 实现继承的格式\n\n继承的关键字是extends;\n\n格式：class 子类 extends 父类 { };\n\n * 继承带来的好处\n\n继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。\n\n * 示例\n\npublic class fu {\n    public void show() {\n        system.out.println("show方法被调用");\n    }\n}\n// zi继承fu\npublic class zi extends fu {\n    public void method() {\n        system.out.println("method方法被调用");\n    }\n}\npublic class demo {\n    public static void main(string[] args) {\n\t\t//创建对象，调用方法\n        fu f = new fu();\n        f.show();\n        zi z = new zi();\n        z.method();\n        z.show();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 2. 继承的好处和弊端\n\n * 继承好处\n\n提高了代码的复用性(多个类相同的成员可以放到同一个类中)。\n\n提高了代码的维护性(如果方法的代码需要修改，修改一处即可)。\n\n * 继承弊端\n\n继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性。\n\n * 继承的应用场景：\n\n使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承。\n\nis..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类\n\n\n# 1.2 继承中的成员访问特点\n\n# 1. 继承中变量的访问特点\n\n在子类方法中访问一个变量，采用的是就近原则。\n\n * 子类局部范围找\n\n * 子类成员范围找\n\n * 父类成员范围找\n\n * 如果都没有就报错(不考虑父亲的父亲…)\n\n示例代码\n\nclass fu {\n    int num = 10;\n}\nclass zi {\n    int num = 20;\n    public void show(){\n        int num = 30;\n        system.out.println(num);\n    }\n}\npublic class demo1 {\n    public static void main(string[] args) {\n        zi z = new zi();\n        z.show(); // 输出show方法中的局部变量30\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 2. super\n\n * this&super关键字：\n\nthis：代表本类对象的引用\n\nsuper：代表父类存储空间的标识(可以理解为父类对象引用)\n\n * this和super的使用分别\n   \n   * 成员变量：\n     \n     this.成员变量 - 访问本类成员变量\n     \n     super.成员变量 - 访问父类成员变量\n   \n   * 成员方法：\n     \n     this.成员方法 - 访问本类成员方法\n     \n     super.成员方法 - 访问父类成员方法\n\n * 构造方法：\n\nthis(…) - 访问本类构造方法\n\nsuper(…) - 访问父类构造方法\n\n# 3. 继承中构造方法的访问特点\n\n> 注意：子类中所有的构造方法默认都会访问父类中无参的构造方法。\n\n子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super()。\n\n问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？\n\n 1. 通过使用super关键字去显示的调用父类的带参构造方法。\n\n 2. 在父类中自己提供一个无参构造方法。【推荐】\n\n# 4. 继承中成员方法的访问特点\n\n通过子类对象访问一个方法\n\n * 子类成员范围找\n\n * 父类成员范围找\n\n * 如果都没有就报错(不考虑父亲的父亲…)\n\n# 5. super内存图\n\n对象在堆内存中，会单独存在一块super区域，用来存放父类的数据。\n\n\n\n# 6. 方法重写\n\n * 方法重写概念\n\n子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样）。\n\n * 方法重写的应用场景\n\n当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。\n\n * override注解\n\n用来检测当前的方法，是否是重写的方法，起到【校验】的作用\n\n * 方法重写的注意事项\n   * 私有方法不能被重写(父类私有成员子类是不能继承的)\n   * 子类方法访问权限不能更低(public > 默认 > 私有)\n\npublic class fu {\n    private void show() {\n        system.out.println("fu中show()方法被调用");\n    }\n    void method() {\n        system.out.println("fu中method()方法被调用");\n    }\n}\npublic class zi extends fu {\n    /* 编译【出错】，子类不能重写父类私有的方法*/\n    @override\n    private void show() {\n        system.out.println("zi中show()方法被调用");\n    }\n    /* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @override\n    private void method() {\n        system.out.println("zi中method()方法被调用");\n    }\n    /* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */\n    @override\n    public void method() {\n        system.out.println("zi中method()方法被调用");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 1.3. 继承的注意事项\n\n * java中类只支持单继承，不支持多继承。\n\n错误范例：class a extends b, c { }\n\n * java中类支持多层继承\n\npublic class granddad {\n    public void drink() {\n        system.out.println("爷爷爱喝酒");\n    }\n}\npublic class father extends granddad {\n    public void smoke() {\n        system.out.println("爸爸爱抽烟");\n    }\n}\npublic class mother {\n    public void dance() {\n        system.out.println("妈妈爱跳舞");\n    }\n}\npublic class son extends father {\n// 此时，son类中就同时拥有drink方法以及smoke方法\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2. 多态\n\n\n# 2.1 多态的概述\n\n# 1. 什么是多态?\n\n同一个对象，在不同时刻表现出来的不同形态\n\n多态指的是同一个行为具有多个不同表现形式。是指一个类实例（对象）的相同方法在不同情形下具有 不同表现形式。封装和继承是多态的基础，也就是说，多态只是一种表现形式而已。\n\n# 2. 多态的前提\n\n * 要有继承或实现关系\n\n * 要有方法的重写(父类方法)\n\n * 要有父类引用指向子类对象\n\n\n# 2.2 多态中的成员访问特点\n\n# 1. 成员访问特点\n\n * 成员变量\n\n编译看父类，运行看父类\n\n * 成员方法\n\n编译看父类，运行看子类\n\n# 2. 示例\n\n动物类\n\npublic class animal {\n    public int age = 40;\n    public void eat() {\n        system.out.println("动物吃东西");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n猫\n\npublic class cat extends animal {\n    public int age = 20;\n    public int weight = 10;\n    @override\n    public void eat() {\n        system.out.println("猫吃鱼");\n    }\n    public void playgame() {\n        system.out.println("猫捉迷藏");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试类\n\npublic class animaldemo {\n    public static void main(string[] args) {\n        //有父类引用指向子类对象\n        animal a = new cat();\n        system.out.println(a.age);\n        // system.out.println(a.weight);\n        a.eat();\n        // a.playgame();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.3 多态的好处和弊端\n\n# 好处\n\n提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作\n\n# 弊端\n\n不能使用子类的特有成员。\n\n\n# 2.4 多态中的转型\n\n# 1. 向上转型\n\n父类引用指向子类对象就是向上转型\n\n# 2. 向下转型\n\n格式：子类型 对象名 = (子类型)父类引用;\n\n# 3. 示例\n\n动物类\n\npublic class animal {\n    public int age = 40;\n    public void eat() {\n        system.out.println("动物吃东西");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n猫\n\npublic class cat extends animal {\n    public int age = 20;\n    public int weight = 10;\n    @override\n    public void eat() {\n        system.out.println("猫吃鱼");\n    }\n    public void playgame() {\n        system.out.println("猫捉迷藏");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试类\n\npublic class animaldemo {\n    public static void main(string[] args) {\n        //多态\n        //向上转型\n        animal a = new cat();\n        a.eat();\n        // a.playgame();\n        //向下转型\n        cat c = (cat)a;\n        c.eat();\n        c.playgame();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.5 多态的案例\n\n请采用多态的思想实现猫和狗的案例，并在测试类中进行测试。\n\n动物类\n\npublic class animal {\n    private string name;\n    private int age;\n    public animal() {\n    }\n    public animal(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n    public int getage() {\n        return age;\n    }\n    public void setage(int age) {\n        this.age = age;\n    }\n    public void eat() {\n        system.out.println("动物吃东西");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n猫\n\npublic class cat extends animal {\n    public cat() {\n    }\n    public cat(string name, int age) {\n        super(name, age);\n    }\n    @override\n    public void eat() {\n        system.out.println("猫吃鱼");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n狗\n\npublic class dog extends animal {\n    public dog() {\n    }\n\n    public dog(string name, int age) {\n        super(name, age);\n    }\n\n    @override\n    public void eat() {\n        system.out.println("狗吃骨头");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n测试类\n\npublic class animaldemo {\n    public static void main(string[] args) {\n        //创建猫类对象进行测试\n        animal a = new cat();\n        a.setname("加菲");\n        a.setage(5);\n        system.out.println(a.getname() + "," + a.getage());\n        a.eat();\n        a = new cat("加菲", 5);\n        system.out.println(a.getname() + "," + a.getage());\n        a.eat();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3. 组合\n\n组合其实不难理解，就是将对象引用置于新类中即可。组合也是一种提高类的复用性的一种方式。如果 你想让类具有更多的扩展功能，你需要记住一句话多用组合，少用继承。\n\npublic class soccerplayer {\n\n    private string name;\n    private soccer soccer;\n\n}\npublic class soccer {\n\n    private string soccername;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n代码中soccerplayer引用了 soccer类，通过引用soccer类，来达到调用soccer中的属性和方法。\n\n组合和继承是有区别的，它们的主要区别如下。\n\n特征        组合                        继承\n关系        组合是一种has-a的关系，可以理解为有一 个   继承是一种is-a的关系，可以理解为是一 个\n耦合性       组合的双方是一种松耦合的关系            继承双方紧耦合\n是否具有多 态   组合不具备多态和向上转型              继承是多态的基础，可以实现向上转型\n时期        组合是运行期绑定                  继承是编译期绑定\n\n关于继承和组合孰优孰劣的争论没有结果，只要发挥各自的长处和优点即可，一般情况下，组合和继承 也是一对可以连用的好兄弟。\n\n\n# 4. 代理\n\n除了继承和组合外，另外一种值得探讨的关系模型称为代理。代理的大致描述是，a想要调用b类 的方法，a不直接调用，a会在自己的类中创建一个b对象的代理，再由代理调用b的方法。例如如下代码\n\npublic class destination {\n    public void todo(){\n        system.out.println("control...");\n    }\n}\npublic class device {\n    private string name;\n    private destination destination;\n    private devicecontroller devicecontroller;\n    public void control(destination destination){\n        destination.todo();\n    }\n}\npublic class devicecontroller {\n    private device name;\n    private destination destination;\n    public void control(destination destination){\n        destination.todo();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 5. 向上转型\n\n向上转型代表了父类与子类之间的关系，其实父类和子类之间不仅仅有向上转型，还有向下转型，它们 的转型后的范围不一样\n\n * 向上转型：通过子类对象（小范围）转化为父类对象（大范围），这种转换是自动完成的，不用强制。\n\n * 向下转型：通过父类对象（大范围）实例化子类对象（小范围），这种转换不是自动完成的，需要强制指定。\n\n\n# 6. 修饰符\n\n\n# 6.1 package\n\n# 1. 包的概念\n\n包就是文件夹，用来管理类文件的\n\n# 2. 包的定义格式\n\npackage 包名; (多级包用.分开)\n\n例如：package com.heima.demo;\n\n# 3. 带包编译&带包运行\n\n带包编译：javac –d . 类名.java\n\n * 例如：javac -d . com.heima.demo.helloworld.java\n\n带包运行：java 包名+类名\n\n * 例如：java com.heima.demo.helloworld\n\n\n# 6.2 import\n\n * 导包的意义\n\n使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了。为了简化带包的操作，java就提供了导包的功能。\n\n * 导包的格式\n\n格式：import 包名;\n\n范例：import java.util.scanner;\n\n * 示例\n\n没有使用导包，创建的scanner对象\n\npackage com.heima;\n\npublic class demo {\n\tpublic static void main(string[] args) {\n        // 1. 没有导包，创建scnaner对象\n        java.util.scanner sc = new java.util.scanner(system.in);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用导包后，创建的scanner对象\n\npackage com.heima;\nimport java.util.scanner;\n\npublic class demo {\n    public static void main(string[] args) {\n        // 1. 没有导包，创建scnaner对象\n        scanner sc = new scanner(system.in);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 6.3 final\n\nfinal的意思是最后的、最终的，它可以修饰类、属性和方法。\n\n * final修饰类时，表明这个类不能被继承。final类中的成员变量可以根据需要设为final，但是要注 意final类中的所有成员方法都会被隐式地指定为final方法。\n\n * final修饰方法时，表明这个方法不能被任何子类重写，因此，如果只有在想明确禁止该方法在子 类中被覆盖的情况下才将方法设置为final。\n\n * final修饰变量分为两种情况，一种是修饰基本数据类型，表示数据类型的值不能被修改；一种是 修饰引用类型，表示对其初始化之后便不能再让其指向另一个对象。\n\n\n# 6.4 static\n\n# 1. 修饰属性和方法\n\nstatic是java中的关键字，它的意思是静态的，static可以用来修饰成员变量和方法，static用在没有创建对象的情况下调用方法/变量。\n\n * 用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应 用程序执行期间都有效。\n\nstatic string name = "cxuan"; \n\n\n1\n\n * 使用static修饰的方法称为静态方法，静态方法能够直接使用类名.方法名进行调用。由于静态方 法不依赖于任何对象就可以直接访问，因此对于静态方法来说，是没有this关键字的，实例变量 都会有this关键字。在静态方法中不能访问类的非静态成员变量和非静态方法，\n\nstatic void printmessage(){\n system.out.println("cxuan is writing the article");\n}\n\n\n1\n2\n3\n\n\n# 2. 静态代码块\n\nstatic除了修饰属性和方法外，还有静态代码块的功能，可用于类的初始化操作。进而提升程序的性 能。\n\npublic class staicblock {\n static{\n system.out.println("i\'m a static code block");\n }\n}\n\n\n1\n2\n3\n4\n5\n\n\n由于静态代码块随着类的加载而执行，因此，很多时候会将只需要进行一次的初始化操作放在static代 码块中进行。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"面向对象",frontmatter:{title:"面向对象",date:"2023-02-25T12:49:46.000Z",permalink:"/pages/2876f0/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/02.面向对象.md",key:"v-4a930d01",path:"/pages/2876f0/",headers:[{level:2,title:"1. 类和对象",slug:"_1-类和对象",normalizedTitle:"1. 类和对象",charIndex:11},{level:3,title:"1.1 类和对象的理解",slug:"_1-1-类和对象的理解",normalizedTitle:"1.1 类和对象的理解",charIndex:23},{level:3,title:"1.2 类的定义",slug:"_1-2-类的定义",normalizedTitle:"1.2 类的定义",charIndex:365},{level:3,title:"1.3 对象的使用",slug:"_1-3-对象的使用",normalizedTitle:"1.3 对象的使用",charIndex:1072},{level:3,title:"1.4 学生对象-练习",slug:"_1-4-学生对象-练习",normalizedTitle:"1.4 学生对象-练习",charIndex:1888},{level:2,title:"2. 对象内存图",slug:"_2-对象内存图",normalizedTitle:"2. 对象内存图",charIndex:2743},{level:3,title:"2.1 单个对象内存图",slug:"_2-1-单个对象内存图",normalizedTitle:"2.1 单个对象内存图",charIndex:2756},{level:3,title:"2.2 多个对象内存图",slug:"_2-2-多个对象内存图",normalizedTitle:"2.2 多个对象内存图",charIndex:2802},{level:3,title:"2.3 多个对象指向相同内存图",slug:"_2-3-多个对象指向相同内存图",normalizedTitle:"2.3 多个对象指向相同内存图",charIndex:2913},{level:2,title:"3. 成员变量和局部变量",slug:"_3-成员变量和局部变量",normalizedTitle:"3. 成员变量和局部变量",charIndex:3037},{level:3,title:"3.1 成员变量和局部变量的区别",slug:"_3-1-成员变量和局部变量的区别",normalizedTitle:"3.1 成员变量和局部变量的区别",charIndex:3054},{level:2,title:"4. 封装",slug:"_4-封装",normalizedTitle:"4. 封装",charIndex:3262},{level:3,title:"4.1 private关键字",slug:"_4-1-private关键字",normalizedTitle:"4.1 private关键字",charIndex:3272},{level:3,title:"4.2 private的使用",slug:"_4-2-private的使用",normalizedTitle:"4.2 private的使用",charIndex:4506},{level:3,title:"4.3 this关键字",slug:"_4-3-this关键字",normalizedTitle:"4.3 this关键字",charIndex:5879},{level:3,title:"4.4 this内存原理",slug:"_4-4-this内存原理",normalizedTitle:"4.4 this内存原理",charIndex:6490},{level:3,title:"4.5 封装思想",slug:"_4-5-封装思想",normalizedTitle:"4.5 封装思想",charIndex:6870},{level:2,title:"5. 对象的创建",slug:"_5-对象的创建",normalizedTitle:"5. 对象的创建",charIndex:7117},{level:2,title:"6. 属性和方法",slug:"_6-属性和方法",normalizedTitle:"6. 属性和方法",charIndex:7616},{level:3,title:"6.1 构造方法",slug:"_6-1-构造方法",normalizedTitle:"6.1 构造方法",charIndex:8037},{level:4,title:"默认的构造方法",slug:"默认的构造方法",normalizedTitle:"默认的构造方法",charIndex:8752},{level:3,title:"6.2 方法重载",slug:"_6-2-方法重载",normalizedTitle:"6.2 方法重载",charIndex:9286},{level:4,title:"重载的条件🚗",slug:"重载的条件",normalizedTitle:"重载的条件🚗",charIndex:9766},{level:3,title:"6.3 方法的重写",slug:"_6-3-方法的重写",normalizedTitle:"6.3 方法的重写",charIndex:9917},{level:4,title:"重写的原则🚗",slug:"重写的原则",normalizedTitle:"重写的原则🚗",charIndex:10257},{level:2,title:"7. 初始化",slug:"_7-初始化",normalizedTitle:"7. 初始化",charIndex:10371},{level:3,title:"7.1 类的初始化",slug:"_7-1-类的初始化",normalizedTitle:"7.1 类的初始化",charIndex:10382},{level:3,title:"7.2 成员初始化",slug:"_7-2-成员初始化",normalizedTitle:"7.2 成员初始化",charIndex:10558},{level:3,title:"7.3 构造器初始化",slug:"_7-3-构造器初始化",normalizedTitle:"7.3 构造器初始化",charIndex:10915},{level:3,title:"7.4 初始化顺序",slug:"_7-4-初始化顺序",normalizedTitle:"7.4 初始化顺序",charIndex:11072},{level:3,title:"7.5 数组初始化",slug:"_7-5-数组初始化",normalizedTitle:"7.5 数组初始化",charIndex:12092},{level:2,title:"8. 对象的销毁",slug:"_8-对象的销毁",normalizedTitle:"8. 对象的销毁",charIndex:12641},{level:3,title:"对象作用域",slug:"对象作用域",normalizedTitle:"对象作用域",charIndex:12851},{level:2,title:"9. this和super",slug:"_9-this和super",normalizedTitle:"9. this和super",charIndex:13170}],headersStr:"1. 类和对象 1.1 类和对象的理解 1.2 类的定义 1.3 对象的使用 1.4 学生对象-练习 2. 对象内存图 2.1 单个对象内存图 2.2 多个对象内存图 2.3 多个对象指向相同内存图 3. 成员变量和局部变量 3.1 成员变量和局部变量的区别 4. 封装 4.1 private关键字 4.2 private的使用 4.3 this关键字 4.4 this内存原理 4.5 封装思想 5. 对象的创建 6. 属性和方法 6.1 构造方法 默认的构造方法 6.2 方法重载 重载的条件🚗 6.3 方法的重写 重写的原则🚗 7. 初始化 7.1 类的初始化 7.2 成员初始化 7.3 构造器初始化 7.4 初始化顺序 7.5 数组初始化 8. 对象的销毁 对象作用域 9. this和super",content:'# 面向对象\n\n\n# 1. 类和对象\n\n\n# 1.1 类和对象的理解\n\n客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。\n\n * 类\n   * 类的理解\n     * 类是对现实生活中一类具有共同属性和行为的事物的抽象\n     * 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合\n     * 简单理解：类就是对现实事物的一种描述\n   * 类的组成\n     * 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）\n     * 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）\n * 类和对象的关系\n   * 类：类是对现实生活中一类具有共同属性和行为的事物的抽象\n   * 对象：是能够看得到摸的着的真实存在的实体\n   * 简单理解：类是对事物的一种描述，对象则为具体存在的事物\n\n\n# 1.2 类的定义\n\n类的组成是由属性和行为两部分组成\n\n * 属性：在类中通过成员变量来体现（类中方法外的变量）\n * 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）\n\n类的定义步骤：\n\n①定义类\n\n②编写类的成员变量\n\n③编写类的成员方法\n\npublic class 类名 {\n\t// 成员变量\n\t变量1的数据类型 变量1；\n\t变量2的数据类型 变量2;\n\t…\n\t// 成员方法\n\t方法1;\n\t方法2;\t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n示例代码：\n\n/*\n    手机类：\n        类名：\n        手机(Phone)\n\n        成员变量：\n        品牌(brand)\n        价格(price)\n\n        成员方法：\n        打电话(call)\n        发短信(sendMessage)\n */\npublic class Phone {\n    //成员变量\n    String brand;\n    int price;\n\n    //成员方法\n    public void call() {\n        System.out.println("打电话");\n    }\n\n    public void sendMessage() {\n        System.out.println("发短信");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 1.3 对象的使用\n\n * 创建对象的格式：\n   * 类名 对象名 = new 类名();\n * 调用成员的格式：\n   * 对象名.成员变量\n   * 对象名.成员方法();\n * 示例代码\n\n/*\n    创建对象\n        格式：类名 对象名 = new 类名();\n        范例：Phone p = new Phone();\n\n    使用对象\n        1：使用成员变量\n            格式：对象名.变量名\n            范例：p.brand\n        2：使用成员方法\n            格式：对象名.方法名()\n            范例：p.call()\n */\npublic class PhoneDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Phone p = new Phone();\n\n        //使用成员变量\n        System.out.println(p.brand);\n        System.out.println(p.price);\n\n        p.brand = "小米";\n        p.price = 2999;\n\n        System.out.println(p.brand);\n        System.out.println(p.price);\n\n        //使用成员方法\n        p.call();\n        p.sendMessage();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 1.4 学生对象-练习\n\n * 需求：首先定义一个学生类，然后定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法的使用\n * 分析：\n   * 成员变量：姓名，年龄…\n   * 成员方法：学习，做作业…\n * 示例代码：\n\n![1](C:\\TeachRes\\Java2019\\JavaSe01\\day07\\4-笔记\\笔记图片资源包\\1.png)class Student {\n    //成员变量\n    String name;\n    int age;\n\n    //成员方法\n    public void study() {\n        System.out.println("好好学习，天天向上");\n    }\n\n    public void doHomework() {\n        System.out.println("键盘敲烂，月薪过万");\n    }\n}\n/*\n    学生测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s = new Student();\n\n        //使用对象\n        System.out.println(s.name + "," + s.age);\n\n        s.name = "林青霞";\n        s.age = 30;\n\n        System.out.println(s.name + "," + s.age);\n\n        s.study();\n        s.doHomework();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2. 对象内存图\n\n\n# 2.1 单个对象内存图\n\n * 成员变量使用过程\n\n\n\n * 成员方法调用过程\n\n\n\n\n# 2.2 多个对象内存图\n\n * 成员变量使用过程\n\n\n\n * 成员方法调用过程\n\n\n\n * 总结：\n   \n   多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份\n\n\n# 2.3 多个对象指向相同内存图\n\n\n\n * 总结\n   \n   当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）\n   \n   只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。\n\n\n# 3. 成员变量和局部变量\n\n\n# 3.1 成员变量和局部变量的区别\n\n * 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）\n * 内存中位置不同：成员变量（堆内存）局部变量（栈内存）\n * 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）\n * 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）\n\n\n# 4. 封装\n\n\n# 4.1 private关键字\n\nprivate是一个修饰符，可以用来修饰成员（成员变量，成员方法）\n\n * 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作\n   \n   * 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰\n   * 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰\n\n * 示例代码：\n   \n   /*\n       学生类\n    */\n   class Student {\n       //成员变量\n       String name;\n       private int age;\n   \n       //提供get/set方法\n       public void setAge(int a) {\n           if(a<0 || a>120) {\n               System.out.println("你给的年龄有误");\n           } else {\n               age = a;\n           }\n       }\n   \n       public int getAge() {\n           return age;\n       }\n   \n       //成员方法\n       public void show() {\n           System.out.println(name + "," + age);\n       }\n   }\n   /*\n       学生测试类\n    */\n   public class StudentDemo {\n       public static void main(String[] args) {\n           //创建对象\n           Student s = new Student();\n           //给成员变量赋值\n           s.name = "林青霞";\n           s.setAge(30);\n           //调用show方法\n           s.show();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   \n\n\n# 4.2 private的使用\n\n * 需求：定义标准的学生类，要求name和age使用private修饰，并提供set和get方法以及便于显示数据的show方法，测试类中创建对象并使用，最终控制台输出  林青霞，30\n\n * 示例代码：\n   \n   /*\n       学生类\n    */\n   class Student {\n       //成员变量\n       private String name;\n       private int age;\n   \n       //get/set方法\n       public void setName(String n) {\n           name = n;\n       }\n   \n       public String getName() {\n           return name;\n       }\n   \n       public void setAge(int a) {\n           age = a;\n       }\n   \n       public int getAge() {\n           return age;\n       }\n   \n       public void show() {\n           System.out.println(name + "," + age);\n       }\n   }\n   /*\n       学生测试类\n    */\n   public class StudentDemo {\n       public static void main(String[] args) {\n           //创建对象\n           Student s = new Student();\n   \n           //使用set方法给成员变量赋值\n           s.setName("林青霞");\n           s.setAge(30);\n   \n           s.show();\n   \n           //使用get方法获取成员变量的值\n           System.out.println(s.getName() + "---" + s.getAge());\n           System.out.println(s.getName() + "," + s.getAge());\n   \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   \n\n\n# 4.3 this关键字\n\n * this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）\n   * 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量\n   * 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量\n\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void show() {\n        System.out.println(name + "," + age);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 4.4 this内存原理\n\n * this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象\n\n * 示例代码：\n   \n   public class StudentDemo {\n       public static void main(String[] args) {\n           Student s1 = new Student();\n           s1.setName("林青霞");\n           Student s2 = new Student();\n           s2.setName("张曼玉");\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 图解：\n   \n   \n   \n   \n\n\n# 4.5 封装思想\n\n 1. 封装概述 是面向对象三大特征之一（封装，继承，多态） 是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的\n 2. 封装原则 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法\n 3. 封装好处 通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性\n\n\n# 5. 对象的创建\n\n在Java中，万事万物都是对象。这句话相信你一定不陌生，尽管一切都看作是对象，但是你操纵的却 是一个对象的引用(reference)。在这里有一个很形象的比喻：你可以把车钥匙和车看作是一组对象 引用和对象的组合。当你想要开车的时候，你首先需要拿出车钥匙点击开锁的选项，停车时，你需要点 击加锁来锁车。车钥匙相当于就是引用，车就是对象，由车钥匙来驱动车的加锁和开锁。并且，即使没 有车的存在，车钥匙也是一个独立存在的实体，也就是说，你有一个对象引用，但你不一定需要一个对 象与之关联，也就是\n\nCar carKey\n\n\n1\n\n\n这里创建的只是引用，而并非对象，但是如果你想要使用S这个引用时，会返回一个异常，告诉你需要 一个对象来和这个引用进行关联。一种安全的做法是，在创建对象引用时同时把一个对象赋给它。\n\nCar carKey = new Car();\n\n\n1\n\n\n在Java中，一旦创建了一个引用，就希望它能与一个新的对象进行关联，通常使用new操作符来实 现这一目的。new的意思是，给我一个新对象，如果你不想相亲，自己new 一个对象就好了。祝你 下辈子幸福。\n\n\n# 6. 属性和方法\n\n类一个最基本的要素就是有属性和方法。\n\n * 属性\n\n属性也被称为字段，它是类的重要组成部分，属性可以是任意类型的对象，也可以是基本数据类型。例 如下\n\nclass A{\n int a;\n Apple apple;\n}\n\n\n1\n2\n3\n4\n\n * 方法\n\n类中还应该包括方法，方法表示的是做某些事情的方式。方法其实就是函数，只不过Java习惯把函数 称为方法。这种叫法也体现了面向对象的概念。\n\n**方法的基本组成包括方法名称、参数、返回值和方法体，**下面是它的示例\n\npublic int getResult(){\n // ...\n return 1;\n}\n\n\n1\n2\n3\n4\n\n\n其中，getResult就是方法名称、()里面表示方法接收的参数、return表示方法的返回值，\n\n注意：方法的返回值必须和方法的参数类型保持一致。有一种特殊的参数类型void表示方法无返 回值。{}包含的代码段被称为方法体。\n\n\n# 6.1 构造方法\n\n在Java中，有一种特殊的方法被称为构造方法，也被称为构造函数、构造器等。在Java中，通过 提供这个构造器，来确保每个对象都被初始化。构造方法只能在对象的创建时期调用一次，保证了对象 初始化的进行。构造方法比较特殊，它没有参数类型和返回值，它的名称要和类名保持一致，并且构造 方法可以有多个，下面是一个构造方法的示例\n\nclass Apple {\n \n int sum;\n String color;\n \n public Apple(){}\n public Apple(int sum){}\n public Apple(String color){}\n public Apple(int sum,String color){}\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 有参构造、无参构造函数\n\n上面定义了一个Apple类，你会发现这个Apple类没有参数类型和返回值，并且有多个以Apple同名 的方法，而且各个Apple的参数列表都不一样，这其实是一种多态的体现，我们后面会说。在定义完成 构造方法后，我们就能够创建Apple对象了。\n\nclass createApple {\n public static void main(String[] args) {\n Apple apple1 = new Apple();\n Apple apple2 = new Apple(1);\n Apple apple3 = new Apple("red");\n Apple apple4 = new Apple(2,"color");\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 默认的构造方法\n\n如上面所示，我们定义了四个Apple对象，并调用了 Apple的四种不同的构造方法，其中，不加任何参数的构造方法被称为默认的构造方法，也就是\n\nApple apple1 = new Apple();\n\n\n1\n\n * 如果类中没有定义任何构造方法，那么JVM会为你自动生成一个构造方法，如下\n\nclass Apple {\n    int sum;\n     String color;\n}\nclass createApple {\n\tpublic static void main(String[] args) {\n    \tApple apple1 = new Apple();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 上面代码不会发生编译错误，因为Apple对象包含了一个默认的构造方法。\n\n默认的构造方法也被称为默认构造器或者无参构造器。\n\n这里需要注意一点的是，即使JVM会为你默认添加一个无参的构造器，但是如果你手动定义了任何一 个构造方法，JVM就不再为你提供默认的构造器，你必须手动指定，否则会出现编译错误。\n\n显示的错误是，必须提供Apple带有int参数的构造函数，而默认的无参构造函数没有被允许使用。\n\n\n# 6.2 方法重载\n\n在Java中一个很重要的概念是方法的重载，它是类名的不同表现形式。我们上面说到了构造函数，其实构造函数也是重载的一种。另外一种就是方法的重载\n\npublic class Apple {\n int sum;\n String color;\n public Apple(){}\n public Apple(int sum){}\n public int getApple(int num){\n return 1;\n }\n \n public String getApple(String color){\n return "color";\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如上面所示，就有两种重载的方式，一种是Apple构造函数的重载，一种是getApple方法的重载。\n\n但是这样就涉及到一个问题，要是有几个相同的名字，Java如何知道你调用的是哪个方法呢？\n\n这里记住一点即可，每个重载的方法都有独一无二的参数列表。其中包括参数的类型、顺序、参数数量等，满足一种一个因素就构成了重载的必要条件。\n\n# 重载的条件🚗\n\n * 方法名称必须相同。\n\n * 参数列表必须不同(个数不同、或类型不同、参数类型排列顺序不同等)。\n\n * 方法的返回类型可以相同也可以不相同。\n\n * 仅仅返回类型不同不足以成为方法的重载。\n\n * 重载是发生在编译时的，因为编译器可以根据参数的类型来选择使用哪个方法。\n\n\n# 6.3 方法的重写\n\n方法的重写与重载虽然名字很相似，但却完全是不同的东西。方法重写的描述是对子类和父类之间 的。而重载指的是同一类中的。例如如下代码\n\nclass Fruit {\n public void eat(){\n System.out.printl(\'eat fruit\');\n }\n}\n// 重写\nclass Apple extends Fruit{\n \n @Override\n public void eat(){\n System.out.printl(\'eat apple\');\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面这段代码描述的就是重写的代码，你可以看到，子类Apple中的方法和父类Fruit中的方法同名。\n\n# 重写的原则🚗\n\n * 重写的方法必须要和父类保持一致，包括返回值类型，方法名,参数列表也都一样。\n\n * 重写的方法可以使用@Override注解来标识\n\n * 子类中重写方法的访问权限不能低于父类中方法的访问权限。\n\n\n# 7. 初始化\n\n\n# 7.1 类的初始化\n\n上面我们创建出来了一个Car这个对象，其实在使用new关键字创建一个对象的时候，其实是调用了 这个对象无参数的构造方法进行的初始化，也就是如下这段代码\n\nclass Car{\n  public Car(){}\n}\n\n\n1\n2\n3\n\n\n这个无参数的构造函数可以隐藏，由JVM自动添加。也就是说，构造函数能够确保类的初始化。\n\n\n# 7.2 成员初始化\n\nJava会尽量保证每个变量在使用前都会获得初始化，初始化涉及两种初始化。\n\n * 一种是编译器默认指定的字段初始化，基本数据类型的初始化\n\n类型        初始值\nboolean   false\nchar      /u0000\nbyte      (byte)0\nshort     (short)0\nint       0\nlong      0L\nfloat     0.0f\ndouble    0.0d\n\n一种是其他对象类型的初始化，String也是一种对象，对象的初始值都为null，其中也包括基本类型的包装类。\n\n * 一种是指定数值的初始化，例如\n\nint a = 11\n\n\n1\n\n\n也就是说，指定a的初始化值不是0，而是11。其他基本类型和对象类型也是一样的。\n\n\n# 7.3 构造器初始化\n\n可以利用构造器来对某些方法和某些动作进行初始化，确定初始值，例如\n\npublic class Counter{\n\n int i;\n public Counter(){\n\t i = 11;\n }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n利用构造函数，能够把i的值初始化为11。\n\n\n# 7.4 初始化顺序\n\n首先先来看一下有哪些需要探讨的初始化顺序\n\n * 静态属性：static开头定义的属性\n\n * 静态方法块：static {}包起来的代码块\n\n * 普通属性：非static定义的属性\n\n * 普通方法块：{}包起来的代码块\n\n * 构造函数：类名相同的方法\n\n * 方法：普通方法\n\npublic class LifeCycle {\n \t // 静态属性\n     private static String staticField = getStaticField();\n     // 静态方法块\n     static {\n     System.out.println(staticField);\n     System.out.println("静态方法块");\n     }\n     // 普通属性\n     private String field = getField();\n   \t // 普通方法块\n     {\n     System.out.println(field);\n     }\n     // 构造函数\n     public LifeCycle() {\n     System.out.println("构造函数");\n     }\n     public static String getStaticField() {\n     String statiFiled = "Static Field Initial";\n     return statiFiled;\n     }\n     public static String getField() {\n     String filed = "Field Initial";\n     return filed;\n     } \n     // 主函数\n     public static void main(String[] argc) {\n     new LifeCycle();\n     }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n这段代码的执行结果就反应了它的初始化顺序。\n\n静态属性初始化静态方法块初始化普通属性初始化普通方法块初始化构造函数初始化。\n\n\n# 7.5 数组初始化\n\n数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方 括号下标操作符[]来定义使用。\n\n一般数组是这么定义的\n\nint[] a1;\n//或者\nint a1[];\n\n\n1\n2\n3\n\n\n两种格式的含义是一样的。\n\n * 直接给每个元素赋值:int array[4] = {1,2,3,4};\n\n * 给一部分赋值，后面的都为0 : int array[4] = {1,2};\n\n * 由赋值参数个数决定数组的个数：int array[] = {1,2};\n\n可变参数列表\n\nJava中一种数组冷门的用法就是可变参数，可变参数的定义如下\n\npublic int add(int... numbers){\n int sum = 0;\n for(int num : numbers){\n sum += num;\n }\n return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后，你可以使用下面这几种方式进行可变参数的调用\n\nadd(); // 不传参数\nadd(1); // 传递一个参数\nadd(2,1); // 传递多个参数\nadd(new Integer[] {1, 3, 2}); // 传递数组\n\n\n1\n2\n3\n4\n\n\n\n# 8. 对象的销毁\n\n虽然Java语言是基于C++的，但是它和C/C++ 一个重要的特征就是不需要手动管理对象的销毁工 作。在著名的一书《深入理解Java虚拟机》中提到一个观点：Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人 想进去，墙里面的人却想出来。\n\n在Java中，我们不再需要手动管理对象的销毁，它是由Java虚拟机进行管理和销毁的。虽然我们 不需要手动管理对象，但是你需要知道对象作用域这个概念。\n\n\n# 对象作用域\n\nJ多数语言都有作用域(scope)这个概念。作用域决定了其内部定义的变量名的可见性和生命周期。在 C、C++和Java中，作用域通常由{}的位置来决定，例如\n\n{\n int a = 11;\n {\n int b = 12;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\na变量会在两个{}作用域内有效，而b变量的值只能在它自己的{}内有效。\n\n虽然存在作用域，但是不允许这样写\n\n{\n int x = 11;\n {\n int x = 12;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种写法在C/C++中是可以的，但是在Java中不允许这样写，因为Java设计者认为这样写会导致程序混乱。\n\n\n# 9. this和super\n\nthis和super都是Java中的关键字\n\nthis表示的当前对象，this可以调用方法、调用属性和指向对象本身。this在Java中的使用一般有三 种：指向当前对象\n\npublic class Apple {\n int i = 0;\n Apple eatApple(){\n i++;\n return this;\n }\n public static void main(String[] args) {\n Apple apple = new Apple();\n apple.eatApple().eatApple();\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段代码比较精妙，精妙在哪呢，我一个eatApple。方法竟然可以调用多次，你在后面还可以继续调 用，这就很神奇了，为啥呢？其实就是this在作祟了，我在eatApple方法中加了一个return this的返回值，也就是说哪个对象调用eatApple方法都能返回对象的自身。\n\nthis还可以修饰属性，最常见的就是在构造方法中使用this，如下所示\n\npublic class Apple {\n private int num;\n \n public Apple(int num){\n this.num = num;\n }\n public static void main(String[] args) {\n new Apple(10);\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nmain方法中传递了一个int值为10的参数，它表示的就是苹果的数量，并把这个数量赋给了 num全 局变量。所以num的值现在就是10。\n\nthis还可以和构造函数一起使用，充当一个全局关键字的效果\n\npublic class Apple {\n private int num;\n private String color;\n public Apple(int num){\n this(num,"红色");\n }\n \n public Apple(String color){\n this(1,color);\n }\n public Apple(int num, String color) {\n this.num = num;\n this.color = color;\n }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n你会发现上面这段代码使用的不是this,而是this(参数)。它相当于调用了其他构造方法，然后传递 参数进去。这里注意一点：this。必须放在构造方法的第一行，否则编译不通过。\n\n\n\n如果你把this理解为指向自身的一个引用，那么super就是指向父类的一个引用。super关键字和this —样， 你可以使用super对象来引用父类成员，如下：\n\npublic class Fruit {\n int num;\n String color;\n public void eat(){\n System.out.println("eat Fruit");\n }\n}\npublic class Apple extends Fruit{\n @Override\n public void eat() {\n super.num = 10;\n System.out.println("eat " + num + " Apple");\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n你也可以使用super(参数)来调用父类的构造函数。\n\n下面为你汇总了 this关键字和super关键字的比较。\n\n关键字    THIS               SUPER\n调用方式   调用本类中的属性、构造函数、方法   调用父类中属性、构造函数、方法\n调用位置   构造函数第一行，其他可自行指定    构造函数第一行，其他可自行指定\n调用次数   —个构造函数只能调用一次       一个构造函数只能调用一次',normalizedContent:'# 面向对象\n\n\n# 1. 类和对象\n\n\n# 1.1 类和对象的理解\n\n客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。\n\n * 类\n   * 类的理解\n     * 类是对现实生活中一类具有共同属性和行为的事物的抽象\n     * 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合\n     * 简单理解：类就是对现实事物的一种描述\n   * 类的组成\n     * 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）\n     * 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）\n * 类和对象的关系\n   * 类：类是对现实生活中一类具有共同属性和行为的事物的抽象\n   * 对象：是能够看得到摸的着的真实存在的实体\n   * 简单理解：类是对事物的一种描述，对象则为具体存在的事物\n\n\n# 1.2 类的定义\n\n类的组成是由属性和行为两部分组成\n\n * 属性：在类中通过成员变量来体现（类中方法外的变量）\n * 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）\n\n类的定义步骤：\n\n①定义类\n\n②编写类的成员变量\n\n③编写类的成员方法\n\npublic class 类名 {\n\t// 成员变量\n\t变量1的数据类型 变量1；\n\t变量2的数据类型 变量2;\n\t…\n\t// 成员方法\n\t方法1;\n\t方法2;\t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n示例代码：\n\n/*\n    手机类：\n        类名：\n        手机(phone)\n\n        成员变量：\n        品牌(brand)\n        价格(price)\n\n        成员方法：\n        打电话(call)\n        发短信(sendmessage)\n */\npublic class phone {\n    //成员变量\n    string brand;\n    int price;\n\n    //成员方法\n    public void call() {\n        system.out.println("打电话");\n    }\n\n    public void sendmessage() {\n        system.out.println("发短信");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 1.3 对象的使用\n\n * 创建对象的格式：\n   * 类名 对象名 = new 类名();\n * 调用成员的格式：\n   * 对象名.成员变量\n   * 对象名.成员方法();\n * 示例代码\n\n/*\n    创建对象\n        格式：类名 对象名 = new 类名();\n        范例：phone p = new phone();\n\n    使用对象\n        1：使用成员变量\n            格式：对象名.变量名\n            范例：p.brand\n        2：使用成员方法\n            格式：对象名.方法名()\n            范例：p.call()\n */\npublic class phonedemo {\n    public static void main(string[] args) {\n        //创建对象\n        phone p = new phone();\n\n        //使用成员变量\n        system.out.println(p.brand);\n        system.out.println(p.price);\n\n        p.brand = "小米";\n        p.price = 2999;\n\n        system.out.println(p.brand);\n        system.out.println(p.price);\n\n        //使用成员方法\n        p.call();\n        p.sendmessage();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 1.4 学生对象-练习\n\n * 需求：首先定义一个学生类，然后定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法的使用\n * 分析：\n   * 成员变量：姓名，年龄…\n   * 成员方法：学习，做作业…\n * 示例代码：\n\n![1](c:\\teachres\\java2019\\javase01\\day07\\4-笔记\\笔记图片资源包\\1.png)class student {\n    //成员变量\n    string name;\n    int age;\n\n    //成员方法\n    public void study() {\n        system.out.println("好好学习，天天向上");\n    }\n\n    public void dohomework() {\n        system.out.println("键盘敲烂，月薪过万");\n    }\n}\n/*\n    学生测试类\n */\npublic class studentdemo {\n    public static void main(string[] args) {\n        //创建对象\n        student s = new student();\n\n        //使用对象\n        system.out.println(s.name + "," + s.age);\n\n        s.name = "林青霞";\n        s.age = 30;\n\n        system.out.println(s.name + "," + s.age);\n\n        s.study();\n        s.dohomework();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2. 对象内存图\n\n\n# 2.1 单个对象内存图\n\n * 成员变量使用过程\n\n\n\n * 成员方法调用过程\n\n\n\n\n# 2.2 多个对象内存图\n\n * 成员变量使用过程\n\n\n\n * 成员方法调用过程\n\n\n\n * 总结：\n   \n   多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份\n\n\n# 2.3 多个对象指向相同内存图\n\n\n\n * 总结\n   \n   当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）\n   \n   只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。\n\n\n# 3. 成员变量和局部变量\n\n\n# 3.1 成员变量和局部变量的区别\n\n * 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）\n * 内存中位置不同：成员变量（堆内存）局部变量（栈内存）\n * 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）\n * 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）\n\n\n# 4. 封装\n\n\n# 4.1 private关键字\n\nprivate是一个修饰符，可以用来修饰成员（成员变量，成员方法）\n\n * 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作\n   \n   * 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰\n   * 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰\n\n * 示例代码：\n   \n   /*\n       学生类\n    */\n   class student {\n       //成员变量\n       string name;\n       private int age;\n   \n       //提供get/set方法\n       public void setage(int a) {\n           if(a<0 || a>120) {\n               system.out.println("你给的年龄有误");\n           } else {\n               age = a;\n           }\n       }\n   \n       public int getage() {\n           return age;\n       }\n   \n       //成员方法\n       public void show() {\n           system.out.println(name + "," + age);\n       }\n   }\n   /*\n       学生测试类\n    */\n   public class studentdemo {\n       public static void main(string[] args) {\n           //创建对象\n           student s = new student();\n           //给成员变量赋值\n           s.name = "林青霞";\n           s.setage(30);\n           //调用show方法\n           s.show();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   \n\n\n# 4.2 private的使用\n\n * 需求：定义标准的学生类，要求name和age使用private修饰，并提供set和get方法以及便于显示数据的show方法，测试类中创建对象并使用，最终控制台输出  林青霞，30\n\n * 示例代码：\n   \n   /*\n       学生类\n    */\n   class student {\n       //成员变量\n       private string name;\n       private int age;\n   \n       //get/set方法\n       public void setname(string n) {\n           name = n;\n       }\n   \n       public string getname() {\n           return name;\n       }\n   \n       public void setage(int a) {\n           age = a;\n       }\n   \n       public int getage() {\n           return age;\n       }\n   \n       public void show() {\n           system.out.println(name + "," + age);\n       }\n   }\n   /*\n       学生测试类\n    */\n   public class studentdemo {\n       public static void main(string[] args) {\n           //创建对象\n           student s = new student();\n   \n           //使用set方法给成员变量赋值\n           s.setname("林青霞");\n           s.setage(30);\n   \n           s.show();\n   \n           //使用get方法获取成员变量的值\n           system.out.println(s.getname() + "---" + s.getage());\n           system.out.println(s.getname() + "," + s.getage());\n   \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   \n\n\n# 4.3 this关键字\n\n * this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）\n   * 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量\n   * 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量\n\npublic class student {\n    private string name;\n    private int age;\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void show() {\n        system.out.println(name + "," + age);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 4.4 this内存原理\n\n * this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象\n\n * 示例代码：\n   \n   public class studentdemo {\n       public static void main(string[] args) {\n           student s1 = new student();\n           s1.setname("林青霞");\n           student s2 = new student();\n           s2.setname("张曼玉");\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 图解：\n   \n   \n   \n   \n\n\n# 4.5 封装思想\n\n 1. 封装概述 是面向对象三大特征之一（封装，继承，多态） 是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的\n 2. 封装原则 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getxxx()/setxxx()方法\n 3. 封装好处 通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性\n\n\n# 5. 对象的创建\n\n在java中，万事万物都是对象。这句话相信你一定不陌生，尽管一切都看作是对象，但是你操纵的却 是一个对象的引用(reference)。在这里有一个很形象的比喻：你可以把车钥匙和车看作是一组对象 引用和对象的组合。当你想要开车的时候，你首先需要拿出车钥匙点击开锁的选项，停车时，你需要点 击加锁来锁车。车钥匙相当于就是引用，车就是对象，由车钥匙来驱动车的加锁和开锁。并且，即使没 有车的存在，车钥匙也是一个独立存在的实体，也就是说，你有一个对象引用，但你不一定需要一个对 象与之关联，也就是\n\ncar carkey\n\n\n1\n\n\n这里创建的只是引用，而并非对象，但是如果你想要使用s这个引用时，会返回一个异常，告诉你需要 一个对象来和这个引用进行关联。一种安全的做法是，在创建对象引用时同时把一个对象赋给它。\n\ncar carkey = new car();\n\n\n1\n\n\n在java中，一旦创建了一个引用，就希望它能与一个新的对象进行关联，通常使用new操作符来实 现这一目的。new的意思是，给我一个新对象，如果你不想相亲，自己new 一个对象就好了。祝你 下辈子幸福。\n\n\n# 6. 属性和方法\n\n类一个最基本的要素就是有属性和方法。\n\n * 属性\n\n属性也被称为字段，它是类的重要组成部分，属性可以是任意类型的对象，也可以是基本数据类型。例 如下\n\nclass a{\n int a;\n apple apple;\n}\n\n\n1\n2\n3\n4\n\n * 方法\n\n类中还应该包括方法，方法表示的是做某些事情的方式。方法其实就是函数，只不过java习惯把函数 称为方法。这种叫法也体现了面向对象的概念。\n\n**方法的基本组成包括方法名称、参数、返回值和方法体，**下面是它的示例\n\npublic int getresult(){\n // ...\n return 1;\n}\n\n\n1\n2\n3\n4\n\n\n其中，getresult就是方法名称、()里面表示方法接收的参数、return表示方法的返回值，\n\n注意：方法的返回值必须和方法的参数类型保持一致。有一种特殊的参数类型void表示方法无返 回值。{}包含的代码段被称为方法体。\n\n\n# 6.1 构造方法\n\n在java中，有一种特殊的方法被称为构造方法，也被称为构造函数、构造器等。在java中，通过 提供这个构造器，来确保每个对象都被初始化。构造方法只能在对象的创建时期调用一次，保证了对象 初始化的进行。构造方法比较特殊，它没有参数类型和返回值，它的名称要和类名保持一致，并且构造 方法可以有多个，下面是一个构造方法的示例\n\nclass apple {\n \n int sum;\n string color;\n \n public apple(){}\n public apple(int sum){}\n public apple(string color){}\n public apple(int sum,string color){}\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 有参构造、无参构造函数\n\n上面定义了一个apple类，你会发现这个apple类没有参数类型和返回值，并且有多个以apple同名 的方法，而且各个apple的参数列表都不一样，这其实是一种多态的体现，我们后面会说。在定义完成 构造方法后，我们就能够创建apple对象了。\n\nclass createapple {\n public static void main(string[] args) {\n apple apple1 = new apple();\n apple apple2 = new apple(1);\n apple apple3 = new apple("red");\n apple apple4 = new apple(2,"color");\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 默认的构造方法\n\n如上面所示，我们定义了四个apple对象，并调用了 apple的四种不同的构造方法，其中，不加任何参数的构造方法被称为默认的构造方法，也就是\n\napple apple1 = new apple();\n\n\n1\n\n * 如果类中没有定义任何构造方法，那么jvm会为你自动生成一个构造方法，如下\n\nclass apple {\n    int sum;\n     string color;\n}\nclass createapple {\n\tpublic static void main(string[] args) {\n    \tapple apple1 = new apple();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 上面代码不会发生编译错误，因为apple对象包含了一个默认的构造方法。\n\n默认的构造方法也被称为默认构造器或者无参构造器。\n\n这里需要注意一点的是，即使jvm会为你默认添加一个无参的构造器，但是如果你手动定义了任何一 个构造方法，jvm就不再为你提供默认的构造器，你必须手动指定，否则会出现编译错误。\n\n显示的错误是，必须提供apple带有int参数的构造函数，而默认的无参构造函数没有被允许使用。\n\n\n# 6.2 方法重载\n\n在java中一个很重要的概念是方法的重载，它是类名的不同表现形式。我们上面说到了构造函数，其实构造函数也是重载的一种。另外一种就是方法的重载\n\npublic class apple {\n int sum;\n string color;\n public apple(){}\n public apple(int sum){}\n public int getapple(int num){\n return 1;\n }\n \n public string getapple(string color){\n return "color";\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如上面所示，就有两种重载的方式，一种是apple构造函数的重载，一种是getapple方法的重载。\n\n但是这样就涉及到一个问题，要是有几个相同的名字，java如何知道你调用的是哪个方法呢？\n\n这里记住一点即可，每个重载的方法都有独一无二的参数列表。其中包括参数的类型、顺序、参数数量等，满足一种一个因素就构成了重载的必要条件。\n\n# 重载的条件🚗\n\n * 方法名称必须相同。\n\n * 参数列表必须不同(个数不同、或类型不同、参数类型排列顺序不同等)。\n\n * 方法的返回类型可以相同也可以不相同。\n\n * 仅仅返回类型不同不足以成为方法的重载。\n\n * 重载是发生在编译时的，因为编译器可以根据参数的类型来选择使用哪个方法。\n\n\n# 6.3 方法的重写\n\n方法的重写与重载虽然名字很相似，但却完全是不同的东西。方法重写的描述是对子类和父类之间 的。而重载指的是同一类中的。例如如下代码\n\nclass fruit {\n public void eat(){\n system.out.printl(\'eat fruit\');\n }\n}\n// 重写\nclass apple extends fruit{\n \n @override\n public void eat(){\n system.out.printl(\'eat apple\');\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面这段代码描述的就是重写的代码，你可以看到，子类apple中的方法和父类fruit中的方法同名。\n\n# 重写的原则🚗\n\n * 重写的方法必须要和父类保持一致，包括返回值类型，方法名,参数列表也都一样。\n\n * 重写的方法可以使用@override注解来标识\n\n * 子类中重写方法的访问权限不能低于父类中方法的访问权限。\n\n\n# 7. 初始化\n\n\n# 7.1 类的初始化\n\n上面我们创建出来了一个car这个对象，其实在使用new关键字创建一个对象的时候，其实是调用了 这个对象无参数的构造方法进行的初始化，也就是如下这段代码\n\nclass car{\n  public car(){}\n}\n\n\n1\n2\n3\n\n\n这个无参数的构造函数可以隐藏，由jvm自动添加。也就是说，构造函数能够确保类的初始化。\n\n\n# 7.2 成员初始化\n\njava会尽量保证每个变量在使用前都会获得初始化，初始化涉及两种初始化。\n\n * 一种是编译器默认指定的字段初始化，基本数据类型的初始化\n\n类型        初始值\nboolean   false\nchar      /u0000\nbyte      (byte)0\nshort     (short)0\nint       0\nlong      0l\nfloat     0.0f\ndouble    0.0d\n\n一种是其他对象类型的初始化，string也是一种对象，对象的初始值都为null，其中也包括基本类型的包装类。\n\n * 一种是指定数值的初始化，例如\n\nint a = 11\n\n\n1\n\n\n也就是说，指定a的初始化值不是0，而是11。其他基本类型和对象类型也是一样的。\n\n\n# 7.3 构造器初始化\n\n可以利用构造器来对某些方法和某些动作进行初始化，确定初始值，例如\n\npublic class counter{\n\n int i;\n public counter(){\n\t i = 11;\n }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n利用构造函数，能够把i的值初始化为11。\n\n\n# 7.4 初始化顺序\n\n首先先来看一下有哪些需要探讨的初始化顺序\n\n * 静态属性：static开头定义的属性\n\n * 静态方法块：static {}包起来的代码块\n\n * 普通属性：非static定义的属性\n\n * 普通方法块：{}包起来的代码块\n\n * 构造函数：类名相同的方法\n\n * 方法：普通方法\n\npublic class lifecycle {\n \t // 静态属性\n     private static string staticfield = getstaticfield();\n     // 静态方法块\n     static {\n     system.out.println(staticfield);\n     system.out.println("静态方法块");\n     }\n     // 普通属性\n     private string field = getfield();\n   \t // 普通方法块\n     {\n     system.out.println(field);\n     }\n     // 构造函数\n     public lifecycle() {\n     system.out.println("构造函数");\n     }\n     public static string getstaticfield() {\n     string statifiled = "static field initial";\n     return statifiled;\n     }\n     public static string getfield() {\n     string filed = "field initial";\n     return filed;\n     } \n     // 主函数\n     public static void main(string[] argc) {\n     new lifecycle();\n     }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n这段代码的执行结果就反应了它的初始化顺序。\n\n静态属性初始化静态方法块初始化普通属性初始化普通方法块初始化构造函数初始化。\n\n\n# 7.5 数组初始化\n\n数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方 括号下标操作符[]来定义使用。\n\n一般数组是这么定义的\n\nint[] a1;\n//或者\nint a1[];\n\n\n1\n2\n3\n\n\n两种格式的含义是一样的。\n\n * 直接给每个元素赋值:int array[4] = {1,2,3,4};\n\n * 给一部分赋值，后面的都为0 : int array[4] = {1,2};\n\n * 由赋值参数个数决定数组的个数：int array[] = {1,2};\n\n可变参数列表\n\njava中一种数组冷门的用法就是可变参数，可变参数的定义如下\n\npublic int add(int... numbers){\n int sum = 0;\n for(int num : numbers){\n sum += num;\n }\n return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后，你可以使用下面这几种方式进行可变参数的调用\n\nadd(); // 不传参数\nadd(1); // 传递一个参数\nadd(2,1); // 传递多个参数\nadd(new integer[] {1, 3, 2}); // 传递数组\n\n\n1\n2\n3\n4\n\n\n\n# 8. 对象的销毁\n\n虽然java语言是基于c++的，但是它和c/c++ 一个重要的特征就是不需要手动管理对象的销毁工 作。在著名的一书《深入理解java虚拟机》中提到一个观点：java与c++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人 想进去，墙里面的人却想出来。\n\n在java中，我们不再需要手动管理对象的销毁，它是由java虚拟机进行管理和销毁的。虽然我们 不需要手动管理对象，但是你需要知道对象作用域这个概念。\n\n\n# 对象作用域\n\nj多数语言都有作用域(scope)这个概念。作用域决定了其内部定义的变量名的可见性和生命周期。在 c、c++和java中，作用域通常由{}的位置来决定，例如\n\n{\n int a = 11;\n {\n int b = 12;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\na变量会在两个{}作用域内有效，而b变量的值只能在它自己的{}内有效。\n\n虽然存在作用域，但是不允许这样写\n\n{\n int x = 11;\n {\n int x = 12;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种写法在c/c++中是可以的，但是在java中不允许这样写，因为java设计者认为这样写会导致程序混乱。\n\n\n# 9. this和super\n\nthis和super都是java中的关键字\n\nthis表示的当前对象，this可以调用方法、调用属性和指向对象本身。this在java中的使用一般有三 种：指向当前对象\n\npublic class apple {\n int i = 0;\n apple eatapple(){\n i++;\n return this;\n }\n public static void main(string[] args) {\n apple apple = new apple();\n apple.eatapple().eatapple();\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段代码比较精妙，精妙在哪呢，我一个eatapple。方法竟然可以调用多次，你在后面还可以继续调 用，这就很神奇了，为啥呢？其实就是this在作祟了，我在eatapple方法中加了一个return this的返回值，也就是说哪个对象调用eatapple方法都能返回对象的自身。\n\nthis还可以修饰属性，最常见的就是在构造方法中使用this，如下所示\n\npublic class apple {\n private int num;\n \n public apple(int num){\n this.num = num;\n }\n public static void main(string[] args) {\n new apple(10);\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nmain方法中传递了一个int值为10的参数，它表示的就是苹果的数量，并把这个数量赋给了 num全 局变量。所以num的值现在就是10。\n\nthis还可以和构造函数一起使用，充当一个全局关键字的效果\n\npublic class apple {\n private int num;\n private string color;\n public apple(int num){\n this(num,"红色");\n }\n \n public apple(string color){\n this(1,color);\n }\n public apple(int num, string color) {\n this.num = num;\n this.color = color;\n }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n你会发现上面这段代码使用的不是this,而是this(参数)。它相当于调用了其他构造方法，然后传递 参数进去。这里注意一点：this。必须放在构造方法的第一行，否则编译不通过。\n\n\n\n如果你把this理解为指向自身的一个引用，那么super就是指向父类的一个引用。super关键字和this —样， 你可以使用super对象来引用父类成员，如下：\n\npublic class fruit {\n int num;\n string color;\n public void eat(){\n system.out.println("eat fruit");\n }\n}\npublic class apple extends fruit{\n @override\n public void eat() {\n super.num = 10;\n system.out.println("eat " + num + " apple");\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n你也可以使用super(参数)来调用父类的构造函数。\n\n下面为你汇总了 this关键字和super关键字的比较。\n\n关键字    this               super\n调用方式   调用本类中的属性、构造函数、方法   调用父类中属性、构造函数、方法\n调用位置   构造函数第一行，其他可自行指定    构造函数第一行，其他可自行指定\n调用次数   —个构造函数只能调用一次       一个构造函数只能调用一次',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"接口和抽象类",frontmatter:{title:"接口和抽象类",date:"2023-02-26T08:36:28.000Z",permalink:"/pages/8ae350/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/04.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/04.接口和抽象类.md",key:"v-4a83f009",path:"/pages/8ae350/",headers:[{level:2,title:"1. 抽象类",slug:"_1-抽象类",normalizedTitle:"1. 抽象类",charIndex:13},{level:3,title:"1.1 抽象类的概述",slug:"_1-1-抽象类的概述",normalizedTitle:"1.1 抽象类的概述",charIndex:129},{level:3,title:"1.2 抽象类的特点",slug:"_1-2-抽象类的特点",normalizedTitle:"1.2 抽象类的特点",charIndex:241},{level:3,title:"1.3 抽象类的成员特点",slug:"_1-3-抽象类的成员特点",normalizedTitle:"1.3 抽象类的成员特点",charIndex:512},{level:4,title:"1. 成员的特点",slug:"_1-成员的特点",normalizedTitle:"1. 成员的特点",charIndex:528},{level:4,title:"2. 示例",slug:"_2-示例",normalizedTitle:"2. 示例",charIndex:607},{level:3,title:"1.4 抽象类的案例",slug:"_1-4-抽象类的案例",normalizedTitle:"1.4 抽象类的案例",charIndex:1315},{level:2,title:"2. 接口",slug:"_2-接口",normalizedTitle:"2. 接口",charIndex:2939},{level:3,title:"2.1 接口的概述",slug:"_2-1-接口的概述",normalizedTitle:"2.1 接口的概述",charIndex:3027},{level:3,title:"2.2 接口的特点",slug:"_2-2-接口的特点",normalizedTitle:"2.2 接口的特点",charIndex:3097},{level:3,title:"2.3 接口的成员特点",slug:"_2-3-接口的成员特点",normalizedTitle:"2.3 接口的成员特点",charIndex:3335},{level:4,title:"1. 成员特点",slug:"_1-成员特点",normalizedTitle:"1. 成员特点",charIndex:3350},{level:4,title:"2. 示例",slug:"_2-示例-2",normalizedTitle:"2. 示例",charIndex:607},{level:3,title:"2.4 接口的案例",slug:"_2-4-接口的案例",normalizedTitle:"2.4 接口的案例",charIndex:4572},{level:3,title:"2.5 类和接口的关系",slug:"_2-5-类和接口的关系",normalizedTitle:"2.5 类和接口的关系",charIndex:6504},{level:3,title:"2.6 抽象类和接口的区别",slug:"_2-6-抽象类和接口的区别",normalizedTitle:"2.6 抽象类和接口的区别",charIndex:6634},{level:4,title:"1. 成员区别",slug:"_1-成员区别",normalizedTitle:"1. 成员区别",charIndex:6651},{level:4,title:"2. 关系区别",slug:"_2-关系区别",normalizedTitle:"2. 关系区别",charIndex:6713},{level:4,title:"3. 设计理念区别",slug:"_3-设计理念区别",normalizedTitle:"3. 设计理念区别",charIndex:6788},{level:2,title:"3. 参数传递",slug:"_3-参数传递",normalizedTitle:"3. 参数传递",charIndex:6844},{level:3,title:"3.1 类名作为形参和返回值",slug:"_3-1-类名作为形参和返回值",normalizedTitle:"3.1 类名作为形参和返回值",charIndex:6856},{level:3,title:"3.2 抽象类作为形参和返回值",slug:"_3-2-抽象类作为形参和返回值",normalizedTitle:"3.2 抽象类作为形参和返回值",charIndex:7763},{level:3,title:"3.3 接口名作为形参和返回值",slug:"_3-3-接口名作为形参和返回值",normalizedTitle:"3.3 接口名作为形参和返回值",charIndex:8783}],headersStr:"1. 抽象类 1.1 抽象类的概述 1.2 抽象类的特点 1.3 抽象类的成员特点 1. 成员的特点 2. 示例 1.4 抽象类的案例 2. 接口 2.1 接口的概述 2.2 接口的特点 2.3 接口的成员特点 1. 成员特点 2. 示例 2.4 接口的案例 2.5 类和接口的关系 2.6 抽象类和接口的区别 1. 成员区别 2. 关系区别 3. 设计理念区别 3. 参数传递 3.1 类名作为形参和返回值 3.2 抽象类作为形参和返回值 3.3 接口名作为形参和返回值",content:'# 接口和抽象类\n\n\n# 1. 抽象类\n\n抽象类是一种抽象能力弱于接口的类，在Java中，抽象类使用abstract关键字来表示。如果把接口形容为狗这个物种，那么抽象类可以说是毛发是白色、小体的品种，而实现类可以是具体的类，比如:说是博美、泰迪等。\n\n\n# 1.1 抽象类的概述\n\n当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！\n\n在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！\n\n\n# 1.2 抽象类的特点\n\n * 抽象类和抽象方法必须使用abstract关键字修饰\n\n//抽象类的定义\npublic abstract class 类名 {\n\n    //抽象方法的定义\n    public abstract void eat();\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n\n * 抽象类不能实例化\n\n抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态。\n\n * 抽象类的子类\n\n要么重写抽象类中的所有抽象方法\n\n要么是抽象类\n\n\n# 1.3 抽象类的成员特点\n\n# 1. 成员的特点\n\n * 成员变量\n\n既可以是变量\n\n也可以是常量\n\n * 构造方法\n\n空参构造\n\n有参构造\n\n * 成员方法\n\n抽象方法\n\n普通方法\n\n# 2. 示例\n\n动物类\n\npublic abstract class Animal {\n    private int age = 20;\n    private final String city = "北京";\n    public Animal() {}\n    public Animal(int age) {\n        this.age = age;\n    }\n    public void show() {\n        age = 40;\n        System.out.println(age);\n        // city = "上海";\n        System.out.println(city);\n    }\n    public abstract void eat();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n猫类\n\npublic class Cat extends Animal {\n    @Override\n    public void eat() {\n        System.out.println("猫吃鱼");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n测试类\n\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        Animal a = new Cat();\n        a.eat();\n        a.show();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 1.4 抽象类的案例\n\n请采用抽象类的思想实现猫和狗的案例，并在测试类中进行测试\n\n动物类\n\npublic abstract class Animal {\n    private String name;\n    private int age;\n\n    public Animal() {\n    }\n\n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public abstract void eat();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n猫类\n\npublic class Cat extends Animal {\n\n    public Cat() {\n    }\n\n    public Cat(String name, int age) {\n        super(name, age);\n    }\n\n    @Override\n    public void eat() {\n        System.out.println("猫吃鱼");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n狗类\n\npublic class Dog extends Animal {\n\n    public Dog() {\n    }\n\n    public Dog(String name, int age) {\n        super(name, age);\n    }\n\n    @Override\n    public void eat() {\n        System.out.println("狗吃骨头");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n测试类\n\npackage com.itheima_04;\n/*\n    测试类\n */\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        //创建对象，按照多态的方式\n        Animal a = new Cat();\n        a.setName("加菲");\n        a.setAge(5);\n        System.out.println(a.getName()+","+a.getAge());\n        a.eat();\n        System.out.println("--------");\n\n        a = new Cat("加菲",5);\n        System.out.println(a.getName()+","+a.getAge());\n        a.eat();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2. 接口\n\n接口相当于就是对外的一种约定和标准，这里拿操作系统举例子，为什么会有操作系统？就会为了屏蔽 软件的复杂性和硬件的简单性之间的差异，为软件提供统一的标准。\n\n\n# 2.1 接口的概述\n\n接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。\n\nJava中的接口更多的体现在对行为的抽象！\n\n\n# 2.2 接口的特点\n\n * 接口用关键字interface修饰\n\npublic interface 接口名 {}\n\n\n1\n\n * 类实现接口用implements表示\n\npublic class 类名 implements 接口名 {}\n\n\n1\n\n * 接口不能实例化\n\n接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。\n\n多态的形式：具体类多态，抽象类多态，接口多态。\n\n * 接口的子类\n\n要么重写接口中的所有抽象方法\n\n要么子类也是抽象类\n\n\n# 2.3 接口的成员特点\n\n# 1. 成员特点\n\n * 成员变量\n\n只能是常量\n\n默认修饰符：public static fifinal\n\n * 构造方法\n\n没有，因为接口主要是扩展功能的，而没有具体存在\n\n * 成员方法\n\n只能是抽象方法\n\n默认修饰符：public abstract\n\n关于接口中的方法，JDK8和JDK9中有一些新特性，后面再讲解\n\n# 2. 示例\n\n接口\n\npublic interface Inter {\n    public int num = 10;\n    public final int num2 = 20;\n//    public static final int num3 = 30;\n    int num3 = 30;\n\n//    public Inter() {}\n\n//    public void show() {}\n\n    public abstract void method();\n    void show();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n实现类\n\npackage com.itheima_02;\n\n//public class InterImpl implements Inter {\n\npublic class InterImpl extends Object implements Inter {\n    public InterImpl() {\n        super();\n    }\n\n    @Override\n    public void method() {\n        System.out.println("method");\n    }\n\n    @Override\n    public void show() {\n        System.out.println("show");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n测试类\n\npackage com.itheima_02;\n/*\n    测试类\n */\npublic class InterfaceDemo {\n    public static void main(String[] args) {\n        Inter i = new InterImpl();\n//        i.num = 20;\n        System.out.println(i.num);\n//        i.num2 = 40;\n        System.out.println(i.num2);\n        System.out.println(Inter.num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.4 接口的案例\n\n对猫和狗进行训练，他们就可以跳高了，这里加入跳高功能。请采用抽象类和接口来实现猫狗案例，并在测试类中进行测试。\n\n动物类\n\npackage com.itheima_03;\n\npublic abstract class Animal {\n    private String name;\n    private int age;\n\n    public Animal() {\n    }\n\n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public abstract void eat();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n跳高接口\n\npublic interface Jumpping {\n    public abstract void jump();\n}\n\n\n1\n2\n3\n\n\n猫类\n\npublic class Cat extends Animal implements Jumpping {\n\n    public Cat() {\n    }\n\n    public Cat(String name, int age) {\n        super(name, age);\n    }\n\n    @Override\n    public void eat() {\n        System.out.println("猫吃鱼");\n    }\n\n    @Override\n    public void jump() {\n        System.out.println("猫可以跳高了");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n测试类\n\npackage com.itheima_03;\n/*\n    测试类\n */\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        //创建对象，调用方法\n        Jumpping j = new Cat();\n        j.jump();\n        System.out.println("--------");\n\n        Animal a = new Cat();\n        a.setName("加菲");\n        a.setAge(5);\n        System.out.println(a.getName()+","+a.getAge());\n        a.eat();\n//        a.jump();\n\n        a = new Cat("加菲",5);\n        System.out.println(a.getName()+","+a.getAge());\n        a.eat();\n        System.out.println("--------");\n\n        Cat c = new Cat();\n        c.setName("加菲");\n        c.setAge(5);\n        System.out.println(c.getName()+","+c.getAge());\n        c.eat();\n        c.jump();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 2.5 类和接口的关系\n\n * 类与类的关系\n\n继承关系，只能单继承，但是可以多层继承\n\n * 类与接口的关系\n\n实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n\n * 接口与接口的关系\n\n继承关系，可以单继承，也可以多继承\n\n\n# 2.6 抽象类和接口的区别\n\n# 1. 成员区别\n\n * 抽象类\n\n变量,常量；有构造方法；有抽象方法,也有非抽象方法\n\n * 接口\n\n常量；抽象方法\n\n# 2. 关系区别\n\n * 类与类\n\n继承，单继承\n\n * 类与接口\n\n实现，可以单实现，也可以多实现\n\n * 接口与接口\n\n继承，单继承，多继承\n\n# 3. 设计理念区别\n\n * 抽象类\n\n对类抽象，包括属性、行为\n\n * 接口\n\n对行为抽象，主要是行为\n\n\n# 3. 参数传递\n\n\n# 3.1 类名作为形参和返回值\n\n * 1、类名作为方法的形参\n   \n   方法的形参是类名，其实需要的是该类的对象\n   \n   实际传递的是该对象的【地址值】\n\n * 2、类名作为方法的返回值\n   \n   方法的返回值是类名，其实返回的是该类的对象\n   \n   实际传递的，也是该对象的【地址值】\n\n * 示例代码：\n   \n   class Cat {\n       public void eat() {\n           System.out.println("猫吃鱼");\n       }\n   }\n   class CatOperator {\n       public void useCat(Cat c) { //Cat c = new Cat();\n           c.eat();\n       }\n       public Cat getCat() {\n           Cat c = new Cat();\n           return c;\n       }\n   }\n   public class CatDemo {\n       public static void main(String[] args) {\n           //创建操作类对象，并调用方法\n           CatOperator co = new CatOperator();\n           Cat c = new Cat();\n           co.useCat(c);\n   \n           Cat c2 = co.getCat(); //new Cat()\n           c2.eat();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n\n\n# 3.2 抽象类作为形参和返回值\n\n * 抽象类作为形参和返回值\n   \n   * 方法的形参是抽象类名，其实需要的是该抽象类的子类对象\n   * 方法的返回值是抽象类名，其实返回的是该抽象类的子类对象\n\n * 示例代码：\n   \n   abstract class Animal {\n       public abstract void eat();\n   }\n   class Cat extends Animal {\n       @Override\n       public void eat() {\n           System.out.println("猫吃鱼");\n       }\n   }\n   class AnimalOperator {\n       public void useAnimal(Animal a) { //Animal a = new Cat();\n           a.eat();\n       }\n       public Animal getAnimal() {\n           Animal a = new Cat();\n           return a;\n       }\n   }\n   public class AnimalDemo {\n       public static void main(String[] args) {\n           //创建操作类对象，并调用方法\n           AnimalOperator ao = new AnimalOperator();\n           Animal a = new Cat();\n           ao.useAnimal(a);\n   \n           Animal a2 = ao.getAnimal(); //new Cat()\n           a2.eat();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n\n\n# 3.3 接口名作为形参和返回值\n\n * 接口作为形参和返回值\n   \n   * 方法的形参是接口名，其实需要的是该接口的实现类对象\n   * 方法的返回值是接口名，其实返回的是该接口的实现类对象\n\n * 示例代码：\n   \n   interface Jumpping {\n       void jump();\n   }\n   class JumppingOperator {\n       public void useJumpping(Jumpping j) { //Jumpping j = new Cat();\n           j.jump();\n       }\n       public Jumpping getJumpping() {\n           Jumpping j = new Cat();\n           return j;\n       }\n   }\n   class Cat implements Jumpping {\n       @Override\n       public void jump() {\n           System.out.println("猫可以跳高了");\n       }\n   }\n   public class JumppingDemo {\n       public static void main(String[] args) {\n           //创建操作类对象，并调用方法\n           JumppingOperator jo = new JumppingOperator();\n           Jumpping j = new Cat();\n           jo.useJumpping(j);\n   \n           Jumpping j2 = jo.getJumpping(); //new Cat()\n           j2.jump();\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   ',normalizedContent:'# 接口和抽象类\n\n\n# 1. 抽象类\n\n抽象类是一种抽象能力弱于接口的类，在java中，抽象类使用abstract关键字来表示。如果把接口形容为狗这个物种，那么抽象类可以说是毛发是白色、小体的品种，而实现类可以是具体的类，比如:说是博美、泰迪等。\n\n\n# 1.1 抽象类的概述\n\n当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！\n\n在java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！\n\n\n# 1.2 抽象类的特点\n\n * 抽象类和抽象方法必须使用abstract关键字修饰\n\n//抽象类的定义\npublic abstract class 类名 {\n\n    //抽象方法的定义\n    public abstract void eat();\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n\n * 抽象类不能实例化\n\n抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态。\n\n * 抽象类的子类\n\n要么重写抽象类中的所有抽象方法\n\n要么是抽象类\n\n\n# 1.3 抽象类的成员特点\n\n# 1. 成员的特点\n\n * 成员变量\n\n既可以是变量\n\n也可以是常量\n\n * 构造方法\n\n空参构造\n\n有参构造\n\n * 成员方法\n\n抽象方法\n\n普通方法\n\n# 2. 示例\n\n动物类\n\npublic abstract class animal {\n    private int age = 20;\n    private final string city = "北京";\n    public animal() {}\n    public animal(int age) {\n        this.age = age;\n    }\n    public void show() {\n        age = 40;\n        system.out.println(age);\n        // city = "上海";\n        system.out.println(city);\n    }\n    public abstract void eat();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n猫类\n\npublic class cat extends animal {\n    @override\n    public void eat() {\n        system.out.println("猫吃鱼");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n测试类\n\npublic class animaldemo {\n    public static void main(string[] args) {\n        animal a = new cat();\n        a.eat();\n        a.show();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 1.4 抽象类的案例\n\n请采用抽象类的思想实现猫和狗的案例，并在测试类中进行测试\n\n动物类\n\npublic abstract class animal {\n    private string name;\n    private int age;\n\n    public animal() {\n    }\n\n    public animal(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public abstract void eat();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n猫类\n\npublic class cat extends animal {\n\n    public cat() {\n    }\n\n    public cat(string name, int age) {\n        super(name, age);\n    }\n\n    @override\n    public void eat() {\n        system.out.println("猫吃鱼");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n狗类\n\npublic class dog extends animal {\n\n    public dog() {\n    }\n\n    public dog(string name, int age) {\n        super(name, age);\n    }\n\n    @override\n    public void eat() {\n        system.out.println("狗吃骨头");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n测试类\n\npackage com.itheima_04;\n/*\n    测试类\n */\npublic class animaldemo {\n    public static void main(string[] args) {\n        //创建对象，按照多态的方式\n        animal a = new cat();\n        a.setname("加菲");\n        a.setage(5);\n        system.out.println(a.getname()+","+a.getage());\n        a.eat();\n        system.out.println("--------");\n\n        a = new cat("加菲",5);\n        system.out.println(a.getname()+","+a.getage());\n        a.eat();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2. 接口\n\n接口相当于就是对外的一种约定和标准，这里拿操作系统举例子，为什么会有操作系统？就会为了屏蔽 软件的复杂性和硬件的简单性之间的差异，为软件提供统一的标准。\n\n\n# 2.1 接口的概述\n\n接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。\n\njava中的接口更多的体现在对行为的抽象！\n\n\n# 2.2 接口的特点\n\n * 接口用关键字interface修饰\n\npublic interface 接口名 {}\n\n\n1\n\n * 类实现接口用implements表示\n\npublic class 类名 implements 接口名 {}\n\n\n1\n\n * 接口不能实例化\n\n接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。\n\n多态的形式：具体类多态，抽象类多态，接口多态。\n\n * 接口的子类\n\n要么重写接口中的所有抽象方法\n\n要么子类也是抽象类\n\n\n# 2.3 接口的成员特点\n\n# 1. 成员特点\n\n * 成员变量\n\n只能是常量\n\n默认修饰符：public static fifinal\n\n * 构造方法\n\n没有，因为接口主要是扩展功能的，而没有具体存在\n\n * 成员方法\n\n只能是抽象方法\n\n默认修饰符：public abstract\n\n关于接口中的方法，jdk8和jdk9中有一些新特性，后面再讲解\n\n# 2. 示例\n\n接口\n\npublic interface inter {\n    public int num = 10;\n    public final int num2 = 20;\n//    public static final int num3 = 30;\n    int num3 = 30;\n\n//    public inter() {}\n\n//    public void show() {}\n\n    public abstract void method();\n    void show();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n实现类\n\npackage com.itheima_02;\n\n//public class interimpl implements inter {\n\npublic class interimpl extends object implements inter {\n    public interimpl() {\n        super();\n    }\n\n    @override\n    public void method() {\n        system.out.println("method");\n    }\n\n    @override\n    public void show() {\n        system.out.println("show");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n测试类\n\npackage com.itheima_02;\n/*\n    测试类\n */\npublic class interfacedemo {\n    public static void main(string[] args) {\n        inter i = new interimpl();\n//        i.num = 20;\n        system.out.println(i.num);\n//        i.num2 = 40;\n        system.out.println(i.num2);\n        system.out.println(inter.num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.4 接口的案例\n\n对猫和狗进行训练，他们就可以跳高了，这里加入跳高功能。请采用抽象类和接口来实现猫狗案例，并在测试类中进行测试。\n\n动物类\n\npackage com.itheima_03;\n\npublic abstract class animal {\n    private string name;\n    private int age;\n\n    public animal() {\n    }\n\n    public animal(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public abstract void eat();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n跳高接口\n\npublic interface jumpping {\n    public abstract void jump();\n}\n\n\n1\n2\n3\n\n\n猫类\n\npublic class cat extends animal implements jumpping {\n\n    public cat() {\n    }\n\n    public cat(string name, int age) {\n        super(name, age);\n    }\n\n    @override\n    public void eat() {\n        system.out.println("猫吃鱼");\n    }\n\n    @override\n    public void jump() {\n        system.out.println("猫可以跳高了");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n测试类\n\npackage com.itheima_03;\n/*\n    测试类\n */\npublic class animaldemo {\n    public static void main(string[] args) {\n        //创建对象，调用方法\n        jumpping j = new cat();\n        j.jump();\n        system.out.println("--------");\n\n        animal a = new cat();\n        a.setname("加菲");\n        a.setage(5);\n        system.out.println(a.getname()+","+a.getage());\n        a.eat();\n//        a.jump();\n\n        a = new cat("加菲",5);\n        system.out.println(a.getname()+","+a.getage());\n        a.eat();\n        system.out.println("--------");\n\n        cat c = new cat();\n        c.setname("加菲");\n        c.setage(5);\n        system.out.println(c.getname()+","+c.getage());\n        c.eat();\n        c.jump();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 2.5 类和接口的关系\n\n * 类与类的关系\n\n继承关系，只能单继承，但是可以多层继承\n\n * 类与接口的关系\n\n实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n\n * 接口与接口的关系\n\n继承关系，可以单继承，也可以多继承\n\n\n# 2.6 抽象类和接口的区别\n\n# 1. 成员区别\n\n * 抽象类\n\n变量,常量；有构造方法；有抽象方法,也有非抽象方法\n\n * 接口\n\n常量；抽象方法\n\n# 2. 关系区别\n\n * 类与类\n\n继承，单继承\n\n * 类与接口\n\n实现，可以单实现，也可以多实现\n\n * 接口与接口\n\n继承，单继承，多继承\n\n# 3. 设计理念区别\n\n * 抽象类\n\n对类抽象，包括属性、行为\n\n * 接口\n\n对行为抽象，主要是行为\n\n\n# 3. 参数传递\n\n\n# 3.1 类名作为形参和返回值\n\n * 1、类名作为方法的形参\n   \n   方法的形参是类名，其实需要的是该类的对象\n   \n   实际传递的是该对象的【地址值】\n\n * 2、类名作为方法的返回值\n   \n   方法的返回值是类名，其实返回的是该类的对象\n   \n   实际传递的，也是该对象的【地址值】\n\n * 示例代码：\n   \n   class cat {\n       public void eat() {\n           system.out.println("猫吃鱼");\n       }\n   }\n   class catoperator {\n       public void usecat(cat c) { //cat c = new cat();\n           c.eat();\n       }\n       public cat getcat() {\n           cat c = new cat();\n           return c;\n       }\n   }\n   public class catdemo {\n       public static void main(string[] args) {\n           //创建操作类对象，并调用方法\n           catoperator co = new catoperator();\n           cat c = new cat();\n           co.usecat(c);\n   \n           cat c2 = co.getcat(); //new cat()\n           c2.eat();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n\n\n# 3.2 抽象类作为形参和返回值\n\n * 抽象类作为形参和返回值\n   \n   * 方法的形参是抽象类名，其实需要的是该抽象类的子类对象\n   * 方法的返回值是抽象类名，其实返回的是该抽象类的子类对象\n\n * 示例代码：\n   \n   abstract class animal {\n       public abstract void eat();\n   }\n   class cat extends animal {\n       @override\n       public void eat() {\n           system.out.println("猫吃鱼");\n       }\n   }\n   class animaloperator {\n       public void useanimal(animal a) { //animal a = new cat();\n           a.eat();\n       }\n       public animal getanimal() {\n           animal a = new cat();\n           return a;\n       }\n   }\n   public class animaldemo {\n       public static void main(string[] args) {\n           //创建操作类对象，并调用方法\n           animaloperator ao = new animaloperator();\n           animal a = new cat();\n           ao.useanimal(a);\n   \n           animal a2 = ao.getanimal(); //new cat()\n           a2.eat();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n\n\n# 3.3 接口名作为形参和返回值\n\n * 接口作为形参和返回值\n   \n   * 方法的形参是接口名，其实需要的是该接口的实现类对象\n   * 方法的返回值是接口名，其实返回的是该接口的实现类对象\n\n * 示例代码：\n   \n   interface jumpping {\n       void jump();\n   }\n   class jumppingoperator {\n       public void usejumpping(jumpping j) { //jumpping j = new cat();\n           j.jump();\n       }\n       public jumpping getjumpping() {\n           jumpping j = new cat();\n           return j;\n       }\n   }\n   class cat implements jumpping {\n       @override\n       public void jump() {\n           system.out.println("猫可以跳高了");\n       }\n   }\n   public class jumppingdemo {\n       public static void main(string[] args) {\n           //创建操作类对象，并调用方法\n           jumppingoperator jo = new jumppingoperator();\n           jumpping j = new cat();\n           jo.usejumpping(j);\n   \n           jumpping j2 = jo.getjumpping(); //new cat()\n           j2.jump();\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   ',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"内部类",frontmatter:{title:"内部类",date:"2023-02-26T08:39:34.000Z",permalink:"/pages/646bcb/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/05.%E5%86%85%E9%83%A8%E7%B1%BB.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/05.内部类.md",key:"v-f9f336e8",path:"/pages/646bcb/",headers:[{level:2,title:"1. 内部类的基本使用",slug:"_1-内部类的基本使用",normalizedTitle:"1. 内部类的基本使用",charIndex:10},{level:2,title:"2. 成员内部类",slug:"_2-成员内部类",normalizedTitle:"2. 成员内部类",charIndex:986},{level:2,title:"3. 局部内部类",slug:"_3-局部内部类",normalizedTitle:"3. 局部内部类",charIndex:1873},{level:2,title:"2.4 匿名内部类",slug:"_2-4-匿名内部类",normalizedTitle:"2.4 匿名内部类",charIndex:2656},{level:2,title:"2.4 匿名内部类在开发中的使用",slug:"_2-4-匿名内部类在开发中的使用",normalizedTitle:"2.4 匿名内部类在开发中的使用",charIndex:3610}],headersStr:"1. 内部类的基本使用 2. 成员内部类 3. 局部内部类 2.4 匿名内部类 2.4 匿名内部类在开发中的使用",content:'# 内部类\n\n\n# 1. 内部类的基本使用\n\n * 内部类概念\n   \n   * 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类\n\n * 内部类定义格式\n   \n   * 格式&举例：\n     \n     /*\n     \t格式：\n         class 外部类名{\n         \t修饰符 class 内部类名{\n         \t\n         \t}\n         }\n     */\n     \n     class Outer {\n         public class Inner {\n             \n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     \n\n * 内部类的访问特点\n   \n   * 内部类可以直接访问外部类的成员，包括私有\n   * 外部类要访问内部类的成员，必须创建对象\n\n * 示例代码：\n   \n   /*\n       内部类访问特点：\n           内部类可以直接访问外部类的成员，包括私有\n           外部类要访问内部类的成员，必须创建对象\n    */\n   public class Outer {\n       private int num = 10;\n       public class Inner {\n           public void show() {\n               System.out.println(num);\n           }\n       }\n       public void method() {\n           Inner i = new Inner();\n           i.show();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n\n# 2. 成员内部类\n\n * 成员内部类的定义位置\n   \n   * 在类中方法，跟成员变量是一个位置\n\n * 外界创建成员内部类格式\n   \n   * 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;\n   * 举例：Outer.Inner oi = new Outer().new Inner();\n\n * 成员内部类的推荐使用方案\n   \n   * 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。\n\n * 示例代码：\n   \n   class Outer {\n       private int num = 10;\n       private class Inner {\n           public void show() {\n               System.out.println(num);\n           }\n       }\n       public void method() {\n           Inner i = new Inner();\n           i.show();\n       }\n   }\n   public class InnerDemo {\n       public static void main(String[] args) {\n   \t\t//Outer.Inner oi = new Outer().new Inner();\n   \t\t//oi.show();\n           Outer o = new Outer();\n           o.method();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 3. 局部内部类\n\n * 局部内部类定义位置\n   \n   * 局部内部类是在方法中定义的类\n\n * 局部内部类方式方式\n   \n   * 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用\n   * 该类可以直接访问外部类的成员，也可以访问方法内的局部变量\n\n * 示例代码\n   \n   class Outer {\n       private int num = 10;\n       public void method() {\n           int num2 = 20;\n           class Inner {\n               public void show() {\n                   System.out.println(num);\n                   System.out.println(num2);\n               }\n           }\n           Inner i = new Inner();\n           i.show();\n       }\n   }\n   public class OuterDemo {\n       public static void main(String[] args) {\n           Outer o = new Outer();\n           o.method();\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 2.4 匿名内部类\n\n * 匿名内部类的前提\n   \n   * 存在一个类或者接口，这里的类可以是具体类也可以是抽象类\n\n * 匿名内部类的格式\n   \n   * 格式：new 类名 ( ) { 重写方法 } new 接口名 ( ) { 重写方法 }\n   \n   * 举例：\n     \n     new Inter(){\n         @Override\n         public void method(){}\n     } \n     \n     \n     1\n     2\n     3\n     4\n     \n\n * 匿名内部类的本质\n   \n   * 本质：是一个继承了该类或者实现了该接口的子类匿名对象\n\n * 匿名内部类的细节\n   \n   * 匿名内部类可以通过多态的形式接受\n     \n     Inter i = new Inter(){\n       @Override\n         public void method(){\n             \n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n\n * 匿名内部类直接调用方法\n   \n   interface Inter{\n       void method();\n   }\n   \n   class Test{\n       public static void main(String[] args){\n           new Inter(){\n               @Override\n               public void method(){\n                   System.out.println("我是匿名内部类");\n               }\n           }.method();\t// 直接调用方法\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n\n# 2.4 匿名内部类在开发中的使用\n\n * 匿名内部类在开发中的使用\n   \n   * 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码\n\n * 示例代码：\n   \n   interface Jumpping {\n       void jump();\n   }\n   class Cat implements Jumpping {\n       @Override\n       public void jump() {\n           System.out.println("猫可以跳高了");\n       }\n   }\n   class Dog implements Jumpping {\n       @Override\n       public void jump() {\n           System.out.println("狗可以跳高了");\n       }\n   }\n   class JumppingOperator {\n       public void method(Jumpping j) { //new Cat();   new Dog();\n           j.jump();\n       }\n   }\n   class JumppingDemo {\n       public static void main(String[] args) {\n           //需求：创建接口操作类的对象，调用method方法\n           JumppingOperator jo = new JumppingOperator();\n           Jumpping j = new Cat();\n           jo.method(j);\n   \n           Jumpping j2 = new Dog();\n           jo.method(j2);\n           System.out.println("--------");\n   \n           // 匿名内部类的简化\n           jo.method(new Jumpping() {\n               @Override\n               public void jump() {\n                   System.out.println("猫可以跳高了");\n               }\n           });\n   \t\t// 匿名内部类的简化\n           jo.method(new Jumpping() {\n               @Override\n               public void jump() {\n                   System.out.println("狗可以跳高了");\n               }\n           });\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   ',normalizedContent:'# 内部类\n\n\n# 1. 内部类的基本使用\n\n * 内部类概念\n   \n   * 在一个类中定义一个类。举例：在一个类a的内部定义一个类b，类b就被称为内部类\n\n * 内部类定义格式\n   \n   * 格式&举例：\n     \n     /*\n     \t格式：\n         class 外部类名{\n         \t修饰符 class 内部类名{\n         \t\n         \t}\n         }\n     */\n     \n     class outer {\n         public class inner {\n             \n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     \n\n * 内部类的访问特点\n   \n   * 内部类可以直接访问外部类的成员，包括私有\n   * 外部类要访问内部类的成员，必须创建对象\n\n * 示例代码：\n   \n   /*\n       内部类访问特点：\n           内部类可以直接访问外部类的成员，包括私有\n           外部类要访问内部类的成员，必须创建对象\n    */\n   public class outer {\n       private int num = 10;\n       public class inner {\n           public void show() {\n               system.out.println(num);\n           }\n       }\n       public void method() {\n           inner i = new inner();\n           i.show();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n\n# 2. 成员内部类\n\n * 成员内部类的定义位置\n   \n   * 在类中方法，跟成员变量是一个位置\n\n * 外界创建成员内部类格式\n   \n   * 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;\n   * 举例：outer.inner oi = new outer().new inner();\n\n * 成员内部类的推荐使用方案\n   \n   * 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。\n\n * 示例代码：\n   \n   class outer {\n       private int num = 10;\n       private class inner {\n           public void show() {\n               system.out.println(num);\n           }\n       }\n       public void method() {\n           inner i = new inner();\n           i.show();\n       }\n   }\n   public class innerdemo {\n       public static void main(string[] args) {\n   \t\t//outer.inner oi = new outer().new inner();\n   \t\t//oi.show();\n           outer o = new outer();\n           o.method();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 3. 局部内部类\n\n * 局部内部类定义位置\n   \n   * 局部内部类是在方法中定义的类\n\n * 局部内部类方式方式\n   \n   * 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用\n   * 该类可以直接访问外部类的成员，也可以访问方法内的局部变量\n\n * 示例代码\n   \n   class outer {\n       private int num = 10;\n       public void method() {\n           int num2 = 20;\n           class inner {\n               public void show() {\n                   system.out.println(num);\n                   system.out.println(num2);\n               }\n           }\n           inner i = new inner();\n           i.show();\n       }\n   }\n   public class outerdemo {\n       public static void main(string[] args) {\n           outer o = new outer();\n           o.method();\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 2.4 匿名内部类\n\n * 匿名内部类的前提\n   \n   * 存在一个类或者接口，这里的类可以是具体类也可以是抽象类\n\n * 匿名内部类的格式\n   \n   * 格式：new 类名 ( ) { 重写方法 } new 接口名 ( ) { 重写方法 }\n   \n   * 举例：\n     \n     new inter(){\n         @override\n         public void method(){}\n     } \n     \n     \n     1\n     2\n     3\n     4\n     \n\n * 匿名内部类的本质\n   \n   * 本质：是一个继承了该类或者实现了该接口的子类匿名对象\n\n * 匿名内部类的细节\n   \n   * 匿名内部类可以通过多态的形式接受\n     \n     inter i = new inter(){\n       @override\n         public void method(){\n             \n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n\n * 匿名内部类直接调用方法\n   \n   interface inter{\n       void method();\n   }\n   \n   class test{\n       public static void main(string[] args){\n           new inter(){\n               @override\n               public void method(){\n                   system.out.println("我是匿名内部类");\n               }\n           }.method();\t// 直接调用方法\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n\n# 2.4 匿名内部类在开发中的使用\n\n * 匿名内部类在开发中的使用\n   \n   * 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码\n\n * 示例代码：\n   \n   interface jumpping {\n       void jump();\n   }\n   class cat implements jumpping {\n       @override\n       public void jump() {\n           system.out.println("猫可以跳高了");\n       }\n   }\n   class dog implements jumpping {\n       @override\n       public void jump() {\n           system.out.println("狗可以跳高了");\n       }\n   }\n   class jumppingoperator {\n       public void method(jumpping j) { //new cat();   new dog();\n           j.jump();\n       }\n   }\n   class jumppingdemo {\n       public static void main(string[] args) {\n           //需求：创建接口操作类的对象，调用method方法\n           jumppingoperator jo = new jumppingoperator();\n           jumpping j = new cat();\n           jo.method(j);\n   \n           jumpping j2 = new dog();\n           jo.method(j2);\n           system.out.println("--------");\n   \n           // 匿名内部类的简化\n           jo.method(new jumpping() {\n               @override\n               public void jump() {\n                   system.out.println("猫可以跳高了");\n               }\n           });\n   \t\t// 匿名内部类的简化\n           jo.method(new jumpping() {\n               @override\n               public void jump() {\n                   system.out.println("狗可以跳高了");\n               }\n           });\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   ',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"异常",frontmatter:{title:"异常",date:"2023-02-26T11:01:47.000Z",permalink:"/pages/98887c/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/06.%E5%BC%82%E5%B8%B8.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/06.异常.md",key:"v-526b6042",path:"/pages/98887c/",headers:[{level:2,title:"0. 异常基础(学习)",slug:"_0-异常基础-学习",normalizedTitle:"0. 异常基础(学习)",charIndex:265},{level:3,title:"0.1异常",slug:"_0-1异常",normalizedTitle:"0.1异常",charIndex:281},{level:3,title:"0.2 JVM默认处理异常的方式",slug:"_0-2-jvm默认处理异常的方式",normalizedTitle:"0.2 jvm默认处理异常的方式",charIndex:344},{level:3,title:"0.3 try-catch方式处理异常",slug:"_0-3-try-catch方式处理异常",normalizedTitle:"0.3 try-catch方式处理异常",charIndex:461},{level:3,title:"0.4 Throwable成员方法",slug:"_0-4-throwable成员方法",normalizedTitle:"0.4 throwable成员方法",charIndex:1370},{level:3,title:"0.5 编译时异常和运行时异常的区别",slug:"_0-5-编译时异常和运行时异常的区别",normalizedTitle:"0.5 编译时异常和运行时异常的区别",charIndex:3122},{level:3,title:"0.6 Throws方式处理异常",slug:"_0-6-throws方式处理异常",normalizedTitle:"0.6 throws方式处理异常",charIndex:3280},{level:3,title:"0.7 Throws和Throw的区别",slug:"_0-7-throws和throw的区别",normalizedTitle:"0.7 throws和throw的区别",charIndex:4467},{level:3,title:"0.8 自定义异常",slug:"_0-8-自定义异常",normalizedTitle:"0.8 自定义异常",charIndex:4493},{level:2,title:"1. 认识Exception",slug:"_1-认识exception",normalizedTitle:"1. 认识exception",charIndex:5672},{level:2,title:"2. 什么是Throwable",slug:"_2-什么是throwable",normalizedTitle:"2. 什么是throwable",charIndex:5820},{level:2,title:"3. 常见的Exception",slug:"_3-常见的exception",normalizedTitle:"3. 常见的exception",charIndex:6932},{level:2,title:"4. 与Exception有关的Java关键字",slug:"_4-与exception有关的java关键字",normalizedTitle:"4. 与exception有关的java关键字",charIndex:7697},{level:3,title:"4.1 throws 和 throw",slug:"_4-1-throws-和-throw",normalizedTitle:"4.1 throws 和 throw",charIndex:7801},{level:3,title:"4.2 try、finally、catch",slug:"_4-2-try、finally、catch",normalizedTitle:"4.2 try、finally、catch",charIndex:8147},{level:4,title:"1. try...catch",slug:"_1-try-catch",normalizedTitle:"1. try...catch",charIndex:8239},{level:4,title:"2. try...finally",slug:"_2-try-finally",normalizedTitle:"2. try...finally",charIndex:8448},{level:4,title:"3. try...catch...finally",slug:"_3-try-catch-finally",normalizedTitle:"3. try...catch...finally",charIndex:8805},{level:2,title:"5. 什么是Error",slug:"_5-什么是error",normalizedTitle:"5. 什么是error",charIndex:8888}],headersStr:"0. 异常基础(学习) 0.1异常 0.2 JVM默认处理异常的方式 0.3 try-catch方式处理异常 0.4 Throwable成员方法 0.5 编译时异常和运行时异常的区别 0.6 Throws方式处理异常 0.7 Throws和Throw的区别 0.8 自定义异常 1. 认识Exception 2. 什么是Throwable 3. 常见的Exception 4. 与Exception有关的Java关键字 4.1 throws 和 throw 4.2 try、finally、catch 1. try...catch 2. try...finally 3. try...catch...finally 5. 什么是Error",content:'# 异常\n\n异常是程序经常会出现的，发现错误的最佳时机是在编译阶段，也就是你试图在运行程序之前。但是， 在编译期间并不能找到所有的错误，有一些NullPointerException和ClassNotFoundException异常在编译期找不到，这些异常是RuntimeException运行时异常，这些 异常往往在运行时才能被发现。\n\n我们写Java程序经常会出现两种问题，一种是java.Iang.Exception，—种是java.Iang.Error，都用来 表示出现了异常情况，下面就针对这两种概念进行理解。\n\n\n# 0. 异常基础(学习)\n\n\n# 0.1异常\n\n * 异常的概述\n   \n   异常就是程序出现了不正常的情况\n\n * 异常的体系结构\n   \n   \n\n\n# 0.2 JVM默认处理异常的方式\n\n * 如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤：\n\n * 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台\n\n * 程序停止执行\n\n\n# 0.3 try-catch方式处理异常\n\n * 定义格式\n   \n   try {\n   \t可能出现异常的代码;\n   } catch(异常类名 变量名) {\n   \t异常的处理代码;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 执行流程\n   \n   * 程序从 try 里面的代码开始执行\n   * 出现异常，就会跳转到对应的 catch 里面去执行\n   * 执行完毕之后，程序还可以继续往下执行\n\n * 示例代码\n   \n   public class ExceptionDemo01 {\n       public static void main(String[] args) {\n           System.out.println("开始");\n           method();\n           System.out.println("结束");\n       }\n   \n       public static void method() {\n           try {\n               int[] arr = {1, 2, 3};\n               System.out.println(arr[3]);\n               System.out.println("这里能够访问到吗");\n           } catch (ArrayIndexOutOfBoundsException e) {\n   //            System.out.println("你访问的数组索引不存在，请回去修改为正确的索引");\n               e.printStackTrace();\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 0.4 Throwable成员方法\n\n * 常用方法\n   \n   方法名                             说明\n   public String getMessage()      返回此 throwable 的详细消息字符串\n   public String toString()        返回此可抛出的简短描述\n   public void printStackTrace()   把异常的错误信息输出在控制台\n\n * 示例代码\n   \n   public class ExceptionDemo02 {\n       public static void main(String[] args) {\n           System.out.println("开始");\n           method();\n           System.out.println("结束");\n       }\n   \n       public static void method() {\n           try {\n               int[] arr = {1, 2, 3};\n               System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException();\n               System.out.println("这里能够访问到吗");\n           } catch (ArrayIndexOutOfBoundsException e) { //new ArrayIndexOutOfBoundsException();\n   //            e.printStackTrace();\n   \n               //public String getMessage():返回此 throwable 的详细消息字符串\n   //            System.out.println(e.getMessage());\n               //Index 3 out of bounds for length 3\n   \n               //public String toString():返回此可抛出的简短描述\n   //            System.out.println(e.toString());\n               //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n   \n               //public void printStackTrace():把异常的错误信息输出在控制台\n               e.printStackTrace();\n   //            java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n   //            at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)\n   //            at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11)\n   \n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n\n# 0.5 编译时异常和运行时异常的区别\n\n * 编译时异常\n   \n   * 都是Exception类及其子类\n   * 必须显示处理，否则程序就会发生错误，无法通过编译\n\n * 运行时异常\n   \n   * 都是RuntimeException类及其子类\n   * 无需显示处理，也可以和编译时异常一样处理\n\n\n# 0.6 Throws方式处理异常\n\n * 定义格式\n   \n   public void 方法() throws 异常类名 {\n       \n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 示例代码\n   \n   public class ExceptionDemo {\n       public static void main(String[] args) {\n           System.out.println("开始");\n   //        method();\n           try {\n               method2();\n           }catch (ParseException e) {\n               e.printStackTrace();\n           }\n           System.out.println("结束");\n       }\n   \n       //编译时异常\n       public static void method2() throws ParseException {\n           String s = "2048-08-09";\n           SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n           Date d = sdf.parse(s);\n           System.out.println(d);\n       }\n   \n       //运行时异常\n       public static void method() throws ArrayIndexOutOfBoundsException {\n           int[] arr = {1, 2, 3};\n           System.out.println(arr[3]);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n * 注意事项\n   \n   * 这个throws格式是跟在方法的括号后面的\n   * 编译时异常必须要进行处理，两种处理方案：try...catch …或者 throws，如果采用 throws 这种方案，将来谁调用谁处理\n   * 运行时异常可以不处理，出现问题后，需要我们回来修改代码\n\n\n# 0.7 Throws和Throw的区别\n\n\n\n\n# 0.8 自定义异常\n\n * 自定义异常类\n   \n   public class ScoreException extends Exception {\n   \n       public ScoreException() {}\n   \n       public ScoreException(String message) {\n           super(message);\n       }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 老师类\n   \n   public class Teacher {\n       public void checkScore(int score) throws ScoreException {\n           if(score<0 || score>100) {\n   //            throw new ScoreException();\n               throw new ScoreException("你给的分数有误，分数应该在0-100之间");\n           } else {\n               System.out.println("成绩正常");\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * 测试类\n   \n   public class Demo {\n       public static void main(String[] args) {\n           Scanner sc = new Scanner(System.in);\n           System.out.println("请输入分数：");\n   \n           int score = sc.nextInt();\n   \n           Teacher t = new Teacher();\n           try {\n               t.checkScore(score);\n           } catch (ScoreException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n\n# 1. 认识Exception\n\nException位于java.lang包下，它是一种顶级接口，继承于Throwable类，Exception类及 其子类都是Throwable的组成条件，是程序出现的合理情况。\n\n在认识Exception之前，有必要先了解一下什么是Throwable.\n\n\n# 2. 什么是Throwable\n\nThrowable类是Java语言中所有错误(errors)和异常(exceptions)的父类。只有继承于 Throwable的类或者其子类才能够被抛出，还有一种方式是带有Java中的@throw注解的类也可以 抛出。\n\n在Java规范中，对非受查异常和受查异常的定义是这样的：\n\n> The unchecked exception classes are the run-time exception classes and the error classes.\n> \n> The checked exception classes are all exception classes other than the unchecked exception classes. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses.\n\n也就是说，除了 RuntimeException和其子类，以及error和其子类，其它的所有异常都是 checkedException\n\n那么，按照这种逻辑关系，我们可以对Throwable及其子类进行归类分析\n\n\n\n可以看到，Throwable位于异常和错误的最顶层，我们查看Throwable类中发现它的方法和属性有很 多，我们只讨论其中几个比较常用的\n\n//返回抛出异常的详细信息\npublic string getMessage();\npublic string getLocalizedMessage();\n//返回异常发生时的简要描述\npublic public String toString()Ҕ\n//返回异常发生时的简要描述\npublic void printStackTrace();\npublic void printStackTrace(PrintStream s);\npublic void printStackTrace(PrintWriter s)\n//记录栈帧的的当前状态\npublic synchronized Throwable fillInStackTrace();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n此外，因为Throwable的父类也是Object，所以常用的方法还有继承其父类的getClass()。和 getName()方法。\n\n\n# 3. 常见的Exception\n\n下面我们回到Exception的探讨上来，现在你知道了 Exception的父类是Throwable,并且Exception 有两种异常，一种是RuntimeException ；—种是CheckedException，这两种异常都应该去捕获。\n\n下面列出了一些Java中常见的异常及其分类，这块面试官也可能让你举出几个常见的异常情况并将其分类\n\n * RuntimeException\n\n序号   异常名称                             异常描述\n1    ArraylndexOutOfBoundsException   数组越界异常\n2    NullPointerException             空指针异常\n3    HlegalArgumentException          非法参数异常\n4    NegativeArraySizeException       数组长度为负异常\n5    HlegalStateException             非法状态异常\n6    ClassCastException               类型转换异常\n\n * UncheckedException\n\n序号   异常名称                     异常描述\n1    NoSuchFieldException     表示该类没有指定名称抛出来的异常\n2    NoSuchMethod Exception   表示该类没有指定方法抛出来的异常\n3    HlegalAccessException    不允许访问某个类的异常\n4    ClassNotFoundException   类没有找到抛出异常\n\n\n# 4. 与Exception有关的Java关键字\n\n那么Java中是如何处理这些异常的呢？在Java中有这几个关键字throws、throw、try、finally、 catch下面我们分别来探讨一下\n\n\n# 4.1 throws 和 throw\n\n在Java中，异常也就是一个对象，它能够被程序员自定义抛出或者应用程序抛出，必须借助于 throws和throw语句来定义抛出异常。\n\nthrows和throw通常是成对出现的，例如\n\nstatic void cacheException() throws Exception{\n throw new Exception();\n}\n\n\n1\n2\n3\n\n\nthrow语句用在方法体内，表示抛出异常，由方法体内的语句处理。throws语句用在方法声明后面， 表示再抛出异常，由该方法的调用者来处理。\n\nthrows主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。throw是具 体向外抛异常的动作，所以它是抛出一个异常实例。\n\n\n# 4.2 try、finally、catch\n\n这三个关键字主要有下面几种组合方式try...catch、try...finally、try...catch...finally。\n\n# 1. try...catch\n\ntry...catch表示对某一段代码可能抛出异常进行的捕获，如下\n\nstatic void cacheException() throws Exception{\n try {\n     System.out.println("1");\n }catch (Exception e){\n     e.printStackTrace();\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2. try...finally\n\ntry...finally表示对一段代码不管执行情况如何，都会走finally中的代码\n\nstatic void cacheException() throws Exception{\n for (int i = 0; i < 5; i++) {\n     System.out.println("enter: i=" + i);\n     try {\n     \tSystem.out.println("execute: i=" + i);\n     \tcontinue;\n     } finally {\n     \tSystem.out.println("leave: i=" + i);\n     }\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 3. try...catch...finally\n\ntry...catch...finally也是一样的，表示对异常捕获后，再走finally中的代码逻辑。\n\n\n# 5. 什么是Error\n\nError是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作 无关，而表示代码运行时JVM (Java虚拟机)出现的问题。这些错误是不可检查的，因为它们在应用 程序的控制和处理能力之夕卜，而且绝大多数是程序运行时不允许出现的状况，比如\n\nOutOfMemoryError和StackOverflowError异常的出现会有几种情况，这里需要先介绍一下 Java内存模型JDK1.7。\n\n\n\n其中包括两部分，由所有线程共享的数据区和线程隔离的数据区组成，在上面的Java内存模型中，只 有程序计数器是不会发生OutOfMemoryError情况的区域，程序计数器控制着计算机指令的分支、 循环、跳转、异常处理和线程恢复，并且程序计数器是每个线程私有的。\n\n> 什么是线程私有：表示的就是各条线程之间互不影响，独立存储的内存区域。\n\n如果应用程序执行的是Java方法，那么这个计数器记录的就是虚拟机字节码指令的地址；如果正在执 行的是Native方法，这个计数器值则为空(Undefined)。\n\n除了程序计数器外，其他区域：方法区(Method Area)、虚拟机栈(VM Stack)、本地方法栈 (Native Method Stack)和堆(Heap)都是可能发生 OutOfMemoryError 的区域。\n\n * 虚拟机栈：如果线程请求的栈深度大于虚拟机栈所允许的深度，将会出现 StackOverflowError异常；如果虚拟机动态扩展无法申请到足够的内存，将出现 OutOfMemoryError 。\n\n * 本地方法栈和虚拟机栈一样\n\n * 堆：Java堆可以处于物理上不连续，逻辑上连续，就像我们的磁盘空间一样，如果堆中没有内存 完成实例分配，并且堆无法扩展时，将会抛出OutOfMemoryError。\n\n * 方法区：方法区无法满足内存分配需求时，将抛出。utOfMemoryError异常。\n\n在Java中，你可以把异常理解为是一种能够提高你程序健壮性的机制，它能够让你在编写代码中注意 这些问题，也可以说，如果你写代码不会注意这些异常情况，你是无法成为一位硬核程序员的。',normalizedContent:'# 异常\n\n异常是程序经常会出现的，发现错误的最佳时机是在编译阶段，也就是你试图在运行程序之前。但是， 在编译期间并不能找到所有的错误，有一些nullpointerexception和classnotfoundexception异常在编译期找不到，这些异常是runtimeexception运行时异常，这些 异常往往在运行时才能被发现。\n\n我们写java程序经常会出现两种问题，一种是java.iang.exception，—种是java.iang.error，都用来 表示出现了异常情况，下面就针对这两种概念进行理解。\n\n\n# 0. 异常基础(学习)\n\n\n# 0.1异常\n\n * 异常的概述\n   \n   异常就是程序出现了不正常的情况\n\n * 异常的体系结构\n   \n   \n\n\n# 0.2 jvm默认处理异常的方式\n\n * 如果程序出现了问题，我们没有做任何处理，最终jvm 会做默认的处理，处理方式有如下两个步骤：\n\n * 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台\n\n * 程序停止执行\n\n\n# 0.3 try-catch方式处理异常\n\n * 定义格式\n   \n   try {\n   \t可能出现异常的代码;\n   } catch(异常类名 变量名) {\n   \t异常的处理代码;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 执行流程\n   \n   * 程序从 try 里面的代码开始执行\n   * 出现异常，就会跳转到对应的 catch 里面去执行\n   * 执行完毕之后，程序还可以继续往下执行\n\n * 示例代码\n   \n   public class exceptiondemo01 {\n       public static void main(string[] args) {\n           system.out.println("开始");\n           method();\n           system.out.println("结束");\n       }\n   \n       public static void method() {\n           try {\n               int[] arr = {1, 2, 3};\n               system.out.println(arr[3]);\n               system.out.println("这里能够访问到吗");\n           } catch (arrayindexoutofboundsexception e) {\n   //            system.out.println("你访问的数组索引不存在，请回去修改为正确的索引");\n               e.printstacktrace();\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 0.4 throwable成员方法\n\n * 常用方法\n   \n   方法名                             说明\n   public string getmessage()      返回此 throwable 的详细消息字符串\n   public string tostring()        返回此可抛出的简短描述\n   public void printstacktrace()   把异常的错误信息输出在控制台\n\n * 示例代码\n   \n   public class exceptiondemo02 {\n       public static void main(string[] args) {\n           system.out.println("开始");\n           method();\n           system.out.println("结束");\n       }\n   \n       public static void method() {\n           try {\n               int[] arr = {1, 2, 3};\n               system.out.println(arr[3]); //new arrayindexoutofboundsexception();\n               system.out.println("这里能够访问到吗");\n           } catch (arrayindexoutofboundsexception e) { //new arrayindexoutofboundsexception();\n   //            e.printstacktrace();\n   \n               //public string getmessage():返回此 throwable 的详细消息字符串\n   //            system.out.println(e.getmessage());\n               //index 3 out of bounds for length 3\n   \n               //public string tostring():返回此可抛出的简短描述\n   //            system.out.println(e.tostring());\n               //java.lang.arrayindexoutofboundsexception: index 3 out of bounds for length 3\n   \n               //public void printstacktrace():把异常的错误信息输出在控制台\n               e.printstacktrace();\n   //            java.lang.arrayindexoutofboundsexception: index 3 out of bounds for length 3\n   //            at com.itheima_02.exceptiondemo02.method(exceptiondemo02.java:18)\n   //            at com.itheima_02.exceptiondemo02.main(exceptiondemo02.java:11)\n   \n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n\n# 0.5 编译时异常和运行时异常的区别\n\n * 编译时异常\n   \n   * 都是exception类及其子类\n   * 必须显示处理，否则程序就会发生错误，无法通过编译\n\n * 运行时异常\n   \n   * 都是runtimeexception类及其子类\n   * 无需显示处理，也可以和编译时异常一样处理\n\n\n# 0.6 throws方式处理异常\n\n * 定义格式\n   \n   public void 方法() throws 异常类名 {\n       \n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 示例代码\n   \n   public class exceptiondemo {\n       public static void main(string[] args) {\n           system.out.println("开始");\n   //        method();\n           try {\n               method2();\n           }catch (parseexception e) {\n               e.printstacktrace();\n           }\n           system.out.println("结束");\n       }\n   \n       //编译时异常\n       public static void method2() throws parseexception {\n           string s = "2048-08-09";\n           simpledateformat sdf = new simpledateformat("yyyy-mm-dd");\n           date d = sdf.parse(s);\n           system.out.println(d);\n       }\n   \n       //运行时异常\n       public static void method() throws arrayindexoutofboundsexception {\n           int[] arr = {1, 2, 3};\n           system.out.println(arr[3]);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n * 注意事项\n   \n   * 这个throws格式是跟在方法的括号后面的\n   * 编译时异常必须要进行处理，两种处理方案：try...catch …或者 throws，如果采用 throws 这种方案，将来谁调用谁处理\n   * 运行时异常可以不处理，出现问题后，需要我们回来修改代码\n\n\n# 0.7 throws和throw的区别\n\n\n\n\n# 0.8 自定义异常\n\n * 自定义异常类\n   \n   public class scoreexception extends exception {\n   \n       public scoreexception() {}\n   \n       public scoreexception(string message) {\n           super(message);\n       }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 老师类\n   \n   public class teacher {\n       public void checkscore(int score) throws scoreexception {\n           if(score<0 || score>100) {\n   //            throw new scoreexception();\n               throw new scoreexception("你给的分数有误，分数应该在0-100之间");\n           } else {\n               system.out.println("成绩正常");\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * 测试类\n   \n   public class demo {\n       public static void main(string[] args) {\n           scanner sc = new scanner(system.in);\n           system.out.println("请输入分数：");\n   \n           int score = sc.nextint();\n   \n           teacher t = new teacher();\n           try {\n               t.checkscore(score);\n           } catch (scoreexception e) {\n               e.printstacktrace();\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n\n# 1. 认识exception\n\nexception位于java.lang包下，它是一种顶级接口，继承于throwable类，exception类及 其子类都是throwable的组成条件，是程序出现的合理情况。\n\n在认识exception之前，有必要先了解一下什么是throwable.\n\n\n# 2. 什么是throwable\n\nthrowable类是java语言中所有错误(errors)和异常(exceptions)的父类。只有继承于 throwable的类或者其子类才能够被抛出，还有一种方式是带有java中的@throw注解的类也可以 抛出。\n\n在java规范中，对非受查异常和受查异常的定义是这样的：\n\n> the unchecked exception classes are the run-time exception classes and the error classes.\n> \n> the checked exception classes are all exception classes other than the unchecked exception classes. that is, the checked exception classes are throwable and all its subclasses other than runtimeexception and its subclasses and error and its subclasses.\n\n也就是说，除了 runtimeexception和其子类，以及error和其子类，其它的所有异常都是 checkedexception\n\n那么，按照这种逻辑关系，我们可以对throwable及其子类进行归类分析\n\n\n\n可以看到，throwable位于异常和错误的最顶层，我们查看throwable类中发现它的方法和属性有很 多，我们只讨论其中几个比较常用的\n\n//返回抛出异常的详细信息\npublic string getmessage();\npublic string getlocalizedmessage();\n//返回异常发生时的简要描述\npublic public string tostring()ҕ\n//返回异常发生时的简要描述\npublic void printstacktrace();\npublic void printstacktrace(printstream s);\npublic void printstacktrace(printwriter s)\n//记录栈帧的的当前状态\npublic synchronized throwable fillinstacktrace();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n此外，因为throwable的父类也是object，所以常用的方法还有继承其父类的getclass()。和 getname()方法。\n\n\n# 3. 常见的exception\n\n下面我们回到exception的探讨上来，现在你知道了 exception的父类是throwable,并且exception 有两种异常，一种是runtimeexception ；—种是checkedexception，这两种异常都应该去捕获。\n\n下面列出了一些java中常见的异常及其分类，这块面试官也可能让你举出几个常见的异常情况并将其分类\n\n * runtimeexception\n\n序号   异常名称                             异常描述\n1    arraylndexoutofboundsexception   数组越界异常\n2    nullpointerexception             空指针异常\n3    hlegalargumentexception          非法参数异常\n4    negativearraysizeexception       数组长度为负异常\n5    hlegalstateexception             非法状态异常\n6    classcastexception               类型转换异常\n\n * uncheckedexception\n\n序号   异常名称                     异常描述\n1    nosuchfieldexception     表示该类没有指定名称抛出来的异常\n2    nosuchmethod exception   表示该类没有指定方法抛出来的异常\n3    hlegalaccessexception    不允许访问某个类的异常\n4    classnotfoundexception   类没有找到抛出异常\n\n\n# 4. 与exception有关的java关键字\n\n那么java中是如何处理这些异常的呢？在java中有这几个关键字throws、throw、try、finally、 catch下面我们分别来探讨一下\n\n\n# 4.1 throws 和 throw\n\n在java中，异常也就是一个对象，它能够被程序员自定义抛出或者应用程序抛出，必须借助于 throws和throw语句来定义抛出异常。\n\nthrows和throw通常是成对出现的，例如\n\nstatic void cacheexception() throws exception{\n throw new exception();\n}\n\n\n1\n2\n3\n\n\nthrow语句用在方法体内，表示抛出异常，由方法体内的语句处理。throws语句用在方法声明后面， 表示再抛出异常，由该方法的调用者来处理。\n\nthrows主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。throw是具 体向外抛异常的动作，所以它是抛出一个异常实例。\n\n\n# 4.2 try、finally、catch\n\n这三个关键字主要有下面几种组合方式try...catch、try...finally、try...catch...finally。\n\n# 1. try...catch\n\ntry...catch表示对某一段代码可能抛出异常进行的捕获，如下\n\nstatic void cacheexception() throws exception{\n try {\n     system.out.println("1");\n }catch (exception e){\n     e.printstacktrace();\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2. try...finally\n\ntry...finally表示对一段代码不管执行情况如何，都会走finally中的代码\n\nstatic void cacheexception() throws exception{\n for (int i = 0; i < 5; i++) {\n     system.out.println("enter: i=" + i);\n     try {\n     \tsystem.out.println("execute: i=" + i);\n     \tcontinue;\n     } finally {\n     \tsystem.out.println("leave: i=" + i);\n     }\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 3. try...catch...finally\n\ntry...catch...finally也是一样的，表示对异常捕获后，再走finally中的代码逻辑。\n\n\n# 5. 什么是error\n\nerror是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作 无关，而表示代码运行时jvm (java虚拟机)出现的问题。这些错误是不可检查的，因为它们在应用 程序的控制和处理能力之夕卜，而且绝大多数是程序运行时不允许出现的状况，比如\n\noutofmemoryerror和stackoverflowerror异常的出现会有几种情况，这里需要先介绍一下 java内存模型jdk1.7。\n\n\n\n其中包括两部分，由所有线程共享的数据区和线程隔离的数据区组成，在上面的java内存模型中，只 有程序计数器是不会发生outofmemoryerror情况的区域，程序计数器控制着计算机指令的分支、 循环、跳转、异常处理和线程恢复，并且程序计数器是每个线程私有的。\n\n> 什么是线程私有：表示的就是各条线程之间互不影响，独立存储的内存区域。\n\n如果应用程序执行的是java方法，那么这个计数器记录的就是虚拟机字节码指令的地址；如果正在执 行的是native方法，这个计数器值则为空(undefined)。\n\n除了程序计数器外，其他区域：方法区(method area)、虚拟机栈(vm stack)、本地方法栈 (native method stack)和堆(heap)都是可能发生 outofmemoryerror 的区域。\n\n * 虚拟机栈：如果线程请求的栈深度大于虚拟机栈所允许的深度，将会出现 stackoverflowerror异常；如果虚拟机动态扩展无法申请到足够的内存，将出现 outofmemoryerror 。\n\n * 本地方法栈和虚拟机栈一样\n\n * 堆：java堆可以处于物理上不连续，逻辑上连续，就像我们的磁盘空间一样，如果堆中没有内存 完成实例分配，并且堆无法扩展时，将会抛出outofmemoryerror。\n\n * 方法区：方法区无法满足内存分配需求时，将抛出。utofmemoryerror异常。\n\n在java中，你可以把异常理解为是一种能够提高你程序健壮性的机制，它能够让你在编写代码中注意 这些问题，也可以说，如果你写代码不会注意这些异常情况，你是无法成为一位硬核程序员的。',charsets:{cyrillic:!0,cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"数组",frontmatter:{title:"数组",date:"2023-02-26T14:26:42.000Z",permalink:"/pages/5a582f/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/08.%E6%95%B0%E7%BB%84.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/08.数组.md",key:"v-74b46c48",path:"/pages/5a582f/",headers:[{level:2,title:"1. 数组基础知识：",slug:"_1-数组基础知识",normalizedTitle:"1. 数组基础知识：",charIndex:71},{level:3,title:"1.1 什么是数组?",slug:"_1-1-什么是数组",normalizedTitle:"1.1 什么是数组?",charIndex:86},{level:3,title:"1.2 一维数组",slug:"_1-2-一维数组",normalizedTitle:"1.2 一维数组",charIndex:460},{level:4,title:"1. 一维数组声明与创建：",slug:"_1-一维数组声明与创建",normalizedTitle:"1. 一维数组声明与创建：",charIndex:472},{level:4,title:"2. 数组的初始化：",slug:"_2-数组的初始化",normalizedTitle:"2. 数组的初始化：",charIndex:745},{level:4,title:"3. 数组的常见异常：",slug:"_3-数组的常见异常",normalizedTitle:"3. 数组的常见异常：",charIndex:1002},{level:4,title:"4. 数组内存分析：",slug:"_4-数组内存分析",normalizedTitle:"4. 数组内存分析：",charIndex:1412},{level:4,title:"5 Arrays的使用：",slug:"_5-arrays的使用",normalizedTitle:"5 arrays的使用：",charIndex:1430},{level:3,title:"1.3 二维数组",slug:"_1-3-二维数组",normalizedTitle:"1.3 二维数组",charIndex:1971},{level:4,title:"1. 二维数组定义：",slug:"_1-二维数组定义",normalizedTitle:"1. 二维数组定义：",charIndex:1983},{level:2,title:"2. 数组提高",slug:"_2-数组提高",normalizedTitle:"2. 数组提高",charIndex:2709},{level:3,title:"2.1 数组的特点",slug:"_2-1-数组的特点",normalizedTitle:"2.1 数组的特点",charIndex:2721},{level:3,title:"2.2 变长数组",slug:"_2-2-变长数组",normalizedTitle:"2.2 变长数组",charIndex:3910},{level:3,title:"2.3 数组复制问题",slug:"_2-3-数组复制问题",normalizedTitle:"2.3 数组复制问题",charIndex:5898},{level:3,title:"2.4  数组转换为List注意的地方",slug:"_2-4-数组转换为list注意的地方",normalizedTitle:"2.4  数组转换为list注意的地方",charIndex:null}],headersStr:"1. 数组基础知识： 1.1 什么是数组? 1.2 一维数组 1. 一维数组声明与创建： 2. 数组的初始化： 3. 数组的常见异常： 4. 数组内存分析： 5 Arrays的使用： 1.3 二维数组 1. 二维数组定义： 2. 数组提高 2.1 数组的特点 2.2 变长数组 2.3 数组复制问题 2.4  数组转换为List注意的地方",content:'# 数组\n\n参考：https://blog.csdn.net/a745233700/article/details/82995040\n\n\n# 1. 数组基础知识：\n\n\n# 1.1 什么是数组?\n\n数组是一种线性数据结构，是一个使用连续的内存空间存放相同的数据类型的集合容器，与其他容器相比，数组的区别主要在于性能与保存基本类型的能力。\n\n在Java中，数组是一种效率最高的存储和随机访问对象的方式，通过寻址公式，随机访问的时间复杂可以达到O(1)，但是为了保持空间的连续性，在数组中插入、删除数据时，都需要移动后面数据，该操作的时间复杂度为O(n)。另外，由于空间上连续，所以数组对CPU缓存比较友好，借助CPU的缓存机制，预读数组中的数据，提高访问效率。但是，由于数组是定长的，一旦声明之后就不可以改变长度，所以如果长度声明过大或者过小都会造成问题。\n\n数组可以自动给数组中的元素从0开始编号，方便操作这些元素。数组属于引用变量，并且数组的长度是固定的，数组的使用有四个步骤，声明数组，分配空间，赋值，处理。\n\n\n# 1.2 一维数组\n\n# 1. 一维数组声明与创建：\n\n元素类型[] 数组名 = new 元素类型[元素个数或数组长度];\n\n元素类型[] 数组名 = new 元素类型[]{元素，元素，……};\n\n元素类型[] 数组名 = {元素，元素，……};\n\n示例：int[] arr = new int[5];\n\nint[] arr = new int[]{3,5,1,7};\n\nint[] arr = {3,5,1,7};\n\n注意：给数组分配空间时，必须指定数组能够存储的元素个数来确定数组大小。创建数组之后不能修改数组的大小。可以使用length 属性获取数组的大小。\n\n# 2. 数组的初始化：\n\nint[] arr = new int[5];//创建数组第一种方式,此时默认值都是为0\narr[0] = 1;//数组的初始化\narr[1] = 2;//数组的初始化\n \nint[] arr = new int[]{3,5,1,7};//第二种方式：创建并初始化数组\n \nint[] arr = {3,5,1,7};//第三种方式：创建并初始化数组\n \nint[] arr;\narr = {1,2,3,4,5};//这种方式是错误的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3. 数组的常见异常：\n\n（1）ArrayIndexOutOfBoundsException 索引值越界。\n\n原因：访问了不存在的索引值：\n\npublic static void main(String[] args) {\n \n    int[] x = { 1, 2, 3 };\n    System.out.println(x[3]);//数组角标从0开始\n}\n\n\n1\n2\n3\n4\n5\n\n\n（2）NullPointerException 空指针异常：\n\n原因： 引用类型变量没有指向任何对象，而访问了对象的属性或者是调用了对象的方法。\n\npublic static void main(String[] args) {\n    \n    int[] x = { 1, 2, 3 };\n    x = null;\n    System.out.println(x[1]);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 4. 数组内存分析：\n\n\n\n\n\n# 5 Arrays的使用：\n\n遍历： toString() 将数组的元素以字符串的形式返回\n\n排序： sort() 将数组按照升序排列\n\n查找： binarySearch()在指定数组中查找指定元素，返回元素的索引，如果没有找到返回（-插入点-1） 注意：使用查找的功能的时候，数组一定要先排序。\n\npublic static void main(String[] args) {\n\tint[] array = new int[]{10,30,50,40,60};\n\tSystem.out.println(Arrays.toString(array));\n\t\t\n\tArrays.sort(array);\n\tSystem.out.println(Arrays.toString(array));\n\t\t\n\tSystem.out.println("最小值:"+array[0]+";最大值:"+array[array.length-1]);\n\t\t\n\tint result = Arrays.binarySearch(array, 40);\n\tSystem.out.println("目标值的角标："+result);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 1.3 二维数组\n\n# 1. 二维数组定义：\n\n数组类型[][] 数组名 = new 数组类型[一维数组的个数][每一个一维数组中元素的个数];\n\npublic static void main(String[] args) {\t\n\t\tint[][] a = new int[3][4];\n\t\tSystem.out.println(a);//[[I@15db9742\n\t\tSystem.out.println(a.length);//获取二维数组中存储的一维数组的个数3\n\t\tSystem.out.println(a[0]);//获取的是二维数组中第一个一维数组：[I@6d06d69c\n\t\tSystem.out.println(a[0].length);//第一个一维数组的长度：4\n\t\tSystem.out.println(Arrays.toString(a[0]));//默认值都是0：[0, 0, 0, 0]\t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n疑问： 为什么a.length = 3, a[0].length = 4?\n\n\n\n（2）二维数组的初始化：\n\n//静态初始化：\nint[][] b = new int[][]{{11,12,13,14},{21,22,23,24},{31,32,33,34}};\n//动态初始化：\nint[][] c = new int[3][4];\nint value = 0;\nfor(int i = 0;i<c.length;i++){\n    for(int j = 0;j<c[i].length;j++){\n\t\tc[i][j] = ++value;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2. 数组提高\n\n\n# 2.1 数组的特点\n\n在java中有很多方式来存储一列数据，而且在操作上面比数组方便的多？但为什么我们还需要使用数组，而不是替代它呢？\n\n数组与其他种类的容器之间的区别有三个方面呢：效率、类型和保存基本类型的能力。在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。\n\n数组确实是没有List、Set这些集合使用方便，但是在某些方面数组还是存在一些优势的，例如：速度，而且集合类的底层也都是通过数组来实现的。\n\n--------这是ArrayList的add()------\n    public boolean add(E e) {\n    ensureCapacity(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n（1）例子：数组和list求和操作的比较：\n\nLong time1 = System.currentTimeMillis();\n        for(int i = 0 ; i < 100000000 ;i++){\n            sum += arrays[i%10];\n        }\n        Long time2 = System.currentTimeMillis();\n        System.out.println("数组求和所花费时间：" + (time2 - time1) + "毫秒");\n        Long time3 = System.currentTimeMillis();\n        for (int i = 0; i < 100000000; i++) {\n            sum  += list.get(i%10);\n        }\n        Long time4 = System.currentTimeMillis();\n        System.out.println("List求和所花费时间：" + (time4 - time3) + "毫秒");\n--------------Output:\n数组求和所花费时间：696毫秒\nList求和所花费时间：3498毫秒\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n从上面的时间消耗上面来说数组对于基本类型的求和计算的速度是集合的5倍左右。其实在list集合中，求和当中有一个致命的动作：list.get(i)。这个动作是进行拆箱动作，Integer对象通过intValue方法自动转换成一个int基本类型，在这里就产生了不必要的性能消耗。\n\n所以在性能要求较高的场景中请优先考虑数组。\n\n\n# 2.2 变长数组\n\n数组是定长的，一旦初始化声明后是不可以改变长度的。一旦初始化声明后是不可改变长度的。这对我们在实际开发中是非常不方便的，聪明的我们肯定是可以找到方法来实现的。\n\n那么如何来实现变长数组呢？我们可以利用List集合add方法里面的扩容思路来模拟实现。下面是ArrayList的扩容方法:\n\npublic void ensureCapacity(int minCapacity) {\n        modCount++;  \n        /**\n         * 若当前需要的长度超过数组长度时进行扩容处理\n         */\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n它的思路是将原始数组拷贝到新数组中，新数组是原始数组长度的1.5倍。所以模拟的数组扩容代码如下：\n\npublic class ArrayUtils {\n    /**\n     * @desc 对数组进行扩容\n     * @param <T>\n     * @param datas 原始数组\n     * @param newLen 扩容大小\n     * @return T[]\n     */\n    public static <T> T[] expandCapacity(T[] datas,int newLen){\n        newLen = newLen < 0 ? datas.length :datas.length + newLen;   \n        //生成一个新的数组\n        return Arrays.copyOf(datas, newLen);\n    }\n    \n    /**\n     * @desc 对数组进行扩容处理，1.5倍\n     * @param <T>\n     * @param datas  原始数组\n     * @return T[]\n     */\n    public static <T> T[] expandCapacity(T[] datas){\n        int newLen = (datas.length * 3) / 2;      //扩容原始数组的1.5倍\n        //生成一个新的数组\n        return Arrays.copyOf(datas, newLen);\n    }\n    \n    /**\n     * @desc 对数组进行扩容处理，\n     * @param <T>\n     * @param datas 原始数组\n     * @param mulitiple 扩容的倍数\n     * @return T[]\n     */\n    public static <T> T[] expandCapacityMul(T[] datas,int mulitiple){\n        mulitiple = mulitiple < 0 ? 1 : mulitiple;\n        int newLen = datas.length * mulitiple;\n        return Arrays.copyOf(datas,newLen );\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n通过这种迂回的方式我们可以实现数组的扩容。因此在项目中如果确实需要变长的数据集，数组也是在考虑范围之内的，我们不能因为他是固定长度而排斥他！\n\n\n# 2.3 数组复制问题\n\n前在做集合拷贝的时候由于集合没有拷贝的方法，所以一个一个的复制是非常麻烦的，所以我就干脆使用List.toArray()方法转换成数组然后再通过Arrays.copyOf拷贝，在转换成集合，个人觉得非常方便，殊不知我已经陷入了其中的陷进！我们知道若数组元素为对象，则数组里面数据是对象引用。\n\npublic class Test {\n    public static void main(String[] args) {\n        Person person_01 = new Person("chenssy_01");\n        \n        Person[] persons1 = new Person[]{person_01};\n        Person[] persons2 = Arrays.copyOf(persons1,persons1.length);\n        \n        System.out.println("数组persons1:");\n        display(persons1);\n        System.out.println("---------------------");\n        System.out.println("数组persons2:");\n        display(persons2);\n        //改变其值\n        persons2[0].setName("chessy_02");\n        System.out.println("------------改变其值后------------");\n        System.out.println("数组persons1:");\n        display(persons1);\n        System.out.println("---------------------");\n        System.out.println("数组persons2:");\n        display(persons2);\n    }\n    public static void display(Person[] persons){\n        for(Person person : persons){\n            System.out.println(person.toString());\n        }\n    }\n}\n-------------Output:\n数组persons1:\n姓名是：chenssy_01\n---------------------\n数组persons2:\n姓名是：chenssy_01\n------------改变其值后------------\n数组persons1:\n姓名是：chessy_02\n---------------------\n数组persons2:\n姓名是：chessy_02\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n从结果中发现,persons1中的值也发生了改变，这是典型的浅拷贝问题。所以通过Arrays.copyOf()方法产生的数组是一个浅拷贝。同时数组的clone()方法也是，集合的clone()方法也是，所以我们在使用拷贝方法的同时一定要注意浅拷贝这问题。\n\n\n# 2.4 数组转换为List注意的地方\n\n（1）我们经常需要使用到Arrays这个工具的asList()方法将其转换成列表。方便是方便，但是有时候会出现莫名其妙的问题。如下：\n\npublic static void main(String[] args) {\n        int[] datas = new int[]{1,2,3,4,5};\n        List list = Arrays.asList(datas);\n        System.out.println(list.size());\n    }\n------------Output:\n1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n结果是1,是的你没有看错, 结果就是1。但是为什么会是1而不是5呢？先看asList()的源码：\n\npublic static <T> List<T> asList(T... a) {\n        return new ArrayList<T>(a);\n    }\n\n\n1\n2\n3\n\n\n注意这个参数:T…a，这个参数是一个泛型的变长参数，我们知道基本数据类型是不可能泛型化的，也是就说8个基本数据类型是不可作为泛型参数的，但是为什么编译器没有报错呢？这是因为在java中，数组会当做一个对象来处理，它是可以泛型的，所以我们的程序是把一个int型的数组作为了T的类型，所以在转换之后List中就只会存在一个类型为int数组的元素了。所以我们这样的程序System.out.println(datas.equals(list.get(0)));输出结果肯定是true。当然如果将int改为Integer，则长度就会变成5了。\n\n（2）我们再看下面程序：\n\nenum Week{Sum,Mon,Tue,Web,Thu,Fri,Sat}\n    public static void main(String[] args) {\n        Week[] weeks = {Week.Sum,Week.Mon,Week.Tue,Week.Web,Week.Thu,Week.Fri};\n        List<Week> list = Arrays.asList(weeks);\n        list.add(Week.Sat);\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个程序非常简单，就是讲一个数组转换成list，然后改变集合中值，但是运行呢？\n\nException in thread "main" java.lang.UnsupportedOperationException\n    at java.util.AbstractList.add(AbstractList.java:131)\n    at java.util.AbstractList.add(AbstractList.java:91)\n    at com.array.Test.main(Test.java:18)\n\n\n1\n2\n3\n4\n\n\n编译没错，但是运行竟然出现了异常错误！UnsupportedOperationException ，当不支持请求的操作时，就会抛出该异常。从某种程度上来说就是不支持add方法，我们知道这是不可能的！什么原因引起这个异常呢？先看asList()的源代码：\n\npublic static <T> List<T> asList(T... a) {\n        return new ArrayList<T>(a);\n    }\n\n\n1\n2\n3\n\n\n这里是直接返回一个ArrayList对象返回，但是注意这个ArrayList并不是java.util.ArrayList,而是Arrays工具类的一个内之类：\n\nprivate static class ArrayList<E> extends AbstractList<E>\n    implements RandomAccess, java.io.Serializable{\n        private static final long serialVersionUID = -2764017481108945198L;\n        private final E[] a;\n        ArrayList(E[] array) {\n            if (array==null)\n                throw new NullPointerException();\n        a = array;\n    }\n       /** 省略方法 **/\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n但是这个内部类并没有提供add()方法，那么查看父类：\n\npublic boolean add(E e) {\n    add(size(), e);\n    return true;\n    }\n    public void add(int index, E element) {\n    throw new UnsupportedOperationException();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里父类仅仅只是提供了方法，方法的具体实现却没有，所以具体的实现需要子类自己来提供，但是非常遗憾这个内部类ArrayList并没有提高add的实现方法。在ArrayList中，它主要提供了如下几个方法：\n\n1、size：元素数量\n\n2、toArray：转换为数组，实现了数组的浅拷贝。\n\n3、get：获得指定元素。\n\n4、contains：是否包含某元素。\n\n所以综上所述，asList返回的是一个长度不可变的列表。数组是多长，转换成的列表是多长，我们是无法通过add、remove来增加或者减少其长度的。',normalizedContent:'# 数组\n\n参考：https://blog.csdn.net/a745233700/article/details/82995040\n\n\n# 1. 数组基础知识：\n\n\n# 1.1 什么是数组?\n\n数组是一种线性数据结构，是一个使用连续的内存空间存放相同的数据类型的集合容器，与其他容器相比，数组的区别主要在于性能与保存基本类型的能力。\n\n在java中，数组是一种效率最高的存储和随机访问对象的方式，通过寻址公式，随机访问的时间复杂可以达到o(1)，但是为了保持空间的连续性，在数组中插入、删除数据时，都需要移动后面数据，该操作的时间复杂度为o(n)。另外，由于空间上连续，所以数组对cpu缓存比较友好，借助cpu的缓存机制，预读数组中的数据，提高访问效率。但是，由于数组是定长的，一旦声明之后就不可以改变长度，所以如果长度声明过大或者过小都会造成问题。\n\n数组可以自动给数组中的元素从0开始编号，方便操作这些元素。数组属于引用变量，并且数组的长度是固定的，数组的使用有四个步骤，声明数组，分配空间，赋值，处理。\n\n\n# 1.2 一维数组\n\n# 1. 一维数组声明与创建：\n\n元素类型[] 数组名 = new 元素类型[元素个数或数组长度];\n\n元素类型[] 数组名 = new 元素类型[]{元素，元素，……};\n\n元素类型[] 数组名 = {元素，元素，……};\n\n示例：int[] arr = new int[5];\n\nint[] arr = new int[]{3,5,1,7};\n\nint[] arr = {3,5,1,7};\n\n注意：给数组分配空间时，必须指定数组能够存储的元素个数来确定数组大小。创建数组之后不能修改数组的大小。可以使用length 属性获取数组的大小。\n\n# 2. 数组的初始化：\n\nint[] arr = new int[5];//创建数组第一种方式,此时默认值都是为0\narr[0] = 1;//数组的初始化\narr[1] = 2;//数组的初始化\n \nint[] arr = new int[]{3,5,1,7};//第二种方式：创建并初始化数组\n \nint[] arr = {3,5,1,7};//第三种方式：创建并初始化数组\n \nint[] arr;\narr = {1,2,3,4,5};//这种方式是错误的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3. 数组的常见异常：\n\n（1）arrayindexoutofboundsexception 索引值越界。\n\n原因：访问了不存在的索引值：\n\npublic static void main(string[] args) {\n \n    int[] x = { 1, 2, 3 };\n    system.out.println(x[3]);//数组角标从0开始\n}\n\n\n1\n2\n3\n4\n5\n\n\n（2）nullpointerexception 空指针异常：\n\n原因： 引用类型变量没有指向任何对象，而访问了对象的属性或者是调用了对象的方法。\n\npublic static void main(string[] args) {\n    \n    int[] x = { 1, 2, 3 };\n    x = null;\n    system.out.println(x[1]);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 4. 数组内存分析：\n\n\n\n\n\n# 5 arrays的使用：\n\n遍历： tostring() 将数组的元素以字符串的形式返回\n\n排序： sort() 将数组按照升序排列\n\n查找： binarysearch()在指定数组中查找指定元素，返回元素的索引，如果没有找到返回（-插入点-1） 注意：使用查找的功能的时候，数组一定要先排序。\n\npublic static void main(string[] args) {\n\tint[] array = new int[]{10,30,50,40,60};\n\tsystem.out.println(arrays.tostring(array));\n\t\t\n\tarrays.sort(array);\n\tsystem.out.println(arrays.tostring(array));\n\t\t\n\tsystem.out.println("最小值:"+array[0]+";最大值:"+array[array.length-1]);\n\t\t\n\tint result = arrays.binarysearch(array, 40);\n\tsystem.out.println("目标值的角标："+result);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 1.3 二维数组\n\n# 1. 二维数组定义：\n\n数组类型[][] 数组名 = new 数组类型[一维数组的个数][每一个一维数组中元素的个数];\n\npublic static void main(string[] args) {\t\n\t\tint[][] a = new int[3][4];\n\t\tsystem.out.println(a);//[[i@15db9742\n\t\tsystem.out.println(a.length);//获取二维数组中存储的一维数组的个数3\n\t\tsystem.out.println(a[0]);//获取的是二维数组中第一个一维数组：[i@6d06d69c\n\t\tsystem.out.println(a[0].length);//第一个一维数组的长度：4\n\t\tsystem.out.println(arrays.tostring(a[0]));//默认值都是0：[0, 0, 0, 0]\t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n疑问： 为什么a.length = 3, a[0].length = 4?\n\n\n\n（2）二维数组的初始化：\n\n//静态初始化：\nint[][] b = new int[][]{{11,12,13,14},{21,22,23,24},{31,32,33,34}};\n//动态初始化：\nint[][] c = new int[3][4];\nint value = 0;\nfor(int i = 0;i<c.length;i++){\n    for(int j = 0;j<c[i].length;j++){\n\t\tc[i][j] = ++value;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2. 数组提高\n\n\n# 2.1 数组的特点\n\n在java中有很多方式来存储一列数据，而且在操作上面比数组方便的多？但为什么我们还需要使用数组，而不是替代它呢？\n\n数组与其他种类的容器之间的区别有三个方面呢：效率、类型和保存基本类型的能力。在java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。\n\n数组确实是没有list、set这些集合使用方便，但是在某些方面数组还是存在一些优势的，例如：速度，而且集合类的底层也都是通过数组来实现的。\n\n--------这是arraylist的add()------\n    public boolean add(e e) {\n    ensurecapacity(size + 1);  // increments modcount!!\n    elementdata[size++] = e;\n    return true;\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n（1）例子：数组和list求和操作的比较：\n\nlong time1 = system.currenttimemillis();\n        for(int i = 0 ; i < 100000000 ;i++){\n            sum += arrays[i%10];\n        }\n        long time2 = system.currenttimemillis();\n        system.out.println("数组求和所花费时间：" + (time2 - time1) + "毫秒");\n        long time3 = system.currenttimemillis();\n        for (int i = 0; i < 100000000; i++) {\n            sum  += list.get(i%10);\n        }\n        long time4 = system.currenttimemillis();\n        system.out.println("list求和所花费时间：" + (time4 - time3) + "毫秒");\n--------------output:\n数组求和所花费时间：696毫秒\nlist求和所花费时间：3498毫秒\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n从上面的时间消耗上面来说数组对于基本类型的求和计算的速度是集合的5倍左右。其实在list集合中，求和当中有一个致命的动作：list.get(i)。这个动作是进行拆箱动作，integer对象通过intvalue方法自动转换成一个int基本类型，在这里就产生了不必要的性能消耗。\n\n所以在性能要求较高的场景中请优先考虑数组。\n\n\n# 2.2 变长数组\n\n数组是定长的，一旦初始化声明后是不可以改变长度的。一旦初始化声明后是不可改变长度的。这对我们在实际开发中是非常不方便的，聪明的我们肯定是可以找到方法来实现的。\n\n那么如何来实现变长数组呢？我们可以利用list集合add方法里面的扩容思路来模拟实现。下面是arraylist的扩容方法:\n\npublic void ensurecapacity(int mincapacity) {\n        modcount++;  \n        /**\n         * 若当前需要的长度超过数组长度时进行扩容处理\n         */\n        int oldcapacity = elementdata.length;\n        int newcapacity = oldcapacity + (oldcapacity >> 1);\n        if (newcapacity - mincapacity < 0)\n            newcapacity = mincapacity;\n        if (newcapacity - max_array_size > 0)\n            newcapacity = hugecapacity(mincapacity);\n        // mincapacity is usually close to size, so this is a win:\n        elementdata = arrays.copyof(elementdata, newcapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n它的思路是将原始数组拷贝到新数组中，新数组是原始数组长度的1.5倍。所以模拟的数组扩容代码如下：\n\npublic class arrayutils {\n    /**\n     * @desc 对数组进行扩容\n     * @param <t>\n     * @param datas 原始数组\n     * @param newlen 扩容大小\n     * @return t[]\n     */\n    public static <t> t[] expandcapacity(t[] datas,int newlen){\n        newlen = newlen < 0 ? datas.length :datas.length + newlen;   \n        //生成一个新的数组\n        return arrays.copyof(datas, newlen);\n    }\n    \n    /**\n     * @desc 对数组进行扩容处理，1.5倍\n     * @param <t>\n     * @param datas  原始数组\n     * @return t[]\n     */\n    public static <t> t[] expandcapacity(t[] datas){\n        int newlen = (datas.length * 3) / 2;      //扩容原始数组的1.5倍\n        //生成一个新的数组\n        return arrays.copyof(datas, newlen);\n    }\n    \n    /**\n     * @desc 对数组进行扩容处理，\n     * @param <t>\n     * @param datas 原始数组\n     * @param mulitiple 扩容的倍数\n     * @return t[]\n     */\n    public static <t> t[] expandcapacitymul(t[] datas,int mulitiple){\n        mulitiple = mulitiple < 0 ? 1 : mulitiple;\n        int newlen = datas.length * mulitiple;\n        return arrays.copyof(datas,newlen );\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n通过这种迂回的方式我们可以实现数组的扩容。因此在项目中如果确实需要变长的数据集，数组也是在考虑范围之内的，我们不能因为他是固定长度而排斥他！\n\n\n# 2.3 数组复制问题\n\n前在做集合拷贝的时候由于集合没有拷贝的方法，所以一个一个的复制是非常麻烦的，所以我就干脆使用list.toarray()方法转换成数组然后再通过arrays.copyof拷贝，在转换成集合，个人觉得非常方便，殊不知我已经陷入了其中的陷进！我们知道若数组元素为对象，则数组里面数据是对象引用。\n\npublic class test {\n    public static void main(string[] args) {\n        person person_01 = new person("chenssy_01");\n        \n        person[] persons1 = new person[]{person_01};\n        person[] persons2 = arrays.copyof(persons1,persons1.length);\n        \n        system.out.println("数组persons1:");\n        display(persons1);\n        system.out.println("---------------------");\n        system.out.println("数组persons2:");\n        display(persons2);\n        //改变其值\n        persons2[0].setname("chessy_02");\n        system.out.println("------------改变其值后------------");\n        system.out.println("数组persons1:");\n        display(persons1);\n        system.out.println("---------------------");\n        system.out.println("数组persons2:");\n        display(persons2);\n    }\n    public static void display(person[] persons){\n        for(person person : persons){\n            system.out.println(person.tostring());\n        }\n    }\n}\n-------------output:\n数组persons1:\n姓名是：chenssy_01\n---------------------\n数组persons2:\n姓名是：chenssy_01\n------------改变其值后------------\n数组persons1:\n姓名是：chessy_02\n---------------------\n数组persons2:\n姓名是：chessy_02\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n从结果中发现,persons1中的值也发生了改变，这是典型的浅拷贝问题。所以通过arrays.copyof()方法产生的数组是一个浅拷贝。同时数组的clone()方法也是，集合的clone()方法也是，所以我们在使用拷贝方法的同时一定要注意浅拷贝这问题。\n\n\n# 2.4 数组转换为list注意的地方\n\n（1）我们经常需要使用到arrays这个工具的aslist()方法将其转换成列表。方便是方便，但是有时候会出现莫名其妙的问题。如下：\n\npublic static void main(string[] args) {\n        int[] datas = new int[]{1,2,3,4,5};\n        list list = arrays.aslist(datas);\n        system.out.println(list.size());\n    }\n------------output:\n1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n结果是1,是的你没有看错, 结果就是1。但是为什么会是1而不是5呢？先看aslist()的源码：\n\npublic static <t> list<t> aslist(t... a) {\n        return new arraylist<t>(a);\n    }\n\n\n1\n2\n3\n\n\n注意这个参数:t…a，这个参数是一个泛型的变长参数，我们知道基本数据类型是不可能泛型化的，也是就说8个基本数据类型是不可作为泛型参数的，但是为什么编译器没有报错呢？这是因为在java中，数组会当做一个对象来处理，它是可以泛型的，所以我们的程序是把一个int型的数组作为了t的类型，所以在转换之后list中就只会存在一个类型为int数组的元素了。所以我们这样的程序system.out.println(datas.equals(list.get(0)));输出结果肯定是true。当然如果将int改为integer，则长度就会变成5了。\n\n（2）我们再看下面程序：\n\nenum week{sum,mon,tue,web,thu,fri,sat}\n    public static void main(string[] args) {\n        week[] weeks = {week.sum,week.mon,week.tue,week.web,week.thu,week.fri};\n        list<week> list = arrays.aslist(weeks);\n        list.add(week.sat);\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个程序非常简单，就是讲一个数组转换成list，然后改变集合中值，但是运行呢？\n\nexception in thread "main" java.lang.unsupportedoperationexception\n    at java.util.abstractlist.add(abstractlist.java:131)\n    at java.util.abstractlist.add(abstractlist.java:91)\n    at com.array.test.main(test.java:18)\n\n\n1\n2\n3\n4\n\n\n编译没错，但是运行竟然出现了异常错误！unsupportedoperationexception ，当不支持请求的操作时，就会抛出该异常。从某种程度上来说就是不支持add方法，我们知道这是不可能的！什么原因引起这个异常呢？先看aslist()的源代码：\n\npublic static <t> list<t> aslist(t... a) {\n        return new arraylist<t>(a);\n    }\n\n\n1\n2\n3\n\n\n这里是直接返回一个arraylist对象返回，但是注意这个arraylist并不是java.util.arraylist,而是arrays工具类的一个内之类：\n\nprivate static class arraylist<e> extends abstractlist<e>\n    implements randomaccess, java.io.serializable{\n        private static final long serialversionuid = -2764017481108945198l;\n        private final e[] a;\n        arraylist(e[] array) {\n            if (array==null)\n                throw new nullpointerexception();\n        a = array;\n    }\n       /** 省略方法 **/\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n但是这个内部类并没有提供add()方法，那么查看父类：\n\npublic boolean add(e e) {\n    add(size(), e);\n    return true;\n    }\n    public void add(int index, e element) {\n    throw new unsupportedoperationexception();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里父类仅仅只是提供了方法，方法的具体实现却没有，所以具体的实现需要子类自己来提供，但是非常遗憾这个内部类arraylist并没有提高add的实现方法。在arraylist中，它主要提供了如下几个方法：\n\n1、size：元素数量\n\n2、toarray：转换为数组，实现了数组的浅拷贝。\n\n3、get：获得指定元素。\n\n4、contains：是否包含某元素。\n\n所以综上所述，aslist返回的是一个长度不可变的列表。数组是多长，转换成的列表是多长，我们是无法通过add、remove来增加或者减少其长度的。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"集合",frontmatter:{title:"集合",date:"2023-02-26T13:35:12.000Z",permalink:"/pages/27a8e1/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/07.%E9%9B%86%E5%90%88.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/07.集合.md",key:"v-684ba736",path:"/pages/27a8e1/",headers:[{level:2,title:"1. Collection集合",slug:"_1-collection集合",normalizedTitle:"1. collection集合",charIndex:9},{level:3,title:"1.1 集合体系结构",slug:"_1-1-集合体系结构",normalizedTitle:"1.1 集合体系结构",charIndex:29},{level:3,title:"1.2 Collection集合概述和基本使用",slug:"_1-2-collection集合概述和基本使用",normalizedTitle:"1.2 collection集合概述和基本使用",charIndex:102},{level:3,title:"1.3 Collection集合的常用方法",slug:"_1-3-collection集合的常用方法",normalizedTitle:"1.3 collection集合的常用方法",charIndex:725},{level:3,title:"1.4 Collection集合的遍历",slug:"_1-4-collection集合的遍历",normalizedTitle:"1.4 collection集合的遍历",charIndex:1026},{level:3,title:"1.5 集合使用步骤图解",slug:"_1-5-集合使用步骤图解",normalizedTitle:"1.5 集合使用步骤图解",charIndex:1808},{level:3,title:"1.6 集合的案例-Collection集合存储学生对象并遍历",slug:"_1-6-集合的案例-collection集合存储学生对象并遍历",normalizedTitle:"1.6 集合的案例-collection集合存储学生对象并遍历",charIndex:1836},{level:2,title:"2. List集合",slug:"_2-list集合",normalizedTitle:"2. list集合",charIndex:3486},{level:3,title:"2.1 List集合概述和特点",slug:"_2-1-list集合概述和特点",normalizedTitle:"2.1 list集合概述和特点",charIndex:3500},{level:3,title:"2.2 List集合的特有方法",slug:"_2-2-list集合的特有方法",normalizedTitle:"2.2 list集合的特有方法",charIndex:3669},{level:3,title:"2.3 并发修改异常",slug:"_2-3-并发修改异常",normalizedTitle:"2.3 并发修改异常",charIndex:3922},{level:3,title:"2.4 List集合循环遍历",slug:"_2-4-list集合循环遍历",normalizedTitle:"2.4 list集合循环遍历",charIndex:5134},{level:4,title:"1 列表迭代器",slug:"_1-列表迭代器",normalizedTitle:"1 列表迭代器",charIndex:5152},{level:4,title:"2 增强for循环",slug:"_2-增强for循环",normalizedTitle:"2 增强for循环",charIndex:6036},{level:4,title:"3. 集合的案例-List集合存储学生对象三种方式遍历",slug:"_3-集合的案例-list集合存储学生对象三种方式遍历",normalizedTitle:"3. 集合的案例-list集合存储学生对象三种方式遍历",charIndex:7374},{level:3,title:"2.5 List集合的实现类",slug:"_2-5-list集合的实现类",normalizedTitle:"2.5 list集合的实现类",charIndex:9793},{level:4,title:"1. List集合子类的特点",slug:"_1-list集合子类的特点",normalizedTitle:"1. list集合子类的特点",charIndex:9811},{level:4,title:"2. 集合的案例-ArrayList集合存储学生对象三种方式遍历",slug:"_2-集合的案例-arraylist集合存储学生对象三种方式遍历",normalizedTitle:"2. 集合的案例-arraylist集合存储学生对象三种方式遍历",charIndex:9912},{level:4,title:"3. LinkedList集合的特有功能",slug:"_3-linkedlist集合的特有功能",normalizedTitle:"3. linkedlist集合的特有功能",charIndex:12370},{level:2,title:"3. Set集合",slug:"_3-set集合",normalizedTitle:"3. set集合",charIndex:12718},{level:3,title:"3.1 Set集合概述和特点",slug:"_3-1-set集合概述和特点",normalizedTitle:"3.1 set集合概述和特点",charIndex:12731},{level:3,title:"3.2 哈希值",slug:"_3-2-哈希值",normalizedTitle:"3.2 哈希值",charIndex:13251},{level:3,title:"3.3HashSet集合概述和特点",slug:"_3-3hashset集合概述和特点",normalizedTitle:"3.3hashset集合概述和特点",charIndex:15523},{level:3,title:"3.4 HashSet集合保证元素唯一性源码分析",slug:"_3-4-hashset集合保证元素唯一性源码分析",normalizedTitle:"3.4 hashset集合保证元素唯一性源码分析",charIndex:16223},{level:3,title:"3.5 常见数据结构之哈希表",slug:"_3-5-常见数据结构之哈希表",normalizedTitle:"3.5 常见数据结构之哈希表",charIndex:16539},{level:3,title:"3.6 HashSet集合存储学生对象并遍历",slug:"_3-6-hashset集合存储学生对象并遍历",normalizedTitle:"3.6 hashset集合存储学生对象并遍历",charIndex:16560},{level:3,title:"3.7 LinkedHashSet集合概述和特点",slug:"_3-7-linkedhashset集合概述和特点",normalizedTitle:"3.7 linkedhashset集合概述和特点",charIndex:19182},{level:3,title:"3.8 Set集合排序",slug:"_3-8-set集合排序",normalizedTitle:"3.8 set集合排序",charIndex:19962},{level:4,title:"1. TreeSet集合概述和特点",slug:"_1-treeset集合概述和特点",normalizedTitle:"1. treeset集合概述和特点",charIndex:19977},{level:4,title:"2. 自然排序Comparable的使用",slug:"_2-自然排序comparable的使用",normalizedTitle:"2. 自然排序comparable的使用",charIndex:20783},{level:4,title:"3. 比较器排序Comparator的使用",slug:"_3-比较器排序comparator的使用",normalizedTitle:"3. 比较器排序comparator的使用",charIndex:23543},{level:4,title:"4. 成绩排序案例",slug:"_4-成绩排序案例",normalizedTitle:"4. 成绩排序案例",charIndex:26261},{level:4,title:"5. 不重复的随机数案例",slug:"_5-不重复的随机数案例",normalizedTitle:"5. 不重复的随机数案例",charIndex:29675},{level:2,title:"4. 泛型",slug:"_4-泛型",normalizedTitle:"4. 泛型",charIndex:30478},{level:3,title:"4.1 泛型概述和好处",slug:"_4-1-泛型概述和好处",normalizedTitle:"4.1 泛型概述和好处",charIndex:30488},{level:3,title:"4.2 泛型类",slug:"_4-2-泛型类",normalizedTitle:"4.2 泛型类",charIndex:30923},{level:3,title:"3.3 泛型方法",slug:"_3-3-泛型方法",normalizedTitle:"3.3 泛型方法",charIndex:31967},{level:3,title:"3.4 泛型接口",slug:"_3-4-泛型接口",normalizedTitle:"3.4 泛型接口",charIndex:32592},{level:3,title:"3.5 类型通配符",slug:"_3-5-类型通配符",normalizedTitle:"3.5 类型通配符",charIndex:33431},{level:2,title:"5. 可变参数",slug:"_5-可变参数",normalizedTitle:"5. 可变参数",charIndex:34802},{level:3,title:"5.1 可变参数",slug:"_5-1-可变参数",normalizedTitle:"5.1 可变参数",charIndex:34814},{level:3,title:"5.2可变参数的使用",slug:"_5-2可变参数的使用",normalizedTitle:"5.2可变参数的使用",charIndex:35911},{level:2,title:"6. Map集合",slug:"_6-map集合",normalizedTitle:"6. map集合",charIndex:39545},{level:3,title:"6.1 Map集合概述和特点",slug:"_6-1-map集合概述和特点",normalizedTitle:"6.1 map集合概述和特点",charIndex:39558},{level:3,title:"6.2 Map集合的基本功能",slug:"_6-2-map集合的基本功能",normalizedTitle:"6.2 map集合的基本功能",charIndex:40284},{level:3,title:"6.3Map集合的获取功能",slug:"_6-3map集合的获取功能",normalizedTitle:"6.3map集合的获取功能",charIndex:41888},{level:3,title:"6.4Map集合的遍历(方式1)",slug:"_6-4map集合的遍历-方式1",normalizedTitle:"6.4map集合的遍历(方式1)",charIndex:42923},{level:3,title:"6.5 Map集合的遍历(方式2)",slug:"_6-5-map集合的遍历-方式2",normalizedTitle:"6.5 map集合的遍历(方式2)",charIndex:43916},{level:3,title:"6.6 Map集合的案例",slug:"_6-6-map集合的案例",normalizedTitle:"6.6 map集合的案例",charIndex:45072},{level:4,title:"1. HashMap集合练习之键是String值是Student",slug:"_1-hashmap集合练习之键是string值是student",normalizedTitle:"1. hashmap集合练习之键是string值是student",charIndex:45088},{level:4,title:"2. HashMap集合练习之键是Student值是String",slug:"_2-hashmap集合练习之键是student值是string",normalizedTitle:"2. hashmap集合练习之键是student值是string",charIndex:47930},{level:4,title:"3. 集合嵌套之ArrayList嵌套HashMap",slug:"_3-集合嵌套之arraylist嵌套hashmap",normalizedTitle:"3. 集合嵌套之arraylist嵌套hashmap",charIndex:50738},{level:4,title:"4. 集合嵌套之HashMap嵌套ArrayList",slug:"_4-集合嵌套之hashmap嵌套arraylist",normalizedTitle:"4. 集合嵌套之hashmap嵌套arraylist",charIndex:52280},{level:4,title:"5. 统计字符串中每个字符出现的次数",slug:"_5-统计字符串中每个字符出现的次数",normalizedTitle:"5. 统计字符串中每个字符出现的次数",charIndex:53790},{level:2,title:"7. Collections集合工具类",slug:"_7-collections集合工具类",normalizedTitle:"7. collections集合工具类",charIndex:55636},{level:3,title:"7.1 Collections概述和使用",slug:"_7-1-collections概述和使用",normalizedTitle:"7.1 collections概述和使用",charIndex:55660},{level:3,title:"7.2 ArrayList集合存储学生并排序",slug:"_7-2-arraylist集合存储学生并排序",normalizedTitle:"7.2 arraylist集合存储学生并排序",charIndex:56640},{level:2,title:"8. 斗地主案例",slug:"_8-斗地主案例",normalizedTitle:"8. 斗地主案例",charIndex:59199},{level:3,title:"8.1 模拟斗地主案例-普通版本",slug:"_8-1-模拟斗地主案例-普通版本",normalizedTitle:"8.1 模拟斗地主案例-普通版本",charIndex:59212},{level:3,title:"3.2 模拟斗地主案例-升级版本",slug:"_3-2-模拟斗地主案例-升级版本",normalizedTitle:"3.2 模拟斗地主案例-升级版本",charIndex:61810}],headersStr:"1. Collection集合 1.1 集合体系结构 1.2 Collection集合概述和基本使用 1.3 Collection集合的常用方法 1.4 Collection集合的遍历 1.5 集合使用步骤图解 1.6 集合的案例-Collection集合存储学生对象并遍历 2. List集合 2.1 List集合概述和特点 2.2 List集合的特有方法 2.3 并发修改异常 2.4 List集合循环遍历 1 列表迭代器 2 增强for循环 3. 集合的案例-List集合存储学生对象三种方式遍历 2.5 List集合的实现类 1. List集合子类的特点 2. 集合的案例-ArrayList集合存储学生对象三种方式遍历 3. LinkedList集合的特有功能 3. Set集合 3.1 Set集合概述和特点 3.2 哈希值 3.3HashSet集合概述和特点 3.4 HashSet集合保证元素唯一性源码分析 3.5 常见数据结构之哈希表 3.6 HashSet集合存储学生对象并遍历 3.7 LinkedHashSet集合概述和特点 3.8 Set集合排序 1. TreeSet集合概述和特点 2. 自然排序Comparable的使用 3. 比较器排序Comparator的使用 4. 成绩排序案例 5. 不重复的随机数案例 4. 泛型 4.1 泛型概述和好处 4.2 泛型类 3.3 泛型方法 3.4 泛型接口 3.5 类型通配符 5. 可变参数 5.1 可变参数 5.2可变参数的使用 6. Map集合 6.1 Map集合概述和特点 6.2 Map集合的基本功能 6.3Map集合的获取功能 6.4Map集合的遍历(方式1) 6.5 Map集合的遍历(方式2) 6.6 Map集合的案例 1. HashMap集合练习之键是String值是Student 2. HashMap集合练习之键是Student值是String 3. 集合嵌套之ArrayList嵌套HashMap 4. 集合嵌套之HashMap嵌套ArrayList 5. 统计字符串中每个字符出现的次数 7. Collections集合工具类 7.1 Collections概述和使用 7.2 ArrayList集合存储学生并排序 8. 斗地主案例 8.1 模拟斗地主案例-普通版本 3.2 模拟斗地主案例-升级版本",content:'# 集合\n\n\n# 1. Collection集合\n\n\n# 1.1 集合体系结构\n\n * 集合类的特点\n\n提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变\n\n * 集合类的体系图\n\n\n\n\n# 1.2 Collection集合概述和基本使用\n\n * Collection集合概述\n   \n   * 是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素\n   \n   * JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现\n\n * Collection集合基本使用\n   \n   public class CollectionDemo01 {\n       public static void main(String[] args) {\n           //创建Collection集合的对象\n           Collection<String> c = new ArrayList<String>();\n   \n           //添加元素：boolean add(E e)\n           c.add("hello");\n           c.add("world");\n           c.add("java");\n   \n           //输出集合对象\n           System.out.println(c);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n\n# 1.3 Collection集合的常用方法\n\n方法名                          说明\nboolean add(E e)             添加元素\nboolean remove(Object o)     从集合中移除指定的元素\nvoid clear()                 清空集合中的元素\nboolean contains(Object o)   判断集合中是否存在指定的元素\nboolean isEmpty()            判断集合是否为空\nint size()                   集合的长度，也就是集合中元素的个数\n\n\n# 1.4 Collection集合的遍历\n\n * 迭代器的介绍\n   \n   - 迭代器，集合的专用遍历方式\n   - Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n   - 迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的\n   \n   \n   1\n   2\n   3\n   \n\n * Collection集合的遍历\n\npublic class IteratorDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        Collection<String> c = new ArrayList<>();\n\n        //添加元素\n        c.add("hello");\n        c.add("world");\n        c.add("java");\n        c.add("javaee");\n\n        //Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n        Iterator<String> it = c.iterator();\n\n        //用while循环改进元素的判断和获取\n        while (it.hasNext()) {\n            String s = it.next();\n            System.out.println(s);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 1.5 集合使用步骤图解\n\n * 使用步骤\n\n\n\n\n# 1.6 集合的案例-Collection集合存储学生对象并遍历\n\n * 案例需求\n   \n   创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n * 代码实现\n   \n   * 学生类\n   \n   public class Student {\n       private String name;\n       private int age;\n   \n       public Student() {\n       }\n   \n       public Student(String name, int age) {\n           this.name = name;\n           this.age = age;\n       }\n   \n       public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public int getAge() {\n           return age;\n       }\n   \n       public void setAge(int age) {\n           this.age = age;\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n   * 测试类\n   \n   public class CollectionDemo {\n       public static void main(String[] args) {\n           //创建Collection集合对象\n           Collection<Student> c = new ArrayList<Student>();\n   \n           //创建学生对象\n           Student s1 = new Student("林青霞", 30);\n           Student s2 = new Student("张曼玉", 35);\n           Student s3 = new Student("王祖贤", 33);\n   \n           //把学生添加到集合\n           c.add(s1);\n           c.add(s2);\n           c.add(s3);\n   \n           //遍历集合(迭代器方式)\n           Iterator<Student> it = c.iterator();\n           while (it.hasNext()) {\n               Student s = it.next();\n               System.out.println(s.getName() + "," + s.getAge());\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   \n\n\n# 2. List集合\n\n\n# 2.1 List集合概述和特点\n\n * List集合概述\n   * 有序集合(也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素\n   * 与Set集合不同，列表通常允许重复的元素\n * List集合特点\n   * 有索引\n   * 可以存储重复元素\n   * 元素存取有序\n\n\n# 2.2 List集合的特有方法\n\n方法名                             描述\nvoid add(int index,E element)   在此集合中的指定位置插入指定的元素\nE remove(int index)             删除指定索引处的元素，返回被删除的元素\nE set(int index,E element)      修改指定索引处的元素，返回被修改的元素\nE get(int index)                返回指定索引处的元素\n\n\n# 2.3 并发修改异常\n\n * 出现的原因\n   \n   迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：ConcurrentModificationException\n\n * 解决的方案\n   \n   用for循环遍历，然后用集合对象做对应的操作即可\n\n * 示例代码\n   \n   public class ListDemo {\n       public static void main(String[] args) {\n           //创建集合对象\n           List<String> list = new ArrayList<String>();\n   \n           //添加元素\n           list.add("hello");\n           list.add("world");\n           list.add("java");\n   \n           //遍历集合，得到每一个元素，看有没有"world"这个元素，如果有，我就添加一个"javaee"元素，请写代码实现\n   //        Iterator<String> it = list.iterator();\n   //        while (it.hasNext()) {\n   //            String s = it.next();\n   //            if(s.equals("world")) {\n   //                list.add("javaee");\n   //            }\n   //        }\n   \n           for(int i=0; i<list.size(); i++) {\n               String s = list.get(i);\n               if(s.equals("world")) {\n                   list.add("javaee");\n               }\n           }\n   \n           //输出集合对象\n           System.out.println(list);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n\n# 2.4 List集合循环遍历\n\n# 1 列表迭代器\n\n * List Iterator介绍\n   \n   * 通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器\n   * 用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置\n\n * 示例代码\n   \n   public class ListIteratorDemo {\n       public static void main(String[] args) {\n           //创建集合对象\n           List<String> list = new ArrayList<String>();\n   \n           //添加元素\n           list.add("hello");\n           list.add("world");\n           list.add("java");\n   \n           //获取列表迭代器\n           ListIterator<String> lit = list.listIterator();\n           while (lit.hasNext()) {\n               String s = lit.next();\n               if(s.equals("world")) {\n                   lit.add("javaee");\n               }\n           }\n   \n           System.out.println(list);\n   \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   \n\n# 2 增强for循环\n\n * 定义格式\n   \n   for(元素数据类型 变量名 : 数组/集合对象名) {\n       循环体;\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 示例代码\n   \n   public class ForDemo {\n       public static void main(String[] args) {\n           int[] arr = {1,2,3,4,5};\n           for(int i : arr) {\n               System.out.println(i);\n           }\n           \n           System.out.println("--------");\n   \n           String[] strArray = {"hello","world","java"};\n           for(String s : strArray) {\n               System.out.println(s);\n           }\n           \n           System.out.println("--------");\n   \n           List<String> list = new ArrayList<String>();\n           list.add("hello");\n           list.add("world");\n           list.add("java");\n   \n           for(String s : list) {\n               System.out.println(s);\n           }\n           \n           System.out.println("--------");\n   \n           //内部原理是一个Iterator迭代器\n           /*\n           for(String s : list) {\n               if(s.equals("world")) {\n                   list.add("javaee"); //ConcurrentModificationException\n               }\n           }\n           */\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   \n\n# 3. 集合的案例-List集合存储学生对象三种方式遍历\n\n * 案例需求\n   \n   创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student {\n         private String name;\n         private int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     public class ListDemo {\n         public static void main(String[] args) {\n             //创建List集合对象\n             List<Student> list = new ArrayList<Student>();\n     \n             //创建学生对象\n             Student s1 = new Student("林青霞", 30);\n             Student s2 = new Student("张曼玉", 35);\n             Student s3 = new Student("王祖贤", 33);\n     \n             //把学生添加到集合\n             list.add(s1);\n             list.add(s2);\n             list.add(s3);\n     \n             //迭代器：集合特有的遍历方式\n             Iterator<Student> it = list.iterator();\n             while (it.hasNext()) {\n                 Student s = it.next();\n                 System.out.println(s.getName()+","+s.getAge());\n             }\n             System.out.println("--------");\n     \n             //普通for：带有索引的遍历方式\n             for(int i=0; i<list.size(); i++) {\n                 Student s = list.get(i);\n                 System.out.println(s.getName()+","+s.getAge());\n             }\n             System.out.println("--------");\n     \n             //增强for：最方便的遍历方式\n             for(Student s : list) {\n                 System.out.println(s.getName()+","+s.getAge());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n\n\n# 2.5 List集合的实现类\n\n# 1. List集合子类的特点\n\n * ArrayList集合\n   \n   底层是数组结构实现，查询快、增删慢\n\n * LinkedList集合\n   \n   底层是链表结构实现，查询慢、增删快\n\n# 2. 集合的案例-ArrayList集合存储学生对象三种方式遍历\n\n * 案例需求\n   \n   创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student {\n         private String name;\n         private int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     public class ArrayListDemo {\n         public static void main(String[] args) {\n             //创建ArrayList集合对象\n             ArrayList<Student> array = new ArrayList<Student>();\n     \n             //创建学生对象\n             Student s1 = new Student("林青霞", 30);\n             Student s2 = new Student("张曼玉", 35);\n             Student s3 = new Student("王祖贤", 33);\n     \n             //把学生添加到集合\n             array.add(s1);\n             array.add(s2);\n             array.add(s3);\n     \n             //迭代器：集合特有的遍历方式\n             Iterator<Student> it = array.iterator();\n             while (it.hasNext()) {\n                 Student s = it.next();\n                 System.out.println(s.getName() + "," + s.getAge());\n             }\n             System.out.println("--------");\n     \n             //普通for：带有索引的遍历方式\n             for(int i=0; i<array.size(); i++) {\n                 Student s = array.get(i);\n                 System.out.println(s.getName() + "," + s.getAge());\n             }\n             System.out.println("--------");\n     \n             //增强for：最方便的遍历方式\n             for(Student s : array) {\n                 System.out.println(s.getName() + "," + s.getAge());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n\n# 3. LinkedList集合的特有功能\n\n * 特有方法\n   \n   方法名                         说明\n   public void addFirst(E e)   在该列表开头插入指定的元素\n   public void addLast(E e)    将指定的元素追加到此列表的末尾\n   public E getFirst()         返回此列表中的第一个元素\n   public E getLast()          返回此列表中的最后一个元素\n   public E removeFirst()      从此列表中删除并返回第一个元素\n   public E removeLast()       从此列表中删除并返回最后一个元素\n\n\n# 3. Set集合\n\n\n# 3.1 Set集合概述和特点\n\n * Set集合的特点\n   * 元素存取无序\n   * 没有索引、只能通过迭代器或增强for循环遍历\n   * 不能存储重复元素\n * Set集合的基本使用\n\npublic class SetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        Set<String> set = new HashSet<String>();\n\n        //添加元素\n        set.add("hello");\n        set.add("world");\n        set.add("java");\n        //不包含重复元素的集合\n        set.add("world");\n\n        //遍历\n        for(String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3.2 哈希值\n\n * 哈希值简介\n   \n   是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\n\n * 如何获取哈希值\n   \n   Object类中的public int hashCode()：返回对象的哈希码值\n\n * 哈希值的特点\n   \n   * 同一个对象多次调用hashCode()方法返回的哈希值是相同的\n   * 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同\n\n * 获取哈希值的代码\n   \n   * 学生类\n   \n   public class Student {\n       private String name;\n       private int age;\n   \n       public Student() {\n       }\n   \n       public Student(String name, int age) {\n           this.name = name;\n           this.age = age;\n       }\n   \n       public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public int getAge() {\n           return age;\n       }\n   \n       public void setAge(int age) {\n           this.age = age;\n       }\n   \n       @Override\n       public int hashCode() {\n           return 0;\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   \n   * 测试类\n   \n   public class HashDemo {\n       public static void main(String[] args) {\n           //创建学生对象\n           Student s1 = new Student("林青霞",30);\n   \n           //同一个对象多次调用hashCode()方法返回的哈希值是相同的\n           System.out.println(s1.hashCode()); //1060830840\n           System.out.println(s1.hashCode()); //1060830840\n           System.out.println("--------");\n   \n           Student s2 = new Student("林青霞",30);\n   \n           //默认情况下，不同对象的哈希值是不相同的\n           //通过方法重写，可以实现不同对象的哈希值是相同的\n           System.out.println(s2.hashCode()); //2137211482\n           System.out.println("--------");\n   \n           System.out.println("hello".hashCode()); //99162322\n           System.out.println("world".hashCode()); //113318802\n           System.out.println("java".hashCode()); //3254818\n   \n           System.out.println("world".hashCode()); //113318802\n           System.out.println("--------");\n   \n           System.out.println("重地".hashCode()); //1179395\n           System.out.println("通话".hashCode()); //1179395\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n\n\n# 3.3HashSet集合概述和特点\n\n * HashSet集合的特点\n   \n   * 底层数据结构是哈希表\n   * 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致\n   * 没有带索引的方法，所以不能使用普通for循环遍历\n   * 由于是Set集合，所以是不包含重复元素的集合\n\n * HashSet集合的基本使用\n   \n   public class HashSetDemo01 {\n       public static void main(String[] args) {\n           //创建集合对象\n           HashSet<String> hs = new HashSet<String>();\n   \n           //添加元素\n           hs.add("hello");\n           hs.add("world");\n           hs.add("java");\n   \n           hs.add("world");\n   \n           //遍历\n           for(String s : hs) {\n               System.out.println(s);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 3.4 HashSet集合保证元素唯一性源码分析\n\n * HashSet集合保证元素唯一性的原理\n   \n   1.根据对象的哈希值计算存储位置\n   \n   如果当前位置没有元素则直接存入\n   \n   如果当前位置有元素存在，则进入第二步\n   \n   2.当前元素的元素和已经存在的元素比较哈希值\n   \n   如果哈希值不同，则将当前元素进行存储\n   \n   如果哈希值相同，则进入第三步\n   \n   3.通过equals()方法比较两个元素的内容\n   \n   如果内容不相同，则将当前元素进行存储\n   \n   如果内容相同，则不存储当前元素\n\n * HashSet集合保证元素唯一性的图解\n   \n   \n\n\n# 3.5 常见数据结构之哈希表\n\n\n\n\n# 3.6 HashSet集合存储学生对象并遍历\n\n * 案例需求\n   \n   * 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合\n   * 要求：学生对象的成员变量值相同，我们就认为是同一个对象\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student {\n         private String name;\n         private int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     \n         @Override\n         public boolean equals(Object o) {\n             if (this == o) return true;\n             if (o == null || getClass() != o.getClass()) return false;\n     \n             Student student = (Student) o;\n     \n             if (age != student.age) return false;\n             return name != null ? name.equals(student.name) : student.name == null;\n         }\n     \n         @Override\n         public int hashCode() {\n             int result = name != null ? name.hashCode() : 0;\n             result = 31 * result + age;\n             return result;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     \n   \n   * 测试类\n     \n     public class HashSetDemo02 {\n         public static void main(String[] args) {\n             //创建HashSet集合对象\n             HashSet<Student> hs = new HashSet<Student>();\n     \n             //创建学生对象\n             Student s1 = new Student("林青霞", 30);\n             Student s2 = new Student("张曼玉", 35);\n             Student s3 = new Student("王祖贤", 33);\n     \n             Student s4 = new Student("王祖贤", 33);\n     \n             //把学生添加到集合\n             hs.add(s1);\n             hs.add(s2);\n             hs.add(s3);\n             hs.add(s4);\n     \n             //遍历集合(增强for)\n             for (Student s : hs) {\n                 System.out.println(s.getName() + "," + s.getAge());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     \n\n\n# 3.7 LinkedHashSet集合概述和特点\n\n * LinkedHashSet集合特点\n   \n   * 哈希表和链表实现的Set接口，具有可预测的迭代次序\n   * 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的\n   * 由哈希表保证元素唯一，也就是说没有重复的元素\n\n * LinkedHashSet集合基本使用\n   \n   public class LinkedHashSetDemo {\n       public static void main(String[] args) {\n           //创建集合对象\n           LinkedHashSet<String> linkedHashSet = new LinkedHashSet<String>();\n   \n           //添加元素\n           linkedHashSet.add("hello");\n           linkedHashSet.add("world");\n           linkedHashSet.add("java");\n   \n           linkedHashSet.add("world");\n   \n           //遍历集合\n           for(String s : linkedHashSet) {\n               System.out.println(s);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 3.8 Set集合排序\n\n# 1. TreeSet集合概述和特点\n\n * TreeSet集合概述\n   \n   * 元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法\n     * TreeSet()：根据其元素的自然排序进行排序\n     * TreeSet(Comparator comparator) ：根据指定的比较器进行排序\n   * 没有带索引的方法，所以不能使用普通for循环遍历\n   * 由于是Set集合，所以不包含重复元素的集合\n\n * TreeSet集合基本使用\n   \n   public class TreeSetDemo01 {\n       public static void main(String[] args) {\n           //创建集合对象\n           TreeSet<Integer> ts = new TreeSet<Integer>();\n   \n           //添加元素\n           ts.add(10);\n           ts.add(40);\n           ts.add(30);\n           ts.add(50);\n           ts.add(20);\n   \n           ts.add(30);\n   \n           //遍历集合\n           for(Integer i : ts) {\n               System.out.println(i);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n# 2. 自然排序Comparable的使用\n\n * 案例需求\n   \n   * 存储学生对象并遍历，创建TreeSet集合使用无参构造方法\n   * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n * 实现步骤\n   \n   * 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的\n   * 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法\n   * 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student implements Comparable<Student> {\n         private String name;\n         private int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     \n         @Override\n         public int compareTo(Student s) {\n     //        return 0;\n     //        return 1;\n     //        return -1;\n             //按照年龄从小到大排序\n            int num = this.age - s.age;\n     //        int num = s.age - this.age;\n             //年龄相同时，按照姓名的字母顺序排序\n            int num2 = num==0?this.name.compareTo(s.name):num;\n             return num2;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     \n   \n   * 测试类\n     \n     public class TreeSetDemo02 {\n         public static void main(String[] args) {\n             //创建集合对象\n             TreeSet<Student> ts = new TreeSet<Student>();\n     \n             //创建学生对象\n             Student s1 = new Student("xishi", 29);\n             Student s2 = new Student("wangzhaojun", 28);\n             Student s3 = new Student("diaochan", 30);\n             Student s4 = new Student("yangyuhuan", 33);\n     \n             Student s5 = new Student("linqingxia",33);\n             Student s6 = new Student("linqingxia",33);\n     \n             //把学生添加到集合\n             ts.add(s1);\n             ts.add(s2);\n             ts.add(s3);\n             ts.add(s4);\n             ts.add(s5);\n             ts.add(s6);\n     \n             //遍历集合\n             for (Student s : ts) {\n                 System.out.println(s.getName() + "," + s.getAge());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n\n# 3. 比较器排序Comparator的使用\n\n * 案例需求\n   \n   * 存储学生对象并遍历，创建TreeSet集合使用带参构造方法\n   * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n * 实现步骤\n   \n   * 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的\n   * 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法\n   * 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student {\n         private String name;\n         private int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     public class TreeSetDemo {\n         public static void main(String[] args) {\n             //创建集合对象\n             TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {\n                 @Override\n                 public int compare(Student s1, Student s2) {\n                     //this.age - s.age\n                     //s1,s2\n                     int num = s1.getAge() - s2.getAge();\n                     int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num;\n                     return num2;\n                 }\n             });\n     \n             //创建学生对象\n             Student s1 = new Student("xishi", 29);\n             Student s2 = new Student("wangzhaojun", 28);\n             Student s3 = new Student("diaochan", 30);\n             Student s4 = new Student("yangyuhuan", 33);\n     \n             Student s5 = new Student("linqingxia",33);\n             Student s6 = new Student("linqingxia",33);\n     \n             //把学生添加到集合\n             ts.add(s1);\n             ts.add(s2);\n             ts.add(s3);\n             ts.add(s4);\n             ts.add(s5);\n             ts.add(s6);\n     \n             //遍历集合\n             for (Student s : ts) {\n                 System.out.println(s.getName() + "," + s.getAge());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     \n\n# 4. 成绩排序案例\n\n * 案例需求\n   \n   * 用TreeSet集合存储多个学生信息(姓名，语文成绩，数学成绩)，并遍历该集合\n   * 要求：按照总分从高到低出现\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student {\n         private String name;\n         private int chinese;\n         private int math;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int chinese, int math) {\n             this.name = name;\n             this.chinese = chinese;\n             this.math = math;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getChinese() {\n             return chinese;\n         }\n     \n         public void setChinese(int chinese) {\n             this.chinese = chinese;\n         }\n     \n         public int getMath() {\n             return math;\n         }\n     \n         public void setMath(int math) {\n             this.math = math;\n         }\n     \n         public int getSum() {\n             return this.chinese + this.math;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     \n   \n   * 测试类\n     \n     public class TreeSetDemo {\n         public static void main(String[] args) {\n             //创建TreeSet集合对象，通过比较器排序进行排序\n             TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {\n                 @Override\n                 public int compare(Student s1, Student s2) {\n     //                int num = (s2.getChinese()+s2.getMath())-(s1.getChinese()+s1.getMath());\n                     //主要条件\n                     int num = s2.getSum() - s1.getSum();\n                     //次要条件\n                     int num2 = num == 0 ? s1.getChinese() - s2.getChinese() : num;\n                     int num3 = num2 == 0 ? s1.getName().compareTo(s2.getName()) : num2;\n                     return num3;\n                 }\n             });\n     \n             //创建学生对象\n             Student s1 = new Student("林青霞", 98, 100);\n             Student s2 = new Student("张曼玉", 95, 95);\n             Student s3 = new Student("王祖贤", 100, 93);\n             Student s4 = new Student("柳岩", 100, 97);\n             Student s5 = new Student("风清扬", 98, 98);\n     \n             Student s6 = new Student("左冷禅", 97, 99);\n     //        Student s7 = new Student("左冷禅", 97, 99);\n             Student s7 = new Student("赵云", 97, 99);\n     \n             //把学生对象添加到集合\n             ts.add(s1);\n             ts.add(s2);\n             ts.add(s3);\n             ts.add(s4);\n             ts.add(s5);\n             ts.add(s6);\n             ts.add(s7);\n     \n             //遍历集合\n             for (Student s : ts) {\n                 System.out.println(s.getName() + "," + s.getChinese() + "," + s.getMath() + "," + s.getSum());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     \n\n# 5. 不重复的随机数案例\n\n * 案例需求\n   \n   * 编写一个程序，获取10个1-20之间的随机数，要求随机数不能重复，并在控制台输出\n\n * 代码实现\n   \n   public class SetDemo {\n       public static void main(String[] args) {\n           //创建Set集合对象\n   //        Set<Integer> set = new HashSet<Integer>();\n           Set<Integer> set = new TreeSet<Integer>();\n   \n           //创建随机数对象\n           Random r = new Random();\n   \n           //判断集合的长度是不是小于10\n           while (set.size()<10) {\n               //产生一个随机数，添加到集合\n               int number = r.nextInt(20) + 1;\n               set.add(number);\n           }\n   \n           //遍历集合\n           for(Integer i : set) {\n               System.out.println(i);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 4. 泛型\n\n\n# 4.1 泛型概述和好处\n\n * 泛型概述\n   \n   是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型\n   \n   它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口\n\n * 泛型定义格式\n   \n   * <类型>：指定一种类型的格式。这里的类型可以看成是形参\n   * <类型1,类型2…>：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参\n   * 将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型\n\n * 泛型的好处\n   \n   * 把运行时期的问题提前到了编译期间\n   * 避免了强制类型转换\n\n\n# 4.2 泛型类\n\n * 定义格式\n   \n   修饰符 class 类名<类型> {  }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 泛型类\n     \n     public class Generic<T> {\n         private T t;\n     \n         public T getT() {\n             return t;\n         }\n     \n         public void setT(T t) {\n             this.t = t;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     \n   \n   * 测试类\n     \n     public class GenericDemo {\n         public static void main(String[] args) {\n             Generic<String> g1 = new Generic<String>();\n             g1.setT("林青霞");\n             System.out.println(g1.getT());\n     \n             Generic<Integer> g2 = new Generic<Integer>();\n             g2.setT(30);\n             System.out.println(g2.getT());\n     \n             Generic<Boolean> g3 = new Generic<Boolean>();\n             g3.setT(true);\n             System.out.println(g3.getT());\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n\n# 3.3 泛型方法\n\n * 定义格式\n   \n   修饰符 <类型> 返回值类型 方法名(类型 变量名) {  }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 带有泛型方法的类\n     \n     public class Generic {\n         public <T> void show(T t) {\n             System.out.println(t);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n   \n   * 测试类\n     \n     public class GenericDemo {\n         public static void main(String[] args) {\n     \t\tGeneric g = new Generic();\n             g.show("林青霞");\n             g.show(30);\n             g.show(true);\n             g.show(12.34);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     \n\n\n# 3.4 泛型接口\n\n * 定义格式\n   \n   修饰符 interface 接口名<类型> {  }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 泛型接口\n     \n     public interface Generic<T> {\n         void show(T t);\n     }\n     \n     \n     1\n     2\n     3\n     \n   \n   * 泛型接口实现类\n     \n     public class GenericImpl<T> implements Generic<T> {\n         @Override\n         public void show(T t) {\n             System.out.println(t);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n   \n   * 测试类\n     \n     public class GenericDemo {\n         public static void main(String[] args) {\n             Generic<String> g1 = new GenericImpl<String>();\n             g1.show("林青霞");\n     \n             Generic<Integer> g2 = new GenericImpl<Integer>();\n             g2.show(30);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     \n\n\n# 3.5 类型通配符\n\n * 类型通配符的作用\n   \n   为了表示各种泛型List的父类，可以使用类型通配符\n\n * 类型通配符的分类\n   \n   - 类型通配符：<?>\n     - List<?>：表示元素类型未知的List，它的元素可以匹配任何的类型\n     - 这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中\n   - 类型通配符上限：<? extends 类型>\n     - List<? extends Number>：它表示的类型是Number或者其子类型\n   - 类型通配符下限：<? super 类型>\n     - List<? super Number>：它表示的类型是Number或者其父类型\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 类型通配符的基本使用\n   \n   public class GenericDemo {\n       public static void main(String[] args) {\n           //类型通配符：<?>\n           List<?> list1 = new ArrayList<Object>();\n           List<?> list2 = new ArrayList<Number>();\n           List<?> list3 = new ArrayList<Integer>();\n           System.out.println("--------");\n   \n           //类型通配符上限：<? extends 类型>\n   //        List<? extends Number> list4 = new ArrayList<Object>();\n           List<? extends Number> list5 = new ArrayList<Number>();\n           List<? extends Number> list6 = new ArrayList<Integer>();\n           System.out.println("--------");\n   \n           //类型通配符下限：<? super 类型>\n           List<? super Number> list7 = new ArrayList<Object>();\n           List<? super Number> list8 = new ArrayList<Number>();\n   //        List<? super Number> list9 = new ArrayList<Integer>();\n   \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 5. 可变参数\n\n\n# 5.1 可变参数\n\n * 可变参数介绍\n   \n   可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了\n\n * 可变参数定义格式\n   \n   修饰符 返回值类型 方法名(数据类型… 变量名) {  }\n   \n   \n   1\n   \n\n * 可变参数的注意事项\n   \n   * 这里的变量其实是一个数组\n   * 如果一个方法有多个参数，包含可变参数，可变参数要放在最后\n\n * 可变参数的基本使用\n   \n   public class ArgsDemo01 {\n       public static void main(String[] args) {\n           System.out.println(sum(10, 20));\n           System.out.println(sum(10, 20, 30));\n           System.out.println(sum(10, 20, 30, 40));\n   \n           System.out.println(sum(10,20,30,40,50));\n           System.out.println(sum(10,20,30,40,50,60));\n           System.out.println(sum(10,20,30,40,50,60,70));\n           System.out.println(sum(10,20,30,40,50,60,70,80,90,100));\n       }\n   \n   //    public static int sum(int b,int... a) {\n   //        return 0;\n   //    }\n   \n       public static int sum(int... a) {\n           int sum = 0;\n           for(int i : a) {\n               sum += i;\n           }\n           return sum;\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 5.2可变参数的使用\n\n * Arrays工具类中有一个静态方法：\n   \n   - public static <T> List<T> asList(T... a)：返回由指定数组支持的固定大小的列表\n   - 返回的集合不能做增删操作，可以做修改操作\n   \n   \n   1\n   2\n   \n\n * List接口中有一个静态方法：\n   \n   - public static <E> List<E> of(E... elements)：返回包含任意数量元素的不可变列表\n   - 返回的集合不能做增删改操作\n   \n   \n   1\n   2\n   \n\n * Set接口中有一个静态方法：\n   \n   - public static <E> Set<E> of(E... elements) ：返回一个包含任意数量元素的不可变集合\n   - 在给元素的时候，不能给重复的元素\n   - 返回的集合不能做增删操作，没有修改的方法\n   \n   \n   1\n   2\n   3\n   \n\n * 示例代码\n   \n   public class ArgsDemo02 {\n       public static void main(String[] args) {\n           //public static <T> List<T> asList(T... a)：返回由指定数组支持的固定大小的列表\n   //        List<String> list = Arrays.asList("hello", "world", "java");\n   //\n   ////        list.add("javaee"); //UnsupportedOperationException\n   ////        list.remove("world"); //UnsupportedOperationException\n   //        list.set(1,"javaee");\n   //\n   //        System.out.println(list);\n   \n           //public static <E> List<E> of(E... elements)：返回包含任意数量元素的不可变列表\n   //        List<String> list = List.of("hello", "world", "java", "world");\n   //\n   ////        list.add("javaee");//UnsupportedOperationException\n   ////        list.remove("java");//UnsupportedOperationException\n   ////        list.set(1,"javaee");//UnsupportedOperationException\n   //\n   //        System.out.println(list);\n   \n           //public static <E> Set<E> of(E... elements) ：返回一个包含任意数量元素的不可变集合\n   //        Set<String> set = Set.of("hello", "world", "java","world"); //IllegalArgumentException\n           //Set<String> set = Set.of("hello", "world", "java");\n   \n   //        set.add("javaee");//UnsupportedOperationException\n   //        set.remove("world");//UnsupportedOperationException\n   \n           //System.out.println(set);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n * public class HashMapDemo {\n       public static void main(String[] args) {\n           //键盘录入一个字符串\n           Scanner sc = new Scanner(System.in);\n           System.out.println("请输入一个字符串：");\n           String line = sc.nextLine();\n   \n           //创建HashMap集合，键是Character，值是Integer\n   //        HashMap<Character, Integer> hm = new HashMap<Character, Integer>();\n           TreeMap<Character, Integer> hm = new TreeMap<Character, Integer>();\n   \n           //遍历字符串，得到每一个字符\n           for (int i = 0; i < line.length(); i++) {\n               char key = line.charAt(i);\n   \n               //拿得到的每一个字符作为键到HashMap集合中去找对应的值，看其返回值\n               Integer value = hm.get(key);\n   \n               if (value == null) {\n                   //如果返回值是null：说明该字符在HashMap集合中不存在，就把该字符作为键，1作为值存储\n                   hm.put(key,1);\n               } else {\n                   //如果返回值不是null：说明该字符在HashMap集合中存在，把该值加1，然后重新存储该字符和对应的值\n                   value++;\n                   hm.put(key,value);\n               }\n           }\n   \n           //遍历HashMap集合，得到键和值，按照要求进行拼接\n           StringBuilder sb = new StringBuilder();\n   \n           Set<Character> keySet = hm.keySet();\n           for(Character key : keySet) {\n               Integer value = hm.get(key);\n               sb.append(key).append("(").append(value).append(")");\n           }\n   \n           String result = sb.toString();\n   \n           //输出结果\n          System.out.println(result);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   \n\n\n# 6. Map集合\n\n\n# 6.1 Map集合概述和特点\n\n * Map集合概述\n   \n   interface Map<K,V>  K：键的类型；V：值的类型\n   \n   \n   1\n   \n\n * Map集合的特点\n   \n   * 键值对映射关系\n   * 一个键对应一个值\n   * 键不能重复，值可以重复\n   * 元素存取无序\n\n * Map集合的基本使用\n   \n   public class MapDemo01 {\n       public static void main(String[] args) {\n           //创建集合对象\n           Map<String,String> map = new HashMap<String,String>();\n   \n           //V put(K key, V value) 将指定的值与该映射中的指定键相关联\n           map.put("itheima001","林青霞");\n           map.put("itheima002","张曼玉");\n           map.put("itheima003","王祖贤");\n           map.put("itheima003","柳岩");\n   \n           //输出集合对象\n           System.out.println(map);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n\n# 6.2 Map集合的基本功能\n\n * 方法介绍\n   \n   方法名                                   说明\n   V put(K key, V value)                 添加元素\n   V remove(Object key)                  根据键删除键值对元素\n   void clear()                          移除所有的键值对元素\n   boolean containsKey(Object key)       判断集合是否包含指定的键\n   boolean containsValue(Object value)   判断集合是否包含指定的值\n   boolean isEmpty()                     判断集合是否为空\n   int size()                            集合的长度，也就是集合中键值对的个数\n\n * 示例代码\n   \n   public class MapDemo02 {\n       public static void main(String[] args) {\n           //创建集合对象\n           Map<String,String> map = new HashMap<String,String>();\n   \n           //V put(K key,V value)：添加元素\n           map.put("张无忌","赵敏");\n           map.put("郭靖","黄蓉");\n           map.put("杨过","小龙女");\n   \n           //V remove(Object key)：根据键删除键值对元素\n   //        System.out.println(map.remove("郭靖"));\n   //        System.out.println(map.remove("郭襄"));\n   \n           //void clear()：移除所有的键值对元素\n   //        map.clear();\n   \n           //boolean containsKey(Object key)：判断集合是否包含指定的键\n   //        System.out.println(map.containsKey("郭靖"));\n   //        System.out.println(map.containsKey("郭襄"));\n   \n           //boolean isEmpty()：判断集合是否为空\n   //        System.out.println(map.isEmpty());\n   \n           //int size()：集合的长度，也就是集合中键值对的个数\n           System.out.println(map.size());\n   \n   \n           //输出集合对象\n           System.out.println(map);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n\n# 6.3Map集合的获取功能\n\n * 方法介绍\n   \n   \n\n * 示例代码\n   \n   public class MapDemo03 {\n       public static void main(String[] args) {\n           //创建集合对象\n           Map<String, String> map = new HashMap<String, String>();\n   \n           //添加元素\n           map.put("张无忌", "赵敏");\n           map.put("郭靖", "黄蓉");\n           map.put("杨过", "小龙女");\n   \n           //V get(Object key):根据键获取值\n   //        System.out.println(map.get("张无忌"));\n   //        System.out.println(map.get("张三丰"));\n   \n           //Set<K> keySet():获取所有键的集合\n   //        Set<String> keySet = map.keySet();\n   //        for(String key : keySet) {\n   //            System.out.println(key);\n   //        }\n   \n           //Collection<V> values():获取所有值的集合\n           Collection<String> values = map.values();\n           for(String value : values) {\n               System.out.println(value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   \n\n\n# 6.4Map集合的遍历(方式1)\n\n * 遍历思路\n   \n   * 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n     * 把所有的丈夫给集中起来\n     * 遍历丈夫的集合，获取到每一个丈夫\n     * 根据丈夫去找对应的妻子\n\n * 步骤分析\n   \n   * 获取所有键的集合。用keySet()方法实现\n   * 遍历键的集合，获取到每一个键。用增强for实现\n   * 根据键去找值。用get(Object key)方法实现\n\n * 代码实现\n   \n   public class MapDemo01 {\n       public static void main(String[] args) {\n           //创建集合对象\n           Map<String, String> map = new HashMap<String, String>();\n   \n           //添加元素\n           map.put("张无忌", "赵敏");\n           map.put("郭靖", "黄蓉");\n           map.put("杨过", "小龙女");\n   \n           //获取所有键的集合。用keySet()方法实现\n           Set<String> keySet = map.keySet();\n           //遍历键的集合，获取到每一个键。用增强for实现\n           for (String key : keySet) {\n               //根据键去找值。用get(Object key)方法实现\n               String value = map.get(key);\n               System.out.println(key + "," + value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 6.5 Map集合的遍历(方式2)\n\n * 遍历思路\n   \n   * 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n     * 获取所有结婚证的集合\n     * 遍历结婚证的集合，得到每一个结婚证\n     * 根据结婚证获取丈夫和妻子\n\n * 步骤分析\n   \n   * 获取所有键值对对象的集合\n     * Set<Map.Entry<K,V>> entrySet()：获取所有键值对对象的集合\n   * 遍历键值对对象的集合，得到每一个键值对对象\n     * 用增强for实现，得到每一个Map.Entry\n   * 根据键值对对象获取键和值\n     * 用getKey()得到键\n     * 用getValue()得到值\n\n * 代码实现\n   \n   public class MapDemo02 {\n       public static void main(String[] args) {\n           //创建集合对象\n           Map<String, String> map = new HashMap<String, String>();\n   \n           //添加元素\n           map.put("张无忌", "赵敏");\n           map.put("郭靖", "黄蓉");\n           map.put("杨过", "小龙女");\n   \n           //获取所有键值对对象的集合\n           Set<Map.Entry<String, String>> entrySet = map.entrySet();\n           //遍历键值对对象的集合，得到每一个键值对对象\n           for (Map.Entry<String, String> me : entrySet) {\n               //根据键值对对象获取键和值\n               String key = me.getKey();\n               String value = me.getValue();\n               System.out.println(key + "," + value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 6.6 Map集合的案例\n\n# 1. HashMap集合练习之键是String值是Student\n\n * 案例需求\n   \n   创建一个HashMap集合，键是学号(String)，值是学生对象(Student)。存储三个键值对元素，并遍历\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student {\n         private String name;\n         private int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     /*\n         需求：\n             创建一个HashMap集合，键是学号(String)，值是学生对象(Student)。存储三个键值对元素，并遍历\n     \n         思路：\n             1:定义学生类\n             2:创建HashMap集合对象\n             3:创建学生对象\n             4:把学生添加到集合\n             5:遍历集合\n                 方式1：键找值\n                 方式2：键值对对象找键和值\n      */\n     public class HashMapDemo {\n         public static void main(String[] args) {\n             //创建HashMap集合对象\n             HashMap<String, Student> hm = new HashMap<String, Student>();\n     \n             //创建学生对象\n             Student s1 = new Student("林青霞", 30);\n             Student s2 = new Student("张曼玉", 35);\n             Student s3 = new Student("王祖贤", 33);\n     \n             //把学生添加到集合\n             hm.put("itheima001", s1);\n             hm.put("itheima002", s2);\n             hm.put("itheima003", s3);\n     \n             //方式1：键找值\n             Set<String> keySet = hm.keySet();\n             for (String key : keySet) {\n                 Student value = hm.get(key);\n                 System.out.println(key + "," + value.getName() + "," + value.getAge());\n             }\n             System.out.println("--------");\n     \n             //方式2：键值对对象找键和值\n             Set<Map.Entry<String, Student>> entrySet = hm.entrySet();\n             for (Map.Entry<String, Student> me : entrySet) {\n                 String key = me.getKey();\n                 Student value = me.getValue();\n                 System.out.println(key + "," + value.getName() + "," + value.getAge());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     \n\n# 2. HashMap集合练习之键是Student值是String\n\n * 案例需求\n   \n   * 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。\n   * 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student {\n         private String name;\n         private int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     \n         @Override\n         public boolean equals(Object o) {\n             if (this == o) return true;\n             if (o == null || getClass() != o.getClass()) return false;\n     \n             Student student = (Student) o;\n     \n             if (age != student.age) return false;\n             return name != null ? name.equals(student.name) : student.name == null;\n         }\n     \n         @Override\n         public int hashCode() {\n             int result = name != null ? name.hashCode() : 0;\n             result = 31 * result + age;\n             return result;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     \n   \n   * 测试类\n     \n     public class HashMapDemo {\n         public static void main(String[] args) {\n             //创建HashMap集合对象\n             HashMap<Student, String> hm = new HashMap<Student, String>();\n     \n             //创建学生对象\n             Student s1 = new Student("林青霞", 30);\n             Student s2 = new Student("张曼玉", 35);\n             Student s3 = new Student("王祖贤", 33);\n             Student s4 = new Student("王祖贤", 33);\n     \n             //把学生添加到集合\n             hm.put(s1, "西安");\n             hm.put(s2, "武汉");\n             hm.put(s3, "郑州");\n             hm.put(s4, "北京");\n     \n             //遍历集合\n             Set<Student> keySet = hm.keySet();\n             for (Student key : keySet) {\n                 String value = hm.get(key);\n                 System.out.println(key.getName() + "," + key.getAge() + "," + value);\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     \n\n# 3. 集合嵌套之ArrayList嵌套HashMap\n\n * 案例需求\n   \n   * 创建一个ArrayList集合，存储三个元素，每一个元素都是HashMap\n   * 每一个HashMap的键和值都是String，并遍历。\n\n * 代码实现\n   \n   public class ArrayListIncludeHashMapDemo {\n       public static void main(String[] args) {\n           //创建ArrayList集合\n           ArrayList<HashMap<String, String>> array = new ArrayList<HashMap<String, String>>();\n   \n           //创建HashMap集合，并添加键值对元素\n           HashMap<String, String> hm1 = new HashMap<String, String>();\n           hm1.put("孙策", "大乔");\n           hm1.put("周瑜", "小乔");\n           //把HashMap作为元素添加到ArrayList集合\n           array.add(hm1);\n   \n           HashMap<String, String> hm2 = new HashMap<String, String>();\n           hm2.put("郭靖", "黄蓉");\n           hm2.put("杨过", "小龙女");\n           //把HashMap作为元素添加到ArrayList集合\n           array.add(hm2);\n   \n           HashMap<String, String> hm3 = new HashMap<String, String>();\n           hm3.put("令狐冲", "任盈盈");\n           hm3.put("林平之", "岳灵珊");\n           //把HashMap作为元素添加到ArrayList集合\n           array.add(hm3);\n   \n           //遍历ArrayList集合\n           for (HashMap<String, String> hm : array) {\n               Set<String> keySet = hm.keySet();\n               for (String key : keySet) {\n                   String value = hm.get(key);\n                   System.out.println(key + "," + value);\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   \n\n# 4. 集合嵌套之HashMap嵌套ArrayList\n\n * 案例需求\n   \n   * 创建一个HashMap集合，存储三个键值对元素，每一个键值对元素的键是String，值是ArrayList\n   * 每一个ArrayList的元素是String，并遍历。\n\n * 代码实现\n   \n   public class HashMapIncludeArrayListDemo {\n       public static void main(String[] args) {\n           //创建HashMap集合\n           HashMap<String, ArrayList<String>> hm = new HashMap<String, ArrayList<String>>();\n   \n           //创建ArrayList集合，并添加元素\n           ArrayList<String> sgyy = new ArrayList<String>();\n           sgyy.add("诸葛亮");\n           sgyy.add("赵云");\n           //把ArrayList作为元素添加到HashMap集合\n           hm.put("三国演义",sgyy);\n   \n           ArrayList<String> xyj = new ArrayList<String>();\n           xyj.add("唐僧");\n           xyj.add("孙悟空");\n           //把ArrayList作为元素添加到HashMap集合\n           hm.put("西游记",xyj);\n   \n           ArrayList<String> shz = new ArrayList<String>();\n           shz.add("武松");\n           shz.add("鲁智深");\n           //把ArrayList作为元素添加到HashMap集合\n           hm.put("水浒传",shz);\n   \n           //遍历HashMap集合\n           Set<String> keySet = hm.keySet();\n           for(String key : keySet) {\n               System.out.println(key);\n               ArrayList<String> value = hm.get(key);\n               for(String s : value) {\n                   System.out.println("\\t" + s);\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   \n\n# 5. 统计字符串中每个字符出现的次数\n\n * 案例需求\n   \n   * 键盘录入一个字符串，要求统计字符串中每个字符串出现的次数。\n   * 举例：键盘录入“aababcabcdabcde” 在控制台输出：“a(5)b(4)c(3)d(2)e(1)”\n\n * 代码实现\n   \n   public class HashMapDemo {\n       public static void main(String[] args) {\n           //键盘录入一个字符串\n           Scanner sc = new Scanner(System.in);\n           System.out.println("请输入一个字符串：");\n           String line = sc.nextLine();\n   \n           //创建HashMap集合，键是Character，值是Integer\n   //        HashMap<Character, Integer> hm = new HashMap<Character, Integer>();\n           TreeMap<Character, Integer> hm = new TreeMap<Character, Integer>();\n   \n           //遍历字符串，得到每一个字符\n           for (int i = 0; i < line.length(); i++) {\n               char key = line.charAt(i);\n   \n               //拿得到的每一个字符作为键到HashMap集合中去找对应的值，看其返回值\n               Integer value = hm.get(key);\n   \n               if (value == null) {\n                   //如果返回值是null：说明该字符在HashMap集合中不存在，就把该字符作为键，1作为值存储\n                   hm.put(key,1);\n               } else {\n                   //如果返回值不是null：说明该字符在HashMap集合中存在，把该值加1，然后重新存储该字符和对应的值\n                   value++;\n                   hm.put(key,value);\n               }\n           }\n   \n           //遍历HashMap集合，得到键和值，按照要求进行拼接\n           StringBuilder sb = new StringBuilder();\n   \n           Set<Character> keySet = hm.keySet();\n           for(Character key : keySet) {\n               Integer value = hm.get(key);\n               sb.append(key).append("(").append(value).append(")");\n           }\n   \n           String result = sb.toString();\n   \n           //输出结果\n           System.out.println(result);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   \n\n\n# 7. Collections集合工具类\n\n\n# 7.1 Collections概述和使用\n\n * Collections类的作用\n   \n   是针对集合操作的工具类\n\n * Collections类常用方法\n   \n   \n\n * 示例代码\n   \n   public class CollectionsDemo01 {\n       public static void main(String[] args) {\n           //创建集合对象\n           List<Integer> list = new ArrayList<Integer>();\n   \n           //添加元素\n           list.add(30);\n           list.add(20);\n           list.add(50);\n           list.add(10);\n           list.add(40);\n   \n           //public static <T extends Comparable<? super T>> void sort(List<T> list)：将指定的列表按升序排序\n   //        Collections.sort(list);\n   \n           //public static void reverse(List<?> list)：反转指定列表中元素的顺序\n   //        Collections.reverse(list);\n   \n           //public static void shuffle(List<?> list)：使用默认的随机源随机排列指定的列表\n           Collections.shuffle(list);\n   \n           System.out.println(list);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 7.2 ArrayList集合存储学生并排序\n\n * 案例需求\n   \n   * ArrayList存储学生对象，使用Collections对ArrayList进行排序\n   * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student {\n         private String name;\n         private int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     public class CollectionsDemo02 {\n         public static void main(String[] args) {\n             //创建ArrayList集合对象\n             ArrayList<Student> array = new ArrayList<Student>();\n     \n             //创建学生对象\n             Student s1 = new Student("linqingxia", 30);\n             Student s2 = new Student("zhangmanyu", 35);\n             Student s3 = new Student("wangzuxian", 33);\n             Student s4 = new Student("liuyan", 33);\n     \n             //把学生添加到集合\n             array.add(s1);\n             array.add(s2);\n             array.add(s3);\n             array.add(s4);\n     \n             //使用Collections对ArrayList集合排序\n             //sort(List<T> list, Comparator<? super T> c)\n             Collections.sort(array, new Comparator<Student>() {\n                 @Override\n                 public int compare(Student s1, Student s2) {\n                     //按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n                     int num = s1.getAge() - s2.getAge();\n                     int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num;\n                     return num2;\n                 }\n             });\n     \n             //遍历集合\n             for (Student s : array) {\n                 System.out.println(s.getName() + "," + s.getAge());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     \n\n\n# 8. 斗地主案例\n\n\n# 8.1 模拟斗地主案例-普通版本\n\n * 案例需求\n   \n   通过程序实现斗地主过程中的洗牌，发牌和看牌\n\n * 代码实现\n   \n   public class PokerDemo {\n       public static void main(String[] args) {\n           //创建一个牌盒，也就是定义一个集合对象，用ArrayList集合实现\n           ArrayList<String> array = new ArrayList<String>();\n   \n           //往牌盒里面装牌\n           /*\n               ♦2,♦3,♦4...♦K,♦A\n               ♣2,...\n               ♥2,...\n               ♠2,...\n               小王，大王\n            */\n           //定义花色数组\n           String[] colors = {"♦", "♣", "♥", "♠"};\n           //定义点数数组\n           String[] numbers = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"};\n           for (String color : colors) {\n               for (String number : numbers) {\n                   array.add(color + number);\n               }\n           }\n           array.add("小王");\n           array.add("大王");\n   \n           //洗牌，也就是把牌打撒，用Collections的shuffle()方法实现\n           Collections.shuffle(array);\n   \n   //        System.out.println(array);\n   \n           //发牌，也就是遍历集合，给三个玩家发牌\n           ArrayList<String> lqxArray = new ArrayList<String>();\n           ArrayList<String> lyArray = new ArrayList<String>();\n           ArrayList<String> fqyArray = new ArrayList<String>();\n           ArrayList<String> dpArray = new ArrayList<String>();\n   \n           for (int i = 0; i < array.size(); i++) {\n               String poker = array.get(i);\n               if (i >= array.size() - 3) {\n                   dpArray.add(poker);\n               } else if (i % 3 == 0) {\n                   lqxArray.add(poker);\n               } else if (i % 3 == 1) {\n                   lyArray.add(poker);\n               } else if (i % 3 == 2) {\n                   fqyArray.add(poker);\n               }\n           }\n   \n           //看牌，也就是三个玩家分别遍历自己的牌\n           lookPoker("林青霞", lqxArray);\n           lookPoker("柳岩", lyArray);\n           lookPoker("风清扬", fqyArray);\n           lookPoker("底牌", dpArray);\n       }\n   \n       //看牌的方法\n       public static void lookPoker(String name, ArrayList<String> array) {\n           System.out.print(name + "的牌是：");\n           for (String poker : array) {\n               System.out.print(poker + " ");\n           }\n           System.out.println();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   \n\n\n# 3.2 模拟斗地主案例-升级版本\n\n * 案例需求\n   \n   通过程序实现斗地主过程中的洗牌，发牌和看牌。要求：对牌进行排序\n\n * 代码实现\n   \n   public class PokerDemo {\n       public static void main(String[] args) {\n           //创建HashMap，键是编号，值是牌\n           HashMap<Integer, String> hm = new HashMap<Integer, String>();\n   \n           //创建ArrayList，存储编号\n           ArrayList<Integer> array = new ArrayList<Integer>();\n   \n           //创建花色数组和点数数组\n           String[] colors = {"♦", "♣", "♥", "♠"};\n           String[] numbers = {"3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"};\n   \n           //从0开始往HashMap里面存储编号，并存储对应的牌。同时往ArrayList里面存储编号\n           int index = 0;\n   \n           for (String number : numbers) {\n               for (String color : colors) {\n                   hm.put(index, color + number);\n                   array.add(index);\n                   index++;\n               }\n           }\n           hm.put(index, "小王");\n           array.add(index);\n           index++;\n           hm.put(index, "大王");\n           array.add(index);\n   \n           //洗牌(洗的是编号)，用Collections的shuffle()方法实现\n           Collections.shuffle(array);\n   \n           //发牌(发的也是编号，为了保证编号是排序的，创建TreeSet集合接收)\n           TreeSet<Integer> lqxSet = new TreeSet<Integer>();\n           TreeSet<Integer> lySet = new TreeSet<Integer>();\n           TreeSet<Integer> fqySet = new TreeSet<Integer>();\n           TreeSet<Integer> dpSet = new TreeSet<Integer>();\n   \n           for (int i = 0; i < array.size(); i++) {\n               int x = array.get(i);\n               if (i >= array.size() - 3) {\n                   dpSet.add(x);\n               } else if (i % 3 == 0) {\n                   lqxSet.add(x);\n               } else if (i % 3 == 1) {\n                   lySet.add(x);\n               } else if (i % 3 == 2) {\n                   fqySet.add(x);\n               }\n           }\n   \n           //调用看牌方法\n           lookPoker("林青霞", lqxSet, hm);\n           lookPoker("柳岩", lySet, hm);\n           lookPoker("风清扬", fqySet, hm);\n           lookPoker("底牌", dpSet, hm);\n       }\n   \n       //定义方法看牌(遍历TreeSet集合，获取编号，到HashMap集合找对应的牌)\n       public static void lookPoker(String name, TreeSet<Integer> ts, HashMap<Integer, String> hm) {\n           System.out.print(name + "的牌是：");\n           for (Integer key : ts) {\n               String poker = hm.get(key);\n               System.out.print(poker + " ");\n           }\n           System.out.println();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   ',normalizedContent:'# 集合\n\n\n# 1. collection集合\n\n\n# 1.1 集合体系结构\n\n * 集合类的特点\n\n提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变\n\n * 集合类的体系图\n\n\n\n\n# 1.2 collection集合概述和基本使用\n\n * collection集合概述\n   \n   * 是单例集合的顶层接口，它表示一组对象，这些对象也称为collection的元素\n   \n   * jdk 不提供此接口的任何直接实现，它提供更具体的子接口（如set和list）实现\n\n * collection集合基本使用\n   \n   public class collectiondemo01 {\n       public static void main(string[] args) {\n           //创建collection集合的对象\n           collection<string> c = new arraylist<string>();\n   \n           //添加元素：boolean add(e e)\n           c.add("hello");\n           c.add("world");\n           c.add("java");\n   \n           //输出集合对象\n           system.out.println(c);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n\n# 1.3 collection集合的常用方法\n\n方法名                          说明\nboolean add(e e)             添加元素\nboolean remove(object o)     从集合中移除指定的元素\nvoid clear()                 清空集合中的元素\nboolean contains(object o)   判断集合中是否存在指定的元素\nboolean isempty()            判断集合是否为空\nint size()                   集合的长度，也就是集合中元素的个数\n\n\n# 1.4 collection集合的遍历\n\n * 迭代器的介绍\n   \n   - 迭代器，集合的专用遍历方式\n   - iterator<e> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n   - 迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的\n   \n   \n   1\n   2\n   3\n   \n\n * collection集合的遍历\n\npublic class iteratordemo {\n    public static void main(string[] args) {\n        //创建集合对象\n        collection<string> c = new arraylist<>();\n\n        //添加元素\n        c.add("hello");\n        c.add("world");\n        c.add("java");\n        c.add("javaee");\n\n        //iterator<e> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n        iterator<string> it = c.iterator();\n\n        //用while循环改进元素的判断和获取\n        while (it.hasnext()) {\n            string s = it.next();\n            system.out.println(s);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 1.5 集合使用步骤图解\n\n * 使用步骤\n\n\n\n\n# 1.6 集合的案例-collection集合存储学生对象并遍历\n\n * 案例需求\n   \n   创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n * 代码实现\n   \n   * 学生类\n   \n   public class student {\n       private string name;\n       private int age;\n   \n       public student() {\n       }\n   \n       public student(string name, int age) {\n           this.name = name;\n           this.age = age;\n       }\n   \n       public string getname() {\n           return name;\n       }\n   \n       public void setname(string name) {\n           this.name = name;\n       }\n   \n       public int getage() {\n           return age;\n       }\n   \n       public void setage(int age) {\n           this.age = age;\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n   * 测试类\n   \n   public class collectiondemo {\n       public static void main(string[] args) {\n           //创建collection集合对象\n           collection<student> c = new arraylist<student>();\n   \n           //创建学生对象\n           student s1 = new student("林青霞", 30);\n           student s2 = new student("张曼玉", 35);\n           student s3 = new student("王祖贤", 33);\n   \n           //把学生添加到集合\n           c.add(s1);\n           c.add(s2);\n           c.add(s3);\n   \n           //遍历集合(迭代器方式)\n           iterator<student> it = c.iterator();\n           while (it.hasnext()) {\n               student s = it.next();\n               system.out.println(s.getname() + "," + s.getage());\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   \n\n\n# 2. list集合\n\n\n# 2.1 list集合概述和特点\n\n * list集合概述\n   * 有序集合(也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素\n   * 与set集合不同，列表通常允许重复的元素\n * list集合特点\n   * 有索引\n   * 可以存储重复元素\n   * 元素存取有序\n\n\n# 2.2 list集合的特有方法\n\n方法名                             描述\nvoid add(int index,e element)   在此集合中的指定位置插入指定的元素\ne remove(int index)             删除指定索引处的元素，返回被删除的元素\ne set(int index,e element)      修改指定索引处的元素，返回被修改的元素\ne get(int index)                返回指定索引处的元素\n\n\n# 2.3 并发修改异常\n\n * 出现的原因\n   \n   迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：concurrentmodificationexception\n\n * 解决的方案\n   \n   用for循环遍历，然后用集合对象做对应的操作即可\n\n * 示例代码\n   \n   public class listdemo {\n       public static void main(string[] args) {\n           //创建集合对象\n           list<string> list = new arraylist<string>();\n   \n           //添加元素\n           list.add("hello");\n           list.add("world");\n           list.add("java");\n   \n           //遍历集合，得到每一个元素，看有没有"world"这个元素，如果有，我就添加一个"javaee"元素，请写代码实现\n   //        iterator<string> it = list.iterator();\n   //        while (it.hasnext()) {\n   //            string s = it.next();\n   //            if(s.equals("world")) {\n   //                list.add("javaee");\n   //            }\n   //        }\n   \n           for(int i=0; i<list.size(); i++) {\n               string s = list.get(i);\n               if(s.equals("world")) {\n                   list.add("javaee");\n               }\n           }\n   \n           //输出集合对象\n           system.out.println(list);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n\n# 2.4 list集合循环遍历\n\n# 1 列表迭代器\n\n * list iterator介绍\n   \n   * 通过list集合的listiterator()方法得到，所以说它是list集合特有的迭代器\n   * 用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置\n\n * 示例代码\n   \n   public class listiteratordemo {\n       public static void main(string[] args) {\n           //创建集合对象\n           list<string> list = new arraylist<string>();\n   \n           //添加元素\n           list.add("hello");\n           list.add("world");\n           list.add("java");\n   \n           //获取列表迭代器\n           listiterator<string> lit = list.listiterator();\n           while (lit.hasnext()) {\n               string s = lit.next();\n               if(s.equals("world")) {\n                   lit.add("javaee");\n               }\n           }\n   \n           system.out.println(list);\n   \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   \n\n# 2 增强for循环\n\n * 定义格式\n   \n   for(元素数据类型 变量名 : 数组/集合对象名) {\n       循环体;\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 示例代码\n   \n   public class fordemo {\n       public static void main(string[] args) {\n           int[] arr = {1,2,3,4,5};\n           for(int i : arr) {\n               system.out.println(i);\n           }\n           \n           system.out.println("--------");\n   \n           string[] strarray = {"hello","world","java"};\n           for(string s : strarray) {\n               system.out.println(s);\n           }\n           \n           system.out.println("--------");\n   \n           list<string> list = new arraylist<string>();\n           list.add("hello");\n           list.add("world");\n           list.add("java");\n   \n           for(string s : list) {\n               system.out.println(s);\n           }\n           \n           system.out.println("--------");\n   \n           //内部原理是一个iterator迭代器\n           /*\n           for(string s : list) {\n               if(s.equals("world")) {\n                   list.add("javaee"); //concurrentmodificationexception\n               }\n           }\n           */\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   \n\n# 3. 集合的案例-list集合存储学生对象三种方式遍历\n\n * 案例需求\n   \n   创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student {\n         private string name;\n         private int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     public class listdemo {\n         public static void main(string[] args) {\n             //创建list集合对象\n             list<student> list = new arraylist<student>();\n     \n             //创建学生对象\n             student s1 = new student("林青霞", 30);\n             student s2 = new student("张曼玉", 35);\n             student s3 = new student("王祖贤", 33);\n     \n             //把学生添加到集合\n             list.add(s1);\n             list.add(s2);\n             list.add(s3);\n     \n             //迭代器：集合特有的遍历方式\n             iterator<student> it = list.iterator();\n             while (it.hasnext()) {\n                 student s = it.next();\n                 system.out.println(s.getname()+","+s.getage());\n             }\n             system.out.println("--------");\n     \n             //普通for：带有索引的遍历方式\n             for(int i=0; i<list.size(); i++) {\n                 student s = list.get(i);\n                 system.out.println(s.getname()+","+s.getage());\n             }\n             system.out.println("--------");\n     \n             //增强for：最方便的遍历方式\n             for(student s : list) {\n                 system.out.println(s.getname()+","+s.getage());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n\n\n# 2.5 list集合的实现类\n\n# 1. list集合子类的特点\n\n * arraylist集合\n   \n   底层是数组结构实现，查询快、增删慢\n\n * linkedlist集合\n   \n   底层是链表结构实现，查询慢、增删快\n\n# 2. 集合的案例-arraylist集合存储学生对象三种方式遍历\n\n * 案例需求\n   \n   创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student {\n         private string name;\n         private int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     public class arraylistdemo {\n         public static void main(string[] args) {\n             //创建arraylist集合对象\n             arraylist<student> array = new arraylist<student>();\n     \n             //创建学生对象\n             student s1 = new student("林青霞", 30);\n             student s2 = new student("张曼玉", 35);\n             student s3 = new student("王祖贤", 33);\n     \n             //把学生添加到集合\n             array.add(s1);\n             array.add(s2);\n             array.add(s3);\n     \n             //迭代器：集合特有的遍历方式\n             iterator<student> it = array.iterator();\n             while (it.hasnext()) {\n                 student s = it.next();\n                 system.out.println(s.getname() + "," + s.getage());\n             }\n             system.out.println("--------");\n     \n             //普通for：带有索引的遍历方式\n             for(int i=0; i<array.size(); i++) {\n                 student s = array.get(i);\n                 system.out.println(s.getname() + "," + s.getage());\n             }\n             system.out.println("--------");\n     \n             //增强for：最方便的遍历方式\n             for(student s : array) {\n                 system.out.println(s.getname() + "," + s.getage());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n\n# 3. linkedlist集合的特有功能\n\n * 特有方法\n   \n   方法名                         说明\n   public void addfirst(e e)   在该列表开头插入指定的元素\n   public void addlast(e e)    将指定的元素追加到此列表的末尾\n   public e getfirst()         返回此列表中的第一个元素\n   public e getlast()          返回此列表中的最后一个元素\n   public e removefirst()      从此列表中删除并返回第一个元素\n   public e removelast()       从此列表中删除并返回最后一个元素\n\n\n# 3. set集合\n\n\n# 3.1 set集合概述和特点\n\n * set集合的特点\n   * 元素存取无序\n   * 没有索引、只能通过迭代器或增强for循环遍历\n   * 不能存储重复元素\n * set集合的基本使用\n\npublic class setdemo {\n    public static void main(string[] args) {\n        //创建集合对象\n        set<string> set = new hashset<string>();\n\n        //添加元素\n        set.add("hello");\n        set.add("world");\n        set.add("java");\n        //不包含重复元素的集合\n        set.add("world");\n\n        //遍历\n        for(string s : set) {\n            system.out.println(s);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3.2 哈希值\n\n * 哈希值简介\n   \n   是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值\n\n * 如何获取哈希值\n   \n   object类中的public int hashcode()：返回对象的哈希码值\n\n * 哈希值的特点\n   \n   * 同一个对象多次调用hashcode()方法返回的哈希值是相同的\n   * 默认情况下，不同对象的哈希值是不同的。而重写hashcode()方法，可以实现让不同对象的哈希值相同\n\n * 获取哈希值的代码\n   \n   * 学生类\n   \n   public class student {\n       private string name;\n       private int age;\n   \n       public student() {\n       }\n   \n       public student(string name, int age) {\n           this.name = name;\n           this.age = age;\n       }\n   \n       public string getname() {\n           return name;\n       }\n   \n       public void setname(string name) {\n           this.name = name;\n       }\n   \n       public int getage() {\n           return age;\n       }\n   \n       public void setage(int age) {\n           this.age = age;\n       }\n   \n       @override\n       public int hashcode() {\n           return 0;\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   \n   * 测试类\n   \n   public class hashdemo {\n       public static void main(string[] args) {\n           //创建学生对象\n           student s1 = new student("林青霞",30);\n   \n           //同一个对象多次调用hashcode()方法返回的哈希值是相同的\n           system.out.println(s1.hashcode()); //1060830840\n           system.out.println(s1.hashcode()); //1060830840\n           system.out.println("--------");\n   \n           student s2 = new student("林青霞",30);\n   \n           //默认情况下，不同对象的哈希值是不相同的\n           //通过方法重写，可以实现不同对象的哈希值是相同的\n           system.out.println(s2.hashcode()); //2137211482\n           system.out.println("--------");\n   \n           system.out.println("hello".hashcode()); //99162322\n           system.out.println("world".hashcode()); //113318802\n           system.out.println("java".hashcode()); //3254818\n   \n           system.out.println("world".hashcode()); //113318802\n           system.out.println("--------");\n   \n           system.out.println("重地".hashcode()); //1179395\n           system.out.println("通话".hashcode()); //1179395\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n\n\n# 3.3hashset集合概述和特点\n\n * hashset集合的特点\n   \n   * 底层数据结构是哈希表\n   * 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致\n   * 没有带索引的方法，所以不能使用普通for循环遍历\n   * 由于是set集合，所以是不包含重复元素的集合\n\n * hashset集合的基本使用\n   \n   public class hashsetdemo01 {\n       public static void main(string[] args) {\n           //创建集合对象\n           hashset<string> hs = new hashset<string>();\n   \n           //添加元素\n           hs.add("hello");\n           hs.add("world");\n           hs.add("java");\n   \n           hs.add("world");\n   \n           //遍历\n           for(string s : hs) {\n               system.out.println(s);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 3.4 hashset集合保证元素唯一性源码分析\n\n * hashset集合保证元素唯一性的原理\n   \n   1.根据对象的哈希值计算存储位置\n   \n   如果当前位置没有元素则直接存入\n   \n   如果当前位置有元素存在，则进入第二步\n   \n   2.当前元素的元素和已经存在的元素比较哈希值\n   \n   如果哈希值不同，则将当前元素进行存储\n   \n   如果哈希值相同，则进入第三步\n   \n   3.通过equals()方法比较两个元素的内容\n   \n   如果内容不相同，则将当前元素进行存储\n   \n   如果内容相同，则不存储当前元素\n\n * hashset集合保证元素唯一性的图解\n   \n   \n\n\n# 3.5 常见数据结构之哈希表\n\n\n\n\n# 3.6 hashset集合存储学生对象并遍历\n\n * 案例需求\n   \n   * 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合\n   * 要求：学生对象的成员变量值相同，我们就认为是同一个对象\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student {\n         private string name;\n         private int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     \n         @override\n         public boolean equals(object o) {\n             if (this == o) return true;\n             if (o == null || getclass() != o.getclass()) return false;\n     \n             student student = (student) o;\n     \n             if (age != student.age) return false;\n             return name != null ? name.equals(student.name) : student.name == null;\n         }\n     \n         @override\n         public int hashcode() {\n             int result = name != null ? name.hashcode() : 0;\n             result = 31 * result + age;\n             return result;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     \n   \n   * 测试类\n     \n     public class hashsetdemo02 {\n         public static void main(string[] args) {\n             //创建hashset集合对象\n             hashset<student> hs = new hashset<student>();\n     \n             //创建学生对象\n             student s1 = new student("林青霞", 30);\n             student s2 = new student("张曼玉", 35);\n             student s3 = new student("王祖贤", 33);\n     \n             student s4 = new student("王祖贤", 33);\n     \n             //把学生添加到集合\n             hs.add(s1);\n             hs.add(s2);\n             hs.add(s3);\n             hs.add(s4);\n     \n             //遍历集合(增强for)\n             for (student s : hs) {\n                 system.out.println(s.getname() + "," + s.getage());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     \n\n\n# 3.7 linkedhashset集合概述和特点\n\n * linkedhashset集合特点\n   \n   * 哈希表和链表实现的set接口，具有可预测的迭代次序\n   * 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的\n   * 由哈希表保证元素唯一，也就是说没有重复的元素\n\n * linkedhashset集合基本使用\n   \n   public class linkedhashsetdemo {\n       public static void main(string[] args) {\n           //创建集合对象\n           linkedhashset<string> linkedhashset = new linkedhashset<string>();\n   \n           //添加元素\n           linkedhashset.add("hello");\n           linkedhashset.add("world");\n           linkedhashset.add("java");\n   \n           linkedhashset.add("world");\n   \n           //遍历集合\n           for(string s : linkedhashset) {\n               system.out.println(s);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 3.8 set集合排序\n\n# 1. treeset集合概述和特点\n\n * treeset集合概述\n   \n   * 元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法\n     * treeset()：根据其元素的自然排序进行排序\n     * treeset(comparator comparator) ：根据指定的比较器进行排序\n   * 没有带索引的方法，所以不能使用普通for循环遍历\n   * 由于是set集合，所以不包含重复元素的集合\n\n * treeset集合基本使用\n   \n   public class treesetdemo01 {\n       public static void main(string[] args) {\n           //创建集合对象\n           treeset<integer> ts = new treeset<integer>();\n   \n           //添加元素\n           ts.add(10);\n           ts.add(40);\n           ts.add(30);\n           ts.add(50);\n           ts.add(20);\n   \n           ts.add(30);\n   \n           //遍历集合\n           for(integer i : ts) {\n               system.out.println(i);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n# 2. 自然排序comparable的使用\n\n * 案例需求\n   \n   * 存储学生对象并遍历，创建treeset集合使用无参构造方法\n   * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n * 实现步骤\n   \n   * 用treeset集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的\n   * 自然排序，就是让元素所属的类实现comparable接口，重写compareto(t o)方法\n   * 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student implements comparable<student> {\n         private string name;\n         private int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     \n         @override\n         public int compareto(student s) {\n     //        return 0;\n     //        return 1;\n     //        return -1;\n             //按照年龄从小到大排序\n            int num = this.age - s.age;\n     //        int num = s.age - this.age;\n             //年龄相同时，按照姓名的字母顺序排序\n            int num2 = num==0?this.name.compareto(s.name):num;\n             return num2;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     \n   \n   * 测试类\n     \n     public class treesetdemo02 {\n         public static void main(string[] args) {\n             //创建集合对象\n             treeset<student> ts = new treeset<student>();\n     \n             //创建学生对象\n             student s1 = new student("xishi", 29);\n             student s2 = new student("wangzhaojun", 28);\n             student s3 = new student("diaochan", 30);\n             student s4 = new student("yangyuhuan", 33);\n     \n             student s5 = new student("linqingxia",33);\n             student s6 = new student("linqingxia",33);\n     \n             //把学生添加到集合\n             ts.add(s1);\n             ts.add(s2);\n             ts.add(s3);\n             ts.add(s4);\n             ts.add(s5);\n             ts.add(s6);\n     \n             //遍历集合\n             for (student s : ts) {\n                 system.out.println(s.getname() + "," + s.getage());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n\n# 3. 比较器排序comparator的使用\n\n * 案例需求\n   \n   * 存储学生对象并遍历，创建treeset集合使用带参构造方法\n   * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n * 实现步骤\n   \n   * 用treeset集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的\n   * 比较器排序，就是让集合构造方法接收comparator的实现类对象，重写compare(t o1,t o2)方法\n   * 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student {\n         private string name;\n         private int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     public class treesetdemo {\n         public static void main(string[] args) {\n             //创建集合对象\n             treeset<student> ts = new treeset<student>(new comparator<student>() {\n                 @override\n                 public int compare(student s1, student s2) {\n                     //this.age - s.age\n                     //s1,s2\n                     int num = s1.getage() - s2.getage();\n                     int num2 = num == 0 ? s1.getname().compareto(s2.getname()) : num;\n                     return num2;\n                 }\n             });\n     \n             //创建学生对象\n             student s1 = new student("xishi", 29);\n             student s2 = new student("wangzhaojun", 28);\n             student s3 = new student("diaochan", 30);\n             student s4 = new student("yangyuhuan", 33);\n     \n             student s5 = new student("linqingxia",33);\n             student s6 = new student("linqingxia",33);\n     \n             //把学生添加到集合\n             ts.add(s1);\n             ts.add(s2);\n             ts.add(s3);\n             ts.add(s4);\n             ts.add(s5);\n             ts.add(s6);\n     \n             //遍历集合\n             for (student s : ts) {\n                 system.out.println(s.getname() + "," + s.getage());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     \n\n# 4. 成绩排序案例\n\n * 案例需求\n   \n   * 用treeset集合存储多个学生信息(姓名，语文成绩，数学成绩)，并遍历该集合\n   * 要求：按照总分从高到低出现\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student {\n         private string name;\n         private int chinese;\n         private int math;\n     \n         public student() {\n         }\n     \n         public student(string name, int chinese, int math) {\n             this.name = name;\n             this.chinese = chinese;\n             this.math = math;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getchinese() {\n             return chinese;\n         }\n     \n         public void setchinese(int chinese) {\n             this.chinese = chinese;\n         }\n     \n         public int getmath() {\n             return math;\n         }\n     \n         public void setmath(int math) {\n             this.math = math;\n         }\n     \n         public int getsum() {\n             return this.chinese + this.math;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     \n   \n   * 测试类\n     \n     public class treesetdemo {\n         public static void main(string[] args) {\n             //创建treeset集合对象，通过比较器排序进行排序\n             treeset<student> ts = new treeset<student>(new comparator<student>() {\n                 @override\n                 public int compare(student s1, student s2) {\n     //                int num = (s2.getchinese()+s2.getmath())-(s1.getchinese()+s1.getmath());\n                     //主要条件\n                     int num = s2.getsum() - s1.getsum();\n                     //次要条件\n                     int num2 = num == 0 ? s1.getchinese() - s2.getchinese() : num;\n                     int num3 = num2 == 0 ? s1.getname().compareto(s2.getname()) : num2;\n                     return num3;\n                 }\n             });\n     \n             //创建学生对象\n             student s1 = new student("林青霞", 98, 100);\n             student s2 = new student("张曼玉", 95, 95);\n             student s3 = new student("王祖贤", 100, 93);\n             student s4 = new student("柳岩", 100, 97);\n             student s5 = new student("风清扬", 98, 98);\n     \n             student s6 = new student("左冷禅", 97, 99);\n     //        student s7 = new student("左冷禅", 97, 99);\n             student s7 = new student("赵云", 97, 99);\n     \n             //把学生对象添加到集合\n             ts.add(s1);\n             ts.add(s2);\n             ts.add(s3);\n             ts.add(s4);\n             ts.add(s5);\n             ts.add(s6);\n             ts.add(s7);\n     \n             //遍历集合\n             for (student s : ts) {\n                 system.out.println(s.getname() + "," + s.getchinese() + "," + s.getmath() + "," + s.getsum());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     \n\n# 5. 不重复的随机数案例\n\n * 案例需求\n   \n   * 编写一个程序，获取10个1-20之间的随机数，要求随机数不能重复，并在控制台输出\n\n * 代码实现\n   \n   public class setdemo {\n       public static void main(string[] args) {\n           //创建set集合对象\n   //        set<integer> set = new hashset<integer>();\n           set<integer> set = new treeset<integer>();\n   \n           //创建随机数对象\n           random r = new random();\n   \n           //判断集合的长度是不是小于10\n           while (set.size()<10) {\n               //产生一个随机数，添加到集合\n               int number = r.nextint(20) + 1;\n               set.add(number);\n           }\n   \n           //遍历集合\n           for(integer i : set) {\n               system.out.println(i);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 4. 泛型\n\n\n# 4.1 泛型概述和好处\n\n * 泛型概述\n   \n   是jdk5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型\n   \n   它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口\n\n * 泛型定义格式\n   \n   * <类型>：指定一种类型的格式。这里的类型可以看成是形参\n   * <类型1,类型2…>：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参\n   * 将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型\n\n * 泛型的好处\n   \n   * 把运行时期的问题提前到了编译期间\n   * 避免了强制类型转换\n\n\n# 4.2 泛型类\n\n * 定义格式\n   \n   修饰符 class 类名<类型> {  }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 泛型类\n     \n     public class generic<t> {\n         private t t;\n     \n         public t gett() {\n             return t;\n         }\n     \n         public void sett(t t) {\n             this.t = t;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     \n   \n   * 测试类\n     \n     public class genericdemo {\n         public static void main(string[] args) {\n             generic<string> g1 = new generic<string>();\n             g1.sett("林青霞");\n             system.out.println(g1.gett());\n     \n             generic<integer> g2 = new generic<integer>();\n             g2.sett(30);\n             system.out.println(g2.gett());\n     \n             generic<boolean> g3 = new generic<boolean>();\n             g3.sett(true);\n             system.out.println(g3.gett());\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n\n# 3.3 泛型方法\n\n * 定义格式\n   \n   修饰符 <类型> 返回值类型 方法名(类型 变量名) {  }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 带有泛型方法的类\n     \n     public class generic {\n         public <t> void show(t t) {\n             system.out.println(t);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n   \n   * 测试类\n     \n     public class genericdemo {\n         public static void main(string[] args) {\n     \t\tgeneric g = new generic();\n             g.show("林青霞");\n             g.show(30);\n             g.show(true);\n             g.show(12.34);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     \n\n\n# 3.4 泛型接口\n\n * 定义格式\n   \n   修饰符 interface 接口名<类型> {  }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 泛型接口\n     \n     public interface generic<t> {\n         void show(t t);\n     }\n     \n     \n     1\n     2\n     3\n     \n   \n   * 泛型接口实现类\n     \n     public class genericimpl<t> implements generic<t> {\n         @override\n         public void show(t t) {\n             system.out.println(t);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n   \n   * 测试类\n     \n     public class genericdemo {\n         public static void main(string[] args) {\n             generic<string> g1 = new genericimpl<string>();\n             g1.show("林青霞");\n     \n             generic<integer> g2 = new genericimpl<integer>();\n             g2.show(30);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     \n\n\n# 3.5 类型通配符\n\n * 类型通配符的作用\n   \n   为了表示各种泛型list的父类，可以使用类型通配符\n\n * 类型通配符的分类\n   \n   - 类型通配符：<?>\n     - list<?>：表示元素类型未知的list，它的元素可以匹配任何的类型\n     - 这种带通配符的list仅表示它是各种泛型list的父类，并不能把元素添加到其中\n   - 类型通配符上限：<? extends 类型>\n     - list<? extends number>：它表示的类型是number或者其子类型\n   - 类型通配符下限：<? super 类型>\n     - list<? super number>：它表示的类型是number或者其父类型\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 类型通配符的基本使用\n   \n   public class genericdemo {\n       public static void main(string[] args) {\n           //类型通配符：<?>\n           list<?> list1 = new arraylist<object>();\n           list<?> list2 = new arraylist<number>();\n           list<?> list3 = new arraylist<integer>();\n           system.out.println("--------");\n   \n           //类型通配符上限：<? extends 类型>\n   //        list<? extends number> list4 = new arraylist<object>();\n           list<? extends number> list5 = new arraylist<number>();\n           list<? extends number> list6 = new arraylist<integer>();\n           system.out.println("--------");\n   \n           //类型通配符下限：<? super 类型>\n           list<? super number> list7 = new arraylist<object>();\n           list<? super number> list8 = new arraylist<number>();\n   //        list<? super number> list9 = new arraylist<integer>();\n   \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 5. 可变参数\n\n\n# 5.1 可变参数\n\n * 可变参数介绍\n   \n   可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了\n\n * 可变参数定义格式\n   \n   修饰符 返回值类型 方法名(数据类型… 变量名) {  }\n   \n   \n   1\n   \n\n * 可变参数的注意事项\n   \n   * 这里的变量其实是一个数组\n   * 如果一个方法有多个参数，包含可变参数，可变参数要放在最后\n\n * 可变参数的基本使用\n   \n   public class argsdemo01 {\n       public static void main(string[] args) {\n           system.out.println(sum(10, 20));\n           system.out.println(sum(10, 20, 30));\n           system.out.println(sum(10, 20, 30, 40));\n   \n           system.out.println(sum(10,20,30,40,50));\n           system.out.println(sum(10,20,30,40,50,60));\n           system.out.println(sum(10,20,30,40,50,60,70));\n           system.out.println(sum(10,20,30,40,50,60,70,80,90,100));\n       }\n   \n   //    public static int sum(int b,int... a) {\n   //        return 0;\n   //    }\n   \n       public static int sum(int... a) {\n           int sum = 0;\n           for(int i : a) {\n               sum += i;\n           }\n           return sum;\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 5.2可变参数的使用\n\n * arrays工具类中有一个静态方法：\n   \n   - public static <t> list<t> aslist(t... a)：返回由指定数组支持的固定大小的列表\n   - 返回的集合不能做增删操作，可以做修改操作\n   \n   \n   1\n   2\n   \n\n * list接口中有一个静态方法：\n   \n   - public static <e> list<e> of(e... elements)：返回包含任意数量元素的不可变列表\n   - 返回的集合不能做增删改操作\n   \n   \n   1\n   2\n   \n\n * set接口中有一个静态方法：\n   \n   - public static <e> set<e> of(e... elements) ：返回一个包含任意数量元素的不可变集合\n   - 在给元素的时候，不能给重复的元素\n   - 返回的集合不能做增删操作，没有修改的方法\n   \n   \n   1\n   2\n   3\n   \n\n * 示例代码\n   \n   public class argsdemo02 {\n       public static void main(string[] args) {\n           //public static <t> list<t> aslist(t... a)：返回由指定数组支持的固定大小的列表\n   //        list<string> list = arrays.aslist("hello", "world", "java");\n   //\n   ////        list.add("javaee"); //unsupportedoperationexception\n   ////        list.remove("world"); //unsupportedoperationexception\n   //        list.set(1,"javaee");\n   //\n   //        system.out.println(list);\n   \n           //public static <e> list<e> of(e... elements)：返回包含任意数量元素的不可变列表\n   //        list<string> list = list.of("hello", "world", "java", "world");\n   //\n   ////        list.add("javaee");//unsupportedoperationexception\n   ////        list.remove("java");//unsupportedoperationexception\n   ////        list.set(1,"javaee");//unsupportedoperationexception\n   //\n   //        system.out.println(list);\n   \n           //public static <e> set<e> of(e... elements) ：返回一个包含任意数量元素的不可变集合\n   //        set<string> set = set.of("hello", "world", "java","world"); //illegalargumentexception\n           //set<string> set = set.of("hello", "world", "java");\n   \n   //        set.add("javaee");//unsupportedoperationexception\n   //        set.remove("world");//unsupportedoperationexception\n   \n           //system.out.println(set);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n * public class hashmapdemo {\n       public static void main(string[] args) {\n           //键盘录入一个字符串\n           scanner sc = new scanner(system.in);\n           system.out.println("请输入一个字符串：");\n           string line = sc.nextline();\n   \n           //创建hashmap集合，键是character，值是integer\n   //        hashmap<character, integer> hm = new hashmap<character, integer>();\n           treemap<character, integer> hm = new treemap<character, integer>();\n   \n           //遍历字符串，得到每一个字符\n           for (int i = 0; i < line.length(); i++) {\n               char key = line.charat(i);\n   \n               //拿得到的每一个字符作为键到hashmap集合中去找对应的值，看其返回值\n               integer value = hm.get(key);\n   \n               if (value == null) {\n                   //如果返回值是null：说明该字符在hashmap集合中不存在，就把该字符作为键，1作为值存储\n                   hm.put(key,1);\n               } else {\n                   //如果返回值不是null：说明该字符在hashmap集合中存在，把该值加1，然后重新存储该字符和对应的值\n                   value++;\n                   hm.put(key,value);\n               }\n           }\n   \n           //遍历hashmap集合，得到键和值，按照要求进行拼接\n           stringbuilder sb = new stringbuilder();\n   \n           set<character> keyset = hm.keyset();\n           for(character key : keyset) {\n               integer value = hm.get(key);\n               sb.append(key).append("(").append(value).append(")");\n           }\n   \n           string result = sb.tostring();\n   \n           //输出结果\n          system.out.println(result);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   \n\n\n# 6. map集合\n\n\n# 6.1 map集合概述和特点\n\n * map集合概述\n   \n   interface map<k,v>  k：键的类型；v：值的类型\n   \n   \n   1\n   \n\n * map集合的特点\n   \n   * 键值对映射关系\n   * 一个键对应一个值\n   * 键不能重复，值可以重复\n   * 元素存取无序\n\n * map集合的基本使用\n   \n   public class mapdemo01 {\n       public static void main(string[] args) {\n           //创建集合对象\n           map<string,string> map = new hashmap<string,string>();\n   \n           //v put(k key, v value) 将指定的值与该映射中的指定键相关联\n           map.put("itheima001","林青霞");\n           map.put("itheima002","张曼玉");\n           map.put("itheima003","王祖贤");\n           map.put("itheima003","柳岩");\n   \n           //输出集合对象\n           system.out.println(map);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n\n# 6.2 map集合的基本功能\n\n * 方法介绍\n   \n   方法名                                   说明\n   v put(k key, v value)                 添加元素\n   v remove(object key)                  根据键删除键值对元素\n   void clear()                          移除所有的键值对元素\n   boolean containskey(object key)       判断集合是否包含指定的键\n   boolean containsvalue(object value)   判断集合是否包含指定的值\n   boolean isempty()                     判断集合是否为空\n   int size()                            集合的长度，也就是集合中键值对的个数\n\n * 示例代码\n   \n   public class mapdemo02 {\n       public static void main(string[] args) {\n           //创建集合对象\n           map<string,string> map = new hashmap<string,string>();\n   \n           //v put(k key,v value)：添加元素\n           map.put("张无忌","赵敏");\n           map.put("郭靖","黄蓉");\n           map.put("杨过","小龙女");\n   \n           //v remove(object key)：根据键删除键值对元素\n   //        system.out.println(map.remove("郭靖"));\n   //        system.out.println(map.remove("郭襄"));\n   \n           //void clear()：移除所有的键值对元素\n   //        map.clear();\n   \n           //boolean containskey(object key)：判断集合是否包含指定的键\n   //        system.out.println(map.containskey("郭靖"));\n   //        system.out.println(map.containskey("郭襄"));\n   \n           //boolean isempty()：判断集合是否为空\n   //        system.out.println(map.isempty());\n   \n           //int size()：集合的长度，也就是集合中键值对的个数\n           system.out.println(map.size());\n   \n   \n           //输出集合对象\n           system.out.println(map);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n\n# 6.3map集合的获取功能\n\n * 方法介绍\n   \n   \n\n * 示例代码\n   \n   public class mapdemo03 {\n       public static void main(string[] args) {\n           //创建集合对象\n           map<string, string> map = new hashmap<string, string>();\n   \n           //添加元素\n           map.put("张无忌", "赵敏");\n           map.put("郭靖", "黄蓉");\n           map.put("杨过", "小龙女");\n   \n           //v get(object key):根据键获取值\n   //        system.out.println(map.get("张无忌"));\n   //        system.out.println(map.get("张三丰"));\n   \n           //set<k> keyset():获取所有键的集合\n   //        set<string> keyset = map.keyset();\n   //        for(string key : keyset) {\n   //            system.out.println(key);\n   //        }\n   \n           //collection<v> values():获取所有值的集合\n           collection<string> values = map.values();\n           for(string value : values) {\n               system.out.println(value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   \n\n\n# 6.4map集合的遍历(方式1)\n\n * 遍历思路\n   \n   * 我们刚才存储的元素都是成对出现的，所以我们把map看成是一个夫妻对的集合\n     * 把所有的丈夫给集中起来\n     * 遍历丈夫的集合，获取到每一个丈夫\n     * 根据丈夫去找对应的妻子\n\n * 步骤分析\n   \n   * 获取所有键的集合。用keyset()方法实现\n   * 遍历键的集合，获取到每一个键。用增强for实现\n   * 根据键去找值。用get(object key)方法实现\n\n * 代码实现\n   \n   public class mapdemo01 {\n       public static void main(string[] args) {\n           //创建集合对象\n           map<string, string> map = new hashmap<string, string>();\n   \n           //添加元素\n           map.put("张无忌", "赵敏");\n           map.put("郭靖", "黄蓉");\n           map.put("杨过", "小龙女");\n   \n           //获取所有键的集合。用keyset()方法实现\n           set<string> keyset = map.keyset();\n           //遍历键的集合，获取到每一个键。用增强for实现\n           for (string key : keyset) {\n               //根据键去找值。用get(object key)方法实现\n               string value = map.get(key);\n               system.out.println(key + "," + value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 6.5 map集合的遍历(方式2)\n\n * 遍历思路\n   \n   * 我们刚才存储的元素都是成对出现的，所以我们把map看成是一个夫妻对的集合\n     * 获取所有结婚证的集合\n     * 遍历结婚证的集合，得到每一个结婚证\n     * 根据结婚证获取丈夫和妻子\n\n * 步骤分析\n   \n   * 获取所有键值对对象的集合\n     * set<map.entry<k,v>> entryset()：获取所有键值对对象的集合\n   * 遍历键值对对象的集合，得到每一个键值对对象\n     * 用增强for实现，得到每一个map.entry\n   * 根据键值对对象获取键和值\n     * 用getkey()得到键\n     * 用getvalue()得到值\n\n * 代码实现\n   \n   public class mapdemo02 {\n       public static void main(string[] args) {\n           //创建集合对象\n           map<string, string> map = new hashmap<string, string>();\n   \n           //添加元素\n           map.put("张无忌", "赵敏");\n           map.put("郭靖", "黄蓉");\n           map.put("杨过", "小龙女");\n   \n           //获取所有键值对对象的集合\n           set<map.entry<string, string>> entryset = map.entryset();\n           //遍历键值对对象的集合，得到每一个键值对对象\n           for (map.entry<string, string> me : entryset) {\n               //根据键值对对象获取键和值\n               string key = me.getkey();\n               string value = me.getvalue();\n               system.out.println(key + "," + value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 6.6 map集合的案例\n\n# 1. hashmap集合练习之键是string值是student\n\n * 案例需求\n   \n   创建一个hashmap集合，键是学号(string)，值是学生对象(student)。存储三个键值对元素，并遍历\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student {\n         private string name;\n         private int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     /*\n         需求：\n             创建一个hashmap集合，键是学号(string)，值是学生对象(student)。存储三个键值对元素，并遍历\n     \n         思路：\n             1:定义学生类\n             2:创建hashmap集合对象\n             3:创建学生对象\n             4:把学生添加到集合\n             5:遍历集合\n                 方式1：键找值\n                 方式2：键值对对象找键和值\n      */\n     public class hashmapdemo {\n         public static void main(string[] args) {\n             //创建hashmap集合对象\n             hashmap<string, student> hm = new hashmap<string, student>();\n     \n             //创建学生对象\n             student s1 = new student("林青霞", 30);\n             student s2 = new student("张曼玉", 35);\n             student s3 = new student("王祖贤", 33);\n     \n             //把学生添加到集合\n             hm.put("itheima001", s1);\n             hm.put("itheima002", s2);\n             hm.put("itheima003", s3);\n     \n             //方式1：键找值\n             set<string> keyset = hm.keyset();\n             for (string key : keyset) {\n                 student value = hm.get(key);\n                 system.out.println(key + "," + value.getname() + "," + value.getage());\n             }\n             system.out.println("--------");\n     \n             //方式2：键值对对象找键和值\n             set<map.entry<string, student>> entryset = hm.entryset();\n             for (map.entry<string, student> me : entryset) {\n                 string key = me.getkey();\n                 student value = me.getvalue();\n                 system.out.println(key + "," + value.getname() + "," + value.getage());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     \n\n# 2. hashmap集合练习之键是student值是string\n\n * 案例需求\n   \n   * 创建一个hashmap集合，键是学生对象(student)，值是居住地 (string)。存储多个元素，并遍历。\n   * 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student {\n         private string name;\n         private int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     \n         @override\n         public boolean equals(object o) {\n             if (this == o) return true;\n             if (o == null || getclass() != o.getclass()) return false;\n     \n             student student = (student) o;\n     \n             if (age != student.age) return false;\n             return name != null ? name.equals(student.name) : student.name == null;\n         }\n     \n         @override\n         public int hashcode() {\n             int result = name != null ? name.hashcode() : 0;\n             result = 31 * result + age;\n             return result;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     \n   \n   * 测试类\n     \n     public class hashmapdemo {\n         public static void main(string[] args) {\n             //创建hashmap集合对象\n             hashmap<student, string> hm = new hashmap<student, string>();\n     \n             //创建学生对象\n             student s1 = new student("林青霞", 30);\n             student s2 = new student("张曼玉", 35);\n             student s3 = new student("王祖贤", 33);\n             student s4 = new student("王祖贤", 33);\n     \n             //把学生添加到集合\n             hm.put(s1, "西安");\n             hm.put(s2, "武汉");\n             hm.put(s3, "郑州");\n             hm.put(s4, "北京");\n     \n             //遍历集合\n             set<student> keyset = hm.keyset();\n             for (student key : keyset) {\n                 string value = hm.get(key);\n                 system.out.println(key.getname() + "," + key.getage() + "," + value);\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     \n\n# 3. 集合嵌套之arraylist嵌套hashmap\n\n * 案例需求\n   \n   * 创建一个arraylist集合，存储三个元素，每一个元素都是hashmap\n   * 每一个hashmap的键和值都是string，并遍历。\n\n * 代码实现\n   \n   public class arraylistincludehashmapdemo {\n       public static void main(string[] args) {\n           //创建arraylist集合\n           arraylist<hashmap<string, string>> array = new arraylist<hashmap<string, string>>();\n   \n           //创建hashmap集合，并添加键值对元素\n           hashmap<string, string> hm1 = new hashmap<string, string>();\n           hm1.put("孙策", "大乔");\n           hm1.put("周瑜", "小乔");\n           //把hashmap作为元素添加到arraylist集合\n           array.add(hm1);\n   \n           hashmap<string, string> hm2 = new hashmap<string, string>();\n           hm2.put("郭靖", "黄蓉");\n           hm2.put("杨过", "小龙女");\n           //把hashmap作为元素添加到arraylist集合\n           array.add(hm2);\n   \n           hashmap<string, string> hm3 = new hashmap<string, string>();\n           hm3.put("令狐冲", "任盈盈");\n           hm3.put("林平之", "岳灵珊");\n           //把hashmap作为元素添加到arraylist集合\n           array.add(hm3);\n   \n           //遍历arraylist集合\n           for (hashmap<string, string> hm : array) {\n               set<string> keyset = hm.keyset();\n               for (string key : keyset) {\n                   string value = hm.get(key);\n                   system.out.println(key + "," + value);\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   \n\n# 4. 集合嵌套之hashmap嵌套arraylist\n\n * 案例需求\n   \n   * 创建一个hashmap集合，存储三个键值对元素，每一个键值对元素的键是string，值是arraylist\n   * 每一个arraylist的元素是string，并遍历。\n\n * 代码实现\n   \n   public class hashmapincludearraylistdemo {\n       public static void main(string[] args) {\n           //创建hashmap集合\n           hashmap<string, arraylist<string>> hm = new hashmap<string, arraylist<string>>();\n   \n           //创建arraylist集合，并添加元素\n           arraylist<string> sgyy = new arraylist<string>();\n           sgyy.add("诸葛亮");\n           sgyy.add("赵云");\n           //把arraylist作为元素添加到hashmap集合\n           hm.put("三国演义",sgyy);\n   \n           arraylist<string> xyj = new arraylist<string>();\n           xyj.add("唐僧");\n           xyj.add("孙悟空");\n           //把arraylist作为元素添加到hashmap集合\n           hm.put("西游记",xyj);\n   \n           arraylist<string> shz = new arraylist<string>();\n           shz.add("武松");\n           shz.add("鲁智深");\n           //把arraylist作为元素添加到hashmap集合\n           hm.put("水浒传",shz);\n   \n           //遍历hashmap集合\n           set<string> keyset = hm.keyset();\n           for(string key : keyset) {\n               system.out.println(key);\n               arraylist<string> value = hm.get(key);\n               for(string s : value) {\n                   system.out.println("\\t" + s);\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   \n\n# 5. 统计字符串中每个字符出现的次数\n\n * 案例需求\n   \n   * 键盘录入一个字符串，要求统计字符串中每个字符串出现的次数。\n   * 举例：键盘录入“aababcabcdabcde” 在控制台输出：“a(5)b(4)c(3)d(2)e(1)”\n\n * 代码实现\n   \n   public class hashmapdemo {\n       public static void main(string[] args) {\n           //键盘录入一个字符串\n           scanner sc = new scanner(system.in);\n           system.out.println("请输入一个字符串：");\n           string line = sc.nextline();\n   \n           //创建hashmap集合，键是character，值是integer\n   //        hashmap<character, integer> hm = new hashmap<character, integer>();\n           treemap<character, integer> hm = new treemap<character, integer>();\n   \n           //遍历字符串，得到每一个字符\n           for (int i = 0; i < line.length(); i++) {\n               char key = line.charat(i);\n   \n               //拿得到的每一个字符作为键到hashmap集合中去找对应的值，看其返回值\n               integer value = hm.get(key);\n   \n               if (value == null) {\n                   //如果返回值是null：说明该字符在hashmap集合中不存在，就把该字符作为键，1作为值存储\n                   hm.put(key,1);\n               } else {\n                   //如果返回值不是null：说明该字符在hashmap集合中存在，把该值加1，然后重新存储该字符和对应的值\n                   value++;\n                   hm.put(key,value);\n               }\n           }\n   \n           //遍历hashmap集合，得到键和值，按照要求进行拼接\n           stringbuilder sb = new stringbuilder();\n   \n           set<character> keyset = hm.keyset();\n           for(character key : keyset) {\n               integer value = hm.get(key);\n               sb.append(key).append("(").append(value).append(")");\n           }\n   \n           string result = sb.tostring();\n   \n           //输出结果\n           system.out.println(result);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   \n\n\n# 7. collections集合工具类\n\n\n# 7.1 collections概述和使用\n\n * collections类的作用\n   \n   是针对集合操作的工具类\n\n * collections类常用方法\n   \n   \n\n * 示例代码\n   \n   public class collectionsdemo01 {\n       public static void main(string[] args) {\n           //创建集合对象\n           list<integer> list = new arraylist<integer>();\n   \n           //添加元素\n           list.add(30);\n           list.add(20);\n           list.add(50);\n           list.add(10);\n           list.add(40);\n   \n           //public static <t extends comparable<? super t>> void sort(list<t> list)：将指定的列表按升序排序\n   //        collections.sort(list);\n   \n           //public static void reverse(list<?> list)：反转指定列表中元素的顺序\n   //        collections.reverse(list);\n   \n           //public static void shuffle(list<?> list)：使用默认的随机源随机排列指定的列表\n           collections.shuffle(list);\n   \n           system.out.println(list);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 7.2 arraylist集合存储学生并排序\n\n * 案例需求\n   \n   * arraylist存储学生对象，使用collections对arraylist进行排序\n   * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student {\n         private string name;\n         private int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     \n   \n   * 测试类\n     \n     public class collectionsdemo02 {\n         public static void main(string[] args) {\n             //创建arraylist集合对象\n             arraylist<student> array = new arraylist<student>();\n     \n             //创建学生对象\n             student s1 = new student("linqingxia", 30);\n             student s2 = new student("zhangmanyu", 35);\n             student s3 = new student("wangzuxian", 33);\n             student s4 = new student("liuyan", 33);\n     \n             //把学生添加到集合\n             array.add(s1);\n             array.add(s2);\n             array.add(s3);\n             array.add(s4);\n     \n             //使用collections对arraylist集合排序\n             //sort(list<t> list, comparator<? super t> c)\n             collections.sort(array, new comparator<student>() {\n                 @override\n                 public int compare(student s1, student s2) {\n                     //按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n                     int num = s1.getage() - s2.getage();\n                     int num2 = num == 0 ? s1.getname().compareto(s2.getname()) : num;\n                     return num2;\n                 }\n             });\n     \n             //遍历集合\n             for (student s : array) {\n                 system.out.println(s.getname() + "," + s.getage());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     \n\n\n# 8. 斗地主案例\n\n\n# 8.1 模拟斗地主案例-普通版本\n\n * 案例需求\n   \n   通过程序实现斗地主过程中的洗牌，发牌和看牌\n\n * 代码实现\n   \n   public class pokerdemo {\n       public static void main(string[] args) {\n           //创建一个牌盒，也就是定义一个集合对象，用arraylist集合实现\n           arraylist<string> array = new arraylist<string>();\n   \n           //往牌盒里面装牌\n           /*\n               ♦2,♦3,♦4...♦k,♦a\n               ♣2,...\n               ♥2,...\n               ♠2,...\n               小王，大王\n            */\n           //定义花色数组\n           string[] colors = {"♦", "♣", "♥", "♠"};\n           //定义点数数组\n           string[] numbers = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "j", "q", "k", "a"};\n           for (string color : colors) {\n               for (string number : numbers) {\n                   array.add(color + number);\n               }\n           }\n           array.add("小王");\n           array.add("大王");\n   \n           //洗牌，也就是把牌打撒，用collections的shuffle()方法实现\n           collections.shuffle(array);\n   \n   //        system.out.println(array);\n   \n           //发牌，也就是遍历集合，给三个玩家发牌\n           arraylist<string> lqxarray = new arraylist<string>();\n           arraylist<string> lyarray = new arraylist<string>();\n           arraylist<string> fqyarray = new arraylist<string>();\n           arraylist<string> dparray = new arraylist<string>();\n   \n           for (int i = 0; i < array.size(); i++) {\n               string poker = array.get(i);\n               if (i >= array.size() - 3) {\n                   dparray.add(poker);\n               } else if (i % 3 == 0) {\n                   lqxarray.add(poker);\n               } else if (i % 3 == 1) {\n                   lyarray.add(poker);\n               } else if (i % 3 == 2) {\n                   fqyarray.add(poker);\n               }\n           }\n   \n           //看牌，也就是三个玩家分别遍历自己的牌\n           lookpoker("林青霞", lqxarray);\n           lookpoker("柳岩", lyarray);\n           lookpoker("风清扬", fqyarray);\n           lookpoker("底牌", dparray);\n       }\n   \n       //看牌的方法\n       public static void lookpoker(string name, arraylist<string> array) {\n           system.out.print(name + "的牌是：");\n           for (string poker : array) {\n               system.out.print(poker + " ");\n           }\n           system.out.println();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   \n\n\n# 3.2 模拟斗地主案例-升级版本\n\n * 案例需求\n   \n   通过程序实现斗地主过程中的洗牌，发牌和看牌。要求：对牌进行排序\n\n * 代码实现\n   \n   public class pokerdemo {\n       public static void main(string[] args) {\n           //创建hashmap，键是编号，值是牌\n           hashmap<integer, string> hm = new hashmap<integer, string>();\n   \n           //创建arraylist，存储编号\n           arraylist<integer> array = new arraylist<integer>();\n   \n           //创建花色数组和点数数组\n           string[] colors = {"♦", "♣", "♥", "♠"};\n           string[] numbers = {"3", "4", "5", "6", "7", "8", "9", "10", "j", "q", "k", "a", "2"};\n   \n           //从0开始往hashmap里面存储编号，并存储对应的牌。同时往arraylist里面存储编号\n           int index = 0;\n   \n           for (string number : numbers) {\n               for (string color : colors) {\n                   hm.put(index, color + number);\n                   array.add(index);\n                   index++;\n               }\n           }\n           hm.put(index, "小王");\n           array.add(index);\n           index++;\n           hm.put(index, "大王");\n           array.add(index);\n   \n           //洗牌(洗的是编号)，用collections的shuffle()方法实现\n           collections.shuffle(array);\n   \n           //发牌(发的也是编号，为了保证编号是排序的，创建treeset集合接收)\n           treeset<integer> lqxset = new treeset<integer>();\n           treeset<integer> lyset = new treeset<integer>();\n           treeset<integer> fqyset = new treeset<integer>();\n           treeset<integer> dpset = new treeset<integer>();\n   \n           for (int i = 0; i < array.size(); i++) {\n               int x = array.get(i);\n               if (i >= array.size() - 3) {\n                   dpset.add(x);\n               } else if (i % 3 == 0) {\n                   lqxset.add(x);\n               } else if (i % 3 == 1) {\n                   lyset.add(x);\n               } else if (i % 3 == 2) {\n                   fqyset.add(x);\n               }\n           }\n   \n           //调用看牌方法\n           lookpoker("林青霞", lqxset, hm);\n           lookpoker("柳岩", lyset, hm);\n           lookpoker("风清扬", fqyset, hm);\n           lookpoker("底牌", dpset, hm);\n       }\n   \n       //定义方法看牌(遍历treeset集合，获取编号，到hashmap集合找对应的牌)\n       public static void lookpoker(string name, treeset<integer> ts, hashmap<integer, string> hm) {\n           system.out.print(name + "的牌是：");\n           for (integer key : ts) {\n               string poker = hm.get(key);\n               system.out.print(poker + " ");\n           }\n           system.out.println();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   ',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"枚举",frontmatter:{title:"枚举",date:"2023-02-26T14:55:14.000Z",permalink:"/pages/1ca5ad/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/09.%E6%9E%9A%E4%B8%BE.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/09.枚举.md",key:"v-4508e630",path:"/pages/1ca5ad/",headers:[{level:2,title:"枚举的场景及历史",slug:"枚举的场景及历史",normalizedTitle:"枚举的场景及历史",charIndex:11},{level:2,title:"1. 声明定义枚举",slug:"_1-声明定义枚举",normalizedTitle:"1. 声明定义枚举",charIndex:208},{level:2,title:"2. 枚举类详解",slug:"_2-枚举类详解",normalizedTitle:"2. 枚举类详解",charIndex:1322},{level:3,title:"例 1",slug:"例-1",normalizedTitle:"例 1",charIndex:570},{level:3,title:"例 2",slug:"例-2",normalizedTitle:"例 2",charIndex:2069},{level:3,title:"例 3",slug:"例-3",normalizedTitle:"例 3",charIndex:2722},{level:2,title:"3. 为枚举添加方法",slug:"_3-为枚举添加方法",normalizedTitle:"3. 为枚举添加方法",charIndex:3255},{level:2,title:"4. EnumMap 与 EnumSet",slug:"_4-enummap-与-enumset",normalizedTitle:"4. enummap 与 enumset",charIndex:5812},{level:3,title:"1. EnumMap 类",slug:"_1-enummap-类",normalizedTitle:"1. enummap 类",charIndex:5905},{level:3,title:"2. EnumSet 类",slug:"_2-enumset-类",normalizedTitle:"2. enumset 类",charIndex:7099},{level:2,title:"5. 枚举的 7 种使用方法及为什么建议你使用枚举",slug:"_5-枚举的-7-种使用方法及为什么建议你使用枚举",normalizedTitle:"5. 枚举的 7 种使用方法及为什么建议你使用枚举",charIndex:7886},{level:2,title:"6. 枚举的 7 种使用方法",slug:"_6-枚举的-7-种使用方法",normalizedTitle:"6. 枚举的 7 种使用方法",charIndex:8162},{level:3,title:"1. 常量",slug:"_1-常量",normalizedTitle:"1. 常量",charIndex:8229},{level:3,title:"2. switch",slug:"_2-switch",normalizedTitle:"2. switch",charIndex:8389},{level:3,title:"3. 枚举中增加方法（该代码是常见的枚举定义模板）",slug:"_3-枚举中增加方法-该代码是常见的枚举定义模板",normalizedTitle:"3. 枚举中增加方法（该代码是常见的枚举定义模板）",charIndex:8933},{level:3,title:"4. 覆盖枚举方法",slug:"_4-覆盖枚举方法",normalizedTitle:"4. 覆盖枚举方法",charIndex:10221},{level:3,title:"5. 实现接口",slug:"_5-实现接口",normalizedTitle:"5. 实现接口",charIndex:10931},{level:3,title:"6. 在接口中组织枚举类",slug:"_6-在接口中组织枚举类",normalizedTitle:"6. 在接口中组织枚举类",charIndex:11875},{level:3,title:"7. 使用枚举集合",slug:"_7-使用枚举集合",normalizedTitle:"7. 使用枚举集合",charIndex:12572},{level:3,title:"使用注意事项",slug:"使用注意事项",normalizedTitle:"使用注意事项",charIndex:15187},{level:2,title:"假如不使用枚举",slug:"假如不使用枚举",normalizedTitle:"假如不使用枚举",charIndex:15412},{level:2,title:"枚举使用场景",slug:"枚举使用场景",normalizedTitle:"枚举使用场景",charIndex:16923},{level:2,title:"知识扩展",slug:"知识扩展",normalizedTitle:"知识扩展",charIndex:17852},{level:3,title:"枚举为什么是线程安全的？",slug:"枚举为什么是线程安全的",normalizedTitle:"枚举为什么是线程安全的？",charIndex:17861},{level:3,title:"枚举比较小技巧",slug:"枚举比较小技巧",normalizedTitle:"枚举比较小技巧",charIndex:18589},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:18855}],headersStr:"枚举的场景及历史 1. 声明定义枚举 2. 枚举类详解 例 1 例 2 例 3 3. 为枚举添加方法 4. EnumMap 与 EnumSet 1. EnumMap 类 2. EnumSet 类 5. 枚举的 7 种使用方法及为什么建议你使用枚举 6. 枚举的 7 种使用方法 1. 常量 2. switch 3. 枚举中增加方法（该代码是常见的枚举定义模板） 4. 覆盖枚举方法 5. 实现接口 6. 在接口中组织枚举类 7. 使用枚举集合 使用注意事项 假如不使用枚举 枚举使用场景 知识扩展 枚举为什么是线程安全的？ 枚举比较小技巧 总结",content:'# 枚举\n\n\n> # 枚举的场景及历史\n\n枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。\n\n在 JDK 1.5 之前没有枚举类型，那时候一般用接口常量来替代。而使用 Java 枚举类型 enum 可以更贴近地表示这种常量。\n\n\n# 1. 声明定义枚举\n\n声明枚举时必须使用 enum 关键字，然后定义枚举的名称、可访问性、基础类型和成员等。枚举声明的语法如下：\n\nenum-modifiers enum enumname:enum-base\n{\n    enum-body,\n}\n\n\n1\n2\n3\n4\n\n\n其中：\n\nenum-modifiers 表示枚举的修饰符主要包括 public、private 和 internal；\n\nenumname 表示声明的枚举名称；\n\nenum-base 表示基础类型；如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是 int。\n\nenum-body 表示枚举的成员，它是枚举类型的命名常数。任意两个枚举成员不能具有相同的名称，且它的常数值必须在该枚举的基础类型的范围之内，多个枚举成员之间使用逗号分隔。\n\n例 1:\n\n下面代码定义了一个表示性别的枚举类型 SexEnum ，一个表示颜色的枚举类型 Color。\n\npublic enum SexEnum\n{\n    male,female;\n}\npublic enum Color\n{\n    RED,BLUE,GREEN,BLACK;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n之后便可以通过枚举类型名直接引用常量，如 SexEnum.male、Color.RED。\n\n使用枚举还可以使 switch 语句的可读性更强，例如以下示例代码：\n\nenum Signal\n{\n    //定义一个枚举类型\n    GREEN,YELLOW,RED\n}\npublic class TrafficLight\n{\n    Signal color=Signal.RED;\n    public void change()\n    {\n        switch(color)\n        {\n            case RED:\n                color=Signal.GREEN;\n                break;\n            case YELLOW:\n                color=Signal.RED;\n                break;\n            case GREEN:\n                color=Signal.YELLOW;\n                break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2. 枚举类详解\n\nJava 中的每一个枚举都继承自 java.lang.Enum 类。当定义一个枚举类型时，每一个枚举类型成员都可以看作是 Enum 类的实例，这些枚举成员默认都被 final、public, static 修饰，当使用枚举类型成员时，直接使用枚举名称调用成员即可。\n\n所有枚举实例都可以调用 Enum 类的方法，常用方法如表 1 所示。\n\n表1 Enum类的常用方法\n\n方法名称          描述\nvalues()      以数组形式返回枚举类型的所有成员\nvalueOf()     将普通字符串转换为枚举实例\ncompareTo()   比较两个枚举成员在定义时的顺序\nordinal()     获取枚举成员的索引位置\n\n\n# 例 1\n\n通过调用枚举类型实例的 values() 方法可以将枚举的所有成员以数组形式返回，也可以通过该方法获取枚举类型的成员。\n\n下面的示例创建一个包含 3 个成员的枚举类型 Signal，然后调用 values() 方法输出这些成员。\n\nenum Signal\n{\n    //定义一个枚举类型\n    GREEN,YELLOW,RED;\n}\npublic static void main(String[] args)\n{\n    for(int i=0;i<Signal.values().length;i++)\n    {\n        System.out.println("枚举成员："+Signal.values()[i]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n输出结果如下：\n\n枚举成员：GREEN\n枚举成员：YELLOW\n枚举成员：RED\n\n\n1\n2\n3\n\n\n\n# 例 2\n\n创建一个示例，调用 valueOf() 方法获取枚举的一个成员，再调用 compareTo() 方法进行比较，并输出结果。具体实现代码如下：\n\npublic class TestEnum\n{\n    public enum Sex\n    {\n        //定义一个枚举\n        male,female;\n    }\n    public static void main(String[] args)\n    {\n        compare(Sex.valueOf("male"));    //比较\n    }\n    public static void compare(Sex s)\n    {\n        for(int i=0;i<Sex.values().length;i++)\n        {\n            System.out.println(s+"与"+Sex.values()[i]+"的比较结果是："+s.compareTo(Sex.values()[i]));\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上述代码中使用 Sex.valueOf(“male”) 取出枚举成员 male 对应的值，再将该值与其他枚举成员进行比较。\n\n最终输出结果如下： male与male的比较结果是：0 male与female的比较结果是：-1\n\n\n# 例 3\n\n通过调用枚举类型实例的 ordinal() 方法可以获取一个成员在枚举中的索引位置。下面的示例创建一个包含 3 个成员的枚举类型 Signal，然后调用 ordinal() 方法输出成员及对应索引位置。\n\n具体实现代码如下：\n\npublic class TestEnum1\n{\n    enum Signal\n    {\n        //定义一个枚举类型\n        GREEN,YELLOW,RED;\n    }\n    public static void main(String[] args)\n    {\n        for(int i=0;i<Signal.values().length;i++)\n        {\n            System.out.println("索引"+Signal.values()[i].ordinal()+"，值："+Signal.values()[i]);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n输出结果如下：\n\n索引0，值：GREEN\n索引1，值：YELLOW\n索引2，值：RED\n\n\n1\n2\n3\n\n\n\n# 3. 为枚举添加方法\n\nJava 为枚举类型提供了一些内置的方法，同时枚举常量也可以有自己的方法。此时要注意必须在枚举实例的最后一个成员后添加分号，而且必须先定义枚举实例。\n\n例 4：\n\n下面的代码创建了一个枚举类型 WeekDay，而且在该类型中添加了自定义的方法。\n\nenum WeekDay\n{\n    Mon("Monday"),\n    Tue("Tuesday"),\n    Wed("Wednesday"),\n    Thu("Thursday"),\n    Fri("Friday"),\n    Sat("Saturday"),\n    Sun("Sunday");\n    //以上是枚举的成员，必须先定义，而且使用分号结束\n    private final String day;\n    private WeekDay(String day)\n    {\n        this.day=day;\n    }\n    public static void printDay(int i)\n    {\n        switch(i)\n        {\n            case 1:\n                System.out.println(WeekDay.Mon);\n                break;\n            case 2:\n                System.out.println(WeekDay.Tue);\n                break;\n            case 3:\n                System.out.println(WeekDay.Wed);\n                break;\n            case 4:\n                System.out.println(WeekDay.Thu);\n                break;\n            case 5:\n                System.out.println(WeekDay.Fri);\n                break;\n            case 6:\n                System.out.println(WeekDay.Sat);\n                break;\n            case 7:\n                System.out.println(WeekDay.Sun);\n                break;\n            default:\n                System.out.println("wrong number!");\n        }\n    }\n    public String getDay()\n    {\n        return day;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n上面代码创建了 WeekDay 枚举类型，下面遍历该枚举中的所有成员，并调用 printDay() 方法。示例代码如下：\n\npublic static void main(String[] args)\n{\n    for(WeekDay day:WeekDay.values())\n    {\n        System.out.println(day+"====>"+day.getDay());\n    }\n    WeekDay.printDay(5);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n输出结果如下：\n\nMon====>Monday\nTue====>Tuesday\nWed====>Wednesday\nThu====>Thursday\nFri====>Friday\nSat====>Saturday\nSun====>Sunday\nFri\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nJava 中的 enum 还可以跟 Class 类一样覆盖基类的方法。下面示例代码创建的 Color 枚举类型覆盖了 toString() 方法。\n\npublic class Test\n{\n    public enum Color\n    {\n        RED("红色",1),GREEN("绿色",2),WHITE("白色",3),YELLOW("黄色",4);\n        //成员变量\n        private String name;\n        private int index;\n        //构造方法\n        private Color(String name,int index)\n        {\n            this.name=name;\n            this.index=index;\n        }\n        //覆盖方法\n        @Override\n        public String toString()\n        {\n            return this.index+"-"+this.name;\n        }\n    }\n    public static void main(String[] args)\n    {\n        System.out.println(Color.RED.toString());    //输出：1-红色\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4. EnumMap 与 EnumSet\n\n为了更好地支持枚举类型，java.util 中添加了两个新类：EnumMap 和 EnumSet。使用它们可以更高效地操作枚举类型。\n\n\n# 1. EnumMap 类\n\nEnumMap 是专门为枚举类型量身定做的 Map 实现。虽然使用其他的 Map（如 HashMap）实现也能完成枚举类型实例到值的映射，但是使用 EnumMap 会更加高效。\n\nHashMap 只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值，使得 EnumMap 的效率非常高。 例5： 下面是使用 EnumMap 的一个代码示例。枚举类型 DataBaseType 里存放了现在支持的所有数据库类型。针对不同的数据库，一些数据库相关的方法需要返回不一样的值，例如示例中 getURL() 方法。\n\n//定义数据库类型枚举\npublic enum DataBaseType\n{\n    MYSQUORACLE,DB2,SQLSERVER\n}\n//某类中定义的获取数据库URL的方法以及EnumMap的声明\nprivate EnumMap<DataBaseType,String>urls=new EnumMap<DataBaseType,String>(DataBaseType.class);\npublic DataBaseInfo()\n{\n    urls.put(DataBaseType.DB2,"jdbc:db2://localhost:5000/sample");\n    urls.put(DataBaseType.MYSQL,"jdbc:mysql://localhost/mydb");\n    urls.put(DataBaseType.ORACLE,"jdbc:oracle:thin:@localhost:1521:sample");\n    urls.put(DataBaseType.SQLSERVER,"jdbc:microsoft:sqlserver://sql:1433;Database=mydb");\n}\n//根据不同的数据库类型，返回对应的URL\n//@param type DataBaseType 枚举类新实例\n//@return\npublic String getURL(DataBaseType type)\n{\n    return this.urls.get(type);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在实际使用中，EnumMap 对象 urls 往往是由外部负责整个应用初始化的代码来填充的。这里为了演示方便，类自己做了内容填充。\n\n从本例中可以看出，使用 EnumMap 可以很方便地为枚举类型在不同的环境中绑定到不同的值上。本例子中 getURL 绑定到 URL 上，在其他的代码中可能又被绑定到数据库驱动上去。\n\n\n# 2. EnumSet 类\n\nEnumSet 是枚举类型的高性能 Set 实现，它要求放入它的枚举常量必须属于同一枚举类型。EnumSet 提供了许多工厂方法以便于初始化，如表 2 所示。\n\n表2 EnumSet 类的常用方法\n\n方法名称                         描述\nallOf(Class element type)    创建一个包含指定枚举类型中所有枚举成员的 EnumSet 对象\ncomplementOf(EnumSet s)      创建一个与指定 EnumSet 对象 s 相同的枚举类型 EnumSet 对象，并包含所有 s 中未包含的枚举成员\ncopyOf(EnumSet s)            创建一个与指定 EnumSet 对象 s 相同的枚举类型 EnumSet 对象，并与 s 包含相同的枚举成员\nnoneOf(<Class elementType)   创建指定枚举类型的空 EnumSet 对象\nof(E first,e…rest)           创建包含指定枚举成员的 EnumSet 对象\nrange(E from ,E to)          创建一个 EnumSet 对象，该对象包含了 from 到 to 之间的所有枚举成员\n\nEnumSet 作为 Set 接口实现，它支持对包含的枚举常量的遍历。\n\nfor(Operation op:EnumSet.range(Operation.PLUS,Operation.MULTIPLY))\n{\n    doSomeThing(op);\n}\n\n\n1\n2\n3\n4\n\n\n---------------------------------------------------------------------------------------\n\n\n# 5. 枚举的 7 种使用方法及为什么建议你使用枚举\n\n枚举是 JDK 1.5 新增的数据类型，使用枚举我们可以很好的描述一些特定的业务场景，比如一年中的春、夏、秋、冬，还有每周的周一到周天，还有各种颜色，以及可以用它来描述一些状态信息，比如错误码等。\n\n枚举类型不止存在在 Java 语言中，在其它语言中也都能找到它的身影，例如 C# 和 Python 等，但我发现在实际的项目中使用枚举的人很少，所以本文就来聊一聊枚举的相关内容，好让朋友们对枚举有一个大概的印象，这样在编程时起码还能想到有“枚举”这样一个类型。\n\n本文的结构目录如下：\n\n\n\n\n# 6. 枚举的 7 种使用方法\n\n很多人不使用枚举的一个重要的原因是对枚举不够熟悉，那么我们就先从枚举的 7 种使用方法说起。\n\n\n# 1. 常量\n\n在 JDK 1.5 之前，我们定义常量都是 public static final... ，但有了枚举，我们就可以把这些常量定义成一个枚举类了，实现代码如下：\n\npublic enum ColorEnum {  \n  RED, GREEN, BLANK, YELLOW  \n} \n\n\n1\n2\n3\n\n\n\n# 2. switch\n\n将枚举用在 switch 判断中，使得代码可读性更高了，实现代码如下：\n\nenum ColorEnum {\n    GREEN, YELLOW, RED\n}\npublic class ColorTest {\n    ColorEnum color = ColorEnum.RED;\n \n    public void change() {\n        switch (color) {\n            case RED:\n                color = ColorEnum.GREEN;\n                break;\n            case YELLOW:\n                color = ColorEnum.RED;\n                break;\n            case GREEN:\n                color = ColorEnum.YELLOW;\n                break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3. 枚举中增加方法（该代码是常见的枚举定义模板）\n\n我们可以在枚举中增加一些方法，让枚举具备更多的特性，实现代码如下：\n\npublic class EnumTest {\n    public static void main(String[] args) {\n        ErrorCodeEnum errorCode = ErrorCodeEnum.SUCCESS;\n        System.out.println("状态码：" + errorCode.code() + \n                           " 状态信息：" + errorCode.msg());\n    }\n}\n \nenum ErrorCodeEnum {\n    SUCCESS(1000, "success"),\n    PARAM_ERROR(1001, "parameter error"),\n    SYS_ERROR(1003, "system error"),\n    NAMESPACE_NOT_FOUND(2001, "namespace not found"),\n    NODE_NOT_EXIST(3002, "node not exist"),\n    NODE_ALREADY_EXIST(3003, "node already exist"),\n    UNKNOWN_ERROR(9999, "unknown error");\n \n    private int code;\n    private String msg;\n \n    ErrorCodeEnum(int code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n \n    public int code() {\n        return code;\n    }\n \n    public String msg() {\n        return msg;\n    }\n \n    public static ErrorCodeEnum getErrorCode(int code) {\n        for (ErrorCodeEnum it : ErrorCodeEnum.values()) {\n            if (it.code() == code) {\n                return it;\n            }\n        }\n        return UNKNOWN_ERROR;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n以上程序的执行结果为：状态码：1000 状态信息：success\n\n\n# 4. 覆盖枚举方法\n\n我们可以覆盖一些枚举中的方法用于实现自己的业务，比如我们可以覆盖 toString() 方法，实现代码如下：\n\npublic class EnumTest {\n    public static void main(String[] args) {\n        ColorEnum colorEnum = ColorEnum.RED;\n        System.out.println(colorEnum.toString());\n    }\n}\n \nenum ColorEnum {\n    RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLOW("黄色", 4);\n    //  成员变量\n    private String name;\n    private int index;\n \n    //  构造方法\n    private ColorEnum(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n \n    //覆盖方法\n    @Override\n    public String toString() {\n        return this.index + "：" + this.name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n以上程序的执行结果为：1：红色\n\n\n# 5. 实现接口\n\n枚举类可以用来实现接口，但不能用于继承类，因为枚举默认继承了 java.lang.Enum 类，在 Java 语言中允许实现多接口，但不能继承多个父类，实现代码如下：\n\npublic class EnumTest {\n    public static void main(String[] args) {\n        ColorEnum colorEnum = ColorEnum.RED;\n        colorEnum.print();\n        System.out.println("颜色：" + colorEnum.getInfo());\n    }\n}\n \ninterface Behaviour {\n    void print();\n \n    String getInfo();\n}\n \nenum ColorEnum implements Behaviour {\n    RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLOW("黄色", 4);\n    private String name;\n    private int index;\n \n    private ColorEnum(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n \n    @Override\n    public void print() {\n        System.out.println(this.index + "：" + this.name);\n    }\n \n    @Override\n    public String getInfo() {\n        return this.name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n以上程序的执行结果为：\n\n1：红色 颜色：红色\n\n\n# 6. 在接口中组织枚举类\n\n我们可以在一个接口中创建多个枚举类，用它可以很好的实现“多态”，也就是说我们可以将拥有相同特性，但又有细微实现差别的枚举类聚集在一个接口中，实现代码如下：\n\npublic class EnumTest {\n    public static void main(String[] args) {\n        // 赋值第一个枚举类\n        ColorInterface colorEnum = ColorInterface.ColorEnum.RED;\n        System.out.println(colorEnum);\n        // 赋值第二个枚举类\n        colorEnum = ColorInterface.NewColorEnum.NEW_RED;\n        System.out.println(colorEnum);\n    }\n}\n \ninterface ColorInterface {\n    enum ColorEnum implements ColorInterface {\n        GREEN, YELLOW, RED\n    }\n    enum NewColorEnum implements ColorInterface {\n        NEW_GREEN, NEW_YELLOW, NEW_RED\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n以上程序的执行结果为：\n\nRED NEW_RED\n\n\n# 7. 使用枚举集合\n\n在 Java 语言中和枚举类相关的，还有两个枚举集合类 java.util.EnumSet 和 java.util.EnumMap，使用它们可以实现更多的功能。\n\n使用 EnumSet 可以保证元素不重复，并且能获取指定范围内的元素，示例代码如下：\n\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.List;\n \npublic class EnumTest {\n    public static void main(String[] args) {\n        List<ColorEnum> list = new ArrayList<ColorEnum>();\n        list.add(ColorEnum.RED);\n        list.add(ColorEnum.RED);  // 重复元素\n        list.add(ColorEnum.YELLOW);\n        list.add(ColorEnum.GREEN);\n        // 去掉重复数据\n        EnumSet<ColorEnum> enumSet = EnumSet.copyOf(list);\n        System.out.println("去重：" + enumSet);\n \n        // 获取指定范围的枚举（获取所有的失败状态）\n        EnumSet<ErrorCodeEnum> errorCodeEnums = EnumSet.range(ErrorCodeEnum.ERROR, ErrorCodeEnum.UNKNOWN_ERROR);\n        System.out.println("所有失败状态：" + errorCodeEnums);\n    }\n}\n \nenum ColorEnum {\n    RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLOW("黄色", 4);\n    private String name;\n    private int index;\n \n    private ColorEnum(String name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n}\n \nenum ErrorCodeEnum {\n    SUCCESS(1000, "success"),\n    ERROR(2001, "parameter error"),\n    SYS_ERROR(2002, "system error"),\n    NAMESPACE_NOT_FOUND(2003, "namespace not found"),\n    NODE_NOT_EXIST(3002, "node not exist"),\n    NODE_ALREADY_EXIST(3003, "node already exist"),\n    UNKNOWN_ERROR(9999, "unknown error");\n \n    private int code;\n    private String msg;\n \n    ErrorCodeEnum(int code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n \n    public int code() {\n        return code;\n    }\n \n    public String msg() {\n        return msg;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n以上程序的执行结果为：\n\n去重：[RED, GREEN, YELLOW] 所有失败状态：[ERROR, SYS_ERROR, NAMESPACE_NOT_FOUND, NODE_NOT_EXIST, NODE_ALREADY_EXIST, UNKNOWN_ERROR]\n\nEnumMap 与 HashMap 类似，不过它是一个专门为枚举设计的 Map 集合，相比 HashMap 来说它的性能更高，因为它内部放弃使用链表和红黑树的结构，采用数组作为数据存储的结构。\n\nEnumMap 基本使用示例如下：\n\nimport java.util.EnumMap;\n \npublic class EnumTest {\n    public static void main(String[] args) {\n        EnumMap<ColorEnum, String> enumMap = new EnumMap<>(ColorEnum.class);\n        enumMap.put(ColorEnum.RED, "红色");\n        enumMap.put(ColorEnum.GREEN, "绿色");\n        enumMap.put(ColorEnum.BLANK, "白色");\n        enumMap.put(ColorEnum.YELLOW, "黄色");\n        System.out.println(ColorEnum.RED + ":" + enumMap.get(ColorEnum.RED));\n    }\n}\n \nenum ColorEnum {\n    RED, GREEN, BLANK, YELLOW;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上程序的执行结果为：RED:红色\n\n\n# 使用注意事项\n\n阿里《Java开发手册》对枚举的相关规定如下，我们在使用时需要稍微注意一下。\n\n> > 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。\n> \n> > 【参考】枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。\n\n\n# 假如不使用枚举\n\n在枚举没有诞生之前，也就是 JDK 1.5 版本之前，我们通常会使用 int 常量来表示枚举，实现代码如下：\n\npublic static final int COLOR_RED = 1;\npublic static final int COLOR_BLUE = 2;\npublic static final int COLOR_GREEN = 3;\n\n\n1\n2\n3\n\n\n但是使用 int 类型可能存在两个问题：\n\n第一，int类型本身并不具备安全性，假如某个程序员在定义int时少些了一个final关键字，那么就会存在被其他人修改的风险，而反观枚举类，它“天然”就是一个常量类，不存在被修改的风险（原因详见下半部分）；\n\n第二，使用 int 类型的语义不够明确，比如我们在控制台打印时如果只输出 1...2...3 这样的数字，我们肯定不知道它代表的是什么含义。\n\n\n\n那有人就说了，那就使用常量字符呗，这总不会还不知道语义吧？实现示例代码如下：\n\npublic static final String COLOR_RED = "RED";\npublic static final String COLOR_BLUE = "BLUE";\npublic static final String COLOR_GREEN = "GREEN";\n\n\n1\n2\n3\n\n\n但是这样同样存在一个问题，有些初级程序员会不按套路出牌，他们可能会直接使用字符串的值进行比较，而不是直接使用枚举的字段，实现示例代码如下：\n\npublic class Singleton {\n    // 枚举类型是线程安全的，并且只会装载一次\n    private enum SingletonEnum {\n        INSTANCE;\n        // 声明单例对象\n        private final Singleton instance;\n        // 实例化\n        SingletonEnum() {\n            instance = new Singleton();\n        }\n        private Singleton getInstance() {\n            return instance;\n        }\n    }\n    // 获取实例（单例对象）\n    public static Singleton getInstance() {\n        return SingletonEnum.INSTANCE.getInstance();\n    }\n    private Singleton() {\n    }\n    // 类方法\n    public void sayHi() {\n        System.out.println("Hi,Java.");\n    }\n}\nclass SingletonTest {\n    public static void main(String[] args) {\n        Singleton singleton = Singleton.getInstance();\n        singleton.sayHi();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n这样当我们修改了枚举中的值，那程序就凉凉了。\n\n\n# 枚举使用场景\n\n枚举的常见使用场景是单例，它的完整实现代码如下：\n\npublic class Singleton {\n    // 枚举类型是线程安全的，并且只会装载一次\n    private enum SingletonEnum {\n        INSTANCE;\n        // 声明单例对象\n        private final Singleton instance;\n        // 实例化\n        SingletonEnum() {\n            instance = new Singleton();\n        }\n        private Singleton getInstance() {\n            return instance;\n        }\n    }\n    // 获取实例（单例对象）\n    public static Singleton getInstance() {\n        return SingletonEnum.INSTANCE.getInstance();\n    }\n    private Singleton() {\n    }\n    // 类方法\n    public void sayHi() {\n        System.out.println("Hi,Java.");\n    }\n}\nclass SingletonTest {\n    public static void main(String[] args) {\n        Singleton singleton = Singleton.getInstance();\n        singleton.sayHi();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n因为枚举只会在类加载时装载一次，所以它是线程安全的，这也是《Effective Java》作者极力推荐使用枚举来实现单例的主要原因。\n\n\n# 知识扩展\n\n\n# 枚举为什么是线程安全的？\n\n这一点要从枚举最终生成的字节码说起，首先我们先来定义一个简单的枚举类：\n\npublic enum ColorEnumTest {\n    RED, GREEN, BLANK, YELLOW;\n}\n\n\n1\n2\n3\n\n\n然后我们再将上面的那段代码编译为字节码，具体内容如下：\n\npublic final class ColorEnumTest extends java.lang.Enum<ColorEnumTest> {\n  public static final ColorEnumTest RED;\n  public static final ColorEnumTest GREEN;\n  public static final ColorEnumTest BLANK;\n  public static final ColorEnumTest YELLOW;\n  public static ColorEnumTest[] values();\n  public static ColorEnumTest valueOf(java.lang.String);\n  static {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n从上述结果可以看出枚举类最终会被编译为被 final 修饰的普通类，它的所有属性也都会被 static 和 final 关键字修饰，所以枚举类在项目启动时就会被 JVM 加载并初始化，而这个执行过程是线程安全的，所以枚举类也是线程安全的类。\n\n> 小贴士：代码反编译的过程是先用 javac 命令将 java 代码编译字节码（.class），再使用 javap 命令查看编译的字节码。\n\n\n# 枚举比较小技巧\n\n我们在枚举比较时使用 == 就够了，因为枚举类是在程序加载时就创建了（它并不是 new 出来的），并且枚举类不允许在外部直接使用 new 关键字来创建枚举实例，所以我们在使用枚举类时本质上只有一个对象，因此在枚举比较时使用 == 就够了。\n\n并且我们在查看枚举的 equlas() 源码会发现，它的内部其实还是直接调用了 == 方法，源码如下：\n\npublic final boolean equals(Object other) {\n    return this==other;\n}\n\n\n1\n2\n3\n\n\n\n# 总结\n\n本文我们介绍了枚举类的 7 种使用方法：常量、switch、枚举中添加方法、覆盖枚举方法、实现接口、在接口中组织枚举类和使用枚举集合等，然后讲了如果不使用枚举类使用 int 类型和 String 类型存在的一些弊端：语义不够清晰、容易被修改、存在被误用的风险，所以我们在适合的环境下应该尽量使用枚举类。并且我们还讲了枚举类的使用场景——单例，以及枚举类为什么是安全的，最后我们讲了枚举比较的小技巧，希望本文对你有帮助。\n\n参考：https://blog.csdn.net/weixin_45433031/article/details/110727772',normalizedContent:'# 枚举\n\n\n> # 枚举的场景及历史\n\n枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。\n\n在 jdk 1.5 之前没有枚举类型，那时候一般用接口常量来替代。而使用 java 枚举类型 enum 可以更贴近地表示这种常量。\n\n\n# 1. 声明定义枚举\n\n声明枚举时必须使用 enum 关键字，然后定义枚举的名称、可访问性、基础类型和成员等。枚举声明的语法如下：\n\nenum-modifiers enum enumname:enum-base\n{\n    enum-body,\n}\n\n\n1\n2\n3\n4\n\n\n其中：\n\nenum-modifiers 表示枚举的修饰符主要包括 public、private 和 internal；\n\nenumname 表示声明的枚举名称；\n\nenum-base 表示基础类型；如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是 int。\n\nenum-body 表示枚举的成员，它是枚举类型的命名常数。任意两个枚举成员不能具有相同的名称，且它的常数值必须在该枚举的基础类型的范围之内，多个枚举成员之间使用逗号分隔。\n\n例 1:\n\n下面代码定义了一个表示性别的枚举类型 sexenum ，一个表示颜色的枚举类型 color。\n\npublic enum sexenum\n{\n    male,female;\n}\npublic enum color\n{\n    red,blue,green,black;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n之后便可以通过枚举类型名直接引用常量，如 sexenum.male、color.red。\n\n使用枚举还可以使 switch 语句的可读性更强，例如以下示例代码：\n\nenum signal\n{\n    //定义一个枚举类型\n    green,yellow,red\n}\npublic class trafficlight\n{\n    signal color=signal.red;\n    public void change()\n    {\n        switch(color)\n        {\n            case red:\n                color=signal.green;\n                break;\n            case yellow:\n                color=signal.red;\n                break;\n            case green:\n                color=signal.yellow;\n                break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2. 枚举类详解\n\njava 中的每一个枚举都继承自 java.lang.enum 类。当定义一个枚举类型时，每一个枚举类型成员都可以看作是 enum 类的实例，这些枚举成员默认都被 final、public, static 修饰，当使用枚举类型成员时，直接使用枚举名称调用成员即可。\n\n所有枚举实例都可以调用 enum 类的方法，常用方法如表 1 所示。\n\n表1 enum类的常用方法\n\n方法名称          描述\nvalues()      以数组形式返回枚举类型的所有成员\nvalueof()     将普通字符串转换为枚举实例\ncompareto()   比较两个枚举成员在定义时的顺序\nordinal()     获取枚举成员的索引位置\n\n\n# 例 1\n\n通过调用枚举类型实例的 values() 方法可以将枚举的所有成员以数组形式返回，也可以通过该方法获取枚举类型的成员。\n\n下面的示例创建一个包含 3 个成员的枚举类型 signal，然后调用 values() 方法输出这些成员。\n\nenum signal\n{\n    //定义一个枚举类型\n    green,yellow,red;\n}\npublic static void main(string[] args)\n{\n    for(int i=0;i<signal.values().length;i++)\n    {\n        system.out.println("枚举成员："+signal.values()[i]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n输出结果如下：\n\n枚举成员：green\n枚举成员：yellow\n枚举成员：red\n\n\n1\n2\n3\n\n\n\n# 例 2\n\n创建一个示例，调用 valueof() 方法获取枚举的一个成员，再调用 compareto() 方法进行比较，并输出结果。具体实现代码如下：\n\npublic class testenum\n{\n    public enum sex\n    {\n        //定义一个枚举\n        male,female;\n    }\n    public static void main(string[] args)\n    {\n        compare(sex.valueof("male"));    //比较\n    }\n    public static void compare(sex s)\n    {\n        for(int i=0;i<sex.values().length;i++)\n        {\n            system.out.println(s+"与"+sex.values()[i]+"的比较结果是："+s.compareto(sex.values()[i]));\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上述代码中使用 sex.valueof(“male”) 取出枚举成员 male 对应的值，再将该值与其他枚举成员进行比较。\n\n最终输出结果如下： male与male的比较结果是：0 male与female的比较结果是：-1\n\n\n# 例 3\n\n通过调用枚举类型实例的 ordinal() 方法可以获取一个成员在枚举中的索引位置。下面的示例创建一个包含 3 个成员的枚举类型 signal，然后调用 ordinal() 方法输出成员及对应索引位置。\n\n具体实现代码如下：\n\npublic class testenum1\n{\n    enum signal\n    {\n        //定义一个枚举类型\n        green,yellow,red;\n    }\n    public static void main(string[] args)\n    {\n        for(int i=0;i<signal.values().length;i++)\n        {\n            system.out.println("索引"+signal.values()[i].ordinal()+"，值："+signal.values()[i]);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n输出结果如下：\n\n索引0，值：green\n索引1，值：yellow\n索引2，值：red\n\n\n1\n2\n3\n\n\n\n# 3. 为枚举添加方法\n\njava 为枚举类型提供了一些内置的方法，同时枚举常量也可以有自己的方法。此时要注意必须在枚举实例的最后一个成员后添加分号，而且必须先定义枚举实例。\n\n例 4：\n\n下面的代码创建了一个枚举类型 weekday，而且在该类型中添加了自定义的方法。\n\nenum weekday\n{\n    mon("monday"),\n    tue("tuesday"),\n    wed("wednesday"),\n    thu("thursday"),\n    fri("friday"),\n    sat("saturday"),\n    sun("sunday");\n    //以上是枚举的成员，必须先定义，而且使用分号结束\n    private final string day;\n    private weekday(string day)\n    {\n        this.day=day;\n    }\n    public static void printday(int i)\n    {\n        switch(i)\n        {\n            case 1:\n                system.out.println(weekday.mon);\n                break;\n            case 2:\n                system.out.println(weekday.tue);\n                break;\n            case 3:\n                system.out.println(weekday.wed);\n                break;\n            case 4:\n                system.out.println(weekday.thu);\n                break;\n            case 5:\n                system.out.println(weekday.fri);\n                break;\n            case 6:\n                system.out.println(weekday.sat);\n                break;\n            case 7:\n                system.out.println(weekday.sun);\n                break;\n            default:\n                system.out.println("wrong number!");\n        }\n    }\n    public string getday()\n    {\n        return day;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n上面代码创建了 weekday 枚举类型，下面遍历该枚举中的所有成员，并调用 printday() 方法。示例代码如下：\n\npublic static void main(string[] args)\n{\n    for(weekday day:weekday.values())\n    {\n        system.out.println(day+"====>"+day.getday());\n    }\n    weekday.printday(5);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n输出结果如下：\n\nmon====>monday\ntue====>tuesday\nwed====>wednesday\nthu====>thursday\nfri====>friday\nsat====>saturday\nsun====>sunday\nfri\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\njava 中的 enum 还可以跟 class 类一样覆盖基类的方法。下面示例代码创建的 color 枚举类型覆盖了 tostring() 方法。\n\npublic class test\n{\n    public enum color\n    {\n        red("红色",1),green("绿色",2),white("白色",3),yellow("黄色",4);\n        //成员变量\n        private string name;\n        private int index;\n        //构造方法\n        private color(string name,int index)\n        {\n            this.name=name;\n            this.index=index;\n        }\n        //覆盖方法\n        @override\n        public string tostring()\n        {\n            return this.index+"-"+this.name;\n        }\n    }\n    public static void main(string[] args)\n    {\n        system.out.println(color.red.tostring());    //输出：1-红色\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4. enummap 与 enumset\n\n为了更好地支持枚举类型，java.util 中添加了两个新类：enummap 和 enumset。使用它们可以更高效地操作枚举类型。\n\n\n# 1. enummap 类\n\nenummap 是专门为枚举类型量身定做的 map 实现。虽然使用其他的 map（如 hashmap）实现也能完成枚举类型实例到值的映射，但是使用 enummap 会更加高效。\n\nhashmap 只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 enummap 使用数组来存放与枚举类型对应的值，使得 enummap 的效率非常高。 例5： 下面是使用 enummap 的一个代码示例。枚举类型 databasetype 里存放了现在支持的所有数据库类型。针对不同的数据库，一些数据库相关的方法需要返回不一样的值，例如示例中 geturl() 方法。\n\n//定义数据库类型枚举\npublic enum databasetype\n{\n    mysquoracle,db2,sqlserver\n}\n//某类中定义的获取数据库url的方法以及enummap的声明\nprivate enummap<databasetype,string>urls=new enummap<databasetype,string>(databasetype.class);\npublic databaseinfo()\n{\n    urls.put(databasetype.db2,"jdbc:db2://localhost:5000/sample");\n    urls.put(databasetype.mysql,"jdbc:mysql://localhost/mydb");\n    urls.put(databasetype.oracle,"jdbc:oracle:thin:@localhost:1521:sample");\n    urls.put(databasetype.sqlserver,"jdbc:microsoft:sqlserver://sql:1433;database=mydb");\n}\n//根据不同的数据库类型，返回对应的url\n//@param type databasetype 枚举类新实例\n//@return\npublic string geturl(databasetype type)\n{\n    return this.urls.get(type);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在实际使用中，enummap 对象 urls 往往是由外部负责整个应用初始化的代码来填充的。这里为了演示方便，类自己做了内容填充。\n\n从本例中可以看出，使用 enummap 可以很方便地为枚举类型在不同的环境中绑定到不同的值上。本例子中 geturl 绑定到 url 上，在其他的代码中可能又被绑定到数据库驱动上去。\n\n\n# 2. enumset 类\n\nenumset 是枚举类型的高性能 set 实现，它要求放入它的枚举常量必须属于同一枚举类型。enumset 提供了许多工厂方法以便于初始化，如表 2 所示。\n\n表2 enumset 类的常用方法\n\n方法名称                         描述\nallof(class element type)    创建一个包含指定枚举类型中所有枚举成员的 enumset 对象\ncomplementof(enumset s)      创建一个与指定 enumset 对象 s 相同的枚举类型 enumset 对象，并包含所有 s 中未包含的枚举成员\ncopyof(enumset s)            创建一个与指定 enumset 对象 s 相同的枚举类型 enumset 对象，并与 s 包含相同的枚举成员\nnoneof(<class elementtype)   创建指定枚举类型的空 enumset 对象\nof(e first,e…rest)           创建包含指定枚举成员的 enumset 对象\nrange(e from ,e to)          创建一个 enumset 对象，该对象包含了 from 到 to 之间的所有枚举成员\n\nenumset 作为 set 接口实现，它支持对包含的枚举常量的遍历。\n\nfor(operation op:enumset.range(operation.plus,operation.multiply))\n{\n    dosomething(op);\n}\n\n\n1\n2\n3\n4\n\n\n---------------------------------------------------------------------------------------\n\n\n# 5. 枚举的 7 种使用方法及为什么建议你使用枚举\n\n枚举是 jdk 1.5 新增的数据类型，使用枚举我们可以很好的描述一些特定的业务场景，比如一年中的春、夏、秋、冬，还有每周的周一到周天，还有各种颜色，以及可以用它来描述一些状态信息，比如错误码等。\n\n枚举类型不止存在在 java 语言中，在其它语言中也都能找到它的身影，例如 c# 和 python 等，但我发现在实际的项目中使用枚举的人很少，所以本文就来聊一聊枚举的相关内容，好让朋友们对枚举有一个大概的印象，这样在编程时起码还能想到有“枚举”这样一个类型。\n\n本文的结构目录如下：\n\n\n\n\n# 6. 枚举的 7 种使用方法\n\n很多人不使用枚举的一个重要的原因是对枚举不够熟悉，那么我们就先从枚举的 7 种使用方法说起。\n\n\n# 1. 常量\n\n在 jdk 1.5 之前，我们定义常量都是 public static final... ，但有了枚举，我们就可以把这些常量定义成一个枚举类了，实现代码如下：\n\npublic enum colorenum {  \n  red, green, blank, yellow  \n} \n\n\n1\n2\n3\n\n\n\n# 2. switch\n\n将枚举用在 switch 判断中，使得代码可读性更高了，实现代码如下：\n\nenum colorenum {\n    green, yellow, red\n}\npublic class colortest {\n    colorenum color = colorenum.red;\n \n    public void change() {\n        switch (color) {\n            case red:\n                color = colorenum.green;\n                break;\n            case yellow:\n                color = colorenum.red;\n                break;\n            case green:\n                color = colorenum.yellow;\n                break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3. 枚举中增加方法（该代码是常见的枚举定义模板）\n\n我们可以在枚举中增加一些方法，让枚举具备更多的特性，实现代码如下：\n\npublic class enumtest {\n    public static void main(string[] args) {\n        errorcodeenum errorcode = errorcodeenum.success;\n        system.out.println("状态码：" + errorcode.code() + \n                           " 状态信息：" + errorcode.msg());\n    }\n}\n \nenum errorcodeenum {\n    success(1000, "success"),\n    param_error(1001, "parameter error"),\n    sys_error(1003, "system error"),\n    namespace_not_found(2001, "namespace not found"),\n    node_not_exist(3002, "node not exist"),\n    node_already_exist(3003, "node already exist"),\n    unknown_error(9999, "unknown error");\n \n    private int code;\n    private string msg;\n \n    errorcodeenum(int code, string msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n \n    public int code() {\n        return code;\n    }\n \n    public string msg() {\n        return msg;\n    }\n \n    public static errorcodeenum geterrorcode(int code) {\n        for (errorcodeenum it : errorcodeenum.values()) {\n            if (it.code() == code) {\n                return it;\n            }\n        }\n        return unknown_error;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n以上程序的执行结果为：状态码：1000 状态信息：success\n\n\n# 4. 覆盖枚举方法\n\n我们可以覆盖一些枚举中的方法用于实现自己的业务，比如我们可以覆盖 tostring() 方法，实现代码如下：\n\npublic class enumtest {\n    public static void main(string[] args) {\n        colorenum colorenum = colorenum.red;\n        system.out.println(colorenum.tostring());\n    }\n}\n \nenum colorenum {\n    red("红色", 1), green("绿色", 2), blank("白色", 3), yellow("黄色", 4);\n    //  成员变量\n    private string name;\n    private int index;\n \n    //  构造方法\n    private colorenum(string name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n \n    //覆盖方法\n    @override\n    public string tostring() {\n        return this.index + "：" + this.name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n以上程序的执行结果为：1：红色\n\n\n# 5. 实现接口\n\n枚举类可以用来实现接口，但不能用于继承类，因为枚举默认继承了 java.lang.enum 类，在 java 语言中允许实现多接口，但不能继承多个父类，实现代码如下：\n\npublic class enumtest {\n    public static void main(string[] args) {\n        colorenum colorenum = colorenum.red;\n        colorenum.print();\n        system.out.println("颜色：" + colorenum.getinfo());\n    }\n}\n \ninterface behaviour {\n    void print();\n \n    string getinfo();\n}\n \nenum colorenum implements behaviour {\n    red("红色", 1), green("绿色", 2), blank("白色", 3), yellow("黄色", 4);\n    private string name;\n    private int index;\n \n    private colorenum(string name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n \n    @override\n    public void print() {\n        system.out.println(this.index + "：" + this.name);\n    }\n \n    @override\n    public string getinfo() {\n        return this.name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n以上程序的执行结果为：\n\n1：红色 颜色：红色\n\n\n# 6. 在接口中组织枚举类\n\n我们可以在一个接口中创建多个枚举类，用它可以很好的实现“多态”，也就是说我们可以将拥有相同特性，但又有细微实现差别的枚举类聚集在一个接口中，实现代码如下：\n\npublic class enumtest {\n    public static void main(string[] args) {\n        // 赋值第一个枚举类\n        colorinterface colorenum = colorinterface.colorenum.red;\n        system.out.println(colorenum);\n        // 赋值第二个枚举类\n        colorenum = colorinterface.newcolorenum.new_red;\n        system.out.println(colorenum);\n    }\n}\n \ninterface colorinterface {\n    enum colorenum implements colorinterface {\n        green, yellow, red\n    }\n    enum newcolorenum implements colorinterface {\n        new_green, new_yellow, new_red\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n以上程序的执行结果为：\n\nred new_red\n\n\n# 7. 使用枚举集合\n\n在 java 语言中和枚举类相关的，还有两个枚举集合类 java.util.enumset 和 java.util.enummap，使用它们可以实现更多的功能。\n\n使用 enumset 可以保证元素不重复，并且能获取指定范围内的元素，示例代码如下：\n\nimport java.util.arraylist;\nimport java.util.enumset;\nimport java.util.list;\n \npublic class enumtest {\n    public static void main(string[] args) {\n        list<colorenum> list = new arraylist<colorenum>();\n        list.add(colorenum.red);\n        list.add(colorenum.red);  // 重复元素\n        list.add(colorenum.yellow);\n        list.add(colorenum.green);\n        // 去掉重复数据\n        enumset<colorenum> enumset = enumset.copyof(list);\n        system.out.println("去重：" + enumset);\n \n        // 获取指定范围的枚举（获取所有的失败状态）\n        enumset<errorcodeenum> errorcodeenums = enumset.range(errorcodeenum.error, errorcodeenum.unknown_error);\n        system.out.println("所有失败状态：" + errorcodeenums);\n    }\n}\n \nenum colorenum {\n    red("红色", 1), green("绿色", 2), blank("白色", 3), yellow("黄色", 4);\n    private string name;\n    private int index;\n \n    private colorenum(string name, int index) {\n        this.name = name;\n        this.index = index;\n    }\n}\n \nenum errorcodeenum {\n    success(1000, "success"),\n    error(2001, "parameter error"),\n    sys_error(2002, "system error"),\n    namespace_not_found(2003, "namespace not found"),\n    node_not_exist(3002, "node not exist"),\n    node_already_exist(3003, "node already exist"),\n    unknown_error(9999, "unknown error");\n \n    private int code;\n    private string msg;\n \n    errorcodeenum(int code, string msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n \n    public int code() {\n        return code;\n    }\n \n    public string msg() {\n        return msg;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n以上程序的执行结果为：\n\n去重：[red, green, yellow] 所有失败状态：[error, sys_error, namespace_not_found, node_not_exist, node_already_exist, unknown_error]\n\nenummap 与 hashmap 类似，不过它是一个专门为枚举设计的 map 集合，相比 hashmap 来说它的性能更高，因为它内部放弃使用链表和红黑树的结构，采用数组作为数据存储的结构。\n\nenummap 基本使用示例如下：\n\nimport java.util.enummap;\n \npublic class enumtest {\n    public static void main(string[] args) {\n        enummap<colorenum, string> enummap = new enummap<>(colorenum.class);\n        enummap.put(colorenum.red, "红色");\n        enummap.put(colorenum.green, "绿色");\n        enummap.put(colorenum.blank, "白色");\n        enummap.put(colorenum.yellow, "黄色");\n        system.out.println(colorenum.red + ":" + enummap.get(colorenum.red));\n    }\n}\n \nenum colorenum {\n    red, green, blank, yellow;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上程序的执行结果为：red:红色\n\n\n# 使用注意事项\n\n阿里《java开发手册》对枚举的相关规定如下，我们在使用时需要稍微注意一下。\n\n> > 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。\n> \n> > 【参考】枚举类名带上 enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例：枚举名字为 processstatusenum 的成员名称：success / unknown_reason。\n\n\n# 假如不使用枚举\n\n在枚举没有诞生之前，也就是 jdk 1.5 版本之前，我们通常会使用 int 常量来表示枚举，实现代码如下：\n\npublic static final int color_red = 1;\npublic static final int color_blue = 2;\npublic static final int color_green = 3;\n\n\n1\n2\n3\n\n\n但是使用 int 类型可能存在两个问题：\n\n第一，int类型本身并不具备安全性，假如某个程序员在定义int时少些了一个final关键字，那么就会存在被其他人修改的风险，而反观枚举类，它“天然”就是一个常量类，不存在被修改的风险（原因详见下半部分）；\n\n第二，使用 int 类型的语义不够明确，比如我们在控制台打印时如果只输出 1...2...3 这样的数字，我们肯定不知道它代表的是什么含义。\n\n\n\n那有人就说了，那就使用常量字符呗，这总不会还不知道语义吧？实现示例代码如下：\n\npublic static final string color_red = "red";\npublic static final string color_blue = "blue";\npublic static final string color_green = "green";\n\n\n1\n2\n3\n\n\n但是这样同样存在一个问题，有些初级程序员会不按套路出牌，他们可能会直接使用字符串的值进行比较，而不是直接使用枚举的字段，实现示例代码如下：\n\npublic class singleton {\n    // 枚举类型是线程安全的，并且只会装载一次\n    private enum singletonenum {\n        instance;\n        // 声明单例对象\n        private final singleton instance;\n        // 实例化\n        singletonenum() {\n            instance = new singleton();\n        }\n        private singleton getinstance() {\n            return instance;\n        }\n    }\n    // 获取实例（单例对象）\n    public static singleton getinstance() {\n        return singletonenum.instance.getinstance();\n    }\n    private singleton() {\n    }\n    // 类方法\n    public void sayhi() {\n        system.out.println("hi,java.");\n    }\n}\nclass singletontest {\n    public static void main(string[] args) {\n        singleton singleton = singleton.getinstance();\n        singleton.sayhi();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n这样当我们修改了枚举中的值，那程序就凉凉了。\n\n\n# 枚举使用场景\n\n枚举的常见使用场景是单例，它的完整实现代码如下：\n\npublic class singleton {\n    // 枚举类型是线程安全的，并且只会装载一次\n    private enum singletonenum {\n        instance;\n        // 声明单例对象\n        private final singleton instance;\n        // 实例化\n        singletonenum() {\n            instance = new singleton();\n        }\n        private singleton getinstance() {\n            return instance;\n        }\n    }\n    // 获取实例（单例对象）\n    public static singleton getinstance() {\n        return singletonenum.instance.getinstance();\n    }\n    private singleton() {\n    }\n    // 类方法\n    public void sayhi() {\n        system.out.println("hi,java.");\n    }\n}\nclass singletontest {\n    public static void main(string[] args) {\n        singleton singleton = singleton.getinstance();\n        singleton.sayhi();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n因为枚举只会在类加载时装载一次，所以它是线程安全的，这也是《effective java》作者极力推荐使用枚举来实现单例的主要原因。\n\n\n# 知识扩展\n\n\n# 枚举为什么是线程安全的？\n\n这一点要从枚举最终生成的字节码说起，首先我们先来定义一个简单的枚举类：\n\npublic enum colorenumtest {\n    red, green, blank, yellow;\n}\n\n\n1\n2\n3\n\n\n然后我们再将上面的那段代码编译为字节码，具体内容如下：\n\npublic final class colorenumtest extends java.lang.enum<colorenumtest> {\n  public static final colorenumtest red;\n  public static final colorenumtest green;\n  public static final colorenumtest blank;\n  public static final colorenumtest yellow;\n  public static colorenumtest[] values();\n  public static colorenumtest valueof(java.lang.string);\n  static {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n从上述结果可以看出枚举类最终会被编译为被 final 修饰的普通类，它的所有属性也都会被 static 和 final 关键字修饰，所以枚举类在项目启动时就会被 jvm 加载并初始化，而这个执行过程是线程安全的，所以枚举类也是线程安全的类。\n\n> 小贴士：代码反编译的过程是先用 javac 命令将 java 代码编译字节码（.class），再使用 javap 命令查看编译的字节码。\n\n\n# 枚举比较小技巧\n\n我们在枚举比较时使用 == 就够了，因为枚举类是在程序加载时就创建了（它并不是 new 出来的），并且枚举类不允许在外部直接使用 new 关键字来创建枚举实例，所以我们在使用枚举类时本质上只有一个对象，因此在枚举比较时使用 == 就够了。\n\n并且我们在查看枚举的 equlas() 源码会发现，它的内部其实还是直接调用了 == 方法，源码如下：\n\npublic final boolean equals(object other) {\n    return this==other;\n}\n\n\n1\n2\n3\n\n\n\n# 总结\n\n本文我们介绍了枚举类的 7 种使用方法：常量、switch、枚举中添加方法、覆盖枚举方法、实现接口、在接口中组织枚举类和使用枚举集合等，然后讲了如果不使用枚举类使用 int 类型和 string 类型存在的一些弊端：语义不够清晰、容易被修改、存在被误用的风险，所以我们在适合的环境下应该尽量使用枚举类。并且我们还讲了枚举类的使用场景——单例，以及枚举类为什么是安全的，最后我们讲了枚举比较的小技巧，希望本文对你有帮助。\n\n参考：https://blog.csdn.net/weixin_45433031/article/details/110727772',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"常用API",frontmatter:{title:"常用API",date:"2023-02-26T11:02:32.000Z",permalink:"/pages/5d20e5/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/100.%E5%B8%B8%E7%94%A8API.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/100.常用API.md",key:"v-4855977e",path:"/pages/5d20e5/",headers:[{level:2,title:"1. API",slug:"_1-api",normalizedTitle:"1. api",charIndex:12},{level:3,title:"1.1 API概述",slug:"_1-1-api概述",normalizedTitle:"1.1 api概述",charIndex:23},{level:3,title:"1.2 如何使用API帮助文档",slug:"_1-2-如何使用api帮助文档",normalizedTitle:"1.2 如何使用api帮助文档",charIndex:222},{level:2,title:"2. String类",slug:"_2-string类",normalizedTitle:"2. string类",charIndex:344},{level:3,title:"2.1 String类概述",slug:"_2-1-string类概述",normalizedTitle:"2.1 string类概述",charIndex:359},{level:3,title:"2.2 String类的特点",slug:"_2-2-string类的特点",normalizedTitle:"2.2 string类的特点",charIndex:503},{level:3,title:"2.3 String类的构造方法",slug:"_2-3-string类的构造方法",normalizedTitle:"2.3 string类的构造方法",charIndex:627},{level:3,title:"2.4 创建字符串对象两种方式的区别",slug:"_2-4-创建字符串对象两种方式的区别",normalizedTitle:"2.4 创建字符串对象两种方式的区别",charIndex:1767},{level:3,title:"2.5 字符串的比较",slug:"_2-5-字符串的比较",normalizedTitle:"2.5 字符串的比较",charIndex:1954},{level:4,title:"1. ==号的作用",slug:"_1-号的作用",normalizedTitle:"1. ==号的作用",charIndex:1968},{level:4,title:"2. equals方法的作用",slug:"_2-equals方法的作用",normalizedTitle:"2. equals方法的作用",charIndex:2025},{level:3,title:"2.6 用户登录案例",slug:"_2-6-用户登录案例",normalizedTitle:"2.6 用户登录案例",charIndex:2979},{level:4,title:"1. 案例需求",slug:"_1-案例需求",normalizedTitle:"1. 案例需求",charIndex:2993},{level:4,title:"2. 代码实现",slug:"_2-代码实现",normalizedTitle:"2. 代码实现",charIndex:3048},{level:3,title:"2.7 遍历字符串案例",slug:"_2-7-遍历字符串案例",normalizedTitle:"2.7 遍历字符串案例",charIndex:4440},{level:4,title:"1. 案例需求",slug:"_1-案例需求-2",normalizedTitle:"1. 案例需求",charIndex:2993},{level:4,title:"2. 代码实现",slug:"_2-代码实现-2",normalizedTitle:"2. 代码实现",charIndex:3048},{level:3,title:"2.8 统计字符次数案例",slug:"_2-8-统计字符次数案例",normalizedTitle:"2.8 统计字符次数案例",charIndex:5225},{level:4,title:"1. 案例需求",slug:"_1-案例需求-3",normalizedTitle:"1. 案例需求",charIndex:2993},{level:4,title:"2. 代码实现",slug:"_2-代码实现-3",normalizedTitle:"2. 代码实现",charIndex:3048},{level:3,title:"2.9 字符串拼接案例",slug:"_2-9-字符串拼接案例",normalizedTitle:"2.9 字符串拼接案例",charIndex:6720},{level:4,title:"1. 案例需求",slug:"_1-案例需求-4",normalizedTitle:"1. 案例需求",charIndex:2993},{level:4,title:"2. 代码实现",slug:"_2-代码实现-4",normalizedTitle:"2. 代码实现",charIndex:3048},{level:3,title:"2.10 字符串反转案例",slug:"_2-10-字符串反转案例",normalizedTitle:"2.10 字符串反转案例",charIndex:7983},{level:4,title:"1. 案例需求",slug:"_1-案例需求-5",normalizedTitle:"1. 案例需求",charIndex:2993},{level:4,title:"2. 代码实现",slug:"_2-代码实现-5",normalizedTitle:"2. 代码实现",charIndex:3048},{level:3,title:"2.11 帮助文档查看String常用方法",slug:"_2-11-帮助文档查看string常用方法",normalizedTitle:"2.11 帮助文档查看string常用方法",charIndex:9065},{level:2,title:"3. StringBuilder类",slug:"_3-stringbuilder类",normalizedTitle:"3. stringbuilder类",charIndex:9310},{level:3,title:"3.1 StringBuilder类概述",slug:"_3-1-stringbuilder类概述",normalizedTitle:"3.1 stringbuilder类概述",charIndex:9332},{level:3,title:"3.2 StringBuilder类和String类的区别",slug:"_3-2-stringbuilder类和string类的区别",normalizedTitle:"3.2 stringbuilder类和string类的区别",charIndex:9431},{level:3,title:"3.3 StringBuilder类的构造方法",slug:"_3-3-stringbuilder类的构造方法",normalizedTitle:"3.3 stringbuilder类的构造方法",charIndex:9510},{level:3,title:"3.4 StringBuilder类添加和反转方法",slug:"_3-4-stringbuilder类添加和反转方法",normalizedTitle:"3.4 stringbuilder类添加和反转方法",charIndex:10267},{level:3,title:"3.5 StringBuilder和String相互转换",slug:"_3-5-stringbuilder和string相互转换",normalizedTitle:"3.5 stringbuilder和string相互转换",charIndex:11288},{level:3,title:"3.6 字符串拼接升级版案例",slug:"_3-6-字符串拼接升级版案例",normalizedTitle:"3.6 字符串拼接升级版案例",charIndex:12283},{level:4,title:"1. 案例需求",slug:"_1-案例需求-6",normalizedTitle:"1. 案例需求",charIndex:2993},{level:4,title:"2. 代码实现",slug:"_2-代码实现-6",normalizedTitle:"2. 代码实现",charIndex:3048},{level:3,title:"3.7 字符串反转升级版案例",slug:"_3-7-字符串反转升级版案例",normalizedTitle:"3.7 字符串反转升级版案例",charIndex:13659},{level:4,title:"1. 案例需求",slug:"_1-案例需求-7",normalizedTitle:"1. 案例需求",charIndex:2993},{level:4,title:"2. 代码实现",slug:"_2-代码实现-7",normalizedTitle:"2. 代码实现",charIndex:3048},{level:3,title:"3.8 帮助文档查看StringBuilder常用方法",slug:"_3-8-帮助文档查看stringbuilder常用方法",normalizedTitle:"3.8 帮助文档查看stringbuilder常用方法",charIndex:14910},{level:2,title:"4. 常用API",slug:"_4-常用api",normalizedTitle:"4. 常用api",charIndex:15206},{level:3,title:"4.1 Math",slug:"_4-1-math",normalizedTitle:"4.1 math",charIndex:15219},{level:3,title:"4.2 System",slug:"_4-2-system",normalizedTitle:"4.2 system",charIndex:15957},{level:3,title:"4.3 Object类的toString方法",slug:"_4-3-object类的tostring方法",normalizedTitle:"4.3 object类的tostring方法",charIndex:16690},{level:3,title:"4.4 Object类的equals方法",slug:"_4-4-object类的equals方法",normalizedTitle:"4.4 object类的equals方法",charIndex:18394},{level:3,title:"4.5 冒泡排序原理🚗",slug:"_4-5-冒泡排序原理",normalizedTitle:"4.5 冒泡排序原理🚗",charIndex:20400},{level:3,title:"4.6 冒泡排序代码实现",slug:"_4-6-冒泡排序代码实现",normalizedTitle:"4.6 冒泡排序代码实现",charIndex:20554},{level:3,title:"4.7 Arrays",slug:"_4-7-arrays",normalizedTitle:"4.7 arrays",charIndex:21901},{level:2,title:"5.时间日期类",slug:"_5-时间日期类",normalizedTitle:"5.时间日期类",charIndex:22171},{level:3,title:"5.1 Date类",slug:"_5-1-date类",normalizedTitle:"5.1 date类",charIndex:22183},{level:3,title:"5.2 Date类常用方法",slug:"_5-2-date类常用方法",normalizedTitle:"5.2 date类常用方法",charIndex:22908},{level:3,title:"5.3 SimpleDateFormat类",slug:"_5-3-simpledateformat类",normalizedTitle:"5.3 simpledateformat类",charIndex:23778},{level:3,title:"5.4 日期工具类案例",slug:"_5-4-日期工具类案例",normalizedTitle:"5.4 日期工具类案例",charIndex:25161},{level:3,title:"5.5 Calendar类",slug:"_5-5-calendar类",normalizedTitle:"5.5 calendar类",charIndex:27002},{level:3,title:"5.6 二月天案例",slug:"_5-6-二月天案例",normalizedTitle:"5.6 二月天案例",charIndex:29180}],headersStr:"1. API 1.1 API概述 1.2 如何使用API帮助文档 2. String类 2.1 String类概述 2.2 String类的特点 2.3 String类的构造方法 2.4 创建字符串对象两种方式的区别 2.5 字符串的比较 1. ==号的作用 2. equals方法的作用 2.6 用户登录案例 1. 案例需求 2. 代码实现 2.7 遍历字符串案例 1. 案例需求 2. 代码实现 2.8 统计字符次数案例 1. 案例需求 2. 代码实现 2.9 字符串拼接案例 1. 案例需求 2. 代码实现 2.10 字符串反转案例 1. 案例需求 2. 代码实现 2.11 帮助文档查看String常用方法 3. StringBuilder类 3.1 StringBuilder类概述 3.2 StringBuilder类和String类的区别 3.3 StringBuilder类的构造方法 3.4 StringBuilder类添加和反转方法 3.5 StringBuilder和String相互转换 3.6 字符串拼接升级版案例 1. 案例需求 2. 代码实现 3.7 字符串反转升级版案例 1. 案例需求 2. 代码实现 3.8 帮助文档查看StringBuilder常用方法 4. 常用API 4.1 Math 4.2 System 4.3 Object类的toString方法 4.4 Object类的equals方法 4.5 冒泡排序原理🚗 4.6 冒泡排序代码实现 4.7 Arrays 5.时间日期类 5.1 Date类 5.2 Date类常用方法 5.3 SimpleDateFormat类 5.4 日期工具类案例 5.5 Calendar类 5.6 二月天案例",content:'# 常用API\n\n\n# 1. API\n\n\n# 1.1 API概述\n\n * 什么是API\n   \n   API (Application Programming Interface) ：应用程序编程接口\n\n * java中的API\n   \n   指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。\n\n\n# 1.2 如何使用API帮助文档\n\n * 打开帮助文档\n\n\n\n * 找到索引选项卡中的输入框\n\n\n\n * 在输入框中输入Random\n\n\n\n * 看类在哪个包下\n\n\n\n * 看类的描述\n\n\n\n * 看构造方法\n\n\n\n * 看成员方法\n\n\n\n\n# 2. String类\n\n\n# 2.1 String类概述\n\nString 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！\n\n\n# 2.2 String类的特点\n\n * 字符串不可变，它们的值在创建后不能被更改\n * 虽然 String 的值是不可变的，但是它们可以被共享\n * 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )\n\n\n# 2.3 String类的构造方法\n\n * 常用的构造方法\n   \n   方法名                         说明\n   public String()             创建一个空白字符串对象，不含有任何内容\n   public String(char[] chs)   根据字符数组的内容，来创建字符串对象\n   public String(byte[] bys)   根据字节数组的内容，来创建字符串对象\n   String s = “abc”;           直接赋值的方式创建字符串对象，内容就是abc\n\n * 示例代码\n   \n   public class StringDemo01 {\n       public static void main(String[] args) {\n           //public String()：创建一个空白字符串对象，不含有任何内容\n           String s1 = new String();\n           System.out.println("s1:" + s1);\n   \n           //public String(char[] chs)：根据字符数组的内容，来创建字符串对象\n           char[] chs = {\'a\', \'b\', \'c\'};\n           String s2 = new String(chs);\n           System.out.println("s2:" + s2);\n   \n           //public String(byte[] bys)：根据字节数组的内容，来创建字符串对象\n           byte[] bys = {97, 98, 99};\n           String s3 = new String(bys);\n           System.out.println("s3:" + s3);\n   \n           //String s = “abc”;\t直接赋值的方式创建字符串对象，内容就是abc\n           String s4 = "abc";\n           System.out.println("s4:" + s4);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 2.4 创建字符串对象两种方式的区别\n\n * 通过构造方法创建\n   \n   通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同\n\n * 直接赋值方式创建\n   \n   以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护\n\n\n# 2.5 字符串的比较\n\n# 1. ==号的作用\n\n * 比较基本数据类型：比较的是具体的值\n * 比较引用数据类型：比较的是对象地址值\n\n# 2. equals方法的作用\n\n * 方法介绍\n   \n   public boolean equals(String s)     比较两个字符串内容是否相同、区分大小写\n   \n   \n   1\n   \n\n * 示例代码\n   \n   public class StringDemo02 {\n       public static void main(String[] args) {\n           //构造方法的方式得到对象\n           char[] chs = {\'a\', \'b\', \'c\'};\n           String s1 = new String(chs);\n           String s2 = new String(chs);\n   \n           //直接赋值的方式得到对象\n           String s3 = "abc";\n           String s4 = "abc";\n   \n           //比较字符串对象地址是否相同\n           System.out.println(s1 == s2);\n           System.out.println(s1 == s3);\n           System.out.println(s3 == s4);\n           System.out.println("--------");\n   \n           //比较字符串内容是否相同\n           System.out.println(s1.equals(s2));\n           System.out.println(s1.equals(s3));\n           System.out.println(s3.equals(s4));\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   \n\n\n# 2.6 用户登录案例\n\n# 1. 案例需求\n\n已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:已知用户名和密码，定义两个字符串表示即可\n        2:键盘录入要登录的用户名和密码，用 Scanner 实现\n        3:拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现\n        4:用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环\n */\npublic class StringTest01 {\n    public static void main(String[] args) {\n        //已知用户名和密码，定义两个字符串表示即可\n        String username = "itheima";\n        String password = "czbk";\n\n        //用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环\n        for(int i=0; i<3; i++) {\n\n            //键盘录入要登录的用户名和密码，用 Scanner 实现\n            Scanner sc = new Scanner(System.in);\n\n            System.out.println("请输入用户名：");\n            String name = sc.nextLine();\n\n            System.out.println("请输入密码：");\n            String pwd = sc.nextLine();\n\n            //拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现\n            if (name.equals(username) && pwd.equals(password)) {\n                System.out.println("登录成功");\n                break;\n            } else {\n                if(2-i == 0) {\n                    System.out.println("你的账户被锁定，请与管理员联系");\n                } else {\n                    //2,1,0\n                    //i,0,1,2\n                    System.out.println("登录失败，你还有" + (2 - i) + "次机会");\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 2.7 遍历字符串案例\n\n# 1. 案例需求\n\n键盘录入一个字符串，使用程序实现在控制台遍历该字符串\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:键盘录入一个字符串，用 Scanner 实现\n        2:遍历字符串，首先要能够获取到字符串中的每一个字符\n            public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的\n        3:遍历字符串，其次要能够获取到字符串的长度\n            public int length()：返回此字符串的长度\n            数组的长度：数组名.length\n            字符串的长度：字符串对象.length()\n        4:遍历字符串的通用格式\n */\npublic class StringTest02 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，用 Scanner 实现\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println("请输入一个字符串：");\n        String line = sc.nextLine();\n\n        for(int i=0; i<line.length(); i++) {\n            System.out.println(line.charAt(i));\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.8 统计字符次数案例\n\n# 1. 案例需求\n\n键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)\n\n# 2. 代码实现\n\n/*\n  思路：\n        1:键盘录入一个字符串，用 Scanner 实现\n        2:要统计三种类型的字符个数，需定义三个统计变量，初始值都为0\n        3:遍历字符串，得到每一个字符\n        4:判断该字符属于哪种类型，然后对应类型的统计变量+1\n            假如ch是一个字符，我要判断它属于大写字母，小写字母，还是数字，直接判断该字符是否在对应的范围即可\n            大写字母：ch>=\'A\' && ch<=\'Z\'\n            小写字母： ch>=\'a\' && ch<=\'z\'\n            数字： ch>=\'0\' && ch<=\'9\'\n        5:输出三种类型的字符个数\n */\npublic class StringTest03 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，用 Scanner 实现\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println("请输入一个字符串：");\n        String line = sc.nextLine();\n\n        //要统计三种类型的字符个数，需定义三个统计变量，初始值都为0\n        int bigCount = 0;\n        int smallCount = 0;\n        int numberCount = 0;\n\n        //遍历字符串，得到每一个字符\n        for(int i=0; i<line.length(); i++) {\n            char ch = line.charAt(i);\n\n            //判断该字符属于哪种类型，然后对应类型的统计变量+1\n            if(ch>=\'A\' && ch<=\'Z\') {\n                bigCount++;\n            } else if(ch>=\'a\' && ch<=\'z\') {\n                smallCount++;\n            } else if(ch>=\'0\' && ch<=\'9\') {\n                numberCount++;\n            }\n        }\n\n        //输出三种类型的字符个数\n        System.out.println("大写字母：" + bigCount + "个");\n        System.out.println("小写字母：" + smallCount + "个");\n        System.out.println("数字：" + numberCount + "个");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 2.9 字符串拼接案例\n\n# 1. 案例需求\n\n定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\n\n并在控制台输出结果。例如，数组为 int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\n          返回值类型 String，参数列表 int[] arr\n        3:在方法中遍历数组，按照要求进行拼接\n        4:调用方法，用一个变量接收结果\n        5:输出结果\n */\npublic class StringTest04 {\n    public static void main(String[] args) {\n        //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        int[] arr = {1, 2, 3};\n\n        //调用方法，用一个变量接收结果\n        String s = arrayToString(arr);\n\n        //输出结果\n        System.out.println("s:" + s);\n    }\n\n    //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回\n    /*\n        两个明确：\n            返回值类型：String\n            参数：int[] arr\n     */\n    public static String arrayToString(int[] arr) {\n        //在方法中遍历数组，按照要求进行拼接\n        String s = "";\n\n        s += "[";\n\n        for(int i=0; i<arr.length; i++) {\n            if(i==arr.length-1) {\n                s += arr[i];\n            } else {\n                s += arr[i];\n                s += ", ";\n            }\n        }\n\n        s += "]";\n\n        return s;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 2.10 字符串反转案例\n\n# 1. 案例需求\n\n定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果\n\n例如，键盘录入 abc，输出结果 cba\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:键盘录入一个字符串，用 Scanner 实现\n        2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s\n        3:在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回\n        4:调用方法，用一个变量接收结果\n        5:输出结果\n */\npublic class StringTest05 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，用 Scanner 实现\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println("请输入一个字符串：");\n        String line = sc.nextLine();\n\n        //调用方法，用一个变量接收结果\n        String s = reverse(line);\n\n        //输出结果\n        System.out.println("s:" + s);\n    }\n\n    //定义一个方法，实现字符串反转\n    /*\n        两个明确：\n            返回值类型：String\n            参数：String s\n     */\n    public static String reverse(String s) {\n        //在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回\n        String ss = "";\n\n        for(int i=s.length()-1; i>=0; i--) {\n            ss += s.charAt(i);\n        }\n\n        return ss;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 2.11 帮助文档查看String常用方法\n\n方法名                                      说明\npublic boolean equals(Object anObject)   比较字符串的内容，严格区分大小写(用户名和密码)\npublic char charAt(int index)            返回指定索引处的 char 值\npublic int length()                      返回此字符串的长度\n\n\n# 3. StringBuilder类\n\n\n# 3.1 StringBuilder类概述\n\nStringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的\n\n\n# 3.2 StringBuilder类和String类的区别\n\n * String类：内容是不可变的\n * StringBuilder类：内容是可变的\n\n\n# 3.3 StringBuilder类的构造方法\n\n * 常用的构造方法\n   \n   方法名                                说明\n   public StringBuilder()             创建一个空白可变字符串对象，不含有任何内容\n   public StringBuilder(String str)   根据字符串的内容，来创建可变字符串对象\n\n * 示例代码\n\npublic class StringBuilderDemo01 {\n    public static void main(String[] args) {\n        //public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容\n        StringBuilder sb = new StringBuilder();\n        System.out.println("sb:" + sb);\n        System.out.println("sb.length():" + sb.length());\n\n        //public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象\n        StringBuilder sb2 = new StringBuilder("hello");\n        System.out.println("sb2:" + sb2);\n        System.out.println("sb2.length():" + sb2.length());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.4 StringBuilder类添加和反转方法\n\n * 添加和反转方法\n   \n   方法名                                 说明\n   public StringBuilder append(任意类型)   添加数据，并返回对象本身\n   public StringBuilder reverse()      返回相反的字符序列\n\n * 示例代码\n\npublic class StringBuilderDemo01 {\n    public static void main(String[] args) {\n        //创建对象\n        StringBuilder sb = new StringBuilder();\n\n        //public StringBuilder append(任意类型)：添加数据，并返回对象本身\n//        StringBuilder sb2 = sb.append("hello");\n//\n//        System.out.println("sb:" + sb);\n//        System.out.println("sb2:" + sb2);\n//        System.out.println(sb == sb2);\n\n//        sb.append("hello");\n//        sb.append("world");\n//        sb.append("java");\n//        sb.append(100);\n\n        //链式编程\n        sb.append("hello").append("world").append("java").append(100);\n\n        System.out.println("sb:" + sb);\n\n        //public StringBuilder reverse()：返回相反的字符序列\n        sb.reverse();\n        System.out.println("sb:" + sb);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3.5 StringBuilder和String相互转换\n\n * StringBuilder转换为String\n   \n   public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String\n\n * String转换为StringBuilder\n   \n   public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder\n\n * 示例代码\n\npublic class StringBuilderDemo02 {\n    public static void main(String[] args) {\n        /*\n        //StringBuilder 转换为 String\n        StringBuilder sb = new StringBuilder();\n        sb.append("hello");\n\n        //String s = sb; //这个是错误的做法\n\n        //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String\n        String s = sb.toString();\n        System.out.println(s);\n        */\n\n        //String 转换为 StringBuilder\n        String s = "hello";\n\n        //StringBuilder sb = s; //这个是错误的做法\n\n        //public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder\n        StringBuilder sb = new StringBuilder(s);\n\n        System.out.println(sb);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 3.6 字符串拼接升级版案例\n\n# 1. 案例需求\n\n定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\n\n并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\n          返回值类型 String，参数列表 int[] arr\n        3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\n        4:调用方法，用一个变量接收结果\n        5:输出结果\n */\npublic class StringBuilderTest01 {\n    public static void main(String[] args) {\n        //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        int[] arr = {1, 2, 3};\n        //调用方法，用一个变量接收结果\n        String s = arrayToString(arr);\n        //输出结果\n        System.out.println("s:" + s);\n    }\n\n    //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回\n    /*\n        两个明确：\n            返回值类型：String\n            参数：int[] arr\n     */\n    public static String arrayToString(int[] arr) {\n        //在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\n        StringBuilder sb = new StringBuilder();\n        sb.append("[");\n        for(int i=0; i<arr.length; i++) {\n            if(i == arr.length-1) {\n                sb.append(arr[i]);\n            } else {\n                sb.append(arr[i]).append(", ");\n            }\n        }\n        sb.append("]");\n        String s = sb.toString();\n        return  s;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 3.7 字符串反转升级版案例\n\n# 1. 案例需求\n\n定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果\n\n例如，键盘录入abc，输出结果 cba\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:键盘录入一个字符串，用 Scanner 实现\n        2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s\n        3:在方法中用StringBuilder实现字符串的反转，并把结果转成String返回\n        4:调用方法，用一个变量接收结果\n        5:输出结果\n */\npublic class StringBuilderTest02 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，用 Scanner 实现\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println("请输入一个字符串：");\n        String line = sc.nextLine();\n\n        //调用方法，用一个变量接收结果\n        String s = myReverse(line);\n\n        //输出结果\n        System.out.println("s:" + s);\n    }\n\n    //定义一个方法，实现字符串反转。返回值类型 String，参数 String s\n    /*\n        两个明确：\n            返回值类型：String\n            参数：String s\n     */\n    public static String myReverse(String s) {\n        //在方法中用StringBuilder实现字符串的反转，并把结果转成String返回\n        //String --- StringBuilder --- reverse() --- String\n//        StringBuilder sb = new StringBuilder(s);\n//        sb.reverse();\n//        String ss = sb.toString();\n//        return ss;\n\n       return new StringBuilder(s).reverse().toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 3.8 帮助文档查看StringBuilder常用方法\n\n方法名                                  说明\npublic StringBuilder append (任意类型)   添加数据，并返回对象本身\npublic StringBuilder reverse()       返回相反的字符序列\npublic int length()                  返回长度，实际存储值\npublic String toString()             通过toString()就可以实现把StringBuilder转换为String\n\n\n# 4. 常用API\n\n\n# 4.1 Math\n\n * 1、Math类概述\n   \n   * Math 包含执行基本数字运算的方法\n\n * 2、Math中方法的调用方式\n   \n   * Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用\n\n * 3、Math类的常用方法\n   \n   方法名 方法名                                        说明\n   public static int abs(int a)                   返回参数的绝对值\n   public static double ceil(double a)            返回大于或等于参数的最小double值，等于一个整数\n   public static double floor(double a)           返回小于或等于参数的最大double值，等于一个整数\n   public static int round(float a)               按照四舍五入返回最接近参数的int\n   public static int max(int a,int b)             返回两个int值中的较大值\n   public static int min(int a,int b)             返回两个int值中的较小值\n   public static double pow (double a,double b)   返回a的b次幂的值\n   public static double random()                  返回值为double的正值，[0.0,1.0)\n\n\n# 4.2 System\n\n * System类的常用方法\n\n方法名                                      说明\npublic static void exit(int status)      终止当前运行的 Java 虚拟机，非零表示异常终止\npublic static long currentTimeMillis()   返回当前时间(以毫秒为单位)\n\n * 示例代码\n   \n   * 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒\n   \n   public class SystemDemo {\n       public static void main(String[] args) {\n           // 获取开始的时间节点\n           long start = System.currentTimeMillis();\n           for (int i = 1; i <= 10000; i++) {\n               System.out.println(i);\n           }\n           // 获取代码运行结束后的时间节点\n           long end = System.currentTimeMillis();\n           System.out.println("共耗时：" + (end - start) + "毫秒");\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 4.3 Object类的toString方法\n\n * Object类概述\n   \n   * Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份\n\n * 查看方法源码的方式\n   \n   * 选中方法，按下Ctrl + B\n\n * 重写toString方法的方式\n   \n   * 1. Alt + Insert 选择toString\n   * 2. 在类的空白区域，右键 -> Generate -> 选择toString\n\n * toString方法的作用：\n   \n   * 以良好的格式，更方便的展示对象中的属性值\n\n * 示例代码：\n   \n   class Student extends Object {\n       private String name;\n       private int age;\n   \n       public Student() {\n       }\n   \n       public Student(String name, int age) {\n           this.name = name;\n           this.age = age;\n       }\n   \n       public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public int getAge() {\n           return age;\n       }\n   \n       public void setAge(int age) {\n           this.age = age;\n       }\n   \n       @Override\n       public String toString() {\n           return "Student{" +\n                   "name=\'" + name + \'\\\'\' +\n                   ", age=" + age +\n                   \'}\';\n       }\n   }\n   public class ObjectDemo {\n       public static void main(String[] args) {\n           Student s = new Student();\n           s.setName("林青霞");\n           s.setAge(30);\n           System.out.println(s); \n           System.out.println(s.toString()); \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   \n\n * 运行结果：\n   \n   Student{name=\'林青霞\', age=30}\n   Student{name=\'林青霞\', age=30}\n   \n   \n   1\n   2\n   \n\n\n# 4.4 Object类的equals方法\n\n * equals方法的作用\n   \n   * 用于对象之间的比较，返回true和false的结果\n   * 举例：s1.equals(s2); s1和s2是两个对象\n\n * 重写equals方法的场景\n   \n   * 不希望比较对象的地址值，想要结合对象属性进行比较的时候。\n\n * 重写equals方法的方式\n   \n   * 1. alt + insert 选择equals() and hashCode()，IntelliJ Default，一路next，finish即可\n   * 2. 在类的空白区域，右键 -> Generate -> 选择equals() and hashCode()，后面的同上。\n\n * 示例代码：\n   \n   class Student {\n       private String name;\n       private int age;\n   \n       public Student() {\n       }\n   \n       public Student(String name, int age) {\n           this.name = name;\n           this.age = age;\n       }\n   \n       public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public int getAge() {\n           return age;\n       }\n   \n       public void setAge(int age) {\n           this.age = age;\n       }\n   \n       @Override\n       public boolean equals(Object o) {\n           //this -- s1\n           //o -- s2\n           if (this == o) return true;\n           if (o == null || getClass() != o.getClass()) return false;\n   \n           Student student = (Student) o; //student -- s2\n   \n           if (age != student.age) return false;\n           return name != null ? name.equals(student.name) : student.name == null;\n       }\n   }\n   public class ObjectDemo {\n       public static void main(String[] args) {\n           Student s1 = new Student();\n           s1.setName("林青霞");\n           s1.setAge(30);\n   \n           Student s2 = new Student();\n           s2.setName("林青霞");\n           s2.setAge(30);\n   \n           //需求：比较两个对象的内容是否相同\n           System.out.println(s1.equals(s2));\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   \n\n\n# 4.5 冒泡排序原理🚗\n\n * 冒泡排序概述\n   * 一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序\n * 如果有n个数据进行排序，总共需要比较n-1次\n * 每一次比较完毕，下一次的比较就会少一个数据参与\n\n\n# 4.6 冒泡排序代码实现\n\n * 代码实现\n\n/*\n    冒泡排序：\n        一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，\n        依次对所有的数据进行操作，直至所有数据按要求完成排序\n */\npublic class ArrayDemo {\n    public static void main(String[] args) {\n        //定义一个数组\n        int[] arr = {24, 69, 80, 57, 13};\n        System.out.println("排序前：" + arrayToString(arr));\n\n        // 这里减1，是控制每轮比较的次数\n        for (int x = 0; x < arr.length - 1; x++) {\n            // -1是为了避免索引越界，-x是为了调高比较效率\n            for (int i = 0; i < arr.length - 1 - x; i++) {\n                if (arr[i] > arr[i + 1]) {\n                    int temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                }\n            }\n        }\n        System.out.println("排序后：" + arrayToString(arr));\n\n    }\n\n    //把数组中的元素按照指定的规则组成一个字符串：[元素1, 元素2, ...]\n    public static String arrayToString(int[] arr) {\n        StringBuilder sb = new StringBuilder();\n        sb.append("[");\n        for (int i = 0; i < arr.length; i++) {\n            if (i == arr.length - 1) {\n                sb.append(arr[i]);\n            } else {\n                sb.append(arr[i]).append(", ");\n            }\n        }\n        sb.append("]");\n        String s = sb.toString();\n        return s;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4.7 Arrays\n\n * Arrays的常用方法\n   \n   方法名                                      说明\n   public static String toString(int[] a)   返回指定数组的内容的字符串表示形式\n   public static void sort(int[] a)         按照数字顺序排列指定的数组\n\n * 工具类设计思想\n   \n   1、构造方法用 private 修饰\n   \n   2、成员用 public static 修饰\n\n\n# 5.时间日期类\n\n\n# 5.1 Date类\n\n * Date类概述\n   \n   Date 代表了一个特定的时间，精确到毫秒\n\n * Date类构造方法\n   \n   方法名                      说明\n   public Date()            分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒\n   public Date(long date)   分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\n\n * 示例代码\n   \n   public class DateDemo01 {\n       public static void main(String[] args) {\n           //public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒\n           Date d1 = new Date();\n           System.out.println(d1);\n   \n           //public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\n           long date = 1000*60*60;\n           Date d2 = new Date(date);\n           System.out.println(d2);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 5.2 Date类常用方法\n\n * 常用方法\n   \n   方法名                              说明\n   public long getTime()            获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n   public void setTime(long time)   设置时间，给的是毫秒值\n\n * 示例代码\n   \n   public class DateDemo02 {\n       public static void main(String[] args) {\n           //创建日期对象\n           Date d = new Date();\n   \n           //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n   //        System.out.println(d.getTime());\n   //        System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + "年");\n   \n           //public void setTime(long time):设置时间，给的是毫秒值\n   //        long time = 1000*60*60;\n           long time = System.currentTimeMillis();\n           d.setTime(time);\n   \n           System.out.println(d);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n\n# 5.3 SimpleDateFormat类\n\n * SimpleDateFormat类概述\n   \n   SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。\n   \n   我们重点学习日期格式化和解析\n\n * SimpleDateFormat类构造方法\n   \n   方法名                                       说明\n   public SimpleDateFormat()                 构造一个SimpleDateFormat，使用默认模式和日期格式\n   public SimpleDateFormat(String pattern)   构造一个SimpleDateFormat使用给定的模式和默认的日期格式\n\n * SimpleDateFormat类的常用方法\n   \n   * 格式化(从Date到String)\n     * public final String format(Date date)：将日期格式化成日期/时间字符串\n   * 解析(从String到Date)\n     * public Date parse(String source)：从给定字符串的开始解析文本以生成日期\n\n * 示例代码\n   \n   public class SimpleDateFormatDemo {\n       public static void main(String[] args) throws ParseException {\n           //格式化：从 Date 到 String\n           Date d = new Date();\n   //        SimpleDateFormat sdf = new SimpleDateFormat();\n           SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");\n           String s = sdf.format(d);\n           System.out.println(s);\n           System.out.println("--------");\n   \n           //从 String 到 Date\n           String ss = "2048-08-09 11:11:11";\n           //ParseException\n           SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n           Date dd = sdf2.parse(ss);\n           System.out.println(dd);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 5.4 日期工具类案例\n\n * 案例需求\n   \n   定义一个日期工具类(DateUtils)，包含两个方法：把日期转换为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类(DateDemo)，测试日期工具类的方法\n\n * 代码实现\n   \n   * 工具类\n   \n   public class DateUtils {\n       private DateUtils() {}\n   \n       /*\n           把日期转为指定格式的字符串\n           返回值类型：String\n           参数：Date date, String format\n        */\n       public static String dateToString(Date date, String format) {\n           SimpleDateFormat sdf = new SimpleDateFormat(format);\n           String s = sdf.format(date);\n           return s;\n       }\n   \n   \n       /*\n           把字符串解析为指定格式的日期\n           返回值类型：Date\n           参数：String s, String format\n        */\n       public static Date stringToDate(String s, String format) throws ParseException {\n           SimpleDateFormat sdf = new SimpleDateFormat(format);\n           Date d = sdf.parse(s);\n           return d;\n       }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   \n   * 测试类\n   \n   public class DateDemo {\n       public static void main(String[] args) throws ParseException {\n           //创建日期对象\n           Date d = new Date();\n   \n           String s1 = DateUtils.dateToString(d, "yyyy年MM月dd日 HH:mm:ss");\n           System.out.println(s1);\n   \n           String s2 = DateUtils.dateToString(d, "yyyy年MM月dd日");\n           System.out.println(s2);\n   \n           String s3 = DateUtils.dateToString(d, "HH:mm:ss");\n           System.out.println(s3);\n           System.out.println("--------");\n   \n           String s = "2048-08-09 12:12:12";\n           Date dd = DateUtils.stringToDate(s, "yyyy-MM-dd HH:mm:ss");\n           System.out.println(dd);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 5.5 Calendar类\n\n * Calendar类概述\n   \n   Calendar 为特定瞬间与一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法\n   \n   Calendar 提供了一个类方法 getInstance 用于获取这种类型的一般有用的对象。\n   \n   该方法返回一个Calendar 对象。\n   \n   其日历字段已使用当前日期和时间初始化：Calendar rightNow = Calendar.getInstance();\n\n * Calendar类常用方法\n   \n   方法名                                                  说明\n   public int get(int field)                            返回给定日历字段的值\n   public abstract void add(int field, int amount)      根据日历的规则，将指定的时间量添加或减去给定的日历字段\n   public final void set(int year,int month,int date)   设置当前日历的年月日\n\n * 示例代码\n   \n   public class CalendarDemo {\n       public static void main(String[] args) {\n           //获取日历类对象\n           Calendar c = Calendar.getInstance();\n   \n           //public int get(int field):返回给定日历字段的值\n           int year = c.get(Calendar.YEAR);\n           int month = c.get(Calendar.MONTH) + 1;\n           int date = c.get(Calendar.DATE);\n           System.out.println(year + "年" + month + "月" + date + "日");\n   \n           //public abstract void add(int field, int amount):根据日历的规则，将指定的时间量添加或减去给定的日历字段\n           //需求1:3年前的今天\n   //        c.add(Calendar.YEAR,-3);\n   //        year = c.get(Calendar.YEAR);\n   //        month = c.get(Calendar.MONTH) + 1;\n   //        date = c.get(Calendar.DATE);\n   //        System.out.println(year + "年" + month + "月" + date + "日");\n   \n           //需求2:10年后的10天前\n   //        c.add(Calendar.YEAR,10);\n   //        c.add(Calendar.DATE,-10);\n   //        year = c.get(Calendar.YEAR);\n   //        month = c.get(Calendar.MONTH) + 1;\n   //        date = c.get(Calendar.DATE);\n   //        System.out.println(year + "年" + month + "月" + date + "日");\n   \n           //public final void set(int year,int month,int date):设置当前日历的年月日\n           c.set(2050,10,10);\n           year = c.get(Calendar.YEAR);\n           month = c.get(Calendar.MONTH) + 1;\n           date = c.get(Calendar.DATE);\n           System.out.println(year + "年" + month + "月" + date + "日");\n   \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   \n\n\n# 5.6 二月天案例\n\n * 案例需求\n   \n   获取任意一年的二月有多少天\n\n * 代码实现\n   \n   public class CalendarTest {\n       public static void main(String[] args) {\n           //键盘录入任意的年份\n           Scanner sc = new Scanner(System.in);\n           System.out.println("请输入年：");\n           int year = sc.nextInt();\n   \n           //设置日历对象的年、月、日\n           Calendar c = Calendar.getInstance();\n           c.set(year, 2, 1);\n   \n           //3月1日往前推一天，就是2月的最后一天\n           c.add(Calendar.DATE, -1);\n   \n           //获取这一天输出即可\n           int date = c.get(Calendar.DATE);\n           System.out.println(year + "年的2月份有" + date + "天");\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   ',normalizedContent:'# 常用api\n\n\n# 1. api\n\n\n# 1.1 api概述\n\n * 什么是api\n   \n   api (application programming interface) ：应用程序编程接口\n\n * java中的api\n   \n   指的就是 jdk 中提供的各种功能的 java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些api如何使用。\n\n\n# 1.2 如何使用api帮助文档\n\n * 打开帮助文档\n\n\n\n * 找到索引选项卡中的输入框\n\n\n\n * 在输入框中输入random\n\n\n\n * 看类在哪个包下\n\n\n\n * 看类的描述\n\n\n\n * 看构造方法\n\n\n\n * 看成员方法\n\n\n\n\n# 2. string类\n\n\n# 2.1 string类概述\n\nstring 类代表字符串，java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，java 程序中所有的双引号字符串，都是 string 类的对象。string 类在 java.lang 包下，所以使用的时候不需要导包！\n\n\n# 2.2 string类的特点\n\n * 字符串不可变，它们的值在创建后不能被更改\n * 虽然 string 的值是不可变的，但是它们可以被共享\n * 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )\n\n\n# 2.3 string类的构造方法\n\n * 常用的构造方法\n   \n   方法名                         说明\n   public string()             创建一个空白字符串对象，不含有任何内容\n   public string(char[] chs)   根据字符数组的内容，来创建字符串对象\n   public string(byte[] bys)   根据字节数组的内容，来创建字符串对象\n   string s = “abc”;           直接赋值的方式创建字符串对象，内容就是abc\n\n * 示例代码\n   \n   public class stringdemo01 {\n       public static void main(string[] args) {\n           //public string()：创建一个空白字符串对象，不含有任何内容\n           string s1 = new string();\n           system.out.println("s1:" + s1);\n   \n           //public string(char[] chs)：根据字符数组的内容，来创建字符串对象\n           char[] chs = {\'a\', \'b\', \'c\'};\n           string s2 = new string(chs);\n           system.out.println("s2:" + s2);\n   \n           //public string(byte[] bys)：根据字节数组的内容，来创建字符串对象\n           byte[] bys = {97, 98, 99};\n           string s3 = new string(bys);\n           system.out.println("s3:" + s3);\n   \n           //string s = “abc”;\t直接赋值的方式创建字符串对象，内容就是abc\n           string s4 = "abc";\n           system.out.println("s4:" + s4);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 2.4 创建字符串对象两种方式的区别\n\n * 通过构造方法创建\n   \n   通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同\n\n * 直接赋值方式创建\n   \n   以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，jvm 都只会建立一个 string 对象，并在字符串池中维护\n\n\n# 2.5 字符串的比较\n\n# 1. ==号的作用\n\n * 比较基本数据类型：比较的是具体的值\n * 比较引用数据类型：比较的是对象地址值\n\n# 2. equals方法的作用\n\n * 方法介绍\n   \n   public boolean equals(string s)     比较两个字符串内容是否相同、区分大小写\n   \n   \n   1\n   \n\n * 示例代码\n   \n   public class stringdemo02 {\n       public static void main(string[] args) {\n           //构造方法的方式得到对象\n           char[] chs = {\'a\', \'b\', \'c\'};\n           string s1 = new string(chs);\n           string s2 = new string(chs);\n   \n           //直接赋值的方式得到对象\n           string s3 = "abc";\n           string s4 = "abc";\n   \n           //比较字符串对象地址是否相同\n           system.out.println(s1 == s2);\n           system.out.println(s1 == s3);\n           system.out.println(s3 == s4);\n           system.out.println("--------");\n   \n           //比较字符串内容是否相同\n           system.out.println(s1.equals(s2));\n           system.out.println(s1.equals(s3));\n           system.out.println(s3.equals(s4));\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   \n\n\n# 2.6 用户登录案例\n\n# 1. 案例需求\n\n已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:已知用户名和密码，定义两个字符串表示即可\n        2:键盘录入要登录的用户名和密码，用 scanner 实现\n        3:拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现\n        4:用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环\n */\npublic class stringtest01 {\n    public static void main(string[] args) {\n        //已知用户名和密码，定义两个字符串表示即可\n        string username = "itheima";\n        string password = "czbk";\n\n        //用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环\n        for(int i=0; i<3; i++) {\n\n            //键盘录入要登录的用户名和密码，用 scanner 实现\n            scanner sc = new scanner(system.in);\n\n            system.out.println("请输入用户名：");\n            string name = sc.nextline();\n\n            system.out.println("请输入密码：");\n            string pwd = sc.nextline();\n\n            //拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现\n            if (name.equals(username) && pwd.equals(password)) {\n                system.out.println("登录成功");\n                break;\n            } else {\n                if(2-i == 0) {\n                    system.out.println("你的账户被锁定，请与管理员联系");\n                } else {\n                    //2,1,0\n                    //i,0,1,2\n                    system.out.println("登录失败，你还有" + (2 - i) + "次机会");\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 2.7 遍历字符串案例\n\n# 1. 案例需求\n\n键盘录入一个字符串，使用程序实现在控制台遍历该字符串\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:键盘录入一个字符串，用 scanner 实现\n        2:遍历字符串，首先要能够获取到字符串中的每一个字符\n            public char charat(int index)：返回指定索引处的char值，字符串的索引也是从0开始的\n        3:遍历字符串，其次要能够获取到字符串的长度\n            public int length()：返回此字符串的长度\n            数组的长度：数组名.length\n            字符串的长度：字符串对象.length()\n        4:遍历字符串的通用格式\n */\npublic class stringtest02 {\n    public static void main(string[] args) {\n        //键盘录入一个字符串，用 scanner 实现\n        scanner sc = new scanner(system.in);\n\n        system.out.println("请输入一个字符串：");\n        string line = sc.nextline();\n\n        for(int i=0; i<line.length(); i++) {\n            system.out.println(line.charat(i));\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.8 统计字符次数案例\n\n# 1. 案例需求\n\n键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)\n\n# 2. 代码实现\n\n/*\n  思路：\n        1:键盘录入一个字符串，用 scanner 实现\n        2:要统计三种类型的字符个数，需定义三个统计变量，初始值都为0\n        3:遍历字符串，得到每一个字符\n        4:判断该字符属于哪种类型，然后对应类型的统计变量+1\n            假如ch是一个字符，我要判断它属于大写字母，小写字母，还是数字，直接判断该字符是否在对应的范围即可\n            大写字母：ch>=\'a\' && ch<=\'z\'\n            小写字母： ch>=\'a\' && ch<=\'z\'\n            数字： ch>=\'0\' && ch<=\'9\'\n        5:输出三种类型的字符个数\n */\npublic class stringtest03 {\n    public static void main(string[] args) {\n        //键盘录入一个字符串，用 scanner 实现\n        scanner sc = new scanner(system.in);\n\n        system.out.println("请输入一个字符串：");\n        string line = sc.nextline();\n\n        //要统计三种类型的字符个数，需定义三个统计变量，初始值都为0\n        int bigcount = 0;\n        int smallcount = 0;\n        int numbercount = 0;\n\n        //遍历字符串，得到每一个字符\n        for(int i=0; i<line.length(); i++) {\n            char ch = line.charat(i);\n\n            //判断该字符属于哪种类型，然后对应类型的统计变量+1\n            if(ch>=\'a\' && ch<=\'z\') {\n                bigcount++;\n            } else if(ch>=\'a\' && ch<=\'z\') {\n                smallcount++;\n            } else if(ch>=\'0\' && ch<=\'9\') {\n                numbercount++;\n            }\n        }\n\n        //输出三种类型的字符个数\n        system.out.println("大写字母：" + bigcount + "个");\n        system.out.println("小写字母：" + smallcount + "个");\n        system.out.println("数字：" + numbercount + "个");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 2.9 字符串拼接案例\n\n# 1. 案例需求\n\n定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\n\n并在控制台输出结果。例如，数组为 int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\n          返回值类型 string，参数列表 int[] arr\n        3:在方法中遍历数组，按照要求进行拼接\n        4:调用方法，用一个变量接收结果\n        5:输出结果\n */\npublic class stringtest04 {\n    public static void main(string[] args) {\n        //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        int[] arr = {1, 2, 3};\n\n        //调用方法，用一个变量接收结果\n        string s = arraytostring(arr);\n\n        //输出结果\n        system.out.println("s:" + s);\n    }\n\n    //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回\n    /*\n        两个明确：\n            返回值类型：string\n            参数：int[] arr\n     */\n    public static string arraytostring(int[] arr) {\n        //在方法中遍历数组，按照要求进行拼接\n        string s = "";\n\n        s += "[";\n\n        for(int i=0; i<arr.length; i++) {\n            if(i==arr.length-1) {\n                s += arr[i];\n            } else {\n                s += arr[i];\n                s += ", ";\n            }\n        }\n\n        s += "]";\n\n        return s;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 2.10 字符串反转案例\n\n# 1. 案例需求\n\n定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果\n\n例如，键盘录入 abc，输出结果 cba\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:键盘录入一个字符串，用 scanner 实现\n        2:定义一个方法，实现字符串反转。返回值类型 string，参数 string s\n        3:在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回\n        4:调用方法，用一个变量接收结果\n        5:输出结果\n */\npublic class stringtest05 {\n    public static void main(string[] args) {\n        //键盘录入一个字符串，用 scanner 实现\n        scanner sc = new scanner(system.in);\n\n        system.out.println("请输入一个字符串：");\n        string line = sc.nextline();\n\n        //调用方法，用一个变量接收结果\n        string s = reverse(line);\n\n        //输出结果\n        system.out.println("s:" + s);\n    }\n\n    //定义一个方法，实现字符串反转\n    /*\n        两个明确：\n            返回值类型：string\n            参数：string s\n     */\n    public static string reverse(string s) {\n        //在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回\n        string ss = "";\n\n        for(int i=s.length()-1; i>=0; i--) {\n            ss += s.charat(i);\n        }\n\n        return ss;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 2.11 帮助文档查看string常用方法\n\n方法名                                      说明\npublic boolean equals(object anobject)   比较字符串的内容，严格区分大小写(用户名和密码)\npublic char charat(int index)            返回指定索引处的 char 值\npublic int length()                      返回此字符串的长度\n\n\n# 3. stringbuilder类\n\n\n# 3.1 stringbuilder类概述\n\nstringbuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 stringbuilder 对象中的内容是可变的\n\n\n# 3.2 stringbuilder类和string类的区别\n\n * string类：内容是不可变的\n * stringbuilder类：内容是可变的\n\n\n# 3.3 stringbuilder类的构造方法\n\n * 常用的构造方法\n   \n   方法名                                说明\n   public stringbuilder()             创建一个空白可变字符串对象，不含有任何内容\n   public stringbuilder(string str)   根据字符串的内容，来创建可变字符串对象\n\n * 示例代码\n\npublic class stringbuilderdemo01 {\n    public static void main(string[] args) {\n        //public stringbuilder()：创建一个空白可变字符串对象，不含有任何内容\n        stringbuilder sb = new stringbuilder();\n        system.out.println("sb:" + sb);\n        system.out.println("sb.length():" + sb.length());\n\n        //public stringbuilder(string str)：根据字符串的内容，来创建可变字符串对象\n        stringbuilder sb2 = new stringbuilder("hello");\n        system.out.println("sb2:" + sb2);\n        system.out.println("sb2.length():" + sb2.length());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.4 stringbuilder类添加和反转方法\n\n * 添加和反转方法\n   \n   方法名                                 说明\n   public stringbuilder append(任意类型)   添加数据，并返回对象本身\n   public stringbuilder reverse()      返回相反的字符序列\n\n * 示例代码\n\npublic class stringbuilderdemo01 {\n    public static void main(string[] args) {\n        //创建对象\n        stringbuilder sb = new stringbuilder();\n\n        //public stringbuilder append(任意类型)：添加数据，并返回对象本身\n//        stringbuilder sb2 = sb.append("hello");\n//\n//        system.out.println("sb:" + sb);\n//        system.out.println("sb2:" + sb2);\n//        system.out.println(sb == sb2);\n\n//        sb.append("hello");\n//        sb.append("world");\n//        sb.append("java");\n//        sb.append(100);\n\n        //链式编程\n        sb.append("hello").append("world").append("java").append(100);\n\n        system.out.println("sb:" + sb);\n\n        //public stringbuilder reverse()：返回相反的字符序列\n        sb.reverse();\n        system.out.println("sb:" + sb);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3.5 stringbuilder和string相互转换\n\n * stringbuilder转换为string\n   \n   public string tostring()：通过 tostring() 就可以实现把 stringbuilder 转换为 string\n\n * string转换为stringbuilder\n   \n   public stringbuilder(string s)：通过构造方法就可以实现把 string 转换为 stringbuilder\n\n * 示例代码\n\npublic class stringbuilderdemo02 {\n    public static void main(string[] args) {\n        /*\n        //stringbuilder 转换为 string\n        stringbuilder sb = new stringbuilder();\n        sb.append("hello");\n\n        //string s = sb; //这个是错误的做法\n\n        //public string tostring()：通过 tostring() 就可以实现把 stringbuilder 转换为 string\n        string s = sb.tostring();\n        system.out.println(s);\n        */\n\n        //string 转换为 stringbuilder\n        string s = "hello";\n\n        //stringbuilder sb = s; //这个是错误的做法\n\n        //public stringbuilder(string s)：通过构造方法就可以实现把 string 转换为 stringbuilder\n        stringbuilder sb = new stringbuilder(s);\n\n        system.out.println(sb);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 3.6 字符串拼接升级版案例\n\n# 1. 案例需求\n\n定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\n\n并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\n          返回值类型 string，参数列表 int[] arr\n        3:在方法中用 stringbuilder 按照要求进行拼接，并把结果转成 string 返回\n        4:调用方法，用一个变量接收结果\n        5:输出结果\n */\npublic class stringbuildertest01 {\n    public static void main(string[] args) {\n        //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        int[] arr = {1, 2, 3};\n        //调用方法，用一个变量接收结果\n        string s = arraytostring(arr);\n        //输出结果\n        system.out.println("s:" + s);\n    }\n\n    //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回\n    /*\n        两个明确：\n            返回值类型：string\n            参数：int[] arr\n     */\n    public static string arraytostring(int[] arr) {\n        //在方法中用 stringbuilder 按照要求进行拼接，并把结果转成 string 返回\n        stringbuilder sb = new stringbuilder();\n        sb.append("[");\n        for(int i=0; i<arr.length; i++) {\n            if(i == arr.length-1) {\n                sb.append(arr[i]);\n            } else {\n                sb.append(arr[i]).append(", ");\n            }\n        }\n        sb.append("]");\n        string s = sb.tostring();\n        return  s;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 3.7 字符串反转升级版案例\n\n# 1. 案例需求\n\n定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果\n\n例如，键盘录入abc，输出结果 cba\n\n# 2. 代码实现\n\n/*\n    思路：\n        1:键盘录入一个字符串，用 scanner 实现\n        2:定义一个方法，实现字符串反转。返回值类型 string，参数 string s\n        3:在方法中用stringbuilder实现字符串的反转，并把结果转成string返回\n        4:调用方法，用一个变量接收结果\n        5:输出结果\n */\npublic class stringbuildertest02 {\n    public static void main(string[] args) {\n        //键盘录入一个字符串，用 scanner 实现\n        scanner sc = new scanner(system.in);\n\n        system.out.println("请输入一个字符串：");\n        string line = sc.nextline();\n\n        //调用方法，用一个变量接收结果\n        string s = myreverse(line);\n\n        //输出结果\n        system.out.println("s:" + s);\n    }\n\n    //定义一个方法，实现字符串反转。返回值类型 string，参数 string s\n    /*\n        两个明确：\n            返回值类型：string\n            参数：string s\n     */\n    public static string myreverse(string s) {\n        //在方法中用stringbuilder实现字符串的反转，并把结果转成string返回\n        //string --- stringbuilder --- reverse() --- string\n//        stringbuilder sb = new stringbuilder(s);\n//        sb.reverse();\n//        string ss = sb.tostring();\n//        return ss;\n\n       return new stringbuilder(s).reverse().tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 3.8 帮助文档查看stringbuilder常用方法\n\n方法名                                  说明\npublic stringbuilder append (任意类型)   添加数据，并返回对象本身\npublic stringbuilder reverse()       返回相反的字符序列\npublic int length()                  返回长度，实际存储值\npublic string tostring()             通过tostring()就可以实现把stringbuilder转换为string\n\n\n# 4. 常用api\n\n\n# 4.1 math\n\n * 1、math类概述\n   \n   * math 包含执行基本数字运算的方法\n\n * 2、math中方法的调用方式\n   \n   * math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用\n\n * 3、math类的常用方法\n   \n   方法名 方法名                                        说明\n   public static int abs(int a)                   返回参数的绝对值\n   public static double ceil(double a)            返回大于或等于参数的最小double值，等于一个整数\n   public static double floor(double a)           返回小于或等于参数的最大double值，等于一个整数\n   public static int round(float a)               按照四舍五入返回最接近参数的int\n   public static int max(int a,int b)             返回两个int值中的较大值\n   public static int min(int a,int b)             返回两个int值中的较小值\n   public static double pow (double a,double b)   返回a的b次幂的值\n   public static double random()                  返回值为double的正值，[0.0,1.0)\n\n\n# 4.2 system\n\n * system类的常用方法\n\n方法名                                      说明\npublic static void exit(int status)      终止当前运行的 java 虚拟机，非零表示异常终止\npublic static long currenttimemillis()   返回当前时间(以毫秒为单位)\n\n * 示例代码\n   \n   * 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒\n   \n   public class systemdemo {\n       public static void main(string[] args) {\n           // 获取开始的时间节点\n           long start = system.currenttimemillis();\n           for (int i = 1; i <= 10000; i++) {\n               system.out.println(i);\n           }\n           // 获取代码运行结束后的时间节点\n           long end = system.currenttimemillis();\n           system.out.println("共耗时：" + (end - start) + "毫秒");\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 4.3 object类的tostring方法\n\n * object类概述\n   \n   * object 是类层次结构的根，每个类都可以将 object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份\n\n * 查看方法源码的方式\n   \n   * 选中方法，按下ctrl + b\n\n * 重写tostring方法的方式\n   \n   * 1. alt + insert 选择tostring\n   * 2. 在类的空白区域，右键 -> generate -> 选择tostring\n\n * tostring方法的作用：\n   \n   * 以良好的格式，更方便的展示对象中的属性值\n\n * 示例代码：\n   \n   class student extends object {\n       private string name;\n       private int age;\n   \n       public student() {\n       }\n   \n       public student(string name, int age) {\n           this.name = name;\n           this.age = age;\n       }\n   \n       public string getname() {\n           return name;\n       }\n   \n       public void setname(string name) {\n           this.name = name;\n       }\n   \n       public int getage() {\n           return age;\n       }\n   \n       public void setage(int age) {\n           this.age = age;\n       }\n   \n       @override\n       public string tostring() {\n           return "student{" +\n                   "name=\'" + name + \'\\\'\' +\n                   ", age=" + age +\n                   \'}\';\n       }\n   }\n   public class objectdemo {\n       public static void main(string[] args) {\n           student s = new student();\n           s.setname("林青霞");\n           s.setage(30);\n           system.out.println(s); \n           system.out.println(s.tostring()); \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   \n\n * 运行结果：\n   \n   student{name=\'林青霞\', age=30}\n   student{name=\'林青霞\', age=30}\n   \n   \n   1\n   2\n   \n\n\n# 4.4 object类的equals方法\n\n * equals方法的作用\n   \n   * 用于对象之间的比较，返回true和false的结果\n   * 举例：s1.equals(s2); s1和s2是两个对象\n\n * 重写equals方法的场景\n   \n   * 不希望比较对象的地址值，想要结合对象属性进行比较的时候。\n\n * 重写equals方法的方式\n   \n   * 1. alt + insert 选择equals() and hashcode()，intellij default，一路next，finish即可\n   * 2. 在类的空白区域，右键 -> generate -> 选择equals() and hashcode()，后面的同上。\n\n * 示例代码：\n   \n   class student {\n       private string name;\n       private int age;\n   \n       public student() {\n       }\n   \n       public student(string name, int age) {\n           this.name = name;\n           this.age = age;\n       }\n   \n       public string getname() {\n           return name;\n       }\n   \n       public void setname(string name) {\n           this.name = name;\n       }\n   \n       public int getage() {\n           return age;\n       }\n   \n       public void setage(int age) {\n           this.age = age;\n       }\n   \n       @override\n       public boolean equals(object o) {\n           //this -- s1\n           //o -- s2\n           if (this == o) return true;\n           if (o == null || getclass() != o.getclass()) return false;\n   \n           student student = (student) o; //student -- s2\n   \n           if (age != student.age) return false;\n           return name != null ? name.equals(student.name) : student.name == null;\n       }\n   }\n   public class objectdemo {\n       public static void main(string[] args) {\n           student s1 = new student();\n           s1.setname("林青霞");\n           s1.setage(30);\n   \n           student s2 = new student();\n           s2.setname("林青霞");\n           s2.setage(30);\n   \n           //需求：比较两个对象的内容是否相同\n           system.out.println(s1.equals(s2));\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   \n\n\n# 4.5 冒泡排序原理🚗\n\n * 冒泡排序概述\n   * 一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序\n * 如果有n个数据进行排序，总共需要比较n-1次\n * 每一次比较完毕，下一次的比较就会少一个数据参与\n\n\n# 4.6 冒泡排序代码实现\n\n * 代码实现\n\n/*\n    冒泡排序：\n        一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，\n        依次对所有的数据进行操作，直至所有数据按要求完成排序\n */\npublic class arraydemo {\n    public static void main(string[] args) {\n        //定义一个数组\n        int[] arr = {24, 69, 80, 57, 13};\n        system.out.println("排序前：" + arraytostring(arr));\n\n        // 这里减1，是控制每轮比较的次数\n        for (int x = 0; x < arr.length - 1; x++) {\n            // -1是为了避免索引越界，-x是为了调高比较效率\n            for (int i = 0; i < arr.length - 1 - x; i++) {\n                if (arr[i] > arr[i + 1]) {\n                    int temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                }\n            }\n        }\n        system.out.println("排序后：" + arraytostring(arr));\n\n    }\n\n    //把数组中的元素按照指定的规则组成一个字符串：[元素1, 元素2, ...]\n    public static string arraytostring(int[] arr) {\n        stringbuilder sb = new stringbuilder();\n        sb.append("[");\n        for (int i = 0; i < arr.length; i++) {\n            if (i == arr.length - 1) {\n                sb.append(arr[i]);\n            } else {\n                sb.append(arr[i]).append(", ");\n            }\n        }\n        sb.append("]");\n        string s = sb.tostring();\n        return s;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4.7 arrays\n\n * arrays的常用方法\n   \n   方法名                                      说明\n   public static string tostring(int[] a)   返回指定数组的内容的字符串表示形式\n   public static void sort(int[] a)         按照数字顺序排列指定的数组\n\n * 工具类设计思想\n   \n   1、构造方法用 private 修饰\n   \n   2、成员用 public static 修饰\n\n\n# 5.时间日期类\n\n\n# 5.1 date类\n\n * date类概述\n   \n   date 代表了一个特定的时间，精确到毫秒\n\n * date类构造方法\n   \n   方法名                      说明\n   public date()            分配一个 date对象，并初始化，以便它代表它被分配的时间，精确到毫秒\n   public date(long date)   分配一个 date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\n\n * 示例代码\n   \n   public class datedemo01 {\n       public static void main(string[] args) {\n           //public date()：分配一个 date对象，并初始化，以便它代表它被分配的时间，精确到毫秒\n           date d1 = new date();\n           system.out.println(d1);\n   \n           //public date(long date)：分配一个 date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\n           long date = 1000*60*60;\n           date d2 = new date(date);\n           system.out.println(d2);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 5.2 date类常用方法\n\n * 常用方法\n   \n   方法名                              说明\n   public long gettime()            获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n   public void settime(long time)   设置时间，给的是毫秒值\n\n * 示例代码\n   \n   public class datedemo02 {\n       public static void main(string[] args) {\n           //创建日期对象\n           date d = new date();\n   \n           //public long gettime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n   //        system.out.println(d.gettime());\n   //        system.out.println(d.gettime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + "年");\n   \n           //public void settime(long time):设置时间，给的是毫秒值\n   //        long time = 1000*60*60;\n           long time = system.currenttimemillis();\n           d.settime(time);\n   \n           system.out.println(d);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n\n# 5.3 simpledateformat类\n\n * simpledateformat类概述\n   \n   simpledateformat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。\n   \n   我们重点学习日期格式化和解析\n\n * simpledateformat类构造方法\n   \n   方法名                                       说明\n   public simpledateformat()                 构造一个simpledateformat，使用默认模式和日期格式\n   public simpledateformat(string pattern)   构造一个simpledateformat使用给定的模式和默认的日期格式\n\n * simpledateformat类的常用方法\n   \n   * 格式化(从date到string)\n     * public final string format(date date)：将日期格式化成日期/时间字符串\n   * 解析(从string到date)\n     * public date parse(string source)：从给定字符串的开始解析文本以生成日期\n\n * 示例代码\n   \n   public class simpledateformatdemo {\n       public static void main(string[] args) throws parseexception {\n           //格式化：从 date 到 string\n           date d = new date();\n   //        simpledateformat sdf = new simpledateformat();\n           simpledateformat sdf = new simpledateformat("yyyy年mm月dd日 hh:mm:ss");\n           string s = sdf.format(d);\n           system.out.println(s);\n           system.out.println("--------");\n   \n           //从 string 到 date\n           string ss = "2048-08-09 11:11:11";\n           //parseexception\n           simpledateformat sdf2 = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n           date dd = sdf2.parse(ss);\n           system.out.println(dd);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 5.4 日期工具类案例\n\n * 案例需求\n   \n   定义一个日期工具类(dateutils)，包含两个方法：把日期转换为指定格式的字符串；把字符串解析为指定格式的日期，然后定义一个测试类(datedemo)，测试日期工具类的方法\n\n * 代码实现\n   \n   * 工具类\n   \n   public class dateutils {\n       private dateutils() {}\n   \n       /*\n           把日期转为指定格式的字符串\n           返回值类型：string\n           参数：date date, string format\n        */\n       public static string datetostring(date date, string format) {\n           simpledateformat sdf = new simpledateformat(format);\n           string s = sdf.format(date);\n           return s;\n       }\n   \n   \n       /*\n           把字符串解析为指定格式的日期\n           返回值类型：date\n           参数：string s, string format\n        */\n       public static date stringtodate(string s, string format) throws parseexception {\n           simpledateformat sdf = new simpledateformat(format);\n           date d = sdf.parse(s);\n           return d;\n       }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   \n   * 测试类\n   \n   public class datedemo {\n       public static void main(string[] args) throws parseexception {\n           //创建日期对象\n           date d = new date();\n   \n           string s1 = dateutils.datetostring(d, "yyyy年mm月dd日 hh:mm:ss");\n           system.out.println(s1);\n   \n           string s2 = dateutils.datetostring(d, "yyyy年mm月dd日");\n           system.out.println(s2);\n   \n           string s3 = dateutils.datetostring(d, "hh:mm:ss");\n           system.out.println(s3);\n           system.out.println("--------");\n   \n           string s = "2048-08-09 12:12:12";\n           date dd = dateutils.stringtodate(s, "yyyy-mm-dd hh:mm:ss");\n           system.out.println(dd);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 5.5 calendar类\n\n * calendar类概述\n   \n   calendar 为特定瞬间与一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法\n   \n   calendar 提供了一个类方法 getinstance 用于获取这种类型的一般有用的对象。\n   \n   该方法返回一个calendar 对象。\n   \n   其日历字段已使用当前日期和时间初始化：calendar rightnow = calendar.getinstance();\n\n * calendar类常用方法\n   \n   方法名                                                  说明\n   public int get(int field)                            返回给定日历字段的值\n   public abstract void add(int field, int amount)      根据日历的规则，将指定的时间量添加或减去给定的日历字段\n   public final void set(int year,int month,int date)   设置当前日历的年月日\n\n * 示例代码\n   \n   public class calendardemo {\n       public static void main(string[] args) {\n           //获取日历类对象\n           calendar c = calendar.getinstance();\n   \n           //public int get(int field):返回给定日历字段的值\n           int year = c.get(calendar.year);\n           int month = c.get(calendar.month) + 1;\n           int date = c.get(calendar.date);\n           system.out.println(year + "年" + month + "月" + date + "日");\n   \n           //public abstract void add(int field, int amount):根据日历的规则，将指定的时间量添加或减去给定的日历字段\n           //需求1:3年前的今天\n   //        c.add(calendar.year,-3);\n   //        year = c.get(calendar.year);\n   //        month = c.get(calendar.month) + 1;\n   //        date = c.get(calendar.date);\n   //        system.out.println(year + "年" + month + "月" + date + "日");\n   \n           //需求2:10年后的10天前\n   //        c.add(calendar.year,10);\n   //        c.add(calendar.date,-10);\n   //        year = c.get(calendar.year);\n   //        month = c.get(calendar.month) + 1;\n   //        date = c.get(calendar.date);\n   //        system.out.println(year + "年" + month + "月" + date + "日");\n   \n           //public final void set(int year,int month,int date):设置当前日历的年月日\n           c.set(2050,10,10);\n           year = c.get(calendar.year);\n           month = c.get(calendar.month) + 1;\n           date = c.get(calendar.date);\n           system.out.println(year + "年" + month + "月" + date + "日");\n   \n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   \n\n\n# 5.6 二月天案例\n\n * 案例需求\n   \n   获取任意一年的二月有多少天\n\n * 代码实现\n   \n   public class calendartest {\n       public static void main(string[] args) {\n           //键盘录入任意的年份\n           scanner sc = new scanner(system.in);\n           system.out.println("请输入年：");\n           int year = sc.nextint();\n   \n           //设置日历对象的年、月、日\n           calendar c = calendar.getinstance();\n           c.set(year, 2, 1);\n   \n           //3月1日往前推一天，就是2月的最后一天\n           c.add(calendar.date, -1);\n   \n           //获取这一天输出即可\n           int date = c.get(calendar.date);\n           system.out.println(year + "年的2月份有" + date + "天");\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   ',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"反射",frontmatter:{title:"反射",date:"2023-02-28T10:49:18.000Z",permalink:"/pages/07d6bb/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/10.%E5%8F%8D%E5%B0%84.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/10.反射.md",key:"v-3ed4795a",path:"/pages/07d6bb/",headers:[{level:2,title:"1. 类加载器",slug:"_1-类加载器",normalizedTitle:"1. 类加载器",charIndex:9},{level:3,title:"1.1 类加载",slug:"_1-1-类加载",normalizedTitle:"1.1 类加载",charIndex:21},{level:3,title:"1.2 类加载器",slug:"_1-2-类加载器",normalizedTitle:"1.2 类加载器",charIndex:761},{level:4,title:"1. 类加载器的作用",slug:"_1-类加载器的作用",normalizedTitle:"1. 类加载器的作用",charIndex:773},{level:4,title:"2. JVM的类加载机制",slug:"_2-jvm的类加载机制",normalizedTitle:"2. jvm的类加载机制",charIndex:872},{level:4,title:"3. Java中的内置类加载器",slug:"_3-java中的内置类加载器",normalizedTitle:"3. java中的内置类加载器",charIndex:1177},{level:4,title:"4. ClassLoader中的两个方法",slug:"_4-classloader中的两个方法",normalizedTitle:"4. classloader中的两个方法",charIndex:1497},{level:2,title:"2. 反射",slug:"_2-反射",normalizedTitle:"2. 反射",charIndex:2183},{level:3,title:"2.1 反射的概述",slug:"_2-1-反射的概述",normalizedTitle:"2.1 反射的概述",charIndex:2193},{level:3,title:"2.2 Java反射主要类",slug:"_2-2-java反射主要类",normalizedTitle:"2.2 java反射主要类",charIndex:2733},{level:4,title:"1. Class",slug:"_1-class",normalizedTitle:"1. class",charIndex:2750},{level:4,title:"2. Field",slug:"_2-field",normalizedTitle:"2. field",charIndex:6135},{level:4,title:"3. Method",slug:"_3-method",normalizedTitle:"3. method",charIndex:6403},{level:4,title:"4. ClassLoader类",slug:"_4-classloader类",normalizedTitle:"4. classloader类",charIndex:6518},{level:3,title:"2.3 获取Class类对象的三种方式",slug:"_2-3-获取class类对象的三种方式",normalizedTitle:"2.3 获取class类对象的三种方式",charIndex:6659},{level:4,title:"1. 三种方式分类",slug:"_1-三种方式分类",normalizedTitle:"1. 三种方式分类",charIndex:6682},{level:4,title:"2. 示例",slug:"_2-示例",normalizedTitle:"2. 示例",charIndex:6821},{level:3,title:"2.4 反射获取构造方法并使用",slug:"_2-4-反射获取构造方法并使用",normalizedTitle:"2.4 反射获取构造方法并使用",charIndex:7625},{level:4,title:"1. Class类获取构造方法对象的方法",slug:"_1-class类获取构造方法对象的方法",normalizedTitle:"1. class类获取构造方法对象的方法",charIndex:7644},{level:4,title:"2. Constructor类用于创建对象的方法",slug:"_2-constructor类用于创建对象的方法",normalizedTitle:"2. constructor类用于创建对象的方法",charIndex:9365},{level:4,title:"3. 示例1",slug:"_3-示例1",normalizedTitle:"3. 示例1",charIndex:9481},{level:4,title:"4. 示例2",slug:"_4-示例2",normalizedTitle:"4. 示例2",charIndex:11555},{level:3,title:"2.5 反射获取成员变量并使用",slug:"_2-5-反射获取成员变量并使用",normalizedTitle:"2.5 反射获取成员变量并使用",charIndex:12559},{level:4,title:"1. Class类获取成员变量对象的方法",slug:"_1-class类获取成员变量对象的方法",normalizedTitle:"1. class类获取成员变量对象的方法",charIndex:12578},{level:4,title:"2. Field类用于给成员变量赋值的方法",slug:"_2-field类用于给成员变量赋值的方法",normalizedTitle:"2. field类用于给成员变量赋值的方法",charIndex:14385},{level:4,title:"3. 示例",slug:"_3-示例",normalizedTitle:"3. 示例",charIndex:9481},{level:3,title:"2.6 反射获取成员方法并使用",slug:"_2-6-反射获取成员方法并使用",normalizedTitle:"2.6 反射获取成员方法并使用",charIndex:15930},{level:4,title:"1. Class类获取成员方法对象的方法",slug:"_1-class类获取成员方法对象的方法",normalizedTitle:"1. class类获取成员方法对象的方法",charIndex:15949},{level:4,title:"2. Method类用于执行方法的方法",slug:"_2-method类用于执行方法的方法",normalizedTitle:"2. method类用于执行方法的方法",charIndex:18048},{level:4,title:"3. 示例",slug:"_3-示例-2",normalizedTitle:"3. 示例",charIndex:9481},{level:3,title:"2.7 反射的案例",slug:"_2-7-反射的案例",normalizedTitle:"2.7 反射的案例",charIndex:19639},{level:4,title:"1. 越过泛型检查",slug:"_1-越过泛型检查",normalizedTitle:"1. 越过泛型检查",charIndex:19652},{level:4,title:"2. 运行配置文件中指定类的指定方法",slug:"_2-运行配置文件中指定类的指定方法",normalizedTitle:"2. 运行配置文件中指定类的指定方法",charIndex:20547},{level:2,title:"3. 模块化",slug:"_3-模块化",normalizedTitle:"3. 模块化",charIndex:21787}],headersStr:"1. 类加载器 1.1 类加载 1.2 类加载器 1. 类加载器的作用 2. JVM的类加载机制 3. Java中的内置类加载器 4. ClassLoader中的两个方法 2. 反射 2.1 反射的概述 2.2 Java反射主要类 1. Class 2. Field 3. Method 4. ClassLoader类 2.3 获取Class类对象的三种方式 1. 三种方式分类 2. 示例 2.4 反射获取构造方法并使用 1. Class类获取构造方法对象的方法 2. Constructor类用于创建对象的方法 3. 示例1 4. 示例2 2.5 反射获取成员变量并使用 1. Class类获取成员变量对象的方法 2. Field类用于给成员变量赋值的方法 3. 示例 2.6 反射获取成员方法并使用 1. Class类获取成员方法对象的方法 2. Method类用于执行方法的方法 3. 示例 2.7 反射的案例 1. 越过泛型检查 2. 运行配置文件中指定类的指定方法 3. 模块化",content:'# 反射\n\n\n# 1. 类加载器\n\n\n# 1.1 类加载\n\n 1. 类加载的描述\n    \n    * 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始\n    * 化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把\n    * 这三个步骤统称为类加载或者类初始化\n\n 2. 类的加载\n    \n    * 就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象\n    * 任何类被使用时，系统都会为之建立一个 java.lang.Class 对象\n\n 3. 类的连接\n    \n    * 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致\n    * 准备阶段：负责为类的类变量分配内存，并设置默认初始化值\n    * 解析阶段：将类的二进制数据中的符号引用替换为直接引用\n\n 4. 类的初始化\n    \n    * 在该阶段，主要就是对类变量进行初始化\n\n 5. 类的初始化步骤\n    \n    * 假如类还未被加载和连接，则程序先加载并连接该类\n    * 假如该类的直接父类还未被初始化，则先初始化其直接父类\n    * 假如类中有初始化语句，则系统依次执行这些初始化语句\n\n注意：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3\n\n 6. 类的初始化时机\n    * 创建类的实例\n    * 调用类的类方法\n    * 访问类或者接口的类变量，或者为该类变量赋值\n    * 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象\n    * 初始化某个类的子类\n    * 直接使用java.exe命令来运行某个主类\n\n\n# 1.2 类加载器\n\n# 1. 类加载器的作用\n\n负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象。虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行！\n\n# 2. JVM的类加载机制\n\n * 全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。\n\n * 父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。\n\n * 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区。\n\n# 3. Java中的内置类加载器\n\n * Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null ，并且没有父null。\n\n * Platform class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的JavaSE平台API，其实现类和JDK特定的运行时类。\n\n * System class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类。\n\n * 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap。\n\n# 4. ClassLoader中的两个方法\n\n方法名                                         说明\nstatic ClassLoader getSystemClassLoader()   返回用于委派的系统类加载器\nClassLoader getParent()                     返回父类加载器进行委派\n\n示例代码\n\npublic class ClassLoaderDemo {\n    public static void main(String[] args) {\n//static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器\n        ClassLoader c = ClassLoader.getSystemClassLoader();\n        System.out.println(c); //AppClassLoader\n//ClassLoader getParent()：返回父类加载器进行委派\n        ClassLoader c2 = c.getParent();\n        System.out.println(c2); //PlatformClassLoader\n        ClassLoader c3 = c2.getParent();\n        System.out.println(c3); //null\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2. 反射\n\n\n# 2.1 反射的概述\n\n是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展.\n\n * 反射是Java中一个非常重要同时也是一个高级特性，基本上Spring等一系列框架都是基于反射的思想 写成的。我们首先来认识一下什么反射。\n\nJava反射机制是在程序的运行过程中，对于任何一个类，都能够知道它的所有属性和方法；对于任意 一个对象，都能够知道调用它的任意属性和方法，这种动态获取信息以及动态调用对象方法的功能称为 java语言的反射机制。（来源于百度百科）\n\n * Java反射机制主要提供了以下这几个功能\n   * 在运行时判断任意一个对象所属的类\n   * 在运行时构造任意一个类的对象\n   * 在运行时判断任意一个类所有的成员变量和方法\n   * 在运行时调用任意一个对象的方法\n\n这么一看，反射就像是一个掌控全局的角色，不管你程序怎么运行，我都能够知道你这个类有哪些属性和方法，你这个对象是由谁调用的。\n\n在Java中，使用java.lang.reflect包实现了反射机制。Java.lang.reflect所设计的类如下\n\n\n\n\n# 2.2 Java反射主要类\n\n# 1. Class\n\n在Java中，你每定义一个java class实体都会产生一个Class对象。也就是说，当我们编写一个类， 编译完成后，在生成的-class文件中，就会产生一个Class对象，这个Class对象用于表示这个类 的类型信息。Class中没有公共的构造器，也就是说Class对象不能被实例化。下面来简单看一下 Class类都包括了哪些方法\n\n方法名                                                          说明\ntoString()                                                   方法能够将对象转换为字符串\ntoGenericString()                                            这个方法会返回类的全限定名称，而且包括类的修饰符和类型参数信息。\nforName()                                                    根据类名获得一个Class对象的引用，这个方法会使类对象进行初始化。\nnewInstance()                                                创建一个类的实例，代表着这个类的对象。上面forNameQ方法对类进行初始化，newlnstance方法对类进行实例化。\ngetClassLoader()                                             获取类加载器对象。\ngetTypeParameters()                                          按照声明的顺序获取对象的参数类型信息。\ngetPackage()                                                 返回类的包\ngetlnterfaces()                                              获得当前类实现的类或是接口，可能是有多个，所以返回的是Class数组。\nCast                                                         把对象转换成代表类或是接口的对象\nasSubclass(Class clazz)                                      把传递的类的对象转换成代表其子类的对象\ngetClasses()                                                 返回一个数组，数组中包含该类中所有公共类和接口类的对象\ngetDeclaredClasses()                                         返回一个数组，数组中包含该类中所有类和接口类的对象\ngetSimpleName()                                              获得类的名字\ngetFields()                                                  获得所有公有的属性对象\ngetField(String name)                                        获得某个公有的属性对象\ngetDeclaredField(String name)                                获得某个属性对象 getDeclaredFieldsQ 获得所有属性对象\ngetAnnotation(Class annotationClass)                         返回该类中与参数类型匹配的公有注解对象\ngetAnnotations()                                             返回该类所有的公有注解对象\ngetDeclaredAnnotation(Class annotationClass)                 返回该类中与参数类型匹配的所有注解对象\ngetDeclaredAnnotations()                                     返回该类所有的注解对象\ngetConstructor(Class...<?> parameterTypes)                   获得该类中与参数类型匹配的公有构造方法\ngetConstructorsO                                             获得该类的所有公有构造方法\ngetDeclaredConstructor(Class...<?> parameterTypes)           获得该类中与参数类型匹配的构造方法\ngetDeclaredConstructors()                                    获得该类所有构造方法\ngetMethod(String name, Class...<?> parameterTypes)           获得该类某个公有的方法\ngetMethods()                                                 获得该类所有公有的方法\ngetDeclaredMethod(String name, Class...<?> parameterTypes)   获得该类某个方法\ngetDeclaredMethods()                                         获得该类所有方法\n\n注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 Class...(?)) 指的是 Class...<?>. \n\n\n1\n\n\ntoString()\n\npublic String toString() {\n return (isInterface() ? "interface " : (isPrimitive() ? "" : "class "))\n + getName();\n}\n\n\n1\n2\n3\n4\n\n\ntoString()方法能够将对象转换为字符串，toString()首先会判断Class类型是否是接口类型，也就是说，普通类和接口都能够用Class对象来表示，然后再判断是否是基本数据类型，这里判断的都是基本 数据类型和包装类，还有void类型。\n\n所有的类型如下\n\n * java.lang.Boolean :代表boolean数据类型的包装类\n\n * java.lang.Character:代表char数据类型的包装类\n\n * java.lang.Byte:代表byte数据类型的包装类\n\n * java.Iang.Short:代表short数据类型的包装类\n\n * java.lang.Integer:代表int数据类型的包装类\n\n * java.lang.Long:代表long数据类型的包装类\n\n * java.lang.Float:代表float数据类型的包装类\n\n * java.lang.Double:代表double数据类型的包装类\n\n * java.lang.Void:代表void数据类型的包装类\n\n然后是getNameC)方法，这个方法返回类的全限定名称。\n\n * 如果是引用类型，比如 String.class.getNameQ -》 java. lang. String\n\n * 如果是基本数据类型，byte.class.getNameO -》 byte\n\n * 如果是数组类型，new Object[3]).getClassQ.getNameQ -》 java. lang.Object\n\n# 2. Field\n\nField类提供类或接口中单独字段的信息，以及对单独字段的动态访问。 这里就不再对具体的方法进行介绍了，读者有兴趣可以参考官方API 这里只介绍几个常用的方法。\n\n方法名                             说明\nequals(Object obj)              属性与ob j相等则返回true\nget(Object obj)                 获得obj中对应的属性值\nset(Object obj, Object value)   设置obj中对应属性值\n\n# 3. Method\n\n方法名                                  说明\ninvoke(Object obj, Object... args)   传递object对象及参数调用该对象对应的方法\n\n# 4. ClassLoader类\n\n反射中，还有一个非常重要的类就是ClassLoader类，类装载器是用来把类(class)装载进JVM 的。ClassLoader使用的是双亲委托模型来搜索加载类的，这个模型也就是双亲委派模型。\n\nClassLoader的类继承图如下\n\n\n\n\n# 2.3 获取Class类对象的三种方式\n\n# 1. 三种方式分类\n\n * Class.forName(全类名)方法: Class.forName(java.lang.Thread)\n\n * 类名.class属性: Thread.class\n\n * 对象名.getClass()方法: thread.getClassQ\n\n# 2. 示例\n\npublic class ReflectDemo {\n        public static void main(String[] args) throws ClassNotFoundException {\n\t\t\t//使用类的class属性来获取该类对应的Class对象\n            Class<Student> c1 = Student.class;\n            System.out.println(c1);\n            Class<Student> c2 = Student.class;\n            System.out.println(c1 == c2);\n            System.out.println("--------");\n\t\t\t//调用对象的getClass()方法，返回该对象所属类对应的Class对象\n            Student s = new Student();\n            Class<? extends Student> c3 = s.getClass();\n            System.out.println(c1 == c3);\n            System.out.println("--------");\n\t\t\t//使用Class类中的静态方法forName(String className)\n            Class<?> c4 = Class.forName("com.chggx_02.Student");\n            System.out.println(c1 == c4);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2.4 反射获取构造方法并使用\n\n# 1. Class类获取构造方法对象的方法\n\n方法名                             说明\nequals(Object obj)              属性与ob j相等则返回true\nget(Object obj)                 获得obj中对应的属性值\nset(Object obj, Object value)   设置obj中对应属性值\n\n示例：\n\npublic class ReflectDemo01 {\n    public static void main(String[] args) throws ClassNotFoundException,\n            NoSuchMethodException, IllegalAccessException, InvocationTargetException,\n            InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName("com.chggx_02.Student");\n        //Constructor<?>[] getConstructors() 返回一个包含 Constructor对象的数组，\n        Constructor对象反映了由该 Class对象表示的类的所有公共构造函数\n        // Constructor<?>[] cons = c.getConstructors();\n        //Constructor<?>[] getDeclaredConstructors() 返回反映由该 Class对象表示的类\n        声明的所有构造函数的 Constructor对象的数组\n        Constructor<?>[] cons = c.getDeclaredConstructors();\n        for(Constructor con : cons) {\n            System.out.println(con);\n        }\n        System.out.println("--------");\n        //Constructor<T> getConstructor(Class<?>... parameterTypes) 返回一个\n        Constructor对象，该对象反映由该 Class对象表示的类的指定公共构造函数\n        //Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) 返回\n        一个 Constructor对象，该对象反映由此 Class对象表示的类或接口的指定构造函数\n        //参数：你要获取的构造方法的参数的个数和数据类型对应的字节码文件对象\n        Constructor<?> con = c.getConstructor();\n        //Constructor提供了一个类的单个构造函数的信息和访问权限\n        //T newInstance(Object... initargs) 使用由此 Constructor对象表示的构造函数，\n        使用指定的初始化参数来创建和初始化构造函数的声明类的新实例\n        Object obj = con.newInstance();\n        System.out.println(obj);\n        // Student s = new Student();\n        // System.out.println(s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 2. Constructor类用于创建对象的方法\n\n方法名                                说明\nT newInstance(Object...initargs)   根据指定的构造方法创建对象\n\n# 3. 示例1\n\n通过反射获取公共的构造方法并创建对象\n\n * 学生类\n\npublic class Student {\n    //成员变量：一个私有，一个默认，一个公共\n    private String name;\n    int age;\n    public String address;\n\n    //构造方法：一个私有，一个默认，两个公共\n    public Student() {\n    }\n\n    private Student(String name) {\n        this.name = name;\n    }\n\n    Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public Student(String name, int age, String address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n\n    //成员方法：一个私有，四个公共\n    private void function() {\n        System.out.println("function");\n    }\n\n    public void method1() {\n        System.out.println("method");\n    }\n\n    public void method2(String s) {\n        System.out.println("method:" + s);\n    }\n\n    public String method3(String s, int i) {\n        return s + "," + i;\n    }\n\n    @Override\n    public String toString() {\n        return "Student{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                ", address=\'" + address + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n测试类\n\n/*\n    通过反射实现如下的操作：\n        Student s = new Student("林青霞",30,"西安");\n        System.out.println(s);\n */\npublic class ReflectDemo02 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName("com.chggx_02.Student");\n\n        //public Student(String name, int age, String address)\n        //Constructor<T> getConstructor​(Class<?>... parameterTypes)\n        Constructor<?> con = c.getConstructor(String.class, int.class, String.class);\n        //基本数据类型也可以通过.class得到对应的Class类型\n\n        //T newInstance​(Object... initargs)\n        Object obj = con.newInstance("林青霞", 30, "西安");\n        System.out.println(obj);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 4. 示例2\n\n通过反射获取私有构造方法并创建对象\n\n学生类：参考示例1\n\n测试类\n\npackage com.chggx_03;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n/*\n    通过反射实现如下的操作：\n        Student s = new Student("林青霞");\n        System.out.println(s);\n */\npublic class ReflectDemo03 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName("com.chggx_02.Student");\n\n        //private Student(String name)\n        //Constructor<T> getDeclaredConstructor​(Class<?>... parameterTypes)\n        Constructor<?> con = c.getDeclaredConstructor(String.class);\n\n        //暴力反射\n        //public void setAccessible​(boolean flag):值为true，取消访问检查\n        con.setAccessible(true);\n\n        Object obj = con.newInstance("林青霞");\n        System.out.println(obj);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 2.5 反射获取成员变量并使用\n\n# 1. Class类获取成员变量对象的方法\n\n方法名                                   说明\nField[] getFields()                   返回所有公共成员变量对象的数组\nField[] getDeclaredFields()           返回所有成员变量对象的数组\nField getField(String name)           返回单个公共成员变量对象\nField getDeclaredField(String name)   返回单个成员变量对象\n\n示例：\n\n/*\n    反射获取成员变量并使用\n */\npublic class ReflectDemo01 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName("com.chggx_02.Student");\n\n        //Field[] getFields​() 返回一个包含 Field对象的数组， Field对象反映由该 Class对象表示的类或接口的所有可访问的公共字段\n        //Field[] getDeclaredFields​() 返回一个 Field对象的数组，反映了由该 Class对象表示的类或接口声明的所有字段\n//        Field[] fields = c.getFields();\n        Field[] fields = c.getDeclaredFields();\n        for(Field field : fields) {\n            System.out.println(field);\n        }\n        System.out.println("--------");\n\n        //Field getField​(String name) 返回一个 Field对象，该对象反映由该 Class对象表示的类或接口的指定公共成员字段\n        //Field getDeclaredField​(String name) 返回一个 Field对象，该对象反映由该 Class对象表示的类或接口的指定声明字段\n        Field addressField = c.getField("address");\n\n        //获取无参构造方法创建对象\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n\n//        obj.addressField = "西安";\n\n        //Field提供有关类或接口的单个字段的信息和动态访问\n        //void set​(Object obj, Object value) 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值\n        addressField.set(obj,"西安"); //给obj的成员变量addressField赋值为西安\n\n        System.out.println(obj);\n\n\n\n//        Student s = new Student();\n//        s.address = "西安";\n//        System.out.println(s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n# 2. Field类用于给成员变量赋值的方法\n\n方法名                                说明\nvoidset(Object obj,Object value)   给obj对象的成员变量赋值为value\n\n# 3. 示例\n\n通过反射获取成员变量并赋值\n\n学生类：参见上方学生类\n\n测试类\n\n/*\n    练习：通过反射实现如下操作\n        Student s = new Student();\n        s.name = "林青霞";\n        s.age = 30;\n        s.address = "西安";\n        System.out.println(s);\n */\npublic class ReflectDemo02 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {\n        //获取Class对象\n        Class<?> c = Class.forName("com.chggx_02.Student");\n\n        //Student s = new Student();\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n        System.out.println(obj);\n\n        //s.name = "林青霞";\n//        Field nameField = c.getField("name"); //NoSuchFieldException: name\n        Field nameField = c.getDeclaredField("name");\n        nameField.setAccessible(true);\n        nameField.set(obj, "林青霞");\n        System.out.println(obj);\n\n        //s.age = 30;\n        Field ageField = c.getDeclaredField("age");\n        ageField.setAccessible(true);\n        ageField.set(obj,30);\n        System.out.println(obj);\n\n        //s.address = "西安";\n        Field addressField = c.getDeclaredField("address");\n        addressField.setAccessible(true);\n        addressField.set(obj,"西安");\n        System.out.println(obj);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 2.6 反射获取成员方法并使用\n\n# 1. Class类获取成员方法对象的方法\n\n方法名                                                         说明\nMethod[] getMethods()                                       返回所有公共成员方法对象的数组，包括继承的\nMethod[] getDeclaredMethods()                               返回所有成员方法对象的数组，不包括继承的\nMethod getMethod(String name, Class(?)... parameterTypes)   返回单个公共成员方法对象\nMethod getDeclaredMethod(String name, Class(?)...           返回单个成员方法对象\nparameterTypes)\n\n注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 Class...(?) 指的是 Class...<?>. \n\n\n1\n\n\n示例\n\n/*\n    反射获取成员方法并使用\n */\npublic class ReflectDemo01 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName("com.chggx_02.Student");\n\n        //Method[] getMethods​() 返回一个包含 方法对象的数组， 方法对象反映由该 Class对象表示的类或接口的所有公共方法，包括由类或接口声明的对象以及从超类和超级接口继承的类\n        //Method[] getDeclaredMethods​() 返回一个包含 方法对象的数组， 方法对象反映由 Class对象表示的类或接口的所有声明方法，包括public，protected，default（package）访问和私有方法，但不包括继承方法\n//        Method[] methods = c.getMethods();\n        Method[] methods = c.getDeclaredMethods();\n        for(Method method : methods) {\n            System.out.println(method);\n        }\n        System.out.println("--------");\n\n        //Method getMethod​(String name, Class<?>... parameterTypes) 返回一个 方法对象，该对象反映由该 Class对象表示的类或接口的指定公共成员方法\n        //Method getDeclaredMethod​(String name, Class<?>... parameterTypes) 返回一个 方法对象，它反映此表示的类或接口的指定声明的方法 Class对象\n        //public void method1()\n        Method m = c.getMethod("method1");\n\n        //获取无参构造方法创建对象\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n\n//        obj.m();\n\n        //在类或接口上提供有关单一方法的信息和访问权限\n        //Object invoke​(Object obj, Object... args) 在具有指定参数的指定对象上调用此 方法对象表示的基础方法\n        //Object：返回值类型\n        //obj：调用方法的对象\n        //args：方法需要的参数\n        m.invoke(obj);\n\n//        Student s = new Student();\n//        s.method1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 2. Method类用于执行方法的方法\n\n方法名                                       说明\nObjectinvoke(Object obj,Object... args)   调用obj对象的成员方法，参数是args,返回值是Object类型\n\n# 3. 示例\n\n通过反射获取成员方法并调用\n\n学生类：参见上方学生类\n\n测试类\n\n/*\n     练习：通过反射实现如下操作\n        Student s = new Student();\n        s.method1();\n        s.method2("林青霞");\n        String ss = s.method3("林青霞",30);\n        System.out.println(ss);\n        s.function();\n */\npublic class ReflectDemo02 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName("com.chggx_02.Student");\n\n        //Student s = new Student();\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n\n        //s.method1();\n        Method m1 = c.getMethod("method1");\n        m1.invoke(obj);\n\n        //s.method2("林青霞");\n        Method m2 = c.getMethod("method2", String.class);\n        m2.invoke(obj,"林青霞");\n\n//        String ss = s.method3("林青霞",30);\n//        System.out.println(ss);\n        Method m3 = c.getMethod("method3", String.class, int.class);\n        Object o = m3.invoke(obj, "林青霞", 30);\n        System.out.println(o);\n\n        //s.function();\n//        Method m4 = c.getMethod("function"); //NoSuchMethodException: com.chggx_02.Student.function()\n        Method m4 = c.getDeclaredMethod("function");\n        m4.setAccessible(true);\n        m4.invoke(obj);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 2.7 反射的案例\n\n# 1. 越过泛型检查\n\n通过反射技术，向一个泛型为Integer的集合中添加一些字符串数据\n\npackage com.chggx_06;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\n\n/*\n    练习1：我有一个ArrayList<Integer>集合，现在我想在这个集合中添加一个字符串数据，如何实现？\n */\npublic class ReflectTest01 {\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        //创建集合\n        ArrayList<Integer> array = new ArrayList<Integer>();\n\n//        array.add(10);\n//        array.add(20);\n//        array.add("hello");\n\n        Class<? extends ArrayList> c = array.getClass();\n        Method m = c.getMethod("add", Object.class);\n\n        m.invoke(array,"hello");\n        m.invoke(array,"world");\n        m.invoke(array,"java");\n\n        System.out.println(array);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 2. 运行配置文件中指定类的指定方法\n\n/*\n    练习2：通过配置文件运行类中的方法\n */\npublic class ReflectTest02 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n//        Student s = new Student();\n//        s.study();\n\n//        Teacher t = new Teacher();\n//        t.teach();\n\n        /*\n            class.txt\n            className=xxx\n            methodName=xxx\n         */\n\n        //加载数据\n        Properties prop = new Properties();\n        FileReader fr = new FileReader("myReflect\\\\class.txt");\n        prop.load(fr);\n        fr.close();\n\n        /*\n            className=com.chggx_06.Student\n            methodName=study\n         */\n        String className = prop.getProperty("className");\n        String methodName = prop.getProperty("methodName");\n\n        //通过反射来使用\n        Class<?> c = Class.forName(className);//com.chggx_06.Student\n\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n\n        Method m = c.getMethod(methodName);//study\n        m.invoke(obj);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 3. 模块化\n\n......',normalizedContent:'# 反射\n\n\n# 1. 类加载器\n\n\n# 1.1 类加载\n\n 1. 类加载的描述\n    \n    * 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始\n    * 化这三个步骤来对类进行初始化。如果不出现意外情况，jvm将会连续完成这三个步骤，所以有时也把\n    * 这三个步骤统称为类加载或者类初始化\n\n 2. 类的加载\n    \n    * 就是指将class文件读入内存，并为之创建一个 java.lang.class 对象\n    * 任何类被使用时，系统都会为之建立一个 java.lang.class 对象\n\n 3. 类的连接\n    \n    * 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致\n    * 准备阶段：负责为类的类变量分配内存，并设置默认初始化值\n    * 解析阶段：将类的二进制数据中的符号引用替换为直接引用\n\n 4. 类的初始化\n    \n    * 在该阶段，主要就是对类变量进行初始化\n\n 5. 类的初始化步骤\n    \n    * 假如类还未被加载和连接，则程序先加载并连接该类\n    * 假如该类的直接父类还未被初始化，则先初始化其直接父类\n    * 假如类中有初始化语句，则系统依次执行这些初始化语句\n\n注意：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3\n\n 6. 类的初始化时机\n    * 创建类的实例\n    * 调用类的类方法\n    * 访问类或者接口的类变量，或者为该类变量赋值\n    * 使用反射方式来强制创建某个类或接口对应的java.lang.class对象\n    * 初始化某个类的子类\n    * 直接使用java.exe命令来运行某个主类\n\n\n# 1.2 类加载器\n\n# 1. 类加载器的作用\n\n负责将.class文件加载到内存中，并为之生成对应的java.lang.class对象。虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行！\n\n# 2. jvm的类加载机制\n\n * 全盘负责：就是当一个类加载器负责加载某个class时，该class所依赖的和引用的其他class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。\n\n * 父类委托：就是当一个类加载器负责加载某个class时，先让父类加载器试图加载该class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。\n\n * 缓存机制：保证所有加载过的class都会被缓存，当程序需要使用某个class对象时，类加载器先从缓存区中搜索该class，只有当缓存区中不存在该class对象时，系统才会读取该类对应的二进制数据，并将其转换成class对象，存储到缓存区。\n\n# 3. java中的内置类加载器\n\n * bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null ，并且没有父null。\n\n * platform class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的javase平台api，其实现类和jdk特定的运行时类。\n\n * system class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应用程序类路径，模块路径和jdk特定工具上的类。\n\n * 类加载器的继承关系：system的父加载器为platform，而platform的父加载器为bootstrap。\n\n# 4. classloader中的两个方法\n\n方法名                                         说明\nstatic classloader getsystemclassloader()   返回用于委派的系统类加载器\nclassloader getparent()                     返回父类加载器进行委派\n\n示例代码\n\npublic class classloaderdemo {\n    public static void main(string[] args) {\n//static classloader getsystemclassloader()：返回用于委派的系统类加载器\n        classloader c = classloader.getsystemclassloader();\n        system.out.println(c); //appclassloader\n//classloader getparent()：返回父类加载器进行委派\n        classloader c2 = c.getparent();\n        system.out.println(c2); //platformclassloader\n        classloader c3 = c2.getparent();\n        system.out.println(c3); //null\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2. 反射\n\n\n# 2.1 反射的概述\n\n是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展.\n\n * 反射是java中一个非常重要同时也是一个高级特性，基本上spring等一系列框架都是基于反射的思想 写成的。我们首先来认识一下什么反射。\n\njava反射机制是在程序的运行过程中，对于任何一个类，都能够知道它的所有属性和方法；对于任意 一个对象，都能够知道调用它的任意属性和方法，这种动态获取信息以及动态调用对象方法的功能称为 java语言的反射机制。（来源于百度百科）\n\n * java反射机制主要提供了以下这几个功能\n   * 在运行时判断任意一个对象所属的类\n   * 在运行时构造任意一个类的对象\n   * 在运行时判断任意一个类所有的成员变量和方法\n   * 在运行时调用任意一个对象的方法\n\n这么一看，反射就像是一个掌控全局的角色，不管你程序怎么运行，我都能够知道你这个类有哪些属性和方法，你这个对象是由谁调用的。\n\n在java中，使用java.lang.reflect包实现了反射机制。java.lang.reflect所设计的类如下\n\n\n\n\n# 2.2 java反射主要类\n\n# 1. class\n\n在java中，你每定义一个java class实体都会产生一个class对象。也就是说，当我们编写一个类， 编译完成后，在生成的-class文件中，就会产生一个class对象，这个class对象用于表示这个类 的类型信息。class中没有公共的构造器，也就是说class对象不能被实例化。下面来简单看一下 class类都包括了哪些方法\n\n方法名                                                          说明\ntostring()                                                   方法能够将对象转换为字符串\ntogenericstring()                                            这个方法会返回类的全限定名称，而且包括类的修饰符和类型参数信息。\nforname()                                                    根据类名获得一个class对象的引用，这个方法会使类对象进行初始化。\nnewinstance()                                                创建一个类的实例，代表着这个类的对象。上面fornameq方法对类进行初始化，newlnstance方法对类进行实例化。\ngetclassloader()                                             获取类加载器对象。\ngettypeparameters()                                          按照声明的顺序获取对象的参数类型信息。\ngetpackage()                                                 返回类的包\ngetlnterfaces()                                              获得当前类实现的类或是接口，可能是有多个，所以返回的是class数组。\ncast                                                         把对象转换成代表类或是接口的对象\nassubclass(class clazz)                                      把传递的类的对象转换成代表其子类的对象\ngetclasses()                                                 返回一个数组，数组中包含该类中所有公共类和接口类的对象\ngetdeclaredclasses()                                         返回一个数组，数组中包含该类中所有类和接口类的对象\ngetsimplename()                                              获得类的名字\ngetfields()                                                  获得所有公有的属性对象\ngetfield(string name)                                        获得某个公有的属性对象\ngetdeclaredfield(string name)                                获得某个属性对象 getdeclaredfieldsq 获得所有属性对象\ngetannotation(class annotationclass)                         返回该类中与参数类型匹配的公有注解对象\ngetannotations()                                             返回该类所有的公有注解对象\ngetdeclaredannotation(class annotationclass)                 返回该类中与参数类型匹配的所有注解对象\ngetdeclaredannotations()                                     返回该类所有的注解对象\ngetconstructor(class...<?> parametertypes)                   获得该类中与参数类型匹配的公有构造方法\ngetconstructorso                                             获得该类的所有公有构造方法\ngetdeclaredconstructor(class...<?> parametertypes)           获得该类中与参数类型匹配的构造方法\ngetdeclaredconstructors()                                    获得该类所有构造方法\ngetmethod(string name, class...<?> parametertypes)           获得该类某个公有的方法\ngetmethods()                                                 获得该类所有公有的方法\ngetdeclaredmethod(string name, class...<?> parametertypes)   获得该类某个方法\ngetdeclaredmethods()                                         获得该类所有方法\n\n注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 class...(?)) 指的是 class...<?>. \n\n\n1\n\n\ntostring()\n\npublic string tostring() {\n return (isinterface() ? "interface " : (isprimitive() ? "" : "class "))\n + getname();\n}\n\n\n1\n2\n3\n4\n\n\ntostring()方法能够将对象转换为字符串，tostring()首先会判断class类型是否是接口类型，也就是说，普通类和接口都能够用class对象来表示，然后再判断是否是基本数据类型，这里判断的都是基本 数据类型和包装类，还有void类型。\n\n所有的类型如下\n\n * java.lang.boolean :代表boolean数据类型的包装类\n\n * java.lang.character:代表char数据类型的包装类\n\n * java.lang.byte:代表byte数据类型的包装类\n\n * java.iang.short:代表short数据类型的包装类\n\n * java.lang.integer:代表int数据类型的包装类\n\n * java.lang.long:代表long数据类型的包装类\n\n * java.lang.float:代表float数据类型的包装类\n\n * java.lang.double:代表double数据类型的包装类\n\n * java.lang.void:代表void数据类型的包装类\n\n然后是getnamec)方法，这个方法返回类的全限定名称。\n\n * 如果是引用类型，比如 string.class.getnameq -》 java. lang. string\n\n * 如果是基本数据类型，byte.class.getnameo -》 byte\n\n * 如果是数组类型，new object[3]).getclassq.getnameq -》 java. lang.object\n\n# 2. field\n\nfield类提供类或接口中单独字段的信息，以及对单独字段的动态访问。 这里就不再对具体的方法进行介绍了，读者有兴趣可以参考官方api 这里只介绍几个常用的方法。\n\n方法名                             说明\nequals(object obj)              属性与ob j相等则返回true\nget(object obj)                 获得obj中对应的属性值\nset(object obj, object value)   设置obj中对应属性值\n\n# 3. method\n\n方法名                                  说明\ninvoke(object obj, object... args)   传递object对象及参数调用该对象对应的方法\n\n# 4. classloader类\n\n反射中，还有一个非常重要的类就是classloader类，类装载器是用来把类(class)装载进jvm 的。classloader使用的是双亲委托模型来搜索加载类的，这个模型也就是双亲委派模型。\n\nclassloader的类继承图如下\n\n\n\n\n# 2.3 获取class类对象的三种方式\n\n# 1. 三种方式分类\n\n * class.forname(全类名)方法: class.forname(java.lang.thread)\n\n * 类名.class属性: thread.class\n\n * 对象名.getclass()方法: thread.getclassq\n\n# 2. 示例\n\npublic class reflectdemo {\n        public static void main(string[] args) throws classnotfoundexception {\n\t\t\t//使用类的class属性来获取该类对应的class对象\n            class<student> c1 = student.class;\n            system.out.println(c1);\n            class<student> c2 = student.class;\n            system.out.println(c1 == c2);\n            system.out.println("--------");\n\t\t\t//调用对象的getclass()方法，返回该对象所属类对应的class对象\n            student s = new student();\n            class<? extends student> c3 = s.getclass();\n            system.out.println(c1 == c3);\n            system.out.println("--------");\n\t\t\t//使用class类中的静态方法forname(string classname)\n            class<?> c4 = class.forname("com.chggx_02.student");\n            system.out.println(c1 == c4);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2.4 反射获取构造方法并使用\n\n# 1. class类获取构造方法对象的方法\n\n方法名                             说明\nequals(object obj)              属性与ob j相等则返回true\nget(object obj)                 获得obj中对应的属性值\nset(object obj, object value)   设置obj中对应属性值\n\n示例：\n\npublic class reflectdemo01 {\n    public static void main(string[] args) throws classnotfoundexception,\n            nosuchmethodexception, illegalaccessexception, invocationtargetexception,\n            instantiationexception {\n        //获取class对象\n        class<?> c = class.forname("com.chggx_02.student");\n        //constructor<?>[] getconstructors() 返回一个包含 constructor对象的数组，\n        constructor对象反映了由该 class对象表示的类的所有公共构造函数\n        // constructor<?>[] cons = c.getconstructors();\n        //constructor<?>[] getdeclaredconstructors() 返回反映由该 class对象表示的类\n        声明的所有构造函数的 constructor对象的数组\n        constructor<?>[] cons = c.getdeclaredconstructors();\n        for(constructor con : cons) {\n            system.out.println(con);\n        }\n        system.out.println("--------");\n        //constructor<t> getconstructor(class<?>... parametertypes) 返回一个\n        constructor对象，该对象反映由该 class对象表示的类的指定公共构造函数\n        //constructor<t> getdeclaredconstructor(class<?>... parametertypes) 返回\n        一个 constructor对象，该对象反映由此 class对象表示的类或接口的指定构造函数\n        //参数：你要获取的构造方法的参数的个数和数据类型对应的字节码文件对象\n        constructor<?> con = c.getconstructor();\n        //constructor提供了一个类的单个构造函数的信息和访问权限\n        //t newinstance(object... initargs) 使用由此 constructor对象表示的构造函数，\n        使用指定的初始化参数来创建和初始化构造函数的声明类的新实例\n        object obj = con.newinstance();\n        system.out.println(obj);\n        // student s = new student();\n        // system.out.println(s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 2. constructor类用于创建对象的方法\n\n方法名                                说明\nt newinstance(object...initargs)   根据指定的构造方法创建对象\n\n# 3. 示例1\n\n通过反射获取公共的构造方法并创建对象\n\n * 学生类\n\npublic class student {\n    //成员变量：一个私有，一个默认，一个公共\n    private string name;\n    int age;\n    public string address;\n\n    //构造方法：一个私有，一个默认，两个公共\n    public student() {\n    }\n\n    private student(string name) {\n        this.name = name;\n    }\n\n    student(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public student(string name, int age, string address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n\n    //成员方法：一个私有，四个公共\n    private void function() {\n        system.out.println("function");\n    }\n\n    public void method1() {\n        system.out.println("method");\n    }\n\n    public void method2(string s) {\n        system.out.println("method:" + s);\n    }\n\n    public string method3(string s, int i) {\n        return s + "," + i;\n    }\n\n    @override\n    public string tostring() {\n        return "student{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                ", address=\'" + address + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n测试类\n\n/*\n    通过反射实现如下的操作：\n        student s = new student("林青霞",30,"西安");\n        system.out.println(s);\n */\npublic class reflectdemo02 {\n    public static void main(string[] args) throws classnotfoundexception, nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception {\n        //获取class对象\n        class<?> c = class.forname("com.chggx_02.student");\n\n        //public student(string name, int age, string address)\n        //constructor<t> getconstructor​(class<?>... parametertypes)\n        constructor<?> con = c.getconstructor(string.class, int.class, string.class);\n        //基本数据类型也可以通过.class得到对应的class类型\n\n        //t newinstance​(object... initargs)\n        object obj = con.newinstance("林青霞", 30, "西安");\n        system.out.println(obj);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 4. 示例2\n\n通过反射获取私有构造方法并创建对象\n\n学生类：参考示例1\n\n测试类\n\npackage com.chggx_03;\n\nimport java.lang.reflect.constructor;\nimport java.lang.reflect.invocationtargetexception;\n\n/*\n    通过反射实现如下的操作：\n        student s = new student("林青霞");\n        system.out.println(s);\n */\npublic class reflectdemo03 {\n    public static void main(string[] args) throws classnotfoundexception, nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception {\n        //获取class对象\n        class<?> c = class.forname("com.chggx_02.student");\n\n        //private student(string name)\n        //constructor<t> getdeclaredconstructor​(class<?>... parametertypes)\n        constructor<?> con = c.getdeclaredconstructor(string.class);\n\n        //暴力反射\n        //public void setaccessible​(boolean flag):值为true，取消访问检查\n        con.setaccessible(true);\n\n        object obj = con.newinstance("林青霞");\n        system.out.println(obj);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 2.5 反射获取成员变量并使用\n\n# 1. class类获取成员变量对象的方法\n\n方法名                                   说明\nfield[] getfields()                   返回所有公共成员变量对象的数组\nfield[] getdeclaredfields()           返回所有成员变量对象的数组\nfield getfield(string name)           返回单个公共成员变量对象\nfield getdeclaredfield(string name)   返回单个成员变量对象\n\n示例：\n\n/*\n    反射获取成员变量并使用\n */\npublic class reflectdemo01 {\n    public static void main(string[] args) throws classnotfoundexception, nosuchfieldexception, nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception {\n        //获取class对象\n        class<?> c = class.forname("com.chggx_02.student");\n\n        //field[] getfields​() 返回一个包含 field对象的数组， field对象反映由该 class对象表示的类或接口的所有可访问的公共字段\n        //field[] getdeclaredfields​() 返回一个 field对象的数组，反映了由该 class对象表示的类或接口声明的所有字段\n//        field[] fields = c.getfields();\n        field[] fields = c.getdeclaredfields();\n        for(field field : fields) {\n            system.out.println(field);\n        }\n        system.out.println("--------");\n\n        //field getfield​(string name) 返回一个 field对象，该对象反映由该 class对象表示的类或接口的指定公共成员字段\n        //field getdeclaredfield​(string name) 返回一个 field对象，该对象反映由该 class对象表示的类或接口的指定声明字段\n        field addressfield = c.getfield("address");\n\n        //获取无参构造方法创建对象\n        constructor<?> con = c.getconstructor();\n        object obj = con.newinstance();\n\n//        obj.addressfield = "西安";\n\n        //field提供有关类或接口的单个字段的信息和动态访问\n        //void set​(object obj, object value) 将指定的对象参数中由此 field对象表示的字段设置为指定的新值\n        addressfield.set(obj,"西安"); //给obj的成员变量addressfield赋值为西安\n\n        system.out.println(obj);\n\n\n\n//        student s = new student();\n//        s.address = "西安";\n//        system.out.println(s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n# 2. field类用于给成员变量赋值的方法\n\n方法名                                说明\nvoidset(object obj,object value)   给obj对象的成员变量赋值为value\n\n# 3. 示例\n\n通过反射获取成员变量并赋值\n\n学生类：参见上方学生类\n\n测试类\n\n/*\n    练习：通过反射实现如下操作\n        student s = new student();\n        s.name = "林青霞";\n        s.age = 30;\n        s.address = "西安";\n        system.out.println(s);\n */\npublic class reflectdemo02 {\n    public static void main(string[] args) throws classnotfoundexception, nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception, nosuchfieldexception {\n        //获取class对象\n        class<?> c = class.forname("com.chggx_02.student");\n\n        //student s = new student();\n        constructor<?> con = c.getconstructor();\n        object obj = con.newinstance();\n        system.out.println(obj);\n\n        //s.name = "林青霞";\n//        field namefield = c.getfield("name"); //nosuchfieldexception: name\n        field namefield = c.getdeclaredfield("name");\n        namefield.setaccessible(true);\n        namefield.set(obj, "林青霞");\n        system.out.println(obj);\n\n        //s.age = 30;\n        field agefield = c.getdeclaredfield("age");\n        agefield.setaccessible(true);\n        agefield.set(obj,30);\n        system.out.println(obj);\n\n        //s.address = "西安";\n        field addressfield = c.getdeclaredfield("address");\n        addressfield.setaccessible(true);\n        addressfield.set(obj,"西安");\n        system.out.println(obj);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 2.6 反射获取成员方法并使用\n\n# 1. class类获取成员方法对象的方法\n\n方法名                                                         说明\nmethod[] getmethods()                                       返回所有公共成员方法对象的数组，包括继承的\nmethod[] getdeclaredmethods()                               返回所有成员方法对象的数组，不包括继承的\nmethod getmethod(string name, class(?)... parametertypes)   返回单个公共成员方法对象\nmethod getdeclaredmethod(string name, class(?)...           返回单个成员方法对象\nparametertypes)\n\n注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 class...(?) 指的是 class...<?>. \n\n\n1\n\n\n示例\n\n/*\n    反射获取成员方法并使用\n */\npublic class reflectdemo01 {\n    public static void main(string[] args) throws classnotfoundexception, nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception {\n        //获取class对象\n        class<?> c = class.forname("com.chggx_02.student");\n\n        //method[] getmethods​() 返回一个包含 方法对象的数组， 方法对象反映由该 class对象表示的类或接口的所有公共方法，包括由类或接口声明的对象以及从超类和超级接口继承的类\n        //method[] getdeclaredmethods​() 返回一个包含 方法对象的数组， 方法对象反映由 class对象表示的类或接口的所有声明方法，包括public，protected，default（package）访问和私有方法，但不包括继承方法\n//        method[] methods = c.getmethods();\n        method[] methods = c.getdeclaredmethods();\n        for(method method : methods) {\n            system.out.println(method);\n        }\n        system.out.println("--------");\n\n        //method getmethod​(string name, class<?>... parametertypes) 返回一个 方法对象，该对象反映由该 class对象表示的类或接口的指定公共成员方法\n        //method getdeclaredmethod​(string name, class<?>... parametertypes) 返回一个 方法对象，它反映此表示的类或接口的指定声明的方法 class对象\n        //public void method1()\n        method m = c.getmethod("method1");\n\n        //获取无参构造方法创建对象\n        constructor<?> con = c.getconstructor();\n        object obj = con.newinstance();\n\n//        obj.m();\n\n        //在类或接口上提供有关单一方法的信息和访问权限\n        //object invoke​(object obj, object... args) 在具有指定参数的指定对象上调用此 方法对象表示的基础方法\n        //object：返回值类型\n        //obj：调用方法的对象\n        //args：方法需要的参数\n        m.invoke(obj);\n\n//        student s = new student();\n//        s.method1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 2. method类用于执行方法的方法\n\n方法名                                       说明\nobjectinvoke(object obj,object... args)   调用obj对象的成员方法，参数是args,返回值是object类型\n\n# 3. 示例\n\n通过反射获取成员方法并调用\n\n学生类：参见上方学生类\n\n测试类\n\n/*\n     练习：通过反射实现如下操作\n        student s = new student();\n        s.method1();\n        s.method2("林青霞");\n        string ss = s.method3("林青霞",30);\n        system.out.println(ss);\n        s.function();\n */\npublic class reflectdemo02 {\n    public static void main(string[] args) throws classnotfoundexception, nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception {\n        //获取class对象\n        class<?> c = class.forname("com.chggx_02.student");\n\n        //student s = new student();\n        constructor<?> con = c.getconstructor();\n        object obj = con.newinstance();\n\n        //s.method1();\n        method m1 = c.getmethod("method1");\n        m1.invoke(obj);\n\n        //s.method2("林青霞");\n        method m2 = c.getmethod("method2", string.class);\n        m2.invoke(obj,"林青霞");\n\n//        string ss = s.method3("林青霞",30);\n//        system.out.println(ss);\n        method m3 = c.getmethod("method3", string.class, int.class);\n        object o = m3.invoke(obj, "林青霞", 30);\n        system.out.println(o);\n\n        //s.function();\n//        method m4 = c.getmethod("function"); //nosuchmethodexception: com.chggx_02.student.function()\n        method m4 = c.getdeclaredmethod("function");\n        m4.setaccessible(true);\n        m4.invoke(obj);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 2.7 反射的案例\n\n# 1. 越过泛型检查\n\n通过反射技术，向一个泛型为integer的集合中添加一些字符串数据\n\npackage com.chggx_06;\n\nimport java.lang.reflect.invocationtargetexception;\nimport java.lang.reflect.method;\nimport java.util.arraylist;\n\n/*\n    练习1：我有一个arraylist<integer>集合，现在我想在这个集合中添加一个字符串数据，如何实现？\n */\npublic class reflecttest01 {\n    public static void main(string[] args) throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n        //创建集合\n        arraylist<integer> array = new arraylist<integer>();\n\n//        array.add(10);\n//        array.add(20);\n//        array.add("hello");\n\n        class<? extends arraylist> c = array.getclass();\n        method m = c.getmethod("add", object.class);\n\n        m.invoke(array,"hello");\n        m.invoke(array,"world");\n        m.invoke(array,"java");\n\n        system.out.println(array);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 2. 运行配置文件中指定类的指定方法\n\n/*\n    练习2：通过配置文件运行类中的方法\n */\npublic class reflecttest02 {\n    public static void main(string[] args) throws ioexception, classnotfoundexception, nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception {\n//        student s = new student();\n//        s.study();\n\n//        teacher t = new teacher();\n//        t.teach();\n\n        /*\n            class.txt\n            classname=xxx\n            methodname=xxx\n         */\n\n        //加载数据\n        properties prop = new properties();\n        filereader fr = new filereader("myreflect\\\\class.txt");\n        prop.load(fr);\n        fr.close();\n\n        /*\n            classname=com.chggx_06.student\n            methodname=study\n         */\n        string classname = prop.getproperty("classname");\n        string methodname = prop.getproperty("methodname");\n\n        //通过反射来使用\n        class<?> c = class.forname(classname);//com.chggx_06.student\n\n        constructor<?> con = c.getconstructor();\n        object obj = con.newinstance();\n\n        method m = c.getmethod(methodname);//study\n        m.invoke(obj);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 3. 模块化\n\n......',charsets:{cjk:!0},lastUpdated:"2023/02/28, 18:23:46",lastUpdatedTimestamp:1677579826e3},{title:"IO",frontmatter:{title:"IO",date:"2023-02-28T13:51:50.000Z",permalink:"/pages/539c95/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/11.IO%E6%B5%81.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/11.IO流.md",key:"v-9bb40838",path:"/pages/539c95/",headers:[{level:2,title:"1.File类😄",slug:"_1-file类",normalizedTitle:"1.file类😄",charIndex:176},{level:3,title:"1.1File类概述和构造方法",slug:"_1-1file类概述和构造方法",normalizedTitle:"1.1file类概述和构造方法",charIndex:190},{level:3,title:"1.2File类创建功能",slug:"_1-2file类创建功能",normalizedTitle:"1.2file类创建功能",charIndex:1362},{level:3,title:"1.3File类判断和获取功能",slug:"_1-3file类判断和获取功能",normalizedTitle:"1.3file类判断和获取功能",charIndex:2731},{level:3,title:"1.4File类删除功能",slug:"_1-4file类删除功能",normalizedTitle:"1.4file类删除功能",charIndex:5088},{level:2,title:"2.递归",slug:"_2-递归",normalizedTitle:"2.递归",charIndex:6616},{level:3,title:"2.1递归",slug:"_2-1递归",normalizedTitle:"2.1递归",charIndex:6625},{level:3,title:"2.2递归求阶乘",slug:"_2-2递归求阶乘",normalizedTitle:"2.2递归求阶乘",charIndex:7891},{level:3,title:"2.3递归遍历目录",slug:"_2-3递归遍历目录",normalizedTitle:"2.3递归遍历目录",charIndex:8572},{level:2,title:"3.IO-字节流 InputStream和OutputStream😄",slug:"_3-io-字节流-inputstream和outputstream",normalizedTitle:"3.io-字节流 inputstream和outputstream😄",charIndex:9797},{level:3,title:"3.1 IO流概述和分类",slug:"_3-1-io流概述和分类",normalizedTitle:"3.1 io流概述和分类",charIndex:9837},{level:3,title:"3.2 字节流写数据",slug:"_3-2-字节流写数据",normalizedTitle:"3.2 字节流写数据",charIndex:10242},{level:3,title:"3.3 字节流写数据的三种方式",slug:"_3-3-字节流写数据的三种方式",normalizedTitle:"3.3 字节流写数据的三种方式",charIndex:11402},{level:3,title:"3.4 字节流写数据的两个小问题",slug:"_3-4-字节流写数据的两个小问题",normalizedTitle:"3.4 字节流写数据的两个小问题",charIndex:13262},{level:3,title:"3.5 字节流写数据加异常处理",slug:"_3-5-字节流写数据加异常处理",normalizedTitle:"3.5 字节流写数据加异常处理",charIndex:14121},{level:3,title:"3.6 字节流读数据(一次读一个字节数据)",slug:"_3-6-字节流读数据-一次读一个字节数据",normalizedTitle:"3.6 字节流读数据(一次读一个字节数据)",charIndex:15184},{level:3,title:"3.7 字节流复制文本文件",slug:"_3-7-字节流复制文本文件",normalizedTitle:"3.7 字节流复制文本文件",charIndex:16085},{level:3,title:"3.8 字节流读数据(一次读一个字节数组数据)",slug:"_3-8-字节流读数据-一次读一个字节数组数据",normalizedTitle:"3.8 字节流读数据(一次读一个字节数组数据)",charIndex:17082},{level:3,title:"3.9 字节流复制图片",slug:"_3-9-字节流复制图片",normalizedTitle:"3.9 字节流复制图片",charIndex:18013},{level:3,title:"3.10  字节缓冲流-构造方法😄",slug:"_3-10-字节缓冲流-构造方法",normalizedTitle:"3.10  字节缓冲流-构造方法😄",charIndex:null},{level:3,title:"3.11 字节流-复制视频",slug:"_3-11-字节流-复制视频",normalizedTitle:"3.11 字节流-复制视频",charIndex:20646},{level:2,title:"4. 字符流 Reader和Writer😄",slug:"_4-字符流-reader和writer",normalizedTitle:"4. 字符流 reader和writer😄",charIndex:23798},{level:3,title:"4.1为什么会出现字符流",slug:"_4-1为什么会出现字符流",normalizedTitle:"4.1为什么会出现字符流",charIndex:23825},{level:3,title:"4.2 编码表",slug:"_4-2-编码表",normalizedTitle:"4.2 编码表",charIndex:24033},{level:3,title:"2.3 字符串中的编码解码问题",slug:"_2-3-字符串中的编码解码问题",normalizedTitle:"2.3 字符串中的编码解码问题",charIndex:24845},{level:3,title:"2.4 字符流中的编码解码问题",slug:"_2-4-字符流中的编码解码问题",normalizedTitle:"2.4 字符流中的编码解码问题",charIndex:25957},{level:3,title:"2.5 字符流写数据的5种方式",slug:"_2-5-字符流写数据的5种方式",normalizedTitle:"2.5 字符流写数据的5种方式",charIndex:27756},{level:3,title:"2.6 字符流读数据的2种方式【应用】",slug:"_2-6-字符流读数据的2种方式【应用】",normalizedTitle:"2.6 字符流读数据的2种方式【应用】",charIndex:29329},{level:3,title:"2.7 字符流复制Java文件",slug:"_2-7-字符流复制java文件",normalizedTitle:"2.7 字符流复制java文件",charIndex:30309},{level:3,title:"2.8 字符流复制Java文件改进版",slug:"_2-8-字符流复制java文件改进版",normalizedTitle:"2.8 字符流复制java文件改进版",charIndex:31469},{level:3,title:"2.9 字符缓冲流😄",slug:"_2-9-字符缓冲流",normalizedTitle:"2.9 字符缓冲流😄",charIndex:32509},{level:3,title:"2.10 字符缓冲流复制Java文件",slug:"_2-10-字符缓冲流复制java文件",normalizedTitle:"2.10 字符缓冲流复制java文件",charIndex:34016},{level:3,title:"2.11 字符缓冲流特有功能",slug:"_2-11-字符缓冲流特有功能",normalizedTitle:"2.11 字符缓冲流特有功能",charIndex:35165},{level:3,title:"2.12 字符缓冲流特有功能复制Java文件",slug:"_2-12-字符缓冲流特有功能复制java文件",normalizedTitle:"2.12 字符缓冲流特有功能复制java文件",charIndex:36471},{level:3,title:"2.13 IO流小结 😄",slug:"_2-13-io流小结",normalizedTitle:"2.13 io流小结 😄",charIndex:37483},{level:2,title:"5. IO特殊操作流🚗",slug:"_5-io特殊操作流",normalizedTitle:"5. io特殊操作流🚗",charIndex:37533},{level:3,title:"5.1 标准输入流",slug:"_5-1-标准输入流",normalizedTitle:"5.1 标准输入流",charIndex:37550},{level:3,title:"5.2 标准输出流",slug:"_5-2-标准输出流",normalizedTitle:"5.2 标准输出流",charIndex:38993},{level:3,title:"5.3 字节打印流",slug:"_5-3-字节打印流",normalizedTitle:"5.3 字节打印流",charIndex:39954},{level:3,title:"5.4 字符打印流",slug:"_5-4-字符打印流",normalizedTitle:"5.4 字符打印流",charIndex:40972},{level:3,title:"5.5 复制Java文件打印流改进版",slug:"_5-5-复制java文件打印流改进版",normalizedTitle:"5.5 复制java文件打印流改进版",charIndex:42703},{level:3,title:"5.6 对象序列化流",slug:"_5-6-对象序列化流",normalizedTitle:"5.6 对象序列化流",charIndex:44245},{level:3,title:"5.7对象反序列化流",slug:"_5-7对象反序列化流",normalizedTitle:"5.7对象反序列化流",charIndex:46826},{level:3,title:"5.8 serialVersionUID&transient",slug:"_5-8-serialversionuid-transient",normalizedTitle:"5.8 serialversionuid&amp;transient",charIndex:null},{level:2,title:"6.Properties集合",slug:"_6-properties集合",normalizedTitle:"6.properties集合",charIndex:50603},{level:3,title:"6.1 Properties作为Map集合的使用",slug:"_6-1-properties作为map集合的使用",normalizedTitle:"6.1 properties作为map集合的使用",charIndex:50622},{level:3,title:"6.2 Properties作为Map集合的特有方法",slug:"_6-2-properties作为map集合的特有方法",normalizedTitle:"6.2 properties作为map集合的特有方法",charIndex:51503},{level:3,title:"6.3 Properties和IO流相结合的方法",slug:"_6-3-properties和io流相结合的方法",normalizedTitle:"6.3 properties和io流相结合的方法",charIndex:53433},{level:3,title:"6.4 游戏次数案例",slug:"_6-4-游戏次数案例",normalizedTitle:"6.4 游戏次数案例",charIndex:55169}],headersStr:"1.File类😄 1.1File类概述和构造方法 1.2File类创建功能 1.3File类判断和获取功能 1.4File类删除功能 2.递归 2.1递归 2.2递归求阶乘 2.3递归遍历目录 3.IO-字节流 InputStream和OutputStream😄 3.1 IO流概述和分类 3.2 字节流写数据 3.3 字节流写数据的三种方式 3.4 字节流写数据的两个小问题 3.5 字节流写数据加异常处理 3.6 字节流读数据(一次读一个字节数据) 3.7 字节流复制文本文件 3.8 字节流读数据(一次读一个字节数组数据) 3.9 字节流复制图片 3.10  字节缓冲流-构造方法😄 3.11 字节流-复制视频 4. 字符流 Reader和Writer😄 4.1为什么会出现字符流 4.2 编码表 2.3 字符串中的编码解码问题 2.4 字符流中的编码解码问题 2.5 字符流写数据的5种方式 2.6 字符流读数据的2种方式【应用】 2.7 字符流复制Java文件 2.8 字符流复制Java文件改进版 2.9 字符缓冲流😄 2.10 字符缓冲流复制Java文件 2.11 字符缓冲流特有功能 2.12 字符缓冲流特有功能复制Java文件 2.13 IO流小结 😄 5. IO特殊操作流🚗 5.1 标准输入流 5.2 标准输出流 5.3 字节打印流 5.4 字符打印流 5.5 复制Java文件打印流改进版 5.6 对象序列化流 5.7对象反序列化流 5.8 serialVersionUID&transient 6.Properties集合 6.1 Properties作为Map集合的使用 6.2 Properties作为Map集合的特有方法 6.3 Properties和IO流相结合的方法 6.4 游戏次数案例",content:'# IO\n\n创建一个良好的I/O程序是非常复杂的。JDK开发人员编写了大量的类只为了能够创建一个良好的工具 包，想必编写I/O工具包很费劲吧。\n\nIO类设计出来，肯定是为了解决IO相关操作的，最常见的I/O读写就是网络、磁盘等。在Java中, 对文件的操作是一个典型的I/O操作。下面我们就对I/O进行一个分类。\n\n\n\n根据操作对象分类：\n\n\n\n\n# 1.File类😄\n\n\n# 1.1File类概述和构造方法\n\n * File类介绍\n   \n   * 它是文件和目录路径名的抽象表示\n   * 文件和目录是可以通过File封装成对象的\n   * 对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的\n\n * File类的构造方法\n   \n   方法名                                 说明\n   File(String pathname)               通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例\n   File(String parent, String child)   从父路径名字符串和子路径名字符串创建新的 File实例\n   File(File parent, String child)     从父抽象路径名和子路径名字符串创建新的 File实例\n\n * 示例代码\n   \n   public class FileDemo01 {\n       public static void main(String[] args) {\n           //File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。\n           File f1 = new File("E:\\\\itcast\\\\java.txt");\n           System.out.println(f1);\n   \n           //File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的 File实例。\n           File f2 = new File("E:\\\\itcast","java.txt");\n           System.out.println(f2);\n   \n           //File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。\n           File f3 = new File("E:\\\\itcast");\n           File f4 = new File(f3,"java.txt");\n           System.out.println(f4);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n\n# 1.2File类创建功能\n\n * 方法分类\n   \n   方法名                              说明\n   public boolean createNewFile()   当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件\n   public boolean mkdir()           创建由此抽象路径名命名的目录\n   public boolean mkdirs()          创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录\n\n * 示例代码\n   \n   public class FileDemo02 {\n       public static void main(String[] args) throws IOException {\n           //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt\n           File f1 = new File("E:\\\\itcast\\\\java.txt");\n           System.out.println(f1.createNewFile());\n           System.out.println("--------");\n   \n           //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE\n           File f2 = new File("E:\\\\itcast\\\\JavaSE");\n           System.out.println(f2.mkdir());\n           System.out.println("--------");\n   \n           //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML\n           File f3 = new File("E:\\\\itcast\\\\JavaWEB\\\\HTML");\n   //        System.out.println(f3.mkdir());\n           System.out.println(f3.mkdirs());\n           System.out.println("--------");\n   \n           //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt\n           File f4 = new File("E:\\\\itcast\\\\javase.txt");\n   //        System.out.println(f4.mkdir());\n           System.out.println(f4.createNewFile());\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 1.3File类判断和获取功能\n\n * 判断功能\n   \n   方法名                            说明\n   public boolean isDirectory()   测试此抽象路径名表示的File是否为目录\n   public boolean isFile()        测试此抽象路径名表示的File是否为文件\n   public boolean exists()        测试此抽象路径名表示的File是否存在\n\n * 获取功能\n   \n   方法名                               说明\n   public String getAbsolutePath()   返回此抽象路径名的绝对路径名字符串\n   public String getPath()           将此抽象路径名转换为路径名字符串\n   public String getName()           返回由此抽象路径名表示的文件或目录的名称\n   public String[] list()            返回此抽象路径名表示的目录中的文件和目录的名称字符串数组\n   public File[] listFiles()         返回此抽象路径名表示的目录中的文件和目录的File对象数组\n\n * 示例代码\n   \n   public class FileDemo04 {\n       public static void main(String[] args) {\n           //创建一个File对象\n           File f = new File("myFile\\\\java.txt");\n   \n   //        public boolean isDirectory()：测试此抽象路径名表示的File是否为目录\n   //        public boolean isFile()：测试此抽象路径名表示的File是否为文件\n   //        public boolean exists()：测试此抽象路径名表示的File是否存在\n           System.out.println(f.isDirectory());\n           System.out.println(f.isFile());\n           System.out.println(f.exists());\n   \n   //        public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串\n   //        public String getPath()：将此抽象路径名转换为路径名字符串\n   //        public String getName()：返回由此抽象路径名表示的文件或目录的名称\n           System.out.println(f.getAbsolutePath());\n           System.out.println(f.getPath());\n           System.out.println(f.getName());\n           System.out.println("--------");\n   \n   //        public String[] list()：返回此抽象路径名表示的目录中的文件和目录的名称字符串数组\n   //        public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组\n           File f2 = new File("E:\\\\itcast");\n   \n           String[] strArray = f2.list();\n           for(String str : strArray) {\n               System.out.println(str);\n           }\n           System.out.println("--------");\n   \n           File[] fileArray = f2.listFiles();\n           for(File file : fileArray) {\n   //            System.out.println(file);\n   //            System.out.println(file.getName());\n               if(file.isFile()) {\n                   System.out.println(file.getName());\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   \n\n\n# 1.4File类删除功能\n\n * 方法分类\n   \n   方法名                       说明\n   public boolean delete()   删除由此抽象路径名表示的文件或目录\n\n * 示例代码\n   \n   public class FileDemo03 {\n       public static void main(String[] args) throws IOException {\n   //        File f1 = new File("E:\\\\itcast\\\\java.txt");\n           //需求1：在当前模块目录下创建java.txt文件\n           File f1 = new File("myFile\\\\java.txt");\n   //        System.out.println(f1.createNewFile());\n   \n           //需求2：删除当前模块目录下的java.txt文件\n           System.out.println(f1.delete());\n           System.out.println("--------");\n   \n           //需求3：在当前模块目录下创建itcast目录\n           File f2 = new File("myFile\\\\itcast");\n   //        System.out.println(f2.mkdir());\n   \n           //需求4：删除当前模块目录下的itcast目录\n           System.out.println(f2.delete());\n           System.out.println("--------");\n   \n           //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt\n           File f3 = new File("myFile\\\\itcast");\n   //        System.out.println(f3.mkdir());\n           File f4 = new File("myFile\\\\itcast\\\\java.txt");\n   //        System.out.println(f4.createNewFile());\n   \n           //需求6：删除当前模块下的目录itcast\n           System.out.println(f4.delete());\n           System.out.println(f3.delete());\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n * 绝对路径和相对路径的区别\n   \n   * 绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E:\\itcast\\java.txt\n   * 相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile\\java.txt\n\n\n# 2.递归\n\n\n# 2.1递归\n\n * 递归的介绍\n   \n   * 以编程的角度来看，递归指的是方法定义中调用方法本身的现象\n   * 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解\n   * 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算\n\n * 递归的基本使用\n   \n   public class DiGuiDemo {\n       public static void main(String[] args) {\n           //回顾不死神兔问题，求第20个月兔子的对数\n           //每个月的兔子对数：1,1,2,3,5,8，...\n           int[] arr = new int[20];\n   \n           arr[0] = 1;\n           arr[1] = 1;\n   \n           for (int i = 2; i < arr.length; i++) {\n               arr[i] = arr[i - 1] + arr[i - 2];\n           }\n           System.out.println(arr[19]);\n           System.out.println(f(20));\n       }\n   \n       /*\n           递归解决问题，首先就是要定义一个方法：\n               定义一个方法f(n)：表示第n个月的兔子对数\n               那么，第n-1个月的兔子对数该如何表示呢？f(n-1)\n               同理，第n-2个月的兔子对数该如何表示呢？f(n-2)\n   \n           StackOverflowError:当堆栈溢出发生时抛出一个应用程序递归太深\n        */\n       public static int f(int n) {\n           if(n==1 || n==2) {\n               return 1;\n           } else {\n               return f(n - 1) + f(n - 2);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n * 递归的注意事项\n   \n   * 递归一定要有出口。否则内存溢出\n   * 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出\n\n\n# 2.2递归求阶乘\n\n * 案例需求\n   \n   用递归求5的阶乘，并把结果在控制台输出\n\n * 代码实现\n   \n   public class DiGuiDemo01 {\n       public static void main(String[] args) {\n           //调用方法\n           int result = jc(5);\n           //输出结果\n           System.out.println("5的阶乘是：" + result);\n       }\n   \n       //定义一个方法，用于递归求阶乘，参数为一个int类型的变量\n       public static int jc(int n) {\n           //在方法内部判断该变量的值是否是1\n           if(n == 1) {\n               //是：返回1\n               return 1;\n           } else {\n               //不是：返回n*(n-1)!\n               return n*jc(n-1);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 2.3递归遍历目录\n\n * 案例需求\n   \n   给定一个路径(E:\\itcast)，通过递归完成遍历该目录下所有内容，并把所有文件的绝对路径输出在控制台\n\n * 代码实现\n   \n   public class DiGuiDemo02 {\n       public static void main(String[] args) {\n           //根据给定的路径创建一个File对象\n   //        File srcFile = new File("E:\\\\itcast");\n           File srcFile = new File("E:\\\\itheima");\n   \n           //调用方法\n           getAllFilePath(srcFile);\n       }\n   \n       //定义一个方法，用于获取给定目录下的所有内容，参数为第1步创建的File对象\n       public static void getAllFilePath(File srcFile) {\n           //获取给定的File目录下所有的文件或者目录的File数组\n           File[] fileArray = srcFile.listFiles();\n           //遍历该File数组，得到每一个File对象\n           if(fileArray != null) {\n               for(File file : fileArray) {\n                   //判断该File对象是否是目录\n                   if(file.isDirectory()) {\n                       //是：递归调用\n                       getAllFilePath(file);\n                   } else {\n                       //不是：获取绝对路径输出在控制台\n                       System.out.println(file.getAbsolutePath());\n                   }\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n\n\n# 3.IO-字节流 InputStream和OutputStream😄\n\n\n# 3.1 IO流概述和分类\n\n * IO流介绍\n   * IO：输入/输出(Input/Output)\n   * 流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输\n   * IO流就是用来处理设备间数据传输问题的。常见的应用：文件复制；文件上传；文件下载\n * IO流的分类\n   * 按照数据的流向\n     * 输入流：读数据\n     * 输出流：写数据\n   * 按照数据类型来分\n     * 字节流\n       * 字节输入流\n       * 字节输出流\n     * 字符流\n       * 字符输入流\n       * 字符输出流\n * IO流的使用场景\n   * 如果操作的是纯文本文件，优先使用字符流\n   * 如果操作的是图片、视频、音频等二进制文件。优先使用字节流\n   * 如果不确定文件类型，优先使用字节流。字节流是万能的流\n\n\n# 3.2 字节流写数据\n\n * 字节流抽象基类\n   \n   * InputStream：这个抽象类是表示字节输入流的所有类的超类\n   * OutputStream：这个抽象类是表示字节输出流的所有类的超类\n   * 子类名特点：子类名称都是以其父类名作为子类名的后缀\n\n * 字节输出流\n   \n   * FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n\n * 使用字节输出流写数据的步骤\n   \n   * 创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件)\n   * 调用字节输出流对象的写数据方法\n   * 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)\n\n * 示例代码\n   \n   public class FileOutputStreamDemo01 {\n       public static void main(String[] args) throws IOException {\n           //创建字节输出流对象\n           //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n           FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n           /*\n               做了三件事情：\n                   A:调用系统功能创建了文件\n                   B:创建了字节输出流对象\n                   C:让字节输出流对象指向创建好的文件\n            */\n   \n           //void write(int b)：将指定的字节写入此文件输出流\n           fos.write(97);\n   //        fos.write(57);\n   //        fos.write(55);\n   \n           //最后都要释放资源\n           //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。\n           fos.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 3.3 字节流写数据的三种方式\n\n * 写数据的方法分类\n   \n   方法名                                      说明\n   void write(int b)                        将指定的字节写入此文件输出流 一次写一个字节数据\n   void write(byte[] b)                     将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据\n   void write(byte[] b, int off, int len)   将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据\n\n * 示例代码\n   \n   public class FileOutputStreamDemo02 {\n       public static void main(String[] args) throws IOException {\n           //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n           FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n           //new File(name)\n   //        FileOutputStream fos = new FileOutputStream(new File("myByteStream\\\\fos.txt"));\n   \n           //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件\n   //        File file = new File("myByteStream\\\\fos.txt");\n   //        FileOutputStream fos2 = new FileOutputStream(file);\n   //        FileOutputStream fos2 = new FileOutputStream(new File("myByteStream\\\\fos.txt"));\n   \n           //void write(int b)：将指定的字节写入此文件输出流\n   //        fos.write(97);\n   //        fos.write(98);\n   //        fos.write(99);\n   //        fos.write(100);\n   //        fos.write(101);\n   \n   //        void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流\n   //        byte[] bys = {97, 98, 99, 100, 101};\n           //byte[] getBytes()：返回字符串对应的字节数组\n           byte[] bys = "abcde".getBytes();\n   //        fos.write(bys);\n   \n           //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流\n   //        fos.write(bys,0,bys.length);\n           fos.write(bys,1,3);\n   \n           //释放资源\n           fos.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   \n\n\n# 3.4 字节流写数据的两个小问题\n\n * 字节流写数据如何实现换行\n   \n   * windows:\\r\\n\n   * linux:\\n\n   * mac:\\r\n\n * 字节流写数据如何实现追加写入\n   \n   * public FileOutputStream(String name,boolean append)\n   * 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头\n\n * 示例代码\n   \n   public class FileOutputStreamDemo03 {\n       public static void main(String[] args) throws IOException {\n           //创建字节输出流对象\n   //        FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt");\n           FileOutputStream fos = new FileOutputStream("myByteStream\\\\fos.txt",true);\n   \n           //写数据\n           for (int i = 0; i < 10; i++) {\n               fos.write("hello".getBytes());\n               fos.write("\\r\\n".getBytes());\n           }\n   \n           //释放资源\n           fos.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n\n# 3.5 字节流写数据加异常处理\n\n * 异常处理格式\n   \n   * try-catch-finally\n     \n     try{\n     \t可能出现异常的代码;\n     }catch(异常类名 变量名){\n     \t异常的处理代码;\n     }finally{\n     \t执行所有清除操作;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n   \n   * finally特点\n     \n     * 被finally控制的语句一定会执行，除非JVM退出\n\n * 示例代码\n   \n   public class FileOutputStreamDemo04 {\n       public static void main(String[] args) {\n           //加入finally来实现释放资源\n           FileOutputStream fos = null;\n           try {\n               fos = new FileOutputStream("myByteStream\\\\fos.txt");\n               fos.write("hello".getBytes());\n           } catch (IOException e) {\n               e.printStackTrace();\n           } finally {\n               if(fos != null) {\n                   try {\n                       fos.close();\n                   } catch (IOException e) {\n                       e.printStackTrace();\n                   }\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 3.6 字节流读数据(一次读一个字节数据)\n\n * 字节输入流\n   \n   * FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream ，该文件由文件系统中的路径名name命名\n\n * 字节输入流读取数据的步骤\n   \n   * 创建字节输入流对象\n   * 调用字节输入流对象的读数据方法\n   * 释放资源\n\n * 示例代码\n   \n   public class FileInputStreamDemo01 {\n       public static void main(String[] args) throws IOException {\n           //创建字节输入流对象\n           //FileInputStream(String name)\n           FileInputStream fis = new FileInputStream("myByteStream\\\\fos.txt");\n   \n           int by;\n           /*\n               fis.read()：读数据\n               by=fis.read()：把读取到的数据赋值给by\n               by != -1：判断读取到的数据是否是-1\n            */\n           while ((by=fis.read())!=-1) {\n               System.out.print((char)by);\n           }\n   \n           //释放资源\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 3.7 字节流复制文本文件\n\n * 案例需求\n   \n   把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt”\n\n * 实现步骤\n   \n   * 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地)\n   \n   * 数据源：\n     \n     E:\\itcast\\窗里窗外.txt --- 读数据 --- InputStream --- FileInputStream\n   \n   * 目的地：\n     \n     myByteStream\\窗里窗外.txt --- 写数据 --- OutputStream --- FileOutputStream\n\n * 代码实现\n   \n   public class CopyTxtDemo {\n       public static void main(String[] args) throws IOException {\n           //根据数据源创建字节输入流对象\n           FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\窗里窗外.txt");\n           //根据目的地创建字节输出流对象\n           FileOutputStream fos = new FileOutputStream("myByteStream\\\\窗里窗外.txt");\n   \n           //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节)\n           int by;\n           while ((by=fis.read())!=-1) {\n               fos.write(by);\n           }\n   \n           //释放资源\n           fos.close();\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 3.8 字节流读数据(一次读一个字节数组数据)\n\n * 一次读一个字节数组的方法\n   \n   * public int read(byte[] b)：从输入流读取最多b.length个字节的数据\n   * 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数\n\n * 示例代码\n   \n   public class FileInputStreamDemo02 {\n       public static void main(String[] args) throws IOException {\n           //创建字节输入流对象\n           FileInputStream fis = new FileInputStream("myByteStream\\\\fos.txt");\n   \n           /*\n               hello\\r\\n\n               world\\r\\n\n   \n               第一次：hello\n               第二次：\\r\\nwor\n               第三次：ld\\r\\nr\n   \n            */\n   \n           byte[] bys = new byte[1024]; //1024及其整数倍\n           int len;\n           while ((len=fis.read(bys))!=-1) {\n               System.out.print(new String(bys,0,len));\n           }\n   \n           //释放资源\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n\n\n# 3.9 字节流复制图片\n\n * 案例需求\n   \n   把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg”\n\n * 实现步骤\n   \n   * 根据数据源创建字节输入流对象\n   * 根据目的地创建字节输出流对象\n   * 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n   * 释放资源\n\n * 代码实现\n   \n   public class CopyJpgDemo {\n       public static void main(String[] args) throws IOException {\n           //根据数据源创建字节输入流对象\n           FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\mn.jpg");\n           //根据目的地创建字节输出流对象\n           FileOutputStream fos = new FileOutputStream("myByteStream\\\\mn.jpg");\n   \n           //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n           byte[] bys = new byte[1024];\n           int len;\n           while ((len=fis.read(bys))!=-1) {\n               fos.write(bys,0,len);\n           }\n   \n           //释放资源\n           fos.close();\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n\n# 3.10 字节缓冲流-构造方法😄\n\n * 字节缓冲流介绍\n   \n   * lBufferOutputStream：该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用\n   \n   * lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。 当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节\n\n * 构造方法：\n   \n   方法名                                      说明\n   BufferedOutputStream(OutputStream out)   创建字节缓冲输出流对象\n   BufferedInputStream(InputStream in)      创建字节缓冲输入流对象\n\n * 示例代码\n   \n   public class BufferStreamDemo {\n       public static void main(String[] args) throws IOException {\n           //字节缓冲输出流：BufferedOutputStream(OutputStream out)\n    \n           BufferedOutputStream bos = new BufferedOutputStream(new \t\t\t\t                                       FileOutputStream("myByteStream\\\\bos.txt"));\n           //写数据\n           bos.write("hello\\r\\n".getBytes());\n           bos.write("world\\r\\n".getBytes());\n           //释放资源\n           bos.close();\n       \n   \n           //字节缓冲输入流：BufferedInputStream(InputStream in)\n           BufferedInputStream bis = new BufferedInputStream(new                                                          FileInputStream("myByteStream\\\\bos.txt"));\n   \n           //一次读取一个字节数据\n   //        int by;\n   //        while ((by=bis.read())!=-1) {\n   //            System.out.print((char)by);\n   //        }\n   \n           //一次读取一个字节数组数据\n           byte[] bys = new byte[1024];\n           int len;\n           while ((len=bis.read(bys))!=-1) {\n               System.out.print(new String(bys,0,len));\n           }\n   \n           //释放资源\n           bis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n\n# 3.11 字节流-复制视频\n\n * 案例需求\n   \n   把“E:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi”\n\n * 实现步骤\n   \n   * 根据数据源创建字节输入流对象\n   \n   * 根据目的地创建字节输出流对象\n   \n   * 读写数据，复制视频\n   \n   * 释放资源\n\n * 代码实现\n   \n   public class CopyAviDemo {\n       public static void main(String[] args) throws IOException {\n           //记录开始时间\n           long startTime = System.currentTimeMillis();\n   \n           //复制视频\n   //        method1();\n   //        method2();\n   //        method3();\n           method4();\n   \n           //记录结束时间\n           long endTime = System.currentTimeMillis();\n           System.out.println("共耗时：" + (endTime - startTime) + "毫秒");\n       }\n   \n       //字节缓冲流一次读写一个字节数组\n       public static void method4() throws IOException {\n           BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi"));\n           BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myByteStream\\\\字节流复制图片.avi"));\n   \n           byte[] bys = new byte[1024];\n           int len;\n           while ((len=bis.read(bys))!=-1) {\n               bos.write(bys,0,len);\n           }\n   \n           bos.close();\n           bis.close();\n       }\n   \n       //字节缓冲流一次读写一个字节\n       public static void method3() throws IOException {\n           BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi"));\n           BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myByteStream\\\\字节流复制图片.avi"));\n   \n           int by;\n           while ((by=bis.read())!=-1) {\n               bos.write(by);\n           }\n   \n           bos.close();\n           bis.close();\n       }\n   \n   \n       //基本字节流一次读写一个字节数组\n       public static void method2() throws IOException {\n           //E:\\\\itcast\\\\字节流复制图片.avi\n           //模块目录下的 字节流复制图片.avi\n           FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi");\n           FileOutputStream fos = new FileOutputStream("myByteStream\\\\字节流复制图片.avi");\n   \n           byte[] bys = new byte[1024];\n           int len;\n           while ((len=fis.read(bys))!=-1) {\n               fos.write(bys,0,len);\n           }\n   \n           fos.close();\n           fis.close();\n       }\n   \n       //基本字节流一次读写一个字节\n       public static void method1() throws IOException {\n           //E:\\\\itcast\\\\字节流复制图片.avi\n           //模块目录下的 字节流复制图片.avi\n           FileInputStream fis = new FileInputStream("E:\\\\itcast\\\\字节流复制图片.avi");\n           FileOutputStream fos = new FileOutputStream("myByteStream\\\\字节流复制图片.avi");\n   \n           int by;\n           while ((by=fis.read())!=-1) {\n               fos.write(by);\n           }\n   \n           fos.close();\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   \n\n\n# 4. 字符流 Reader和Writer😄\n\n\n# 4.1为什么会出现字符流\n\n * 字符流的介绍\n   \n   由于字节流操作中文不是特别的方便，所以Java就提供字符流\n   \n   字符流 = 字节流 + 编码表\n\n * 中文的字节存储方式\n   \n   用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？\n   \n   汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数\n\n\n# 4.2 编码表\n\n * 什么是字符集\n   \n   是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n   \n   l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等\n\n * 常见的字符集\n   \n   * ASCII字符集：\n     \n     lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号)\n     \n     基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n   \n   * GBXXX字符集：\n     \n     GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等\n   \n   * Unicode字符集：\n     \n     UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码\n     \n     编码规则：\n     \n     128个US-ASCII字符，只需一个字节编码\n     \n     拉丁文等字符，需要二个字节编码\n     \n     大部分常用字（含中文），使用三个字节编码\n     \n     其他极少使用的Unicode辅助字符，使用四字节编码\n\n\n# 2.3 字符串中的编码解码问题\n\n * 相关方法\n   \n   方法名                                        说明\n   byte[] getBytes()                          使用平台的默认字符集将该 String编码为一系列字节\n   byte[] getBytes(String charsetName)        使用指定的字符集将该 String编码为一系列字节\n   String(byte[] bytes)                       使用平台的默认字符集解码指定的字节数组来创建字符串\n   String(byte[] bytes, String charsetName)   通过指定的字符集解码指定的字节数组来创建字符串\n\n * 代码演示\n   \n   public class StringDemo {\n       public static void main(String[] args) throws UnsupportedEncodingException {\n           //定义一个字符串\n           String s = "中国";\n   \n           //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67]\n           //byte[] bys = s.getBytes("UTF-8"); //[-28, -72, -83, -27, -101, -67]\n           byte[] bys = s.getBytes("GBK"); //[-42, -48, -71, -6]\n           System.out.println(Arrays.toString(bys));\n   \n           //String ss = new String(bys);\n           //String ss = new String(bys,"UTF-8");\n           String ss = new String(bys,"GBK");\n           System.out.println(ss);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n\n# 2.4 字符流中的编码解码问题\n\n * 字符流中和编码解码问题相关的两个类\n   \n   * InputStreamReader：是从字节流到字符流的桥梁\n     \n     它读取字节，并使用指定的编码将其解码为字符\n     \n     它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n   \n   * OutputStreamWriter：是从字符流到字节流的桥梁\n     \n     是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节\n     \n     它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n\n * 构造方法\n   \n   方法名                                                   说明\n   InputStreamReader(InputStream in)                     使用默认字符编码创建InputStreamReader对象\n   InputStreamReader(InputStream in,String chatset)      使用指定的字符编码创建InputStreamReader对象\n   OutputStreamWriter(OutputStream out)                  使用默认字符编码创建OutputStreamWriter对象\n   OutputStreamWriter(OutputStream out,String charset)   使用指定的字符编码创建OutputStreamWriter对象\n\n * 代码演示\n   \n   public class ConversionStreamDemo {\n       public static void main(String[] args) throws IOException {\n           //OutputStreamWriter osw = new OutputStreamWriter(new                                             FileOutputStream("myCharStream\\\\osw.txt"));\n           OutputStreamWriter osw = new OutputStreamWriter(new                                              FileOutputStream("myCharStream\\\\osw.txt"),"GBK");\n           osw.write("中国");\n           osw.close();\n   \n           //InputStreamReader isr = new InputStreamReader(new \t                                         FileInputStream("myCharStream\\\\osw.txt"));\n           InputStreamReader isr = new InputStreamReader(new                                                 FileInputStream("myCharStream\\\\osw.txt"),"GBK");\n           //一次读取一个字符数据\n           int ch;\n           while ((ch=isr.read())!=-1) {\n               System.out.print((char)ch);\n           }\n           isr.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n\n# 2.5 字符流写数据的5种方式\n\n * 方法介绍\n   \n   方法名                                         说明\n   void write(int c)                           写一个字符\n   void write(char[] cbuf)                     写入一个字符数组\n   void write(char[] cbuf, int off, int len)   写入字符数组的一部分\n   void write(String str)                      写一个字符串\n   void write(String str, int off, int len)    写一个字符串的一部分\n\n * 刷新和关闭的方法\n   \n   方法名       说明\n   flush()   刷新流，之后还可以继续写数据\n   close()   关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据\n\n * 代码演示\n   \n   public class OutputStreamWriterDemo {\n       public static void main(String[] args) throws IOException {\n           OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("myCharStream\\\\osw.txt"));\n   \n           //void write(int c)：写一个字符\n   //        osw.write(97);\n   //        osw.write(98);\n   //        osw.write(99);\n   \n           //void writ(char[] cbuf)：写入一个字符数组\n           char[] chs = {\'a\', \'b\', \'c\', \'d\', \'e\'};\n   //        osw.write(chs);\n   \n           //void write(char[] cbuf, int off, int len)：写入字符数组的一部分\n   //        osw.write(chs, 0, chs.length);\n   //        osw.write(chs, 1, 3);\n   \n           //void write(String str)：写一个字符串\n   //        osw.write("abcde");\n   \n           //void write(String str, int off, int len)：写一个字符串的一部分\n   //        osw.write("abcde", 0, "abcde".length());\n           osw.write("abcde", 1, 3);\n   \n           //释放资源\n           osw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n\n\n# 2.6 字符流读数据的2种方式【应用】\n\n * 方法介绍\n   \n   方法名                     说明\n   int read()              一次读一个字符数据\n   int read(char[] cbuf)   一次读一个字符数组数据\n\n * 代码演示\n   \n   public class InputStreamReaderDemo {\n       public static void main(String[] args) throws IOException {\n      \n           InputStreamReader isr = new InputStreamReader(new FileInputStream("myCharStream\\\\ConversionStreamDemo.java"));\n   \n           //int read()：一次读一个字符数据\n   //        int ch;\n   //        while ((ch=isr.read())!=-1) {\n   //            System.out.print((char)ch);\n   //        }\n   \n           //int read(char[] cbuf)：一次读一个字符数组数据\n           char[] chs = new char[1024];\n           int len;\n           while ((len = isr.read(chs)) != -1) {\n               System.out.print(new String(chs, 0, len));\n           }\n   \n           //释放资源\n           isr.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 2.7 字符流复制Java文件\n\n * 案例需求\n   \n   把模块目录下的“ConversionStreamDemo.java” 复制到模块目录下的“Copy.java”\n\n * 实现步骤\n   \n   * 根据数据源创建字符输入流对象\n   * 根据目的地创建字符输出流对象\n   * 读写数据，复制文件\n   * 释放资源\n\n * 代码实现\n   \n   public class CopyJavaDemo01 {\n       public static void main(String[] args) throws IOException {\n           //根据数据源创建字符输入流对象\n           InputStreamReader isr = new InputStreamReader(new FileInputStream("myCharStream\\\\ConversionStreamDemo.java"));\n           //根据目的地创建字符输出流对象\n           OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("myCharStream\\\\Copy.java"));\n   \n           //读写数据，复制文件\n           //一次读写一个字符数据\n   //        int ch;\n   //        while ((ch=isr.read())!=-1) {\n   //            osw.write(ch);\n   //        }\n   \n           //一次读写一个字符数组数据\n           char[] chs = new char[1024];\n           int len;\n           while ((len=isr.read(chs))!=-1) {\n               osw.write(chs,0,len);\n           }\n   \n           //释放资源\n           osw.close();\n           isr.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n\n# 2.8 字符流复制Java文件改进版\n\n * 案例需求\n   \n   使用便捷流对象，把模块目录下的“ConversionStreamDemo.java” 复制到模块目录下的“Copy.java”\n\n * 实现步骤\n   \n   * 根据数据源创建字符输入流对象\n   \n   * 根据目的地创建字符输出流对象\n   \n   * 读写数据，复制文件\n   \n   * 释放资源\n\n * 代码实现\n   \n   public class CopyJavaDemo02 {\n       public static void main(String[] args) throws IOException {\n           //根据数据源创建字符输入流对象\n           FileReader fr = new FileReader("myCharStream\\\\ConversionStreamDemo.java");\n           //根据目的地创建字符输出流对象\n           FileWriter fw = new FileWriter("myCharStream\\\\Copy.java");\n   \n           //读写数据，复制文件\n   //        int ch;\n   //        while ((ch=fr.read())!=-1) {\n   //            fw.write(ch);\n   //        }\n   \n           char[] chs = new char[1024];\n           int len;\n           while ((len=fr.read(chs))!=-1) {\n               fw.write(chs,0,len);\n           }\n   \n           //释放资源\n           fw.close();\n           fr.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 2.9 字符缓冲流😄\n\n * 字符缓冲流介绍\n   \n   * BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途\n   \n   * BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途\n\n * 构造方法\n   \n   方法名                          说明\n   BufferedWriter(Writer out)   创建字符缓冲输出流对象\n   BufferedReader(Reader in)    创建字符缓冲输入流对象\n\n * 代码演示\n   \n   public class BufferedStreamDemo01 {\n       public static void main(String[] args) throws IOException {\n           //BufferedWriter(Writer out)\n           BufferedWriter bw = new BufferedWriter(new                                                            FileWriter("myCharStream\\\\bw.txt"));\n           bw.write("hello\\r\\n");\n           bw.write("world\\r\\n");\n           bw.close();\n   \n           //BufferedReader(Reader in)\n           BufferedReader br = new BufferedReader(new                                                           FileReader("myCharStream\\\\bw.txt"));\n   \n           //一次读取一个字符数据\n   //        int ch;\n   //        while ((ch=br.read())!=-1) {\n   //            System.out.print((char)ch);\n   //        }\n   \n           //一次读取一个字符数组数据\n           char[] chs = new char[1024];\n           int len;\n           while ((len=br.read(chs))!=-1) {\n               System.out.print(new String(chs,0,len));\n           }\n   \n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   \n\n\n# 2.10 字符缓冲流复制Java文件\n\n * 案例需求\n   \n   把模块目录下的ConversionStreamDemo.java 复制到模块目录下的 Copy.java\n\n * 实现步骤\n   \n   * 根据数据源创建字符缓冲输入流对象\n   * 根据目的地创建字符缓冲输出流对象\n   * 读写数据，复制文件，使用字符缓冲流特有功能实现\n   * 释放资源\n\n * 代码实现\n   \n   public class CopyJavaDemo01 {\n       public static void main(String[] args) throws IOException {\n           //根据数据源创建字符缓冲输入流对象\n           BufferedReader br = new BufferedReader(new FileReader("myCharStream\\\\ConversionStreamDemo.java"));\n           //根据目的地创建字符缓冲输出流对象\n           BufferedWriter bw = new BufferedWriter(new FileWriter("myCharStream\\\\Copy.java"));\n   \n           //读写数据，复制文件\n           //一次读写一个字符数据\n   //        int ch;\n   //        while ((ch=br.read())!=-1) {\n   //            bw.write(ch);\n   //        }\n   \n           //一次读写一个字符数组数据\n           char[] chs = new char[1024];\n           int len;\n           while ((len=br.read(chs))!=-1) {\n               bw.write(chs,0,len);\n           }\n   \n           //释放资源\n           bw.close();\n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n\n# 2.11 字符缓冲流特有功能\n\n * 方法介绍\n   \n   BufferedWriter：\n   \n   方法名              说明\n   void newLine()   写一行行分隔符，行分隔符字符串由系统属性定义\n   \n   BufferedReader:\n   \n   方法名                 说明\n   String readLine()   读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null\n\n * 代码演示\n   \n   public class BufferedStreamDemo02 {\n       public static void main(String[] args) throws IOException {\n   \n           //创建字符缓冲输出流\n           BufferedWriter bw = new BufferedWriter(new                                                          FileWriter("myCharStream\\\\bw.txt"));\n   \n           //写数据\n           for (int i = 0; i < 10; i++) {\n               bw.write("hello" + i);\n               //bw.write("\\r\\n");\n               bw.newLine();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n   \n           //创建字符缓冲输入流\n           BufferedReader br = new BufferedReader(new                                                          FileReader("myCharStream\\\\bw.txt"));\n   \n           String line;\n           while ((line=br.readLine())!=null) {\n               System.out.println(line);\n           }\n   \n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n\n\n# 2.12 字符缓冲流特有功能复制Java文件\n\n * 案例需求\n   \n   使用特有功能把模块目录下的ConversionStreamDemo.java 复制到模块目录下的 Copy.java\n\n * 实现步骤\n   \n   * 根据数据源创建字符缓冲输入流对象\n   * 根据目的地创建字符缓冲输出流对象\n   * 读写数据，复制文件，使用字符缓冲流特有功能实现\n   * 释放资源\n\n * 代码实现\n   \n   public class CopyJavaDemo02 {\n       public static void main(String[] args) throws IOException {\n           //根据数据源创建字符缓冲输入流对象\n           BufferedReader br = new BufferedReader(new FileReader("myCharStream\\\\ConversionStreamDemo.java"));\n           //根据目的地创建字符缓冲输出流对象\n           BufferedWriter bw = new BufferedWriter(new FileWriter("myCharStream\\\\Copy.java"));\n   \n           //读写数据，复制文件\n           //使用字符缓冲流特有功能实现\n           String line;\n           while ((line=br.readLine())!=null) {\n               bw.write(line);\n               bw.newLine();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 2.13 IO流小结 😄\n\n * 字节流\n   \n   \n\n * 字符流\n   \n   \n\n\n# 5. IO特殊操作流🚗\n\n\n# 5.1 标准输入流\n\n * System类中有两个静态的成员变量\n   \n   * public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源\n   * public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标\n\n * 自己实现键盘录入数据\n   \n   public class SystemInDemo {\n       public static void main(String[] args) throws IOException {\n           //public static final InputStream in：标准输入流\n   //        InputStream is = System.in;\n   \n   //        int by;\n   //        while ((by=is.read())!=-1) {\n   //            System.out.print((char)by);\n   //        }\n   \n           //如何把字节流转换为字符流？用转换流\n   //        InputStreamReader isr = new InputStreamReader(is);\n   //        //使用字符流能不能够实现一次读取一行数据呢？可以\n   //        //但是，一次读取一行数据的方法是字符缓冲输入流的特有方法\n   //        BufferedReader br = new BufferedReader(isr);\n   \n           BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n   \n           System.out.println("请输入一个字符串：");\n           String line = br.readLine();\n           System.out.println("你输入的字符串是：" + line);\n   \n           System.out.println("请输入一个整数：");\n           int i = Integer.parseInt(br.readLine());\n           System.out.println("你输入的整数是：" + i);\n   \n           //自己实现键盘录入数据太麻烦了，所以Java就提供了一个类供我们使用\n           Scanner sc = new Scanner(System.in);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n\n# 5.2 标准输出流\n\n * System类中有两个静态的成员变量\n   \n   * public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源\n   * public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标\n\n * 输出语句的本质：是一个标准的输出流\n   \n   * PrintStream ps = System.out;\n   * PrintStream类有的方法，System.out都可以使用\n\n * 示例代码\n   \n   public class SystemOutDemo {\n       public static void main(String[] args) {\n           //public static final PrintStream out：标准输出流\n           PrintStream ps = System.out;\n   \n           //能够方便地打印各种数据值\n   //        ps.print("hello");\n   //        ps.print(100);\n   \n   //        ps.println("hello");\n   //        ps.println(100);\n   \n           //System.out的本质是一个字节输出流\n           System.out.println("hello");\n           System.out.println(100);\n   \n           System.out.println();\n   //        System.out.print();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 5.3 字节打印流\n\n * 打印流分类\n   \n   * 字节打印流：PrintStream\n   * 字符打印流：PrintWriter\n\n * 打印流的特点\n   \n   * 只负责输出数据，不负责读取数据\n   * 永远不会抛出IOException\n   * 有自己的特有方法\n\n * 字节打印流\n   \n   * PrintStream(String fileName)：使用指定的文件名创建新的打印流\n   \n   * 使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出\n   \n   * 可以改变输出语句的目的地\n     \n     public static void setOut(PrintStream out)：重新分配“标准”输出流\n\n * 示例代码\n   \n   public class PrintStreamDemo {\n       public static void main(String[] args) throws IOException {\n           //PrintStream(String fileName)：使用指定的文件名创建新的打印流\n           PrintStream ps = new PrintStream("myOtherStream\\\\ps.txt");\n   \n           //写数据\n           //字节输出流有的方法\n   //        ps.write(97);\n   \n           //使用特有方法写数据\n   //        ps.print(97);\n   //        ps.println();\n   //        ps.print(98);\n           ps.println(97);\n           ps.println(98);\n           \n           //释放资源\n           ps.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 5.4 字符打印流\n\n * 字符打印流构造房方法\n   \n   方法名                                          说明\n   PrintWriter(String fileName)                 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新\n   PrintWriter(Writer out, boolean autoFlush)   创建一个新的PrintWriter out：字符输出流 autoFlush： 一个布尔值，如果为真，则println ，\n                                                printf ，或format方法将刷新输出缓冲区\n\n * 示例代码\n   \n   public class PrintWriterDemo {\n       public static void main(String[] args) throws IOException {\n           //PrintWriter(String fileName) ：使用指定的文件名创建一个新的PrintWriter，而不需要自动执行行刷新\n   //        PrintWriter pw = new PrintWriter("myOtherStream\\\\pw.txt");\n   \n   //        pw.write("hello");\n   //        pw.write("\\r\\n");\n   //        pw.flush();\n   //        pw.write("world");\n   //        pw.write("\\r\\n");\n   //        pw.flush();\n   \n   //        pw.println("hello");\n           /*\n               pw.write("hello");\n               pw.write("\\r\\n");\n            */\n   //        pw.flush();\n   //        pw.println("world");\n   //        pw.flush();\n   \n           //PrintWriter(Writer out, boolean autoFlush)：创建一个新的PrintWriter\n           PrintWriter pw = new PrintWriter(new FileWriter("myOtherStream\\\\pw.txt"),true);\n   //        PrintWriter pw = new PrintWriter(new FileWriter("myOtherStream\\\\pw.txt"),false);\n   \n           pw.println("hello");\n           /*\n               pw.write("hello");\n               pw.write("\\r\\n");\n               pw.flush();\n            */\n           pw.println("world");\n   \n           pw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   \n\n\n# 5.5 复制Java文件打印流改进版\n\n * 案例需求\n   \n   * 把模块目录下的PrintStreamDemo.java 复制到模块目录下的 Copy.java\n\n * 分析步骤\n   \n   * 根据数据源创建字符输入流对象\n   * 根据目的地创建字符输出流对象\n   * 读写数据，复制文件\n   * 释放资源\n\n * 代码实现\n   \n   public class CopyJavaDemo {\n       public static void main(String[] args) throws IOException {\n           /*\n           //根据数据源创建字符输入流对象\n           BufferedReader br = new BufferedReader(new FileReader("myOtherStream\\\\PrintStreamDemo.java"));\n           //根据目的地创建字符输出流对象\n           BufferedWriter bw = new BufferedWriter(new FileWriter("myOtherStream\\\\Copy.java"));\n   \n           //读写数据，复制文件\n           String line;\n           while ((line=br.readLine())!=null) {\n               bw.write(line);\n               bw.newLine();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n           br.close();\n           */\n   \n           //根据数据源创建字符输入流对象\n           BufferedReader br = new BufferedReader(new FileReader("myOtherStream\\\\PrintStreamDemo.java"));\n           //根据目的地创建字符输出流对象\n           PrintWriter pw = new PrintWriter(new FileWriter("myOtherStream\\\\Copy.java"),true);\n   \n           //读写数据，复制文件\n           String line;\n           while ((line=br.readLine())!=null) {\n               pw.println(line);\n           }\n   \n           //释放资源\n           pw.close();\n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   \n\n\n# 5.6 对象序列化流\n\n * 对象序列化介绍\n   \n   * 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象\n   * 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息\n   * 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息\n   * 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化\n\n * 对象序列化流： ObjectOutputStream\n   \n   * 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象\n\n * 构造方法\n   \n   方法名                                    说明\n   ObjectOutputStream(OutputStream out)   创建一个写入指定的OutputStream的ObjectOutputStream\n\n * 序列化对象的方法\n   \n   方法名                            说明\n   void writeObject(Object obj)   将指定的对象写入ObjectOutputStream\n\n * 示例代码\n   \n   * 学生类\n     \n     public class Student implements Serializable {\n         private String name;\n         private int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     \n         @Override\n         public String toString() {\n             return "Student{" +\n                     "name=\'" + name + \'\\\'\' +\n                     ", age=" + age +\n                     \'}\';\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n   \n   * 测试类\n     \n     public class ObjectOutputStreamDemo {\n         public static void main(String[] args) throws IOException {\n             //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream\n             ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\\\oos.txt"));\n     \n             //创建对象\n             Student s = new Student("林青霞",30);\n     \n             //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream\n             oos.writeObject(s);\n     \n             //释放资源\n             oos.close();\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n * 注意事项\n   \n   * 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口\n   * Serializable是一个标记接口，实现该接口，不需要重写任何方法\n\n\n# 5.7对象反序列化流\n\n * 对象反序列化流： ObjectInputStream\n   \n   * ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象\n\n * 构造方法\n   \n   方法名                                 说明\n   ObjectInputStream(InputStream in)   创建从指定的InputStream读取的ObjectInputStream\n\n * 反序列化对象的方法\n   \n   方法名                   说明\n   Object readObject()   从ObjectInputStream读取一个对象\n\n * 示例代码\n   \n   public class ObjectInputStreamDemo {\n       public static void main(String[] args) throws IOException, ClassNotFoundException {\n           //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream\n           ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\\\oos.txt"));\n   \n           //Object readObject()：从ObjectInputStream读取一个对象\n           Object obj = ois.readObject();\n   \n           Student s = (Student) obj;\n           System.out.println(s.getName() + "," + s.getAge());\n   \n           ois.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n\n# 5.8 serialVersionUID&transient\n\n * serialVersionUID\n   \n   * 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？\n     * 会出问题，会抛出InvalidClassException异常\n   * 如果出问题了，如何解决呢？\n     * 重新序列化\n     * 给对象所属的类加一个serialVersionUID\n       * private static final long serialVersionUID = 42L;\n\n * transient\n   \n   * 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？\n     * 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程\n\n * 示例代码\n   \n   * 学生类\n     \n     public class Student implements Serializable {\n         private static final long serialVersionUID = 42L;\n         private String name;\n     //    private int age;\n         private transient int age;\n     \n         public Student() {\n         }\n     \n         public Student(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     \n     //    @Override\n     //    public String toString() {\n     //        return "Student{" +\n     //                "name=\'" + name + \'\\\'\' +\n     //                ", age=" + age +\n     //                \'}\';\n     //    }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     \n   \n   * 测试类\n     \n     public class ObjectStreamDemo {\n         public static void main(String[] args) throws IOException, ClassNotFoundException {\n     //        write();\n             read();\n         }\n     \n         //反序列化\n         private static void read() throws IOException, ClassNotFoundException {\n             ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\\\oos.txt"));\n             Object obj = ois.readObject();\n             Student s = (Student) obj;\n             System.out.println(s.getName() + "," + s.getAge());\n             ois.close();\n         }\n     \n         //序列化\n         private static void write() throws IOException {\n             ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\\\oos.txt"));\n             Student s = new Student("林青霞", 30);\n             oos.writeObject(s);\n             oos.close();\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     \n\n\n# 6.Properties集合\n\n\n# 6.1 Properties作为Map集合的使用\n\n * Properties介绍\n   \n   * 是一个Map体系的集合类\n   * Properties可以保存到流中或从流中加载\n   * 属性列表中的每个键及其对应的值都是一个字符串\n\n * Properties基本使用\n   \n   public class PropertiesDemo01 {\n       public static void main(String[] args) {\n           //创建集合对象\n   //        Properties<String,String> prop = new Properties<String,String>(); //错误\n           Properties prop = new Properties();\n   \n           //存储元素\n           prop.put("itheima001", "林青霞");\n           prop.put("itheima002", "张曼玉");\n           prop.put("itheima003", "王祖贤");\n   \n           //遍历集合\n           Set<Object> keySet = prop.keySet();\n           for (Object key : keySet) {\n               Object value = prop.get(key);\n               System.out.println(key + "," + value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n\n# 6.2 Properties作为Map集合的特有方法\n\n * 特有方法\n   \n   方法名                                            说明\n   Object setProperty(String key, String value)   设置集合的键和值，都是String类型，底层调用 Hashtable方法 put\n   String getProperty(String key)                 使用此属性列表中指定的键搜索属性\n   Set(String) stringPropertyNames()              从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串\n   \n   注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 Set(String) 指的是 Set<String>. \n   \n   \n   1\n   \n\n * 示例代码\n   \n   public class PropertiesDemo02 {\n       public static void main(String[] args) {\n           //创建集合对象\n           Properties prop = new Properties();\n   \n           //Object setProperty(String key, String value)：设置集合的键和值，都是String类型，底层调用Hashtable方法put\n           prop.setProperty("itheima001", "林青霞");\n           /*\n               Object setProperty(String key, String value) {\n                   return put(key, value);\n               }\n   \n               Object put(Object key, Object value) {\n                   return map.put(key, value);\n               }\n            */\n           prop.setProperty("itheima002", "张曼玉");\n           prop.setProperty("itheima003", "王祖贤");\n   \n           //String getProperty(String key)：使用此属性列表中指定的键搜索属性\n   //        System.out.println(prop.getProperty("itheima001"));\n   //        System.out.println(prop.getProperty("itheima0011"));\n   \n   //        System.out.println(prop);\n   \n           //Set<String> stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串\n           Set<String> names = prop.stringPropertyNames();\n           for (String key : names) {\n   //            System.out.println(key);\n               String value = prop.getProperty(key);\n               System.out.println(key + "," + value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   \n\n\n# 6.3 Properties和IO流相结合的方法\n\n * 和IO流结合的方法\n   \n   方法名                                             说明\n   void load(InputStream inStream)                 从输入字节流读取属性列表（键和元素对）\n   void load(Reader reader)                        从输入字符流读取属性列表（键和元素对）\n   void store(OutputStream out, String comments)   将此属性列表（键和元素对）写入此 Properties表中，以适合于使用\n                                                   load(InputStream)方法的格式写入输出字节流\n   void store(Writer writer, String comments)      将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流\n\n * 示例代码\n   \n   public class PropertiesDemo03 {\n       public static void main(String[] args) throws IOException {\n           //把集合中的数据保存到文件\n   //        myStore();\n   \n           //把文件中的数据加载到集合\n           myLoad();\n   \n       }\n   \n       private static void myLoad() throws IOException {\n           Properties prop = new Properties();\n   \n           //void load(Reader reader)：\n           FileReader fr = new FileReader("myOtherStream\\\\fw.txt");\n           prop.load(fr);\n           fr.close();\n   \n           System.out.println(prop);\n       }\n   \n       private static void myStore() throws IOException {\n           Properties prop = new Properties();\n   \n           prop.setProperty("itheima001","林青霞");\n           prop.setProperty("itheima002","张曼玉");\n           prop.setProperty("itheima003","王祖贤");\n   \n           //void store(Writer writer, String comments)：\n           FileWriter fw = new FileWriter("myOtherStream\\\\fw.txt");\n           prop.store(fw,null);\n           fw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   \n\n\n# 6.4 游戏次数案例\n\n * 案例需求\n   \n   * 实现猜数字小游戏只能试玩3次，如果还想玩，提示：游戏试玩已结束，想玩请充值(www.itcast.cn)\n\n * 分析步骤\n   \n   1. 写一个游戏类，里面有一个猜数字的小游戏\n   \n   2. 写一个测试类，测试类中有main()方法，main()方法中写如下代码：\n      \n      从文件中读取数据到Properties集合，用load()方法实现\n      \n         文件已经存在：game.txt\n      \n         里面有一个数据值：count=0\n      \n      \n      通过Properties集合获取到玩游戏的次数\n      \n      判断次数是否到到3次了\n      \n         如果到了，给出提示：游戏试玩已结束，想玩请充值(www.itcast.cn)\n      \n         如果不到3次：\n      \n         \t次数+1，重新写回文件，用Properties的store()方法实现玩游戏\n      \n\n * 代码实现\n   \n   public class PropertiesTest {\n       public static void main(String[] args) throws IOException {\n           //从文件中读取数据到Properties集合，用load()方法实现\n           Properties prop = new Properties();\n   \n           FileReader fr = new FileReader("myOtherStream\\\\game.txt");\n           prop.load(fr);\n           fr.close();\n   \n           //通过Properties集合获取到玩游戏的次数\n           String count = prop.getProperty("count");\n           int number = Integer.parseInt(count);\n   \n           //判断次数是否到到3次了\n           if(number >= 3) {\n               //如果到了，给出提示：游戏试玩已结束，想玩请充值(www.itcast.cn)\n               System.out.println("游戏试玩已结束，想玩请充值(www.itcast.cn)");\n           } else {\n               //玩游戏\n               GuessNumber.start();\n   \n               //次数+1，重新写回文件，用Properties的store()方法实现\n               number++;\n               prop.setProperty("count",String.valueOf(number));\n               FileWriter fw = new FileWriter("myOtherStream\\\\game.txt");\n               prop.store(fw,null);\n               fw.close();\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   ',normalizedContent:'# io\n\n创建一个良好的i/o程序是非常复杂的。jdk开发人员编写了大量的类只为了能够创建一个良好的工具 包，想必编写i/o工具包很费劲吧。\n\nio类设计出来，肯定是为了解决io相关操作的，最常见的i/o读写就是网络、磁盘等。在java中, 对文件的操作是一个典型的i/o操作。下面我们就对i/o进行一个分类。\n\n\n\n根据操作对象分类：\n\n\n\n\n# 1.file类😄\n\n\n# 1.1file类概述和构造方法\n\n * file类介绍\n   \n   * 它是文件和目录路径名的抽象表示\n   * 文件和目录是可以通过file封装成对象的\n   * 对于file而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的\n\n * file类的构造方法\n   \n   方法名                                 说明\n   file(string pathname)               通过将给定的路径名字符串转换为抽象路径名来创建新的 file实例\n   file(string parent, string child)   从父路径名字符串和子路径名字符串创建新的 file实例\n   file(file parent, string child)     从父抽象路径名和子路径名字符串创建新的 file实例\n\n * 示例代码\n   \n   public class filedemo01 {\n       public static void main(string[] args) {\n           //file(string pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 file实例。\n           file f1 = new file("e:\\\\itcast\\\\java.txt");\n           system.out.println(f1);\n   \n           //file(string parent, string child)：从父路径名字符串和子路径名字符串创建新的 file实例。\n           file f2 = new file("e:\\\\itcast","java.txt");\n           system.out.println(f2);\n   \n           //file(file parent, string child)：从父抽象路径名和子路径名字符串创建新的 file实例。\n           file f3 = new file("e:\\\\itcast");\n           file f4 = new file(f3,"java.txt");\n           system.out.println(f4);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n\n# 1.2file类创建功能\n\n * 方法分类\n   \n   方法名                              说明\n   public boolean createnewfile()   当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件\n   public boolean mkdir()           创建由此抽象路径名命名的目录\n   public boolean mkdirs()          创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录\n\n * 示例代码\n   \n   public class filedemo02 {\n       public static void main(string[] args) throws ioexception {\n           //需求1：我要在e:\\\\itcast目录下创建一个文件java.txt\n           file f1 = new file("e:\\\\itcast\\\\java.txt");\n           system.out.println(f1.createnewfile());\n           system.out.println("--------");\n   \n           //需求2：我要在e:\\\\itcast目录下创建一个目录javase\n           file f2 = new file("e:\\\\itcast\\\\javase");\n           system.out.println(f2.mkdir());\n           system.out.println("--------");\n   \n           //需求3：我要在e:\\\\itcast目录下创建一个多级目录javaweb\\\\html\n           file f3 = new file("e:\\\\itcast\\\\javaweb\\\\html");\n   //        system.out.println(f3.mkdir());\n           system.out.println(f3.mkdirs());\n           system.out.println("--------");\n   \n           //需求4：我要在e:\\\\itcast目录下创建一个文件javase.txt\n           file f4 = new file("e:\\\\itcast\\\\javase.txt");\n   //        system.out.println(f4.mkdir());\n           system.out.println(f4.createnewfile());\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 1.3file类判断和获取功能\n\n * 判断功能\n   \n   方法名                            说明\n   public boolean isdirectory()   测试此抽象路径名表示的file是否为目录\n   public boolean isfile()        测试此抽象路径名表示的file是否为文件\n   public boolean exists()        测试此抽象路径名表示的file是否存在\n\n * 获取功能\n   \n   方法名                               说明\n   public string getabsolutepath()   返回此抽象路径名的绝对路径名字符串\n   public string getpath()           将此抽象路径名转换为路径名字符串\n   public string getname()           返回由此抽象路径名表示的文件或目录的名称\n   public string[] list()            返回此抽象路径名表示的目录中的文件和目录的名称字符串数组\n   public file[] listfiles()         返回此抽象路径名表示的目录中的文件和目录的file对象数组\n\n * 示例代码\n   \n   public class filedemo04 {\n       public static void main(string[] args) {\n           //创建一个file对象\n           file f = new file("myfile\\\\java.txt");\n   \n   //        public boolean isdirectory()：测试此抽象路径名表示的file是否为目录\n   //        public boolean isfile()：测试此抽象路径名表示的file是否为文件\n   //        public boolean exists()：测试此抽象路径名表示的file是否存在\n           system.out.println(f.isdirectory());\n           system.out.println(f.isfile());\n           system.out.println(f.exists());\n   \n   //        public string getabsolutepath()：返回此抽象路径名的绝对路径名字符串\n   //        public string getpath()：将此抽象路径名转换为路径名字符串\n   //        public string getname()：返回由此抽象路径名表示的文件或目录的名称\n           system.out.println(f.getabsolutepath());\n           system.out.println(f.getpath());\n           system.out.println(f.getname());\n           system.out.println("--------");\n   \n   //        public string[] list()：返回此抽象路径名表示的目录中的文件和目录的名称字符串数组\n   //        public file[] listfiles()：返回此抽象路径名表示的目录中的文件和目录的file对象数组\n           file f2 = new file("e:\\\\itcast");\n   \n           string[] strarray = f2.list();\n           for(string str : strarray) {\n               system.out.println(str);\n           }\n           system.out.println("--------");\n   \n           file[] filearray = f2.listfiles();\n           for(file file : filearray) {\n   //            system.out.println(file);\n   //            system.out.println(file.getname());\n               if(file.isfile()) {\n                   system.out.println(file.getname());\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   \n\n\n# 1.4file类删除功能\n\n * 方法分类\n   \n   方法名                       说明\n   public boolean delete()   删除由此抽象路径名表示的文件或目录\n\n * 示例代码\n   \n   public class filedemo03 {\n       public static void main(string[] args) throws ioexception {\n   //        file f1 = new file("e:\\\\itcast\\\\java.txt");\n           //需求1：在当前模块目录下创建java.txt文件\n           file f1 = new file("myfile\\\\java.txt");\n   //        system.out.println(f1.createnewfile());\n   \n           //需求2：删除当前模块目录下的java.txt文件\n           system.out.println(f1.delete());\n           system.out.println("--------");\n   \n           //需求3：在当前模块目录下创建itcast目录\n           file f2 = new file("myfile\\\\itcast");\n   //        system.out.println(f2.mkdir());\n   \n           //需求4：删除当前模块目录下的itcast目录\n           system.out.println(f2.delete());\n           system.out.println("--------");\n   \n           //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt\n           file f3 = new file("myfile\\\\itcast");\n   //        system.out.println(f3.mkdir());\n           file f4 = new file("myfile\\\\itcast\\\\java.txt");\n   //        system.out.println(f4.createnewfile());\n   \n           //需求6：删除当前模块下的目录itcast\n           system.out.println(f4.delete());\n           system.out.println(f3.delete());\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n * 绝对路径和相对路径的区别\n   \n   * 绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：e:\\itcast\\java.txt\n   * 相对路径：必须使用取自其他路径名的信息进行解释。例如：myfile\\java.txt\n\n\n# 2.递归\n\n\n# 2.1递归\n\n * 递归的介绍\n   \n   * 以编程的角度来看，递归指的是方法定义中调用方法本身的现象\n   * 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解\n   * 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算\n\n * 递归的基本使用\n   \n   public class diguidemo {\n       public static void main(string[] args) {\n           //回顾不死神兔问题，求第20个月兔子的对数\n           //每个月的兔子对数：1,1,2,3,5,8，...\n           int[] arr = new int[20];\n   \n           arr[0] = 1;\n           arr[1] = 1;\n   \n           for (int i = 2; i < arr.length; i++) {\n               arr[i] = arr[i - 1] + arr[i - 2];\n           }\n           system.out.println(arr[19]);\n           system.out.println(f(20));\n       }\n   \n       /*\n           递归解决问题，首先就是要定义一个方法：\n               定义一个方法f(n)：表示第n个月的兔子对数\n               那么，第n-1个月的兔子对数该如何表示呢？f(n-1)\n               同理，第n-2个月的兔子对数该如何表示呢？f(n-2)\n   \n           stackoverflowerror:当堆栈溢出发生时抛出一个应用程序递归太深\n        */\n       public static int f(int n) {\n           if(n==1 || n==2) {\n               return 1;\n           } else {\n               return f(n - 1) + f(n - 2);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n * 递归的注意事项\n   \n   * 递归一定要有出口。否则内存溢出\n   * 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出\n\n\n# 2.2递归求阶乘\n\n * 案例需求\n   \n   用递归求5的阶乘，并把结果在控制台输出\n\n * 代码实现\n   \n   public class diguidemo01 {\n       public static void main(string[] args) {\n           //调用方法\n           int result = jc(5);\n           //输出结果\n           system.out.println("5的阶乘是：" + result);\n       }\n   \n       //定义一个方法，用于递归求阶乘，参数为一个int类型的变量\n       public static int jc(int n) {\n           //在方法内部判断该变量的值是否是1\n           if(n == 1) {\n               //是：返回1\n               return 1;\n           } else {\n               //不是：返回n*(n-1)!\n               return n*jc(n-1);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 2.3递归遍历目录\n\n * 案例需求\n   \n   给定一个路径(e:\\itcast)，通过递归完成遍历该目录下所有内容，并把所有文件的绝对路径输出在控制台\n\n * 代码实现\n   \n   public class diguidemo02 {\n       public static void main(string[] args) {\n           //根据给定的路径创建一个file对象\n   //        file srcfile = new file("e:\\\\itcast");\n           file srcfile = new file("e:\\\\itheima");\n   \n           //调用方法\n           getallfilepath(srcfile);\n       }\n   \n       //定义一个方法，用于获取给定目录下的所有内容，参数为第1步创建的file对象\n       public static void getallfilepath(file srcfile) {\n           //获取给定的file目录下所有的文件或者目录的file数组\n           file[] filearray = srcfile.listfiles();\n           //遍历该file数组，得到每一个file对象\n           if(filearray != null) {\n               for(file file : filearray) {\n                   //判断该file对象是否是目录\n                   if(file.isdirectory()) {\n                       //是：递归调用\n                       getallfilepath(file);\n                   } else {\n                       //不是：获取绝对路径输出在控制台\n                       system.out.println(file.getabsolutepath());\n                   }\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n\n\n# 3.io-字节流 inputstream和outputstream😄\n\n\n# 3.1 io流概述和分类\n\n * io流介绍\n   * io：输入/输出(input/output)\n   * 流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输\n   * io流就是用来处理设备间数据传输问题的。常见的应用：文件复制；文件上传；文件下载\n * io流的分类\n   * 按照数据的流向\n     * 输入流：读数据\n     * 输出流：写数据\n   * 按照数据类型来分\n     * 字节流\n       * 字节输入流\n       * 字节输出流\n     * 字符流\n       * 字符输入流\n       * 字符输出流\n * io流的使用场景\n   * 如果操作的是纯文本文件，优先使用字符流\n   * 如果操作的是图片、视频、音频等二进制文件。优先使用字节流\n   * 如果不确定文件类型，优先使用字节流。字节流是万能的流\n\n\n# 3.2 字节流写数据\n\n * 字节流抽象基类\n   \n   * inputstream：这个抽象类是表示字节输入流的所有类的超类\n   * outputstream：这个抽象类是表示字节输出流的所有类的超类\n   * 子类名特点：子类名称都是以其父类名作为子类名的后缀\n\n * 字节输出流\n   \n   * fileoutputstream(string name)：创建文件输出流以指定的名称写入文件\n\n * 使用字节输出流写数据的步骤\n   \n   * 创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件)\n   * 调用字节输出流对象的写数据方法\n   * 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)\n\n * 示例代码\n   \n   public class fileoutputstreamdemo01 {\n       public static void main(string[] args) throws ioexception {\n           //创建字节输出流对象\n           //fileoutputstream(string name)：创建文件输出流以指定的名称写入文件\n           fileoutputstream fos = new fileoutputstream("mybytestream\\\\fos.txt");\n           /*\n               做了三件事情：\n                   a:调用系统功能创建了文件\n                   b:创建了字节输出流对象\n                   c:让字节输出流对象指向创建好的文件\n            */\n   \n           //void write(int b)：将指定的字节写入此文件输出流\n           fos.write(97);\n   //        fos.write(57);\n   //        fos.write(55);\n   \n           //最后都要释放资源\n           //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。\n           fos.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 3.3 字节流写数据的三种方式\n\n * 写数据的方法分类\n   \n   方法名                                      说明\n   void write(int b)                        将指定的字节写入此文件输出流 一次写一个字节数据\n   void write(byte[] b)                     将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据\n   void write(byte[] b, int off, int len)   将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据\n\n * 示例代码\n   \n   public class fileoutputstreamdemo02 {\n       public static void main(string[] args) throws ioexception {\n           //fileoutputstream(string name)：创建文件输出流以指定的名称写入文件\n           fileoutputstream fos = new fileoutputstream("mybytestream\\\\fos.txt");\n           //new file(name)\n   //        fileoutputstream fos = new fileoutputstream(new file("mybytestream\\\\fos.txt"));\n   \n           //fileoutputstream(file file)：创建文件输出流以写入由指定的 file对象表示的文件\n   //        file file = new file("mybytestream\\\\fos.txt");\n   //        fileoutputstream fos2 = new fileoutputstream(file);\n   //        fileoutputstream fos2 = new fileoutputstream(new file("mybytestream\\\\fos.txt"));\n   \n           //void write(int b)：将指定的字节写入此文件输出流\n   //        fos.write(97);\n   //        fos.write(98);\n   //        fos.write(99);\n   //        fos.write(100);\n   //        fos.write(101);\n   \n   //        void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流\n   //        byte[] bys = {97, 98, 99, 100, 101};\n           //byte[] getbytes()：返回字符串对应的字节数组\n           byte[] bys = "abcde".getbytes();\n   //        fos.write(bys);\n   \n           //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流\n   //        fos.write(bys,0,bys.length);\n           fos.write(bys,1,3);\n   \n           //释放资源\n           fos.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   \n\n\n# 3.4 字节流写数据的两个小问题\n\n * 字节流写数据如何实现换行\n   \n   * windows:\\r\\n\n   * linux:\\n\n   * mac:\\r\n\n * 字节流写数据如何实现追加写入\n   \n   * public fileoutputstream(string name,boolean append)\n   * 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头\n\n * 示例代码\n   \n   public class fileoutputstreamdemo03 {\n       public static void main(string[] args) throws ioexception {\n           //创建字节输出流对象\n   //        fileoutputstream fos = new fileoutputstream("mybytestream\\\\fos.txt");\n           fileoutputstream fos = new fileoutputstream("mybytestream\\\\fos.txt",true);\n   \n           //写数据\n           for (int i = 0; i < 10; i++) {\n               fos.write("hello".getbytes());\n               fos.write("\\r\\n".getbytes());\n           }\n   \n           //释放资源\n           fos.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n\n# 3.5 字节流写数据加异常处理\n\n * 异常处理格式\n   \n   * try-catch-finally\n     \n     try{\n     \t可能出现异常的代码;\n     }catch(异常类名 变量名){\n     \t异常的处理代码;\n     }finally{\n     \t执行所有清除操作;\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n   \n   * finally特点\n     \n     * 被finally控制的语句一定会执行，除非jvm退出\n\n * 示例代码\n   \n   public class fileoutputstreamdemo04 {\n       public static void main(string[] args) {\n           //加入finally来实现释放资源\n           fileoutputstream fos = null;\n           try {\n               fos = new fileoutputstream("mybytestream\\\\fos.txt");\n               fos.write("hello".getbytes());\n           } catch (ioexception e) {\n               e.printstacktrace();\n           } finally {\n               if(fos != null) {\n                   try {\n                       fos.close();\n                   } catch (ioexception e) {\n                       e.printstacktrace();\n                   }\n               }\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 3.6 字节流读数据(一次读一个字节数据)\n\n * 字节输入流\n   \n   * fileinputstream(string name)：通过打开与实际文件的连接来创建一个fileinputstream ，该文件由文件系统中的路径名name命名\n\n * 字节输入流读取数据的步骤\n   \n   * 创建字节输入流对象\n   * 调用字节输入流对象的读数据方法\n   * 释放资源\n\n * 示例代码\n   \n   public class fileinputstreamdemo01 {\n       public static void main(string[] args) throws ioexception {\n           //创建字节输入流对象\n           //fileinputstream(string name)\n           fileinputstream fis = new fileinputstream("mybytestream\\\\fos.txt");\n   \n           int by;\n           /*\n               fis.read()：读数据\n               by=fis.read()：把读取到的数据赋值给by\n               by != -1：判断读取到的数据是否是-1\n            */\n           while ((by=fis.read())!=-1) {\n               system.out.print((char)by);\n           }\n   \n           //释放资源\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 3.7 字节流复制文本文件\n\n * 案例需求\n   \n   把“e:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt”\n\n * 实现步骤\n   \n   * 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地)\n   \n   * 数据源：\n     \n     e:\\itcast\\窗里窗外.txt --- 读数据 --- inputstream --- fileinputstream\n   \n   * 目的地：\n     \n     mybytestream\\窗里窗外.txt --- 写数据 --- outputstream --- fileoutputstream\n\n * 代码实现\n   \n   public class copytxtdemo {\n       public static void main(string[] args) throws ioexception {\n           //根据数据源创建字节输入流对象\n           fileinputstream fis = new fileinputstream("e:\\\\itcast\\\\窗里窗外.txt");\n           //根据目的地创建字节输出流对象\n           fileoutputstream fos = new fileoutputstream("mybytestream\\\\窗里窗外.txt");\n   \n           //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节)\n           int by;\n           while ((by=fis.read())!=-1) {\n               fos.write(by);\n           }\n   \n           //释放资源\n           fos.close();\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 3.8 字节流读数据(一次读一个字节数组数据)\n\n * 一次读一个字节数组的方法\n   \n   * public int read(byte[] b)：从输入流读取最多b.length个字节的数据\n   * 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数\n\n * 示例代码\n   \n   public class fileinputstreamdemo02 {\n       public static void main(string[] args) throws ioexception {\n           //创建字节输入流对象\n           fileinputstream fis = new fileinputstream("mybytestream\\\\fos.txt");\n   \n           /*\n               hello\\r\\n\n               world\\r\\n\n   \n               第一次：hello\n               第二次：\\r\\nwor\n               第三次：ld\\r\\nr\n   \n            */\n   \n           byte[] bys = new byte[1024]; //1024及其整数倍\n           int len;\n           while ((len=fis.read(bys))!=-1) {\n               system.out.print(new string(bys,0,len));\n           }\n   \n           //释放资源\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n\n\n# 3.9 字节流复制图片\n\n * 案例需求\n   \n   把“e:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg”\n\n * 实现步骤\n   \n   * 根据数据源创建字节输入流对象\n   * 根据目的地创建字节输出流对象\n   * 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n   * 释放资源\n\n * 代码实现\n   \n   public class copyjpgdemo {\n       public static void main(string[] args) throws ioexception {\n           //根据数据源创建字节输入流对象\n           fileinputstream fis = new fileinputstream("e:\\\\itcast\\\\mn.jpg");\n           //根据目的地创建字节输出流对象\n           fileoutputstream fos = new fileoutputstream("mybytestream\\\\mn.jpg");\n   \n           //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n           byte[] bys = new byte[1024];\n           int len;\n           while ((len=fis.read(bys))!=-1) {\n               fos.write(bys,0,len);\n           }\n   \n           //释放资源\n           fos.close();\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n\n# 3.10 字节缓冲流-构造方法😄\n\n * 字节缓冲流介绍\n   \n   * lbufferoutputstream：该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用\n   \n   * lbufferedinputstream：创建bufferedinputstream将创建一个内部缓冲区数组。 当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节\n\n * 构造方法：\n   \n   方法名                                      说明\n   bufferedoutputstream(outputstream out)   创建字节缓冲输出流对象\n   bufferedinputstream(inputstream in)      创建字节缓冲输入流对象\n\n * 示例代码\n   \n   public class bufferstreamdemo {\n       public static void main(string[] args) throws ioexception {\n           //字节缓冲输出流：bufferedoutputstream(outputstream out)\n    \n           bufferedoutputstream bos = new bufferedoutputstream(new \t\t\t\t                                       fileoutputstream("mybytestream\\\\bos.txt"));\n           //写数据\n           bos.write("hello\\r\\n".getbytes());\n           bos.write("world\\r\\n".getbytes());\n           //释放资源\n           bos.close();\n       \n   \n           //字节缓冲输入流：bufferedinputstream(inputstream in)\n           bufferedinputstream bis = new bufferedinputstream(new                                                          fileinputstream("mybytestream\\\\bos.txt"));\n   \n           //一次读取一个字节数据\n   //        int by;\n   //        while ((by=bis.read())!=-1) {\n   //            system.out.print((char)by);\n   //        }\n   \n           //一次读取一个字节数组数据\n           byte[] bys = new byte[1024];\n           int len;\n           while ((len=bis.read(bys))!=-1) {\n               system.out.print(new string(bys,0,len));\n           }\n   \n           //释放资源\n           bis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n\n# 3.11 字节流-复制视频\n\n * 案例需求\n   \n   把“e:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi”\n\n * 实现步骤\n   \n   * 根据数据源创建字节输入流对象\n   \n   * 根据目的地创建字节输出流对象\n   \n   * 读写数据，复制视频\n   \n   * 释放资源\n\n * 代码实现\n   \n   public class copyavidemo {\n       public static void main(string[] args) throws ioexception {\n           //记录开始时间\n           long starttime = system.currenttimemillis();\n   \n           //复制视频\n   //        method1();\n   //        method2();\n   //        method3();\n           method4();\n   \n           //记录结束时间\n           long endtime = system.currenttimemillis();\n           system.out.println("共耗时：" + (endtime - starttime) + "毫秒");\n       }\n   \n       //字节缓冲流一次读写一个字节数组\n       public static void method4() throws ioexception {\n           bufferedinputstream bis = new bufferedinputstream(new fileinputstream("e:\\\\itcast\\\\字节流复制图片.avi"));\n           bufferedoutputstream bos = new bufferedoutputstream(new fileoutputstream("mybytestream\\\\字节流复制图片.avi"));\n   \n           byte[] bys = new byte[1024];\n           int len;\n           while ((len=bis.read(bys))!=-1) {\n               bos.write(bys,0,len);\n           }\n   \n           bos.close();\n           bis.close();\n       }\n   \n       //字节缓冲流一次读写一个字节\n       public static void method3() throws ioexception {\n           bufferedinputstream bis = new bufferedinputstream(new fileinputstream("e:\\\\itcast\\\\字节流复制图片.avi"));\n           bufferedoutputstream bos = new bufferedoutputstream(new fileoutputstream("mybytestream\\\\字节流复制图片.avi"));\n   \n           int by;\n           while ((by=bis.read())!=-1) {\n               bos.write(by);\n           }\n   \n           bos.close();\n           bis.close();\n       }\n   \n   \n       //基本字节流一次读写一个字节数组\n       public static void method2() throws ioexception {\n           //e:\\\\itcast\\\\字节流复制图片.avi\n           //模块目录下的 字节流复制图片.avi\n           fileinputstream fis = new fileinputstream("e:\\\\itcast\\\\字节流复制图片.avi");\n           fileoutputstream fos = new fileoutputstream("mybytestream\\\\字节流复制图片.avi");\n   \n           byte[] bys = new byte[1024];\n           int len;\n           while ((len=fis.read(bys))!=-1) {\n               fos.write(bys,0,len);\n           }\n   \n           fos.close();\n           fis.close();\n       }\n   \n       //基本字节流一次读写一个字节\n       public static void method1() throws ioexception {\n           //e:\\\\itcast\\\\字节流复制图片.avi\n           //模块目录下的 字节流复制图片.avi\n           fileinputstream fis = new fileinputstream("e:\\\\itcast\\\\字节流复制图片.avi");\n           fileoutputstream fos = new fileoutputstream("mybytestream\\\\字节流复制图片.avi");\n   \n           int by;\n           while ((by=fis.read())!=-1) {\n               fos.write(by);\n           }\n   \n           fos.close();\n           fis.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   \n\n\n# 4. 字符流 reader和writer😄\n\n\n# 4.1为什么会出现字符流\n\n * 字符流的介绍\n   \n   由于字节流操作中文不是特别的方便，所以java就提供字符流\n   \n   字符流 = 字节流 + 编码表\n\n * 中文的字节存储方式\n   \n   用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？\n   \n   汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数\n\n\n# 4.2 编码表\n\n * 什么是字符集\n   \n   是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n   \n   l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ascii字符集、gbxxx字符集、unicode字符集等\n\n * 常见的字符集\n   \n   * ascii字符集：\n     \n     lascii：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号)\n     \n     基本的ascii字符集，使用7位表示一个字符，共128字符。ascii的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等\n   \n   * gbxxx字符集：\n     \n     gbk：最常用的中文码表。是在gb2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容gb2312标准，同时支持繁体汉字以及日韩汉字等\n   \n   * unicode字符集：\n     \n     utf-8编码：可以用来表示unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（ietf）要求所有互联网协议都必须支持utf-8编码。它使用一至四个字节为每个字符编码\n     \n     编码规则：\n     \n     128个us-ascii字符，只需一个字节编码\n     \n     拉丁文等字符，需要二个字节编码\n     \n     大部分常用字（含中文），使用三个字节编码\n     \n     其他极少使用的unicode辅助字符，使用四字节编码\n\n\n# 2.3 字符串中的编码解码问题\n\n * 相关方法\n   \n   方法名                                        说明\n   byte[] getbytes()                          使用平台的默认字符集将该 string编码为一系列字节\n   byte[] getbytes(string charsetname)        使用指定的字符集将该 string编码为一系列字节\n   string(byte[] bytes)                       使用平台的默认字符集解码指定的字节数组来创建字符串\n   string(byte[] bytes, string charsetname)   通过指定的字符集解码指定的字节数组来创建字符串\n\n * 代码演示\n   \n   public class stringdemo {\n       public static void main(string[] args) throws unsupportedencodingexception {\n           //定义一个字符串\n           string s = "中国";\n   \n           //byte[] bys = s.getbytes(); //[-28, -72, -83, -27, -101, -67]\n           //byte[] bys = s.getbytes("utf-8"); //[-28, -72, -83, -27, -101, -67]\n           byte[] bys = s.getbytes("gbk"); //[-42, -48, -71, -6]\n           system.out.println(arrays.tostring(bys));\n   \n           //string ss = new string(bys);\n           //string ss = new string(bys,"utf-8");\n           string ss = new string(bys,"gbk");\n           system.out.println(ss);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n\n# 2.4 字符流中的编码解码问题\n\n * 字符流中和编码解码问题相关的两个类\n   \n   * inputstreamreader：是从字节流到字符流的桥梁\n     \n     它读取字节，并使用指定的编码将其解码为字符\n     \n     它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n   \n   * outputstreamwriter：是从字符流到字节流的桥梁\n     \n     是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节\n     \n     它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n\n * 构造方法\n   \n   方法名                                                   说明\n   inputstreamreader(inputstream in)                     使用默认字符编码创建inputstreamreader对象\n   inputstreamreader(inputstream in,string chatset)      使用指定的字符编码创建inputstreamreader对象\n   outputstreamwriter(outputstream out)                  使用默认字符编码创建outputstreamwriter对象\n   outputstreamwriter(outputstream out,string charset)   使用指定的字符编码创建outputstreamwriter对象\n\n * 代码演示\n   \n   public class conversionstreamdemo {\n       public static void main(string[] args) throws ioexception {\n           //outputstreamwriter osw = new outputstreamwriter(new                                             fileoutputstream("mycharstream\\\\osw.txt"));\n           outputstreamwriter osw = new outputstreamwriter(new                                              fileoutputstream("mycharstream\\\\osw.txt"),"gbk");\n           osw.write("中国");\n           osw.close();\n   \n           //inputstreamreader isr = new inputstreamreader(new \t                                         fileinputstream("mycharstream\\\\osw.txt"));\n           inputstreamreader isr = new inputstreamreader(new                                                 fileinputstream("mycharstream\\\\osw.txt"),"gbk");\n           //一次读取一个字符数据\n           int ch;\n           while ((ch=isr.read())!=-1) {\n               system.out.print((char)ch);\n           }\n           isr.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n\n# 2.5 字符流写数据的5种方式\n\n * 方法介绍\n   \n   方法名                                         说明\n   void write(int c)                           写一个字符\n   void write(char[] cbuf)                     写入一个字符数组\n   void write(char[] cbuf, int off, int len)   写入字符数组的一部分\n   void write(string str)                      写一个字符串\n   void write(string str, int off, int len)    写一个字符串的一部分\n\n * 刷新和关闭的方法\n   \n   方法名       说明\n   flush()   刷新流，之后还可以继续写数据\n   close()   关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据\n\n * 代码演示\n   \n   public class outputstreamwriterdemo {\n       public static void main(string[] args) throws ioexception {\n           outputstreamwriter osw = new outputstreamwriter(new fileoutputstream("mycharstream\\\\osw.txt"));\n   \n           //void write(int c)：写一个字符\n   //        osw.write(97);\n   //        osw.write(98);\n   //        osw.write(99);\n   \n           //void writ(char[] cbuf)：写入一个字符数组\n           char[] chs = {\'a\', \'b\', \'c\', \'d\', \'e\'};\n   //        osw.write(chs);\n   \n           //void write(char[] cbuf, int off, int len)：写入字符数组的一部分\n   //        osw.write(chs, 0, chs.length);\n   //        osw.write(chs, 1, 3);\n   \n           //void write(string str)：写一个字符串\n   //        osw.write("abcde");\n   \n           //void write(string str, int off, int len)：写一个字符串的一部分\n   //        osw.write("abcde", 0, "abcde".length());\n           osw.write("abcde", 1, 3);\n   \n           //释放资源\n           osw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n\n\n# 2.6 字符流读数据的2种方式【应用】\n\n * 方法介绍\n   \n   方法名                     说明\n   int read()              一次读一个字符数据\n   int read(char[] cbuf)   一次读一个字符数组数据\n\n * 代码演示\n   \n   public class inputstreamreaderdemo {\n       public static void main(string[] args) throws ioexception {\n      \n           inputstreamreader isr = new inputstreamreader(new fileinputstream("mycharstream\\\\conversionstreamdemo.java"));\n   \n           //int read()：一次读一个字符数据\n   //        int ch;\n   //        while ((ch=isr.read())!=-1) {\n   //            system.out.print((char)ch);\n   //        }\n   \n           //int read(char[] cbuf)：一次读一个字符数组数据\n           char[] chs = new char[1024];\n           int len;\n           while ((len = isr.read(chs)) != -1) {\n               system.out.print(new string(chs, 0, len));\n           }\n   \n           //释放资源\n           isr.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 2.7 字符流复制java文件\n\n * 案例需求\n   \n   把模块目录下的“conversionstreamdemo.java” 复制到模块目录下的“copy.java”\n\n * 实现步骤\n   \n   * 根据数据源创建字符输入流对象\n   * 根据目的地创建字符输出流对象\n   * 读写数据，复制文件\n   * 释放资源\n\n * 代码实现\n   \n   public class copyjavademo01 {\n       public static void main(string[] args) throws ioexception {\n           //根据数据源创建字符输入流对象\n           inputstreamreader isr = new inputstreamreader(new fileinputstream("mycharstream\\\\conversionstreamdemo.java"));\n           //根据目的地创建字符输出流对象\n           outputstreamwriter osw = new outputstreamwriter(new fileoutputstream("mycharstream\\\\copy.java"));\n   \n           //读写数据，复制文件\n           //一次读写一个字符数据\n   //        int ch;\n   //        while ((ch=isr.read())!=-1) {\n   //            osw.write(ch);\n   //        }\n   \n           //一次读写一个字符数组数据\n           char[] chs = new char[1024];\n           int len;\n           while ((len=isr.read(chs))!=-1) {\n               osw.write(chs,0,len);\n           }\n   \n           //释放资源\n           osw.close();\n           isr.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n\n# 2.8 字符流复制java文件改进版\n\n * 案例需求\n   \n   使用便捷流对象，把模块目录下的“conversionstreamdemo.java” 复制到模块目录下的“copy.java”\n\n * 实现步骤\n   \n   * 根据数据源创建字符输入流对象\n   \n   * 根据目的地创建字符输出流对象\n   \n   * 读写数据，复制文件\n   \n   * 释放资源\n\n * 代码实现\n   \n   public class copyjavademo02 {\n       public static void main(string[] args) throws ioexception {\n           //根据数据源创建字符输入流对象\n           filereader fr = new filereader("mycharstream\\\\conversionstreamdemo.java");\n           //根据目的地创建字符输出流对象\n           filewriter fw = new filewriter("mycharstream\\\\copy.java");\n   \n           //读写数据，复制文件\n   //        int ch;\n   //        while ((ch=fr.read())!=-1) {\n   //            fw.write(ch);\n   //        }\n   \n           char[] chs = new char[1024];\n           int len;\n           while ((len=fr.read(chs))!=-1) {\n               fw.write(chs,0,len);\n           }\n   \n           //释放资源\n           fw.close();\n           fr.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 2.9 字符缓冲流😄\n\n * 字符缓冲流介绍\n   \n   * bufferedwriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途\n   \n   * bufferedreader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途\n\n * 构造方法\n   \n   方法名                          说明\n   bufferedwriter(writer out)   创建字符缓冲输出流对象\n   bufferedreader(reader in)    创建字符缓冲输入流对象\n\n * 代码演示\n   \n   public class bufferedstreamdemo01 {\n       public static void main(string[] args) throws ioexception {\n           //bufferedwriter(writer out)\n           bufferedwriter bw = new bufferedwriter(new                                                            filewriter("mycharstream\\\\bw.txt"));\n           bw.write("hello\\r\\n");\n           bw.write("world\\r\\n");\n           bw.close();\n   \n           //bufferedreader(reader in)\n           bufferedreader br = new bufferedreader(new                                                           filereader("mycharstream\\\\bw.txt"));\n   \n           //一次读取一个字符数据\n   //        int ch;\n   //        while ((ch=br.read())!=-1) {\n   //            system.out.print((char)ch);\n   //        }\n   \n           //一次读取一个字符数组数据\n           char[] chs = new char[1024];\n           int len;\n           while ((len=br.read(chs))!=-1) {\n               system.out.print(new string(chs,0,len));\n           }\n   \n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   \n\n\n# 2.10 字符缓冲流复制java文件\n\n * 案例需求\n   \n   把模块目录下的conversionstreamdemo.java 复制到模块目录下的 copy.java\n\n * 实现步骤\n   \n   * 根据数据源创建字符缓冲输入流对象\n   * 根据目的地创建字符缓冲输出流对象\n   * 读写数据，复制文件，使用字符缓冲流特有功能实现\n   * 释放资源\n\n * 代码实现\n   \n   public class copyjavademo01 {\n       public static void main(string[] args) throws ioexception {\n           //根据数据源创建字符缓冲输入流对象\n           bufferedreader br = new bufferedreader(new filereader("mycharstream\\\\conversionstreamdemo.java"));\n           //根据目的地创建字符缓冲输出流对象\n           bufferedwriter bw = new bufferedwriter(new filewriter("mycharstream\\\\copy.java"));\n   \n           //读写数据，复制文件\n           //一次读写一个字符数据\n   //        int ch;\n   //        while ((ch=br.read())!=-1) {\n   //            bw.write(ch);\n   //        }\n   \n           //一次读写一个字符数组数据\n           char[] chs = new char[1024];\n           int len;\n           while ((len=br.read(chs))!=-1) {\n               bw.write(chs,0,len);\n           }\n   \n           //释放资源\n           bw.close();\n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n\n# 2.11 字符缓冲流特有功能\n\n * 方法介绍\n   \n   bufferedwriter：\n   \n   方法名              说明\n   void newline()   写一行行分隔符，行分隔符字符串由系统属性定义\n   \n   bufferedreader:\n   \n   方法名                 说明\n   string readline()   读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null\n\n * 代码演示\n   \n   public class bufferedstreamdemo02 {\n       public static void main(string[] args) throws ioexception {\n   \n           //创建字符缓冲输出流\n           bufferedwriter bw = new bufferedwriter(new                                                          filewriter("mycharstream\\\\bw.txt"));\n   \n           //写数据\n           for (int i = 0; i < 10; i++) {\n               bw.write("hello" + i);\n               //bw.write("\\r\\n");\n               bw.newline();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n   \n           //创建字符缓冲输入流\n           bufferedreader br = new bufferedreader(new                                                          filereader("mycharstream\\\\bw.txt"));\n   \n           string line;\n           while ((line=br.readline())!=null) {\n               system.out.println(line);\n           }\n   \n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   \n\n\n# 2.12 字符缓冲流特有功能复制java文件\n\n * 案例需求\n   \n   使用特有功能把模块目录下的conversionstreamdemo.java 复制到模块目录下的 copy.java\n\n * 实现步骤\n   \n   * 根据数据源创建字符缓冲输入流对象\n   * 根据目的地创建字符缓冲输出流对象\n   * 读写数据，复制文件，使用字符缓冲流特有功能实现\n   * 释放资源\n\n * 代码实现\n   \n   public class copyjavademo02 {\n       public static void main(string[] args) throws ioexception {\n           //根据数据源创建字符缓冲输入流对象\n           bufferedreader br = new bufferedreader(new filereader("mycharstream\\\\conversionstreamdemo.java"));\n           //根据目的地创建字符缓冲输出流对象\n           bufferedwriter bw = new bufferedwriter(new filewriter("mycharstream\\\\copy.java"));\n   \n           //读写数据，复制文件\n           //使用字符缓冲流特有功能实现\n           string line;\n           while ((line=br.readline())!=null) {\n               bw.write(line);\n               bw.newline();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n\n# 2.13 io流小结 😄\n\n * 字节流\n   \n   \n\n * 字符流\n   \n   \n\n\n# 5. io特殊操作流🚗\n\n\n# 5.1 标准输入流\n\n * system类中有两个静态的成员变量\n   \n   * public static final inputstream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源\n   * public static final printstream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标\n\n * 自己实现键盘录入数据\n   \n   public class systemindemo {\n       public static void main(string[] args) throws ioexception {\n           //public static final inputstream in：标准输入流\n   //        inputstream is = system.in;\n   \n   //        int by;\n   //        while ((by=is.read())!=-1) {\n   //            system.out.print((char)by);\n   //        }\n   \n           //如何把字节流转换为字符流？用转换流\n   //        inputstreamreader isr = new inputstreamreader(is);\n   //        //使用字符流能不能够实现一次读取一行数据呢？可以\n   //        //但是，一次读取一行数据的方法是字符缓冲输入流的特有方法\n   //        bufferedreader br = new bufferedreader(isr);\n   \n           bufferedreader br = new bufferedreader(new inputstreamreader(system.in));\n   \n           system.out.println("请输入一个字符串：");\n           string line = br.readline();\n           system.out.println("你输入的字符串是：" + line);\n   \n           system.out.println("请输入一个整数：");\n           int i = integer.parseint(br.readline());\n           system.out.println("你输入的整数是：" + i);\n   \n           //自己实现键盘录入数据太麻烦了，所以java就提供了一个类供我们使用\n           scanner sc = new scanner(system.in);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   \n\n\n# 5.2 标准输出流\n\n * system类中有两个静态的成员变量\n   \n   * public static final inputstream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源\n   * public static final printstream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标\n\n * 输出语句的本质：是一个标准的输出流\n   \n   * printstream ps = system.out;\n   * printstream类有的方法，system.out都可以使用\n\n * 示例代码\n   \n   public class systemoutdemo {\n       public static void main(string[] args) {\n           //public static final printstream out：标准输出流\n           printstream ps = system.out;\n   \n           //能够方便地打印各种数据值\n   //        ps.print("hello");\n   //        ps.print(100);\n   \n   //        ps.println("hello");\n   //        ps.println(100);\n   \n           //system.out的本质是一个字节输出流\n           system.out.println("hello");\n           system.out.println(100);\n   \n           system.out.println();\n   //        system.out.print();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 5.3 字节打印流\n\n * 打印流分类\n   \n   * 字节打印流：printstream\n   * 字符打印流：printwriter\n\n * 打印流的特点\n   \n   * 只负责输出数据，不负责读取数据\n   * 永远不会抛出ioexception\n   * 有自己的特有方法\n\n * 字节打印流\n   \n   * printstream(string filename)：使用指定的文件名创建新的打印流\n   \n   * 使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出\n   \n   * 可以改变输出语句的目的地\n     \n     public static void setout(printstream out)：重新分配“标准”输出流\n\n * 示例代码\n   \n   public class printstreamdemo {\n       public static void main(string[] args) throws ioexception {\n           //printstream(string filename)：使用指定的文件名创建新的打印流\n           printstream ps = new printstream("myotherstream\\\\ps.txt");\n   \n           //写数据\n           //字节输出流有的方法\n   //        ps.write(97);\n   \n           //使用特有方法写数据\n   //        ps.print(97);\n   //        ps.println();\n   //        ps.print(98);\n           ps.println(97);\n           ps.println(98);\n           \n           //释放资源\n           ps.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 5.4 字符打印流\n\n * 字符打印流构造房方法\n   \n   方法名                                          说明\n   printwriter(string filename)                 使用指定的文件名创建一个新的printwriter，而不需要自动执行刷新\n   printwriter(writer out, boolean autoflush)   创建一个新的printwriter out：字符输出流 autoflush： 一个布尔值，如果为真，则println ，\n                                                printf ，或format方法将刷新输出缓冲区\n\n * 示例代码\n   \n   public class printwriterdemo {\n       public static void main(string[] args) throws ioexception {\n           //printwriter(string filename) ：使用指定的文件名创建一个新的printwriter，而不需要自动执行行刷新\n   //        printwriter pw = new printwriter("myotherstream\\\\pw.txt");\n   \n   //        pw.write("hello");\n   //        pw.write("\\r\\n");\n   //        pw.flush();\n   //        pw.write("world");\n   //        pw.write("\\r\\n");\n   //        pw.flush();\n   \n   //        pw.println("hello");\n           /*\n               pw.write("hello");\n               pw.write("\\r\\n");\n            */\n   //        pw.flush();\n   //        pw.println("world");\n   //        pw.flush();\n   \n           //printwriter(writer out, boolean autoflush)：创建一个新的printwriter\n           printwriter pw = new printwriter(new filewriter("myotherstream\\\\pw.txt"),true);\n   //        printwriter pw = new printwriter(new filewriter("myotherstream\\\\pw.txt"),false);\n   \n           pw.println("hello");\n           /*\n               pw.write("hello");\n               pw.write("\\r\\n");\n               pw.flush();\n            */\n           pw.println("world");\n   \n           pw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   \n\n\n# 5.5 复制java文件打印流改进版\n\n * 案例需求\n   \n   * 把模块目录下的printstreamdemo.java 复制到模块目录下的 copy.java\n\n * 分析步骤\n   \n   * 根据数据源创建字符输入流对象\n   * 根据目的地创建字符输出流对象\n   * 读写数据，复制文件\n   * 释放资源\n\n * 代码实现\n   \n   public class copyjavademo {\n       public static void main(string[] args) throws ioexception {\n           /*\n           //根据数据源创建字符输入流对象\n           bufferedreader br = new bufferedreader(new filereader("myotherstream\\\\printstreamdemo.java"));\n           //根据目的地创建字符输出流对象\n           bufferedwriter bw = new bufferedwriter(new filewriter("myotherstream\\\\copy.java"));\n   \n           //读写数据，复制文件\n           string line;\n           while ((line=br.readline())!=null) {\n               bw.write(line);\n               bw.newline();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n           br.close();\n           */\n   \n           //根据数据源创建字符输入流对象\n           bufferedreader br = new bufferedreader(new filereader("myotherstream\\\\printstreamdemo.java"));\n           //根据目的地创建字符输出流对象\n           printwriter pw = new printwriter(new filewriter("myotherstream\\\\copy.java"),true);\n   \n           //读写数据，复制文件\n           string line;\n           while ((line=br.readline())!=null) {\n               pw.println(line);\n           }\n   \n           //释放资源\n           pw.close();\n           br.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   \n\n\n# 5.6 对象序列化流\n\n * 对象序列化介绍\n   \n   * 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象\n   * 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息\n   * 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息\n   * 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化\n\n * 对象序列化流： objectoutputstream\n   \n   * 将java对象的原始数据类型和图形写入outputstream。 可以使用objectinputstream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象\n\n * 构造方法\n   \n   方法名                                    说明\n   objectoutputstream(outputstream out)   创建一个写入指定的outputstream的objectoutputstream\n\n * 序列化对象的方法\n   \n   方法名                            说明\n   void writeobject(object obj)   将指定的对象写入objectoutputstream\n\n * 示例代码\n   \n   * 学生类\n     \n     public class student implements serializable {\n         private string name;\n         private int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     \n         @override\n         public string tostring() {\n             return "student{" +\n                     "name=\'" + name + \'\\\'\' +\n                     ", age=" + age +\n                     \'}\';\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n   \n   * 测试类\n     \n     public class objectoutputstreamdemo {\n         public static void main(string[] args) throws ioexception {\n             //objectoutputstream(outputstream out)：创建一个写入指定的outputstream的objectoutputstream\n             objectoutputstream oos = new objectoutputstream(new fileoutputstream("myotherstream\\\\oos.txt"));\n     \n             //创建对象\n             student s = new student("林青霞",30);\n     \n             //void writeobject(object obj)：将指定的对象写入objectoutputstream\n             oos.writeobject(s);\n     \n             //释放资源\n             oos.close();\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n * 注意事项\n   \n   * 一个对象要想被序列化，该对象所属的类必须必须实现serializable 接口\n   * serializable是一个标记接口，实现该接口，不需要重写任何方法\n\n\n# 5.7对象反序列化流\n\n * 对象反序列化流： objectinputstream\n   \n   * objectinputstream反序列化先前使用objectoutputstream编写的原始数据和对象\n\n * 构造方法\n   \n   方法名                                 说明\n   objectinputstream(inputstream in)   创建从指定的inputstream读取的objectinputstream\n\n * 反序列化对象的方法\n   \n   方法名                   说明\n   object readobject()   从objectinputstream读取一个对象\n\n * 示例代码\n   \n   public class objectinputstreamdemo {\n       public static void main(string[] args) throws ioexception, classnotfoundexception {\n           //objectinputstream(inputstream in)：创建从指定的inputstream读取的objectinputstream\n           objectinputstream ois = new objectinputstream(new fileinputstream("myotherstream\\\\oos.txt"));\n   \n           //object readobject()：从objectinputstream读取一个对象\n           object obj = ois.readobject();\n   \n           student s = (student) obj;\n           system.out.println(s.getname() + "," + s.getage());\n   \n           ois.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n\n# 5.8 serialversionuid&transient\n\n * serialversionuid\n   \n   * 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？\n     * 会出问题，会抛出invalidclassexception异常\n   * 如果出问题了，如何解决呢？\n     * 重新序列化\n     * 给对象所属的类加一个serialversionuid\n       * private static final long serialversionuid = 42l;\n\n * transient\n   \n   * 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？\n     * 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程\n\n * 示例代码\n   \n   * 学生类\n     \n     public class student implements serializable {\n         private static final long serialversionuid = 42l;\n         private string name;\n     //    private int age;\n         private transient int age;\n     \n         public student() {\n         }\n     \n         public student(string name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     \n     //    @override\n     //    public string tostring() {\n     //        return "student{" +\n     //                "name=\'" + name + \'\\\'\' +\n     //                ", age=" + age +\n     //                \'}\';\n     //    }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     \n   \n   * 测试类\n     \n     public class objectstreamdemo {\n         public static void main(string[] args) throws ioexception, classnotfoundexception {\n     //        write();\n             read();\n         }\n     \n         //反序列化\n         private static void read() throws ioexception, classnotfoundexception {\n             objectinputstream ois = new objectinputstream(new fileinputstream("myotherstream\\\\oos.txt"));\n             object obj = ois.readobject();\n             student s = (student) obj;\n             system.out.println(s.getname() + "," + s.getage());\n             ois.close();\n         }\n     \n         //序列化\n         private static void write() throws ioexception {\n             objectoutputstream oos = new objectoutputstream(new fileoutputstream("myotherstream\\\\oos.txt"));\n             student s = new student("林青霞", 30);\n             oos.writeobject(s);\n             oos.close();\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     \n\n\n# 6.properties集合\n\n\n# 6.1 properties作为map集合的使用\n\n * properties介绍\n   \n   * 是一个map体系的集合类\n   * properties可以保存到流中或从流中加载\n   * 属性列表中的每个键及其对应的值都是一个字符串\n\n * properties基本使用\n   \n   public class propertiesdemo01 {\n       public static void main(string[] args) {\n           //创建集合对象\n   //        properties<string,string> prop = new properties<string,string>(); //错误\n           properties prop = new properties();\n   \n           //存储元素\n           prop.put("itheima001", "林青霞");\n           prop.put("itheima002", "张曼玉");\n           prop.put("itheima003", "王祖贤");\n   \n           //遍历集合\n           set<object> keyset = prop.keyset();\n           for (object key : keyset) {\n               object value = prop.get(key);\n               system.out.println(key + "," + value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n\n# 6.2 properties作为map集合的特有方法\n\n * 特有方法\n   \n   方法名                                            说明\n   object setproperty(string key, string value)   设置集合的键和值，都是string类型，底层调用 hashtable方法 put\n   string getproperty(string key)                 使用此属性列表中指定的键搜索属性\n   set(string) stringpropertynames()              从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串\n   \n   注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 set(string) 指的是 set<string>. \n   \n   \n   1\n   \n\n * 示例代码\n   \n   public class propertiesdemo02 {\n       public static void main(string[] args) {\n           //创建集合对象\n           properties prop = new properties();\n   \n           //object setproperty(string key, string value)：设置集合的键和值，都是string类型，底层调用hashtable方法put\n           prop.setproperty("itheima001", "林青霞");\n           /*\n               object setproperty(string key, string value) {\n                   return put(key, value);\n               }\n   \n               object put(object key, object value) {\n                   return map.put(key, value);\n               }\n            */\n           prop.setproperty("itheima002", "张曼玉");\n           prop.setproperty("itheima003", "王祖贤");\n   \n           //string getproperty(string key)：使用此属性列表中指定的键搜索属性\n   //        system.out.println(prop.getproperty("itheima001"));\n   //        system.out.println(prop.getproperty("itheima0011"));\n   \n   //        system.out.println(prop);\n   \n           //set<string> stringpropertynames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串\n           set<string> names = prop.stringpropertynames();\n           for (string key : names) {\n   //            system.out.println(key);\n               string value = prop.getproperty(key);\n               system.out.println(key + "," + value);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   \n\n\n# 6.3 properties和io流相结合的方法\n\n * 和io流结合的方法\n   \n   方法名                                             说明\n   void load(inputstream instream)                 从输入字节流读取属性列表（键和元素对）\n   void load(reader reader)                        从输入字符流读取属性列表（键和元素对）\n   void store(outputstream out, string comments)   将此属性列表（键和元素对）写入此 properties表中，以适合于使用\n                                                   load(inputstream)方法的格式写入输出字节流\n   void store(writer writer, string comments)      将此属性列表（键和元素对）写入此 properties表中，以适合使用 load(reader)方法的格式写入输出字符流\n\n * 示例代码\n   \n   public class propertiesdemo03 {\n       public static void main(string[] args) throws ioexception {\n           //把集合中的数据保存到文件\n   //        mystore();\n   \n           //把文件中的数据加载到集合\n           myload();\n   \n       }\n   \n       private static void myload() throws ioexception {\n           properties prop = new properties();\n   \n           //void load(reader reader)：\n           filereader fr = new filereader("myotherstream\\\\fw.txt");\n           prop.load(fr);\n           fr.close();\n   \n           system.out.println(prop);\n       }\n   \n       private static void mystore() throws ioexception {\n           properties prop = new properties();\n   \n           prop.setproperty("itheima001","林青霞");\n           prop.setproperty("itheima002","张曼玉");\n           prop.setproperty("itheima003","王祖贤");\n   \n           //void store(writer writer, string comments)：\n           filewriter fw = new filewriter("myotherstream\\\\fw.txt");\n           prop.store(fw,null);\n           fw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   \n\n\n# 6.4 游戏次数案例\n\n * 案例需求\n   \n   * 实现猜数字小游戏只能试玩3次，如果还想玩，提示：游戏试玩已结束，想玩请充值(www.itcast.cn)\n\n * 分析步骤\n   \n   1. 写一个游戏类，里面有一个猜数字的小游戏\n   \n   2. 写一个测试类，测试类中有main()方法，main()方法中写如下代码：\n      \n      从文件中读取数据到properties集合，用load()方法实现\n      \n         文件已经存在：game.txt\n      \n         里面有一个数据值：count=0\n      \n      \n      通过properties集合获取到玩游戏的次数\n      \n      判断次数是否到到3次了\n      \n         如果到了，给出提示：游戏试玩已结束，想玩请充值(www.itcast.cn)\n      \n         如果不到3次：\n      \n         \t次数+1，重新写回文件，用properties的store()方法实现玩游戏\n      \n\n * 代码实现\n   \n   public class propertiestest {\n       public static void main(string[] args) throws ioexception {\n           //从文件中读取数据到properties集合，用load()方法实现\n           properties prop = new properties();\n   \n           filereader fr = new filereader("myotherstream\\\\game.txt");\n           prop.load(fr);\n           fr.close();\n   \n           //通过properties集合获取到玩游戏的次数\n           string count = prop.getproperty("count");\n           int number = integer.parseint(count);\n   \n           //判断次数是否到到3次了\n           if(number >= 3) {\n               //如果到了，给出提示：游戏试玩已结束，想玩请充值(www.itcast.cn)\n               system.out.println("游戏试玩已结束，想玩请充值(www.itcast.cn)");\n           } else {\n               //玩游戏\n               guessnumber.start();\n   \n               //次数+1，重新写回文件，用properties的store()方法实现\n               number++;\n               prop.setproperty("count",string.valueof(number));\n               filewriter fw = new filewriter("myotherstream\\\\game.txt");\n               prop.store(fw,null);\n               fw.close();\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   ',charsets:{cjk:!0},lastUpdated:"2023/02/28, 18:23:46",lastUpdatedTimestamp:1677579826e3},{title:"IO流案例",frontmatter:{title:"IO流案例",date:"2023-02-28T14:23:18.000Z",permalink:"/pages/2e167c/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/12.IO%E6%B5%81%E6%A1%88%E4%BE%8B.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/12.IO流案例.md",key:"v-6c582e6a",path:"/pages/2e167c/",headers:[{level:2,title:"1. 练习案例一",slug:"_1-练习案例一",normalizedTitle:"1. 练习案例一",charIndex:12},{level:3,title:"1.1 集合到文件",slug:"_1-1-集合到文件",normalizedTitle:"1.1 集合到文件",charIndex:25},{level:3,title:"1.2 文件到集合",slug:"_1-2-文件到集合",normalizedTitle:"1.2 文件到集合",charIndex:1023},{level:3,title:"1.3 点名器",slug:"_1-3-点名器",normalizedTitle:"1.3 点名器",charIndex:2084},{level:3,title:"1.4 集合到文件改进版",slug:"_1-4-集合到文件改进版",normalizedTitle:"1.4 集合到文件改进版",charIndex:3408},{level:3,title:"1.5 文件到集合改进版",slug:"_1-5-文件到集合改进版",normalizedTitle:"1.5 文件到集合改进版",charIndex:6745},{level:2,title:"2. 练习案例二",slug:"_2-练习案例二",normalizedTitle:"2. 练习案例二",charIndex:8666},{level:3,title:"2.1 集合到文件数据排序改进版",slug:"_2-1-集合到文件数据排序改进版",normalizedTitle:"2.1 集合到文件数据排序改进版",charIndex:8679},{level:4,title:"1. 案例需求",slug:"_1-案例需求",normalizedTitle:"1. 案例需求",charIndex:8699},{level:4,title:"2. 分析步骤",slug:"_2-分析步骤",normalizedTitle:"2. 分析步骤",charIndex:8804},{level:4,title:"3. 代码实现",slug:"_3-代码实现",normalizedTitle:"3. 代码实现",charIndex:9023},{level:3,title:"2.2 复制单级文件夹",slug:"_2-2-复制单级文件夹",normalizedTitle:"2.2 复制单级文件夹",charIndex:13262},{level:4,title:"1. 案例需求",slug:"_1-案例需求-2",normalizedTitle:"1. 案例需求",charIndex:8699},{level:4,title:"2. 分析步骤",slug:"_2-分析步骤-2",normalizedTitle:"2. 分析步骤",charIndex:8804},{level:4,title:"3. 代码实现",slug:"_3-代码实现-2",normalizedTitle:"3. 代码实现",charIndex:9023},{level:3,title:"2.3 复制多级文件夹",slug:"_2-3-复制多级文件夹",normalizedTitle:"2.3 复制多级文件夹",charIndex:15294},{level:4,title:"1. 案例需求",slug:"_1-案例需求-3",normalizedTitle:"1. 案例需求",charIndex:8699},{level:4,title:"2. 分析步骤",slug:"_2-分析步骤-3",normalizedTitle:"2. 分析步骤",charIndex:8804},{level:4,title:"3. 代码实现",slug:"_3-代码实现-3",normalizedTitle:"3. 代码实现",charIndex:9023},{level:3,title:"2.4 复制文件的异常处理",slug:"_2-4-复制文件的异常处理",normalizedTitle:"2.4 复制文件的异常处理",charIndex:17446},{level:4,title:"1. 基本做法",slug:"_1-基本做法",normalizedTitle:"1. 基本做法",charIndex:17463},{level:4,title:"2. JDK7版本改进",slug:"_2-jdk7版本改进",normalizedTitle:"2. jdk7版本改进",charIndex:18948},{level:4,title:"3. JDK9版本改进",slug:"_3-jdk9版本改进",normalizedTitle:"3. jdk9版本改进",charIndex:19504}],headersStr:"1. 练习案例一 1.1 集合到文件 1.2 文件到集合 1.3 点名器 1.4 集合到文件改进版 1.5 文件到集合改进版 2. 练习案例二 2.1 集合到文件数据排序改进版 1. 案例需求 2. 分析步骤 3. 代码实现 2.2 复制单级文件夹 1. 案例需求 2. 分析步骤 3. 代码实现 2.3 复制多级文件夹 1. 案例需求 2. 分析步骤 3. 代码实现 2.4 复制文件的异常处理 1. 基本做法 2. JDK7版本改进 3. JDK9版本改进",content:'# IO流案例\n\n\n# 1. 练习案例一\n\n\n# 1.1 集合到文件\n\n * 案例需求\n   \n   把文本文件中的数据读取到集合中，并遍历集合。要求：文件中每一行数据是一个集合元素\n\n * 实现步骤\n   \n   * 创建字符缓冲输入流对象\n   * 创建ArrayList集合对象\n   * 调用字符缓冲输入流对象的方法读数据\n   * 把读取到的字符串数据存储到集合中\n   * 释放资源\n   * 遍历集合\n\n * 代码实现\n   \n   public class TxtToArrayListDemo {\n       public static void main(String[] args) throws IOException {\n           //创建字符缓冲输入流对象\n           BufferedReader br = new BufferedReader(new FileReader("myCharStream\\\\array.txt"));\n   \n           //创建ArrayList集合对象\n           ArrayList<String> array = new ArrayList<String>();\n   \n           //调用字符缓冲输入流对象的方法读数据\n           String line;\n           while ((line=br.readLine())!=null) {\n               //把读取到的字符串数据存储到集合中\n               array.add(line);\n           }\n           //释放资源\n           br.close();\n           //遍历集合\n           for(String s : array) {\n               System.out.println(s);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 1.2 文件到集合\n\n * 案例需求\n   \n   把ArrayList集合中的字符串数据写入到文本文件。要求：每一个字符串元素作为文件中的一行数据\n\n * 实现步骤\n   \n   * 创建ArrayList集合\n   * 往集合中存储字符串元素\n   * 创建字符缓冲输出流对象\n   * 遍历集合，得到每一个字符串数据\n   * 调用字符缓冲输出流对象的方法写数据\n   * 释放资源\n\n * 代码实现\n   \n   public class ArrayListToTxtDemo {\n       public static void main(String[] args) throws IOException {\n           //创建ArrayList集合\n           ArrayList<String> array = new ArrayList<String>();\n   \n           //往集合中存储字符串元素\n           array.add("hello");\n           array.add("world");\n           array.add("java");\n   \n           //创建字符缓冲输出流对象\n           BufferedWriter bw = new BufferedWriter(new FileWriter("myCharStream\\\\array.txt"));\n   \n           //遍历集合，得到每一个字符串数据\n           for(String s : array) {\n               //调用字符缓冲输出流对象的方法写数据\n               bw.write(s);\n               bw.newLine();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n\n\n# 1.3 点名器\n\n * 案例需求\n   \n   我有一个文件里面存储了班级同学的姓名，每一个姓名占一行，要求通过程序实现随点名器\n\n * 实现步骤\n   \n   * 创建字符缓冲输入流对象\n   * 创建ArrayList集合对象\n   * 调用字符缓冲输入流对象的方法读数据\n   * 把读取到的字符串数据存储到集合中\n   * 释放资源\n   * 使用Random产生一个随机数，随机数的范围在：[0,集合的长度)\n   * 把第6步产生的随机数作为索引到ArrayList集合中获取值\n   * 把第7步得到的数据输出在控制台\n\n * 代码实现\n   \n   public class CallNameDemo {\n       public static void main(String[] args) throws IOException {\n           //创建字符缓冲输入流对象\n           BufferedReader br = new BufferedReader(new FileReader("myCharStream\\\\names.txt"));\n   \n           //创建ArrayList集合对象\n           ArrayList<String> array = new ArrayList<String>();\n   \n           //调用字符缓冲输入流对象的方法读数据\n           String line;\n           while ((line=br.readLine())!=null) {\n               //把读取到的字符串数据存储到集合中\n               array.add(line);\n           }\n   \n           //释放资源\n           br.close();\n   \n           //使用Random产生一个随机数，随机数的范围在：[0,集合的长度)\n           Random r = new Random();\n           int index = r.nextInt(array.size());\n   \n           //把第6步产生的随机数作为索引到ArrayList集合中获取值\n           String name = array.get(index);\n   \n           //把第7步得到的数据输出在控制台\n           System.out.println("幸运者是：" + name);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n\n\n# 1.4 集合到文件改进版\n\n * 案例需求\n   \n   把ArrayList集合中的学生数据写入到文本文件。要求：每一个学生对象的数据作为文件中的一行数据 格式：学号,姓名,年龄,居住地 举例：itheima001,林青霞,30,西安\n\n * 实现步骤\n   \n   * 定义学生类\n   * 创建ArrayList集合\n   * 创建学生对象\n   * 把学生对象添加到集合中\n   * 创建字符缓冲输出流对象\n   * 遍历集合，得到每一个学生对象\n   * 把学生对象的数据拼接成指定格式的字符串\n   * 调用字符缓冲输出流对象的方法写数据\n   * 释放资源\n\n * 代码实现\n   \n   * 学生类\n     \n     public class Student {\n         private String sid;\n         private String name;\n         private int age;\n         private String address;\n     \n         public Student() {\n         }\n     \n         public Student(String sid, String name, int age, String address) {\n             this.sid = sid;\n             this.name = name;\n             this.age = age;\n             this.address = address;\n         }\n     \n         public String getSid() {\n             return sid;\n         }\n     \n         public void setSid(String sid) {\n             this.sid = sid;\n         }\n     \n         public String getName() {\n             return name;\n         }\n     \n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         public int getAge() {\n             return age;\n         }\n     \n         public void setAge(int age) {\n             this.age = age;\n         }\n     \n         public String getAddress() {\n             return address;\n         }\n     \n         public void setAddress(String address) {\n             this.address = address;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     47\n     48\n     \n   \n   * 测试类\n     \n     public class ArrayListToFileDemo {\n         public static void main(String[] args) throws IOException {\n             //创建ArrayList集合\n             ArrayList<Student> array = new ArrayList<Student>();\n     \n             //创建学生对象\n             Student s1 = new Student("itheima001", "林青霞", 30, "西安");\n             Student s2 = new Student("itheima002", "张曼玉", 35, "武汉");\n             Student s3 = new Student("itheima003", "王祖贤", 33, "郑州");\n     \n             //把学生对象添加到集合中\n             array.add(s1);\n             array.add(s2);\n             array.add(s3);\n     \n             //创建字符缓冲输出流对象\n             BufferedWriter bw = new BufferedWriter(new FileWriter("myCharStream\\\\students.txt"));\n     \n             //遍历集合，得到每一个学生对象\n             for (Student s : array) {\n                 //把学生对象的数据拼接成指定格式的字符串\n                 StringBuilder sb = new StringBuilder();\n                 sb.append(s.getSid()).append(",").append(s.getName()).append(",").append(s.getAge()).append(",").append(s.getAddress());\n     \n                 //调用字符缓冲输出流对象的方法写数据\n                 bw.write(sb.toString());\n                 bw.newLine();\n                 bw.flush();\n             }\n     \n             //释放资源\n             bw.close();\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     \n\n\n# 1.5 文件到集合改进版\n\n * 案例需求\n   \n   把文本文件中的数据读取到集合中，并遍历集合。要求：文件中每一行数据是一个学生对象的成员变量值 举例：itheima001,林青霞,30,西安\n\n * 实现步骤\n   \n   * 定义学生类\n   * 创建字符缓冲输入流对象\n   * 创建ArrayList集合对象\n   * 调用字符缓冲输入流对象的方法读数据\n   * 把读取到的字符串数据用split()进行分割，得到一个字符串数组\n   * 创建学生对象\n   * 把字符串数组中的每一个元素取出来对应的赋值给学生对象的成员变量值\n   * 把学生对象添加到集合\n   * 释放资源\n   * 遍历集合\n\n * 代码实现\n   \n   * 学生类\n     \n     同上\n   \n   * 测试类\n     \n     public class FileToArrayListDemo {\n         public static void main(String[] args) throws IOException {\n             //创建字符缓冲输入流对象\n             BufferedReader br = new BufferedReader(new FileReader("myCharStream\\\\students.txt"));\n     \n             //创建ArrayList集合对象\n             ArrayList<Student> array = new ArrayList<Student>();\n     \n             //调用字符缓冲输入流对象的方法读数据\n             String line;\n             while ((line = br.readLine()) != null) {\n                 //把读取到的字符串数据用split()进行分割，得到一个字符串数组\n                 String[] strArray = line.split(",");\n     \n                 //创建学生对象\n                 Student s = new Student();\n                 //把字符串数组中的每一个元素取出来对应的赋值给学生对象的成员变量值\n                 //itheima001,林青霞,30,西安\n                 s.setSid(strArray[0]);\n                 s.setName(strArray[1]);\n                 s.setAge(Integer.parseInt(strArray[2]));\n                 s.setAddress(strArray[3]);\n     \n                 //把学生对象添加到集合\n                 array.add(s);\n             }\n     \n             //释放资源\n             br.close();\n     \n             //遍历集合\n             for (Student s : array) {\n                 System.out.println(s.getSid() + "," + s.getName() + "," + s.getAge() + "," + s.getAddress());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n\n\n# 2. 练习案例二\n\n\n# 2.1 集合到文件数据排序改进版\n\n# 1. 案例需求\n\n * 键盘录入5个学生信息(姓名,语文成绩,数学成绩,英语成绩)。要求按照成绩总分从高到低写入文本文件\n * 格式：姓名,语文成绩,数学成绩,英语成绩 举例：林青霞,98,99,100\n\n# 2. 分析步骤\n\n 1.  定义学生类\n 2.  创建TreeSet集合，通过比较器排序进行排序\n 3.  键盘录入学生数据\n 4.  创建学生对象，把键盘录入的数据对应赋值给学生对象的成员变量\n 5.  把学生对象添加到TreeSet集合\n 6.  创建字符缓冲输出流对象\n 7.  遍历集合，得到每一个学生对象\n 8.  把学生对象的数据拼接成指定格式的字符串\n 9.  调用字符缓冲输出流对象的方法写数据\n 10. 释放资源\n\n# 3. 代码实现\n\n * 学生类\n   \n   public class Student {\n       // 姓名\n       private String name;\n       // 语文成绩\n       private int chinese;\n       // 数学成绩\n       private int math;\n       // 英语成绩\n       private int english;\n   \n       public Student() {\n           super();\n       }\n   \n       public Student(String name, int chinese, int math, int english) {\n           super();\n           this.name = name;\n           this.chinese = chinese;\n           this.math = math;\n           this.english = english;\n       }\n   \n       public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public int getChinese() {\n           return chinese;\n       }\n   \n       public void setChinese(int chinese) {\n           this.chinese = chinese;\n       }\n   \n       public int getMath() {\n           return math;\n       }\n   \n       public void setMath(int math) {\n           this.math = math;\n       }\n   \n       public int getEnglish() {\n           return english;\n       }\n   \n       public void setEnglish(int english) {\n           this.english = english;\n       }\n   \n       public int getSum() {\n           return this.chinese + this.math + this.english;\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   \n\n * 测试类\n   \n   public class TreeSetToFileDemo {\n       public static void main(String[] args) throws IOException {\n           //创建TreeSet集合，通过比较器排序进行排序\n           TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {\n               @Override\n               public int compare(Student s1, Student s2) {\n                   //成绩总分从高到低\n                   int num = s2.getSum() - s1.getSum();\n                   //次要条件\n                   int num2 = num == 0 ? s1.getChinese() - s2.getChinese() : num;\n                   int num3 = num2 == 0 ? s1.getMath() - s2.getMath() : num2;\n                   int num4 = num3 == 0 ? s1.getName().compareTo(s2.getName()) : num3;\n                   return num4;\n               }\n           });\n   \n           //键盘录入学生数据\n           for (int i = 0; i < 5; i++) {\n               Scanner sc = new Scanner(System.in);\n               System.out.println("请录入第" + (i + 1) + "个学生信息：");\n               System.out.println("姓名：");\n               String name = sc.nextLine();\n               System.out.println("语文成绩：");\n               int chinese = sc.nextInt();\n               System.out.println("数学成绩：");\n               int math = sc.nextInt();\n               System.out.println("英语成绩：");\n               int english = sc.nextInt();\n   \n               //创建学生对象，把键盘录入的数据对应赋值给学生对象的成员变量\n               Student s = new Student();\n               s.setName(name);\n               s.setChinese(chinese);\n               s.setMath(math);\n               s.setEnglish(english);\n   \n               //把学生对象添加到TreeSet集合\n               ts.add(s);\n           }\n   \n           //创建字符缓冲输出流对象\n           BufferedWriter bw = new BufferedWriter(new FileWriter("myCharStream\\\\ts.txt"));\n   \n           //遍历集合，得到每一个学生对象\n           for (Student s : ts) {\n               //把学生对象的数据拼接成指定格式的字符串\n               //格式：姓名,语文成绩,数学成绩,英语成绩\n               StringBuilder sb = new StringBuilder();\n               sb.append(s.getName()).append(",").append(s.getChinese()).append(",").append(s.getMath()).append(",").append(s.getEnglish()).append(",").append(s.getSum());\n   \n   //            调用字符缓冲输出流对象的方法写数据\n               bw.write(sb.toString());\n               bw.newLine();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   \n\n\n# 2.2 复制单级文件夹\n\n# 1. 案例需求\n\n * 把“E:\\itcast”这个文件夹复制到模块目录下\n\n# 2. 分析步骤\n\n 1. 创建数据源目录File对象，路径是E:\\itcast\n\n 2. 获取数据源目录File对象的名称\n\n 3. 创建目的地目录File对象，路径由(模块名+第2步获取的名称)组成\n\n 4. 判断第3步创建的File是否存在，如果不存在，就创建\n\n 5. 获取数据源目录下所有文件的File数组\n\n 6. 遍历File数组，得到每一个File对象，该File对象，其实就是数据源文件\n\n 7. 获取数据源文件File对象的名称\n\n 8. 创建目的地文件File对象，路径由(目的地目录+第7步获取的名称)组成\n\n 9. 复制文件\n    \n    由于不清楚数据源目录下的文件都是什么类型的，所以采用字节流复制文件\n    \n    采用参数为File的构造方法\n\n# 3. 代码实现\n\npublic class CopyFolderDemo {\n    public static void main(String[] args) throws IOException {\n        //创建数据源目录File对象，路径是E:\\\\itcast\n        File srcFolder = new File("E:\\\\itcast");\n\n        //获取数据源目录File对象的名称(itcast)\n        String srcFolderName = srcFolder.getName();\n\n        //创建目的地目录File对象，路径名是模块名+itcast组成(myCharStream\\\\itcast)\n        File destFolder = new File("myCharStream",srcFolderName);\n\n        //判断目的地目录对应的File是否存在，如果不存在，就创建\n        if(!destFolder.exists()) {\n            destFolder.mkdir();\n        }\n\n        //获取数据源目录下所有文件的File数组\n        File[] listFiles = srcFolder.listFiles();\n\n        //遍历File数组，得到每一个File对象，该File对象，其实就是数据源文件\n        for(File srcFile : listFiles) {\n            //数据源文件：E:\\\\itcast\\\\mn.jpg\n            //获取数据源文件File对象的名称(mn.jpg)\n            String srcFileName = srcFile.getName();\n            //创建目的地文件File对象，路径名是目的地目录+mn.jpg组成(myCharStream\\\\itcast\\\\mn.jpg)\n            File destFile = new File(destFolder,srcFileName);\n            //复制文件\n            copyFile(srcFile,destFile);\n        }\n    }\n\n    private static void copyFile(File srcFile, File destFile) throws IOException {\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));\n\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len=bis.read(bys))!=-1) {\n            bos.write(bys,0,len);\n        }\n\n        bos.close();\n        bis.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 2.3 复制多级文件夹\n\n# 1. 案例需求\n\n * 把“E:\\itcast”这个文件夹复制到 F盘目录下\n\n# 2. 分析步骤\n\n 1. 创建数据源File对象，路径是E:\\itcast\n\n 2. 创建目的地File对象，路径是F:\\\n\n 3. 写方法实现文件夹的复制，参数为数据源File对象和目的地File对象\n\n 4. 判断数据源File是否是文件\n    \n    是文件：直接复制，用字节流\n    \n    不是文件：\n    \n     \t 在目的地下创建该目录\n     \n     \t遍历获取该目录下的所有文件的File数组，得到每一个File对象\n     \n     \t回到3继续(递归)\n    \n\n# 3. 代码实现\n\npublic class CopyFoldersDemo {\n    public static void main(String[] args) throws IOException {\n        //创建数据源File对象，路径是E:\\\\itcast\n        File srcFile = new File("E:\\\\itcast");\n        //创建目的地File对象，路径是F:\\\\\n        File destFile = new File("F:\\\\");\n\n        //写方法实现文件夹的复制，参数为数据源File对象和目的地File对象\n        copyFolder(srcFile,destFile);\n    }\n\n    //复制文件夹\n    private static void copyFolder(File srcFile, File destFile) throws IOException {\n        //判断数据源File是否是目录\n        if(srcFile.isDirectory()) {\n            //在目的地下创建和数据源File名称一样的目录\n            String srcFileName = srcFile.getName();\n            File newFolder = new File(destFile,srcFileName); //F:\\\\itcast\n            if(!newFolder.exists()) {\n                newFolder.mkdir();\n            }\n\n            //获取数据源File下所有文件或者目录的File数组\n            File[] fileArray = srcFile.listFiles();\n\n            //遍历该File数组，得到每一个File对象\n            for(File file : fileArray) {\n                //把该File作为数据源File对象，递归调用复制文件夹的方法\n                copyFolder(file,newFolder);\n            }\n        } else {\n            //说明是文件，直接复制，用字节流\n            File newFile = new File(destFile,srcFile.getName());\n            copyFile(srcFile,newFile);\n        }\n    }\n\n    //字节缓冲流复制文件\n    private static void copyFile(File srcFile, File destFile) throws IOException {\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));\n\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len = bis.read(bys)) != -1) {\n            bos.write(bys, 0, len);\n        }\n\n        bos.close();\n        bis.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 2.4 复制文件的异常处理\n\n# 1. 基本做法\n\npublic class CopyFileDemo {\n    public static void main(String[] args) {\n\n    }\n\n    //try...catch...finally\n    private static void method2() {\n        FileReader fr = null;\n        FileWriter fw = null;\n        try {\n            fr = new FileReader("fr.txt");\n            fw = new FileWriter("fw.txt");\n\n            char[] chs = new char[1024];\n            int len;\n            while ((len = fr.read()) != -1) {\n                fw.write(chs, 0, len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if(fw!=null) {\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fr!=null) {\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    //抛出处理\n    private static void method1() throws IOException {\n        FileReader fr = new FileReader("fr.txt");\n        FileWriter fw = new FileWriter("fw.txt");\n\n        char[] chs = new char[1024];\n        int len;\n        while ((len = fr.read()) != -1) {\n            fw.write(chs, 0, len);\n        }\n\n        fw.close();\n        fr.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 2. JDK7版本改进\n\npublic class CopyFileDemo {\n    public static void main(String[] args) {\n\n    }\n\n    //JDK7的改进方案\n    private static void method3() {\n        try(FileReader fr = new FileReader("fr.txt");\n            FileWriter fw = new FileWriter("fw.txt");){\n            char[] chs = new char[1024];\n            int len;\n            while ((len = fr.read()) != -1) {\n                fw.write(chs, 0, len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 3. JDK9版本改进\n\npublic class CopyFileDemo {\n    public static void main(String[] args) {\n\n    }\n\n    //JDK9的改进方案\n    private static void method4() throws IOException {\n        FileReader fr = new FileReader("fr.txt");\n        FileWriter fw = new FileWriter("fw.txt");\n        try(fr;fw){\n            char[] chs = new char[1024];\n            int len;\n            while ((len = fr.read()) != -1) {\n                fw.write(chs, 0, len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',normalizedContent:'# io流案例\n\n\n# 1. 练习案例一\n\n\n# 1.1 集合到文件\n\n * 案例需求\n   \n   把文本文件中的数据读取到集合中，并遍历集合。要求：文件中每一行数据是一个集合元素\n\n * 实现步骤\n   \n   * 创建字符缓冲输入流对象\n   * 创建arraylist集合对象\n   * 调用字符缓冲输入流对象的方法读数据\n   * 把读取到的字符串数据存储到集合中\n   * 释放资源\n   * 遍历集合\n\n * 代码实现\n   \n   public class txttoarraylistdemo {\n       public static void main(string[] args) throws ioexception {\n           //创建字符缓冲输入流对象\n           bufferedreader br = new bufferedreader(new filereader("mycharstream\\\\array.txt"));\n   \n           //创建arraylist集合对象\n           arraylist<string> array = new arraylist<string>();\n   \n           //调用字符缓冲输入流对象的方法读数据\n           string line;\n           while ((line=br.readline())!=null) {\n               //把读取到的字符串数据存储到集合中\n               array.add(line);\n           }\n           //释放资源\n           br.close();\n           //遍历集合\n           for(string s : array) {\n               system.out.println(s);\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 1.2 文件到集合\n\n * 案例需求\n   \n   把arraylist集合中的字符串数据写入到文本文件。要求：每一个字符串元素作为文件中的一行数据\n\n * 实现步骤\n   \n   * 创建arraylist集合\n   * 往集合中存储字符串元素\n   * 创建字符缓冲输出流对象\n   * 遍历集合，得到每一个字符串数据\n   * 调用字符缓冲输出流对象的方法写数据\n   * 释放资源\n\n * 代码实现\n   \n   public class arraylisttotxtdemo {\n       public static void main(string[] args) throws ioexception {\n           //创建arraylist集合\n           arraylist<string> array = new arraylist<string>();\n   \n           //往集合中存储字符串元素\n           array.add("hello");\n           array.add("world");\n           array.add("java");\n   \n           //创建字符缓冲输出流对象\n           bufferedwriter bw = new bufferedwriter(new filewriter("mycharstream\\\\array.txt"));\n   \n           //遍历集合，得到每一个字符串数据\n           for(string s : array) {\n               //调用字符缓冲输出流对象的方法写数据\n               bw.write(s);\n               bw.newline();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n\n\n# 1.3 点名器\n\n * 案例需求\n   \n   我有一个文件里面存储了班级同学的姓名，每一个姓名占一行，要求通过程序实现随点名器\n\n * 实现步骤\n   \n   * 创建字符缓冲输入流对象\n   * 创建arraylist集合对象\n   * 调用字符缓冲输入流对象的方法读数据\n   * 把读取到的字符串数据存储到集合中\n   * 释放资源\n   * 使用random产生一个随机数，随机数的范围在：[0,集合的长度)\n   * 把第6步产生的随机数作为索引到arraylist集合中获取值\n   * 把第7步得到的数据输出在控制台\n\n * 代码实现\n   \n   public class callnamedemo {\n       public static void main(string[] args) throws ioexception {\n           //创建字符缓冲输入流对象\n           bufferedreader br = new bufferedreader(new filereader("mycharstream\\\\names.txt"));\n   \n           //创建arraylist集合对象\n           arraylist<string> array = new arraylist<string>();\n   \n           //调用字符缓冲输入流对象的方法读数据\n           string line;\n           while ((line=br.readline())!=null) {\n               //把读取到的字符串数据存储到集合中\n               array.add(line);\n           }\n   \n           //释放资源\n           br.close();\n   \n           //使用random产生一个随机数，随机数的范围在：[0,集合的长度)\n           random r = new random();\n           int index = r.nextint(array.size());\n   \n           //把第6步产生的随机数作为索引到arraylist集合中获取值\n           string name = array.get(index);\n   \n           //把第7步得到的数据输出在控制台\n           system.out.println("幸运者是：" + name);\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n\n\n# 1.4 集合到文件改进版\n\n * 案例需求\n   \n   把arraylist集合中的学生数据写入到文本文件。要求：每一个学生对象的数据作为文件中的一行数据 格式：学号,姓名,年龄,居住地 举例：itheima001,林青霞,30,西安\n\n * 实现步骤\n   \n   * 定义学生类\n   * 创建arraylist集合\n   * 创建学生对象\n   * 把学生对象添加到集合中\n   * 创建字符缓冲输出流对象\n   * 遍历集合，得到每一个学生对象\n   * 把学生对象的数据拼接成指定格式的字符串\n   * 调用字符缓冲输出流对象的方法写数据\n   * 释放资源\n\n * 代码实现\n   \n   * 学生类\n     \n     public class student {\n         private string sid;\n         private string name;\n         private int age;\n         private string address;\n     \n         public student() {\n         }\n     \n         public student(string sid, string name, int age, string address) {\n             this.sid = sid;\n             this.name = name;\n             this.age = age;\n             this.address = address;\n         }\n     \n         public string getsid() {\n             return sid;\n         }\n     \n         public void setsid(string sid) {\n             this.sid = sid;\n         }\n     \n         public string getname() {\n             return name;\n         }\n     \n         public void setname(string name) {\n             this.name = name;\n         }\n     \n         public int getage() {\n             return age;\n         }\n     \n         public void setage(int age) {\n             this.age = age;\n         }\n     \n         public string getaddress() {\n             return address;\n         }\n     \n         public void setaddress(string address) {\n             this.address = address;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     47\n     48\n     \n   \n   * 测试类\n     \n     public class arraylisttofiledemo {\n         public static void main(string[] args) throws ioexception {\n             //创建arraylist集合\n             arraylist<student> array = new arraylist<student>();\n     \n             //创建学生对象\n             student s1 = new student("itheima001", "林青霞", 30, "西安");\n             student s2 = new student("itheima002", "张曼玉", 35, "武汉");\n             student s3 = new student("itheima003", "王祖贤", 33, "郑州");\n     \n             //把学生对象添加到集合中\n             array.add(s1);\n             array.add(s2);\n             array.add(s3);\n     \n             //创建字符缓冲输出流对象\n             bufferedwriter bw = new bufferedwriter(new filewriter("mycharstream\\\\students.txt"));\n     \n             //遍历集合，得到每一个学生对象\n             for (student s : array) {\n                 //把学生对象的数据拼接成指定格式的字符串\n                 stringbuilder sb = new stringbuilder();\n                 sb.append(s.getsid()).append(",").append(s.getname()).append(",").append(s.getage()).append(",").append(s.getaddress());\n     \n                 //调用字符缓冲输出流对象的方法写数据\n                 bw.write(sb.tostring());\n                 bw.newline();\n                 bw.flush();\n             }\n     \n             //释放资源\n             bw.close();\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     \n\n\n# 1.5 文件到集合改进版\n\n * 案例需求\n   \n   把文本文件中的数据读取到集合中，并遍历集合。要求：文件中每一行数据是一个学生对象的成员变量值 举例：itheima001,林青霞,30,西安\n\n * 实现步骤\n   \n   * 定义学生类\n   * 创建字符缓冲输入流对象\n   * 创建arraylist集合对象\n   * 调用字符缓冲输入流对象的方法读数据\n   * 把读取到的字符串数据用split()进行分割，得到一个字符串数组\n   * 创建学生对象\n   * 把字符串数组中的每一个元素取出来对应的赋值给学生对象的成员变量值\n   * 把学生对象添加到集合\n   * 释放资源\n   * 遍历集合\n\n * 代码实现\n   \n   * 学生类\n     \n     同上\n   \n   * 测试类\n     \n     public class filetoarraylistdemo {\n         public static void main(string[] args) throws ioexception {\n             //创建字符缓冲输入流对象\n             bufferedreader br = new bufferedreader(new filereader("mycharstream\\\\students.txt"));\n     \n             //创建arraylist集合对象\n             arraylist<student> array = new arraylist<student>();\n     \n             //调用字符缓冲输入流对象的方法读数据\n             string line;\n             while ((line = br.readline()) != null) {\n                 //把读取到的字符串数据用split()进行分割，得到一个字符串数组\n                 string[] strarray = line.split(",");\n     \n                 //创建学生对象\n                 student s = new student();\n                 //把字符串数组中的每一个元素取出来对应的赋值给学生对象的成员变量值\n                 //itheima001,林青霞,30,西安\n                 s.setsid(strarray[0]);\n                 s.setname(strarray[1]);\n                 s.setage(integer.parseint(strarray[2]));\n                 s.setaddress(strarray[3]);\n     \n                 //把学生对象添加到集合\n                 array.add(s);\n             }\n     \n             //释放资源\n             br.close();\n     \n             //遍历集合\n             for (student s : array) {\n                 system.out.println(s.getsid() + "," + s.getname() + "," + s.getage() + "," + s.getaddress());\n             }\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     \n\n\n# 2. 练习案例二\n\n\n# 2.1 集合到文件数据排序改进版\n\n# 1. 案例需求\n\n * 键盘录入5个学生信息(姓名,语文成绩,数学成绩,英语成绩)。要求按照成绩总分从高到低写入文本文件\n * 格式：姓名,语文成绩,数学成绩,英语成绩 举例：林青霞,98,99,100\n\n# 2. 分析步骤\n\n 1.  定义学生类\n 2.  创建treeset集合，通过比较器排序进行排序\n 3.  键盘录入学生数据\n 4.  创建学生对象，把键盘录入的数据对应赋值给学生对象的成员变量\n 5.  把学生对象添加到treeset集合\n 6.  创建字符缓冲输出流对象\n 7.  遍历集合，得到每一个学生对象\n 8.  把学生对象的数据拼接成指定格式的字符串\n 9.  调用字符缓冲输出流对象的方法写数据\n 10. 释放资源\n\n# 3. 代码实现\n\n * 学生类\n   \n   public class student {\n       // 姓名\n       private string name;\n       // 语文成绩\n       private int chinese;\n       // 数学成绩\n       private int math;\n       // 英语成绩\n       private int english;\n   \n       public student() {\n           super();\n       }\n   \n       public student(string name, int chinese, int math, int english) {\n           super();\n           this.name = name;\n           this.chinese = chinese;\n           this.math = math;\n           this.english = english;\n       }\n   \n       public string getname() {\n           return name;\n       }\n   \n       public void setname(string name) {\n           this.name = name;\n       }\n   \n       public int getchinese() {\n           return chinese;\n       }\n   \n       public void setchinese(int chinese) {\n           this.chinese = chinese;\n       }\n   \n       public int getmath() {\n           return math;\n       }\n   \n       public void setmath(int math) {\n           this.math = math;\n       }\n   \n       public int getenglish() {\n           return english;\n       }\n   \n       public void setenglish(int english) {\n           this.english = english;\n       }\n   \n       public int getsum() {\n           return this.chinese + this.math + this.english;\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   \n\n * 测试类\n   \n   public class treesettofiledemo {\n       public static void main(string[] args) throws ioexception {\n           //创建treeset集合，通过比较器排序进行排序\n           treeset<student> ts = new treeset<student>(new comparator<student>() {\n               @override\n               public int compare(student s1, student s2) {\n                   //成绩总分从高到低\n                   int num = s2.getsum() - s1.getsum();\n                   //次要条件\n                   int num2 = num == 0 ? s1.getchinese() - s2.getchinese() : num;\n                   int num3 = num2 == 0 ? s1.getmath() - s2.getmath() : num2;\n                   int num4 = num3 == 0 ? s1.getname().compareto(s2.getname()) : num3;\n                   return num4;\n               }\n           });\n   \n           //键盘录入学生数据\n           for (int i = 0; i < 5; i++) {\n               scanner sc = new scanner(system.in);\n               system.out.println("请录入第" + (i + 1) + "个学生信息：");\n               system.out.println("姓名：");\n               string name = sc.nextline();\n               system.out.println("语文成绩：");\n               int chinese = sc.nextint();\n               system.out.println("数学成绩：");\n               int math = sc.nextint();\n               system.out.println("英语成绩：");\n               int english = sc.nextint();\n   \n               //创建学生对象，把键盘录入的数据对应赋值给学生对象的成员变量\n               student s = new student();\n               s.setname(name);\n               s.setchinese(chinese);\n               s.setmath(math);\n               s.setenglish(english);\n   \n               //把学生对象添加到treeset集合\n               ts.add(s);\n           }\n   \n           //创建字符缓冲输出流对象\n           bufferedwriter bw = new bufferedwriter(new filewriter("mycharstream\\\\ts.txt"));\n   \n           //遍历集合，得到每一个学生对象\n           for (student s : ts) {\n               //把学生对象的数据拼接成指定格式的字符串\n               //格式：姓名,语文成绩,数学成绩,英语成绩\n               stringbuilder sb = new stringbuilder();\n               sb.append(s.getname()).append(",").append(s.getchinese()).append(",").append(s.getmath()).append(",").append(s.getenglish()).append(",").append(s.getsum());\n   \n   //            调用字符缓冲输出流对象的方法写数据\n               bw.write(sb.tostring());\n               bw.newline();\n               bw.flush();\n           }\n   \n           //释放资源\n           bw.close();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   \n\n\n# 2.2 复制单级文件夹\n\n# 1. 案例需求\n\n * 把“e:\\itcast”这个文件夹复制到模块目录下\n\n# 2. 分析步骤\n\n 1. 创建数据源目录file对象，路径是e:\\itcast\n\n 2. 获取数据源目录file对象的名称\n\n 3. 创建目的地目录file对象，路径由(模块名+第2步获取的名称)组成\n\n 4. 判断第3步创建的file是否存在，如果不存在，就创建\n\n 5. 获取数据源目录下所有文件的file数组\n\n 6. 遍历file数组，得到每一个file对象，该file对象，其实就是数据源文件\n\n 7. 获取数据源文件file对象的名称\n\n 8. 创建目的地文件file对象，路径由(目的地目录+第7步获取的名称)组成\n\n 9. 复制文件\n    \n    由于不清楚数据源目录下的文件都是什么类型的，所以采用字节流复制文件\n    \n    采用参数为file的构造方法\n\n# 3. 代码实现\n\npublic class copyfolderdemo {\n    public static void main(string[] args) throws ioexception {\n        //创建数据源目录file对象，路径是e:\\\\itcast\n        file srcfolder = new file("e:\\\\itcast");\n\n        //获取数据源目录file对象的名称(itcast)\n        string srcfoldername = srcfolder.getname();\n\n        //创建目的地目录file对象，路径名是模块名+itcast组成(mycharstream\\\\itcast)\n        file destfolder = new file("mycharstream",srcfoldername);\n\n        //判断目的地目录对应的file是否存在，如果不存在，就创建\n        if(!destfolder.exists()) {\n            destfolder.mkdir();\n        }\n\n        //获取数据源目录下所有文件的file数组\n        file[] listfiles = srcfolder.listfiles();\n\n        //遍历file数组，得到每一个file对象，该file对象，其实就是数据源文件\n        for(file srcfile : listfiles) {\n            //数据源文件：e:\\\\itcast\\\\mn.jpg\n            //获取数据源文件file对象的名称(mn.jpg)\n            string srcfilename = srcfile.getname();\n            //创建目的地文件file对象，路径名是目的地目录+mn.jpg组成(mycharstream\\\\itcast\\\\mn.jpg)\n            file destfile = new file(destfolder,srcfilename);\n            //复制文件\n            copyfile(srcfile,destfile);\n        }\n    }\n\n    private static void copyfile(file srcfile, file destfile) throws ioexception {\n        bufferedinputstream bis = new bufferedinputstream(new fileinputstream(srcfile));\n        bufferedoutputstream bos = new bufferedoutputstream(new fileoutputstream(destfile));\n\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len=bis.read(bys))!=-1) {\n            bos.write(bys,0,len);\n        }\n\n        bos.close();\n        bis.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 2.3 复制多级文件夹\n\n# 1. 案例需求\n\n * 把“e:\\itcast”这个文件夹复制到 f盘目录下\n\n# 2. 分析步骤\n\n 1. 创建数据源file对象，路径是e:\\itcast\n\n 2. 创建目的地file对象，路径是f:\\\n\n 3. 写方法实现文件夹的复制，参数为数据源file对象和目的地file对象\n\n 4. 判断数据源file是否是文件\n    \n    是文件：直接复制，用字节流\n    \n    不是文件：\n    \n     \t 在目的地下创建该目录\n     \n     \t遍历获取该目录下的所有文件的file数组，得到每一个file对象\n     \n     \t回到3继续(递归)\n    \n\n# 3. 代码实现\n\npublic class copyfoldersdemo {\n    public static void main(string[] args) throws ioexception {\n        //创建数据源file对象，路径是e:\\\\itcast\n        file srcfile = new file("e:\\\\itcast");\n        //创建目的地file对象，路径是f:\\\\\n        file destfile = new file("f:\\\\");\n\n        //写方法实现文件夹的复制，参数为数据源file对象和目的地file对象\n        copyfolder(srcfile,destfile);\n    }\n\n    //复制文件夹\n    private static void copyfolder(file srcfile, file destfile) throws ioexception {\n        //判断数据源file是否是目录\n        if(srcfile.isdirectory()) {\n            //在目的地下创建和数据源file名称一样的目录\n            string srcfilename = srcfile.getname();\n            file newfolder = new file(destfile,srcfilename); //f:\\\\itcast\n            if(!newfolder.exists()) {\n                newfolder.mkdir();\n            }\n\n            //获取数据源file下所有文件或者目录的file数组\n            file[] filearray = srcfile.listfiles();\n\n            //遍历该file数组，得到每一个file对象\n            for(file file : filearray) {\n                //把该file作为数据源file对象，递归调用复制文件夹的方法\n                copyfolder(file,newfolder);\n            }\n        } else {\n            //说明是文件，直接复制，用字节流\n            file newfile = new file(destfile,srcfile.getname());\n            copyfile(srcfile,newfile);\n        }\n    }\n\n    //字节缓冲流复制文件\n    private static void copyfile(file srcfile, file destfile) throws ioexception {\n        bufferedinputstream bis = new bufferedinputstream(new fileinputstream(srcfile));\n        bufferedoutputstream bos = new bufferedoutputstream(new fileoutputstream(destfile));\n\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len = bis.read(bys)) != -1) {\n            bos.write(bys, 0, len);\n        }\n\n        bos.close();\n        bis.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 2.4 复制文件的异常处理\n\n# 1. 基本做法\n\npublic class copyfiledemo {\n    public static void main(string[] args) {\n\n    }\n\n    //try...catch...finally\n    private static void method2() {\n        filereader fr = null;\n        filewriter fw = null;\n        try {\n            fr = new filereader("fr.txt");\n            fw = new filewriter("fw.txt");\n\n            char[] chs = new char[1024];\n            int len;\n            while ((len = fr.read()) != -1) {\n                fw.write(chs, 0, len);\n            }\n        } catch (ioexception e) {\n            e.printstacktrace();\n        } finally {\n            if(fw!=null) {\n                try {\n                    fw.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            if(fr!=null) {\n                try {\n                    fr.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    }\n\n    //抛出处理\n    private static void method1() throws ioexception {\n        filereader fr = new filereader("fr.txt");\n        filewriter fw = new filewriter("fw.txt");\n\n        char[] chs = new char[1024];\n        int len;\n        while ((len = fr.read()) != -1) {\n            fw.write(chs, 0, len);\n        }\n\n        fw.close();\n        fr.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 2. jdk7版本改进\n\npublic class copyfiledemo {\n    public static void main(string[] args) {\n\n    }\n\n    //jdk7的改进方案\n    private static void method3() {\n        try(filereader fr = new filereader("fr.txt");\n            filewriter fw = new filewriter("fw.txt");){\n            char[] chs = new char[1024];\n            int len;\n            while ((len = fr.read()) != -1) {\n                fw.write(chs, 0, len);\n            }\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 3. jdk9版本改进\n\npublic class copyfiledemo {\n    public static void main(string[] args) {\n\n    }\n\n    //jdk9的改进方案\n    private static void method4() throws ioexception {\n        filereader fr = new filereader("fr.txt");\n        filewriter fw = new filewriter("fw.txt");\n        try(fr;fw){\n            char[] chs = new char[1024];\n            int len;\n            while ((len = fr.read()) != -1) {\n                fw.write(chs, 0, len);\n            }\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',charsets:{cjk:!0},lastUpdated:"2023/02/28, 18:23:46",lastUpdatedTimestamp:1677579826e3},{title:"注解",frontmatter:{title:"注解",date:"2023-02-28T15:38:35.000Z",permalink:"/pages/704cf9/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/13.%E6%B3%A8%E8%A7%A3.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/13.注解.md",key:"v-026fe816",path:"/pages/704cf9/",headers:[{level:2,title:"1. 简介",slug:"_1-简介",normalizedTitle:"1. 简介",charIndex:9},{level:2,title:"2. 注解详细介绍",slug:"_2-注解详细介绍",normalizedTitle:"2. 注解详细介绍",charIndex:837},{level:3,title:"2.1 元注解介绍",slug:"_2-1-元注解介绍",normalizedTitle:"2.1 元注解介绍",charIndex:1009},{level:4,title:"@Target",slug:"target",normalizedTitle:"@target",charIndex:234},{level:5,title:"ElementType",slug:"elementtype",normalizedTitle:"elementtype",charIndex:242},{level:4,title:"@Retention",slug:"retention",normalizedTitle:"@retention",charIndex:198},{level:5,title:"RetentionPolicy.class",slug:"retentionpolicy-class",normalizedTitle:"retentionpolicy.class",charIndex:2747},{level:4,title:"@Documented",slug:"documented",normalizedTitle:"@documented",charIndex:186},{level:4,title:"@Inherited",slug:"inherited",normalizedTitle:"@inherited",charIndex:1158},{level:4,title:"@Native",slug:"native",normalizedTitle:"@native",charIndex:1199},{level:4,title:"@Repeatable",slug:"repeatable",normalizedTitle:"@repeatable",charIndex:1219},{level:3,title:"2.2 JDK基本注解介绍",slug:"_2-2-jdk基本注解介绍",normalizedTitle:"2.2 jdk基本注解介绍",charIndex:6929},{level:4,title:"@Override",slug:"override",normalizedTitle:"@override",charIndex:728},{level:4,title:"@Deprecated",slug:"deprecated",normalizedTitle:"@deprecated",charIndex:6972},{level:4,title:"@SuppressWarnings",slug:"suppresswarnings",normalizedTitle:"@suppresswarnings",charIndex:6989},{level:4,title:"@SafeVarargs",slug:"safevarargs",normalizedTitle:"@safevarargs",charIndex:7012},{level:4,title:"@FunctionalInterface",slug:"functionalinterface",normalizedTitle:"@functionalinterface",charIndex:7030},{level:2,title:"3. 写一个自己的注解",slug:"_3-写一个自己的注解",normalizedTitle:"3. 写一个自己的注解",charIndex:12625},{level:2,title:"4. 参考",slug:"_4-参考",normalizedTitle:"4. 参考",charIndex:14071}],headersStr:"1. 简介 2. 注解详细介绍 2.1 元注解介绍 @Target ElementType @Retention RetentionPolicy.class @Documented @Inherited @Native @Repeatable 2.2 JDK基本注解介绍 @Override @Deprecated @SuppressWarnings @SafeVarargs @FunctionalInterface 3. 写一个自己的注解 4. 参考",content:'# 注解\n\n\n# 1. 简介\n\nAnnotation（注解）是JDK5开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类，方法或者变量，在框架中大量使用（如 Spring、Mybatis等）\n\n> 注解是一种能被添加到java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。\n\n下面是我简单写的一个自定义注解\n\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface Test {\n    public int id() default -1;\n\n    public String msg() default "Hi";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通过对上述文件的字节码（.class）的反编译（javap - p xxx.class）可以得到@interface其实就是一个继承了Annotation的一个接口\n\njavap -p Test.class\n\npublic interface com.dyw.annotation.Test extends java.lang.annotation.Annotation {\n  public abstract int id();\n  public abstract java.lang.String msg();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注解只有被解析之后才会生效，常见的解析方法有两种：\n\n * 编译期间直接扫描：编译器在编译Java代码的时候扫描对于的注解并处理，比如某个方法使用了@Override，编译器在编译的时候就会检测当前的方法是否重写了父类对于的方法。\n * 运行期间通过反射处理：这个经常在Spring框架中看到，例如Spring的@Value注解，就是通过反射来进行处理的。\n\n\n# 2. 注解详细介绍\n\n我们通过上述的例子可以看到我们的注解上面还有着其他的注解例如@Retention、@Target（这些都统称为元注解）.\n\n所以一个注解是由以下成分组成\n\n>  * 元注解\n>  * public @interface 注解名称\n\n----------------------------------------\n\n\n# 2.1 元注解介绍\n\nJDK1.8版本为我们提供了6个标准的用来对注解类型进行注解的注解类（1.8之前只有四个），我们称之为meta-annotation（元注解）.\n\n元注解只能用在注解之上（自定义注解时可用）\n\n\n\n> @Target\n> @Retention\n> @Documented\n> @Inherited\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> @Native（1.8新增）\n> \n> @Repeatable（1.8新增）\n\n----------------------------------------\n\n# @Target\n\n官方解释：\n\n\t指示注解类型适用的上下文。注解类型可能适用的声明上下文和类型上下文在 JLS 9.6.4.1 中指定，并在源代码中由java.lang.annotation.ElementType的枚举常量表示。\n\t如果注解类型T上不存在@Target元注解，则类型T的注解可以写为除类型参数声明之外的任何声明的修饰符。\n\t如果存在@Target元注解，编译器将强制执行ElementType枚举常量指示的使用限制，符合 JLS 9.7.4。\n\n\n1\n2\n3\n\n * 它指明了它所修饰的注解使用的范围 如果自定义的注解为含有@Target元注解修饰，那么默认可以是在（除类型参数之外的）任何项之上使用，若有@Target元注解修饰那么根据Value（ElementType枚举常量）的指定的目标进行规定。\n\n# ElementType\n\nElementType.class\npublic enum ElementType {\n    /** 类、接口（包括注解类型）或枚举声明 */\n    TYPE,\n\n    /** 字段声明（包括枚举常量） */\n    FIELD,\n\n    /** 方法声明 */\n    METHOD,\n\n    /** 参数声明 */\n    PARAMETER,\n\n    /** 构造函数声明 */\n    CONSTRUCTOR,\n\n    /** 局部变量声明 */\n    LOCAL_VARIABLE,\n\n    /** 注解类型声明 */\n    ANNOTATION_TYPE,\n\n    /** 包装声明 */\n    PACKAGE,\n\n    /**\n     * 类型参数声明 类型参数即Map<String,Integer>中的String和Integer这里是作为类型\n     *\n     * @since 1.8\n     */\n    TYPE_PARAMETER,\n\n    /**\n     * 使用类型 对应于 JLS 4.11 中的 15 个类型上下文，以及两个声明上下文：类型声明（包括注解类型声明）和类型参数声明。\n     *\n     * @since 1.8\n     */\n    TYPE_USE\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * ElementType的枚举常量指明了注解可以使用的目标。\n\n@Target(ElementType.METHOD)//可修饰在方法之上\n\n\n1\n\n\n----------------------------------------\n\n# @Retention\n\n官方解释：\n\n指示要保留带注解类型的注解多长时间。如果注释类型声明中不存在保留注释，则保留策略默认为RetentionPolicy.CLASS 。\n仅当元注释类型直接用于注释时，保留元注释才有效。如果将元注释类型用作另一个注释类型中的成员类型，则它没有效果。\n\n\n1\n2\n\n * 即@Retention用来约束注解的生命周期，分别有三个值，源码级别（source）、类文件级别（class）或者运行时级别（runtime）可以通过指定@Retention中的值来实现（值为RetentionPolicy枚举常量）。\n\n# RetentionPolicy.class\n\npublic enum RetentionPolicy {\n    /**\n     * 注解将被编译器丢弃。(该类型的注解信息指挥保留在源码中，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件中)\n     */\n    SOURCE,\n\n    /**\n     * 注解将由编译器记录在类文件中，但不需要在运行时由 VM 保留。这是默认行为.(该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中) 该类型也是未指定@Retention值的缺省值\n     */\n    CLASS,\n\n    /**\n     * 注解将由编译器记录在类文件中，并在运行时由 VM 保留，因此可以反射性地读取它们。(源码，class文件和执行时(VM)都保留注解的信息)\n     */\n    RUNTIME\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意：生命周期大小排序为SOURCE < CLASS < RUNTIME，范围依次增大，前者能使用的地方后者一定能使用。如果需要在运行时去动态获取注解信息，那只能使用RUNTIME；如果要在编译时进行一些预处理操作，比如生成一些辅助代码，就是用CLASS；如果只是做一些检查性的操作，比如@Override和@SupperssWarning，可选择SOURCE\n\n----------------------------------------\n\n# @Documented\n\n官方解释：\n\n表示默认情况下，带有类型的注释将由 javadoc 和类似工具记录。这种类型应该用于注解类型的声明，这些类型的注释会影响其客户对注释元素的使用。如果使用 Documented 对类型声明进行注释，则其注释将成为注释元素的公共 API 的一部分。\n\n\n1\n\n * 带上该注解后的注解表明，在默认情况下这个注解是由JavaDoc和类似工具记录的，即带上了该文档化的注解被使用再生成文档时，会称为API的一部分。（默认情况下JavaDoc是不包含注解的，除非声明注解的时候使用了@Documented）\n\nPerson.java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Person {\n    String name() default "";\n}\n123456\nmain.java\npublic class main {\n    @Person(name = "ding")\n    public static void main(String[] args) {\n\n        System.out.println("hello");\n    }\n    //@Person(name = "ding")\n    @Person(name = "yang")\n    public static void doSome(){\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 生成的文档\n\n\n\n * 不带@Documented注解生成的文档\n\n\n\n----------------------------------------\n\n# @Inherited\n\n官方解释：\n\n指示注解类型是自动继承的。如果注解类型声明中存在 Inherited 元注解，并且用户在类声明中查询注解类型，并且类声明没有该类型的注解，则将自动查询该类的超类以获取注解类型。将重复此过程，直到找到此类型的注释，或到达类层次结构（对象）的顶部。如果没有超类具有此类型的注释，则查询将指示所讨论的类没有此类注释。\n请注意，如果注释类型用于注释类以外的任何内容，则此元注释类型无效。另请注意，此元注释仅导致注释从超类继承；已实现接口上的注解无效。\n12\n\n\n1\n2\n3\n\n * 被该元注解修饰的自定义注解再使用后会自动继承，如果使用了该自定义注解去修饰一个class那么这个注解也会作用于该class的子类。就是说如果某个类使用了被@Inherited修饰的注解，则其子类将会自动具有该注释\n\n注意： @Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。\n\n@Inherited //使用@Inherited修饰的自定义注解\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface Person {\n    String name() default "";\n}\n1234567\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nmain.java\n\npublic class main {\n    public static void main(String[] args) {\n        System.out.println(Father.class.getAnnotation(Person.class));\n        System.out.println(Son.class.getAnnotation(Person.class));\n    }\n\n}\n\n@Person\nclass Father {\n}\nclass Son extends com.dyw.annotation.obj.Father {\n\n}\n1234567891011121314\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n----------------------------------------\n\n# @Native\n\n官方解释：\n\n表示可以从本机代码引用定义常量值的字段。注释可以被生成本机头文件的工具用作提示，以确定是否需要头文件，如果需要，它应该包含哪些声明。\n1\n\n\n1\n2\n\n * 使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可。\n\n----------------------------------------\n\n# @Repeatable\n\n官方解释：\n\n注释类型java.lang.annotation.Repeatable用于指示它（元）注释其声明的注释类型是可重复的。 @Repeatable的值表示可重复注解类型的包含注解类型。\n1\n\n\n1\n2\n\n\n> @Repeatable允许在相同的程序元素中重复注解（不报错）。在需要对同一种注解多次使用时，往往需要借助 @Repeatable 注解。Java 8 版本以前，同一个程序元素前最多只能有一个相同类型的注解，如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。\n\n不使用@Repeatable修饰的自定义注解完成重复注解\n\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Persons {\n    Person[] value();\n}\n\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Person {\n    String name() default "";\n}\n12345678910111213\n@Persons(value = {@Person(name = "ding"),@Person(name = "yang")})\npublic static void doSome(){\n\n}\n1234\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n使用@Repeatable修饰的自定义注解\n\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Persons {\n    Person[] value();\n}\n\n@Repeatable(Persons.class)\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Person {\n    String name() default "";\n}\n\n@Person(name = "ding")\n@Person(name = "yang")\npublic static void doSome(){\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 两种方法不同的地方是，创建重复注解Person时加上了@Repeatable注解，指向存储注解Persons，这样使用时就可以直接重复使用Person注解。从上述例子可以看出使用@Repeatable注解更符合常规思维，可读性强。\n * 但两种方法的效果相同，只是使用了@Repeatable注解简化了写法，这种简化的底层依旧是多个重复注解使用了一个被称作“容器”注解的value的成员的数组元素处理。\n\n----------------------------------------\n\n\n# 2.2 JDK基本注解介绍\n\n基本注解包括\n\n>  * @Override\n>  * @Deprecated\n>  * @SuppressWarnings\n>  * @SafeVarargs\n>  * @FunctionalInterface\n\n# @Override\n\n官方解释：\n\n指示方法声明旨在覆盖超类型中的方法声明。如果使用此注解类型对方法进行注解，则编译器需要生成错误消息，除非至少满足以下条件之一：\n该方法确实覆盖或实现了在超类型中声明的方法。\n该方法的签名与Object中声明的任何公共方法的签名等效。\n123\npublic class Father {\n    public String msg(){\n        return "";\n    }\n}\n\npublic class Son extends Father{\n\n    @Override\n    public String msg() {\n        return "";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 如果将子类中方法名msg改为mg会发生如下编译错误\n\n> java: 方法不会覆盖或实现超类型的方法\n\n * 所以@Override的作用告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否者就会出错，这样可以帮助程序员避免一些低级错误。\n\n----------------------------------------\n\n# @Deprecated\n\n官方解释：\n\n@Deprecated 注释的程序元素是不鼓励程序员使用的程序元素，通常是因为它很危险，或者因为存在更好的替代方案。当在非弃用代码中使用或覆盖弃用的程序元素时，编译器会发出警告。\n1\n\n\n1\n2\n\n * 通俗的说被该注解修饰的目标项是已经过时的了，不推荐使用的。**\n\npublic class Son extends Father{\n    @Deprecated\n    @Override\n    public String msg() {\n        return "";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 使用@Deprecated修饰了Son中的msg方法后，调用该方法会出现删除线和编译警告。\n\n\n\n----------------------------------------\n\n# @SuppressWarnings\n\n官方解释：\n\n/**\n 指示应在带注释的元素（以及带注释的元素中包含的所有程序元素）中抑制命名的编译器警告。请注意，给定元素中抑制的警告集是所有包含元素中抑制的警告的超集。例如，如果您注释一个类以抑制一个警告并注释一个方法以抑制另一个警告，则两个警告都将在方法中被抑制。\n作为风格问题，程序员应该始终在最有效的嵌套元素上使用此注释。如果您想在特定方法中抑制警告，您应该注释该方法而不是它的类。\n*/\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\n@Retention(RetentionPolicy.SOURCE)\npublic @interface SuppressWarnings {\n    /**\n     *编译器要在带注释的元素中抑制的一组警告。允许重复名称。名称的第二次和连续出现将被忽略。存在无法识别的警告名称不是错误：编译器必须忽略它们无法识别的任何警告名称。但是，如果注释包含无法识别的警告名称，它们可以自由发出警告。\n字符串"unchecked"用于抑制未经检查的警告。编译器供应商应结合此注释类型记录他们支持的其他警告名称。鼓励他们合作以确保相同的名称在多个编译器中工作。\n回报：\n要抑制的警告集\n     */\n    String[] value();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * Java中的@SuppressWarnings 注解指示被该注解修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告，且会一直作用于该程序元素的所有子元素。\n * 如果你对于代码的规范不做要求又对编译器的警告感到烦躁那么你可以使用@SuppressWarnings（仅仅只是取消显示，并没有消除），它可以让你免去这些烦恼，当然编译器报错他是无法帮你取消显示的。\n * 添加前：\n\n\n\n * 添加后：\n\n\n\n * 注解的使用有以下三种：\n   \n   * 抑制单类型的警告：@SuppressWarnings("unchecked")\n   * 抑制多类型的警告：@SuppressWarnings("unchecked","rawtypes")\n   * 抑制所有类型的警告：@SuppressWarnings("unchecked")\n\n * 抑制警告的关键字如下表所示：\n   \n   关键字                        用途\n   all                        抑制所有警告\n   boxing                     抑制装箱、拆箱操作时候的警告\n   cast                       抑制映射相关的警告\n   dep-ann                    抑制启用注释的警告\n   deprecation                抑制过期方法警告\n   fallthrough                抑制在 switch 中缺失 breaks 的警告\n   finally                    抑制 finally 模块没有返回的警告\n   hiding                     抑制相对于隐藏变量的局部变量的警告\n   incomplete-switch          忽略不完整的 switch 语句\n   nls                        忽略非 nls 格式的字符\n   null                       忽略对 null 的操作\n   rawtypes                   使用 generics 时忽略没有指定相应的类型\n   restriction                抑制禁止使用劝阻或禁止引用的警告\n   serial                     忽略在 serializable 类中没有声明 serialVersionUID 变量\n   static-access              抑制不正确的静态访问方式警告\n   synthetic-access           抑制子类没有按最优方法访问内部类的警告\n   unchecked                  抑制没有进行类型检查操作的警告\n   unqualified-field-access   抑制没有权限访问的域的警告\n   unused                     抑制没被使用过的代码的警告\n\n----------------------------------------\n\n# @SafeVarargs\n\n官方解释：\n\n/**\n程序员断言带注释的方法或构造函数的主体不会对其 varargs 参数执行潜在的不安全操作。将此注释应用于方法或构造函数会抑制有关不可具体化的变量 arity (vararg) 类型的未经检查的警告，并抑制有关在调用站点创建参数化数组的未经检查的警告。\n除了@Target元注解施加的使用限制外，编译器还需要对该注解类型实施额外的使用限制；如果使用@SafeVarargs注释对方法或构造函数声明进行注释，则这是编译时错误，并且：\n声明是一个固定的arity方法或构造函数\n声明是一个既不是static也不是final的变量 arity 方法。\n鼓励编译器在将此注释类型应用于方法或构造函数声明时发出警告，其中：\n变量 arity 参数具有可具体化的元素类型，包括原始类型、 Object和String 。 （对于可具体化的元素类型，此注释类型抑制的未经检查的警告已经不会出现。）\n方法或构造函数声明的主体执行潜在的不安全操作，例如对变量 arity 参数数组的元素的赋值会生成未经检查的警告。一些不安全的操作不会触发未经检查的警告。例如，别名在\n*/\n   @SafeVarargs // 实际上并不安全！\n   static void m(List<String>... stringLists) {\n     Object[] array = stringLists;\n     List<Integer> tmpList = Arrays.asList(42);\n     array[0] = tmpList; // 语义上无效，但可以编译\n     String s = stringLists[0].get(0); // 哦不，运行时的 ClassCastException！\n   }\n   \n在运行时导致ClassCastException 。\n该平台的未来版本可能会要求此类不安全操作出现编译器错误。\n1234567891011121314151617\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在学习@SafeVarargs之前先来看看下面有一段代码\n\npublic class main {\n    public static void main(String[] args) {\n        display("10",20,30);\n    }\n    public static <T> void display(T ...array){\n        for (T arg : array){\n            System.out.println(arg.getClass().getName()+":"+arg);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这段代码中我设计了一个接收可变参数的方法public static <T> void display(T ...array){}可变参数方法中的参数类型相同，为此声明参数是需要指定泛型。\n\n但是调用可变参数方法时，应该提供相同类型的参数，但是代码中传入了不同类型的参数集合，此时可以看到display签名处有如下警告\n\n\n\n翻译过来就是参数化可变参数类型可能造成的堆污染并且提示添加@SafeVarargs注解（仅仅起一个取消显示的作用，某种方面上来说是和 @SuppressWarnings 作用相同的）。\n\n这个警告是 unchecked（未检查不安全代码），就是因为将非泛型变量赋值给泛型变量所发生的。\n\n\n\n可以发现加上了@SafeVarargs注解后编译器警告没有显示了，你肯定会说我使用@SuppressWarnings效果也是一样的，效果虽然一样，但是两者相较来说这里使用@SafeVarargs注解更合适\n\n注意：@SafeVarargs注解不适用于非 static 或非 final 声明的方法，对于未声明为 static 或 final 的方法，如果要抑制 unchecked 警告，可以使用 @SuppressWarnings 注解。\n\n----------------------------------------\n\n# @FunctionalInterface\n\n官方解释：\n\n一种信息性注解类型，用于指示接口类型声明旨在成为 Java 语言规范定义的功能接口。从概念上讲，函数式接口只有一个抽象方法。由于默认方法有一个实现，它们不是抽象的。如果接口声明了一个覆盖java.lang.Object的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数，因为接口的任何实现都将具有来自java.lang.Object或其他地方的实现(接口的实现是类,所有类的父类都是Object)。\n请注意，函数式接口的实例可以使用 lambda 表达式、方法引用或构造函数引用来创建。\n如果使用此注解类型对类型进行注解，则编译器需要生成错误消息，除非：\n该类型是接口类型，而不是注解类型、枚举或类。\n带注解的类型满足功能接口的要求。\n但是，无论接口声明中是否存在FunctionalInterface注释，编译器都会将满足功能接口定义的任何接口视为功能接口。\n\n\n1\n2\n3\n4\n5\n6\n\n\n在学习Lambda表达式时，我们了解过函数式接口（接口中只有个一个抽象方法可以存在多个默认方法或多个static方法）。\n\n * @FunctionalInterface作用就是用来指定某一个接口必须是函数式接口的，所以@FunctionalInterface只能修饰接口。\n * 这里我写了两个抽象方法出现了编译器报错\n\n\n\n * 这里我只写了一个抽象方法 一个static方法和一个默认方法 符合要求没有报错\n\n\n\n注意：如果接口声明了一个覆盖java.lang.Object的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数\n\n得出结论：@FunctionalInterface只是告诉编译器去检查这个接口是不是函数式接口，保证该接口只能包含一个抽象方法，否者就会出现编译错误。\n\n----------------------------------------\n\n\n# 3. 写一个自己的注解\n\n注解的格式就是\n\n>  * 元注解\n>  * public @interface 注解名\n>  * 注解内容体\n\n@Documented //这里我希望我的注解能够生成在JavaDoc生成的文档中\n@Retention(RetentionPolicy.CLASS) //这里我希望我的注解能够在字节码文件中保留\n@Target({ElementType.TYPE,ElementType.METHOD}) //这里我希望我的注解可以修饰于类、接口、抽象类和方法上\npublic @interface MyAnnotation { //我声明了一个名为MyAnnotation的注解\n    //定义带两个成员变量的注解\n    //注解中的成员以方法的形式命名（注解的本质是接口） 并且可以带有默认值\n    String name() default "";\n    int age() default 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n想要获取注解中的成员变量需要使用反射的知识、首先需要获取类的Class对象，我们就可以通过的这个Class对象反射得到注解的成员变量了。\n\n反射相关的可以参考这篇博客反射\n\npublic class main {\n    public static void main(String[] args) throws NoSuchMethodException {\n        new Test().testMyAnnotation();\n    }\n\n}\nclass Test{\n    @MyAnnotation(name = "dyw",age = 20)//这里我们使用了我们刚才自定义的注解\n    public void testMyAnnotation() throws NoSuchMethodException {\n        //这里获取Test类的Class对象 当类被编译后会当jvm加载时会生成该class文件的Class对象 通过这个Class对象可以完成反射相关的操作\n        Method testMyAnnotation = this.getClass().getMethod("testMyAnnotation");\n        //通过Class对象的getAnnotation()方法反射得到我们的MyAnnotation对象\n        MyAnnotation annotation = testMyAnnotation.getAnnotation(MyAnnotation.class);\n        //通过该对象可以获取注解类的成员\n        System.out.println("name :"+annotation.name());\n        System.out.println("age :"+annotation.age());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输出：\n\n\n\n这里只介绍了自定义注解类的简单用法，但是却完美展现了注解搭配反射可以碰撞出的巨大火花。熟悉掌握注解与反射后就有一定能力去学习那些大佬开发的框架的底层代码了。\n\n----------------------------------------\n\n\n# 4. 参考\n\nJava注解 (biancheng.net)\n\njava.lang.annotation (Java Platform SE 8 ) (oracle.com)\n\n理解注解中的@Inherited - 掘金 (juejin.cn)\n\njava元注解@Native && @Repeatable （java8 新增）_似火似水的博客-CSDN博客_native注解\n\n反射',normalizedContent:'# 注解\n\n\n# 1. 简介\n\nannotation（注解）是jdk5开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类，方法或者变量，在框架中大量使用（如 spring、mybatis等）\n\n> 注解是一种能被添加到java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。\n\n下面是我简单写的一个自定义注解\n\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.type)\npublic @interface test {\n    public int id() default -1;\n\n    public string msg() default "hi";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通过对上述文件的字节码（.class）的反编译（javap - p xxx.class）可以得到@interface其实就是一个继承了annotation的一个接口\n\njavap -p test.class\n\npublic interface com.dyw.annotation.test extends java.lang.annotation.annotation {\n  public abstract int id();\n  public abstract java.lang.string msg();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注解只有被解析之后才会生效，常见的解析方法有两种：\n\n * 编译期间直接扫描：编译器在编译java代码的时候扫描对于的注解并处理，比如某个方法使用了@override，编译器在编译的时候就会检测当前的方法是否重写了父类对于的方法。\n * 运行期间通过反射处理：这个经常在spring框架中看到，例如spring的@value注解，就是通过反射来进行处理的。\n\n\n# 2. 注解详细介绍\n\n我们通过上述的例子可以看到我们的注解上面还有着其他的注解例如@retention、@target（这些都统称为元注解）.\n\n所以一个注解是由以下成分组成\n\n>  * 元注解\n>  * public @interface 注解名称\n\n----------------------------------------\n\n\n# 2.1 元注解介绍\n\njdk1.8版本为我们提供了6个标准的用来对注解类型进行注解的注解类（1.8之前只有四个），我们称之为meta-annotation（元注解）.\n\n元注解只能用在注解之上（自定义注解时可用）\n\n\n\n> @target\n> @retention\n> @documented\n> @inherited\n> \n> \n> 1\n> 2\n> 3\n> 4\n> \n> \n> @native（1.8新增）\n> \n> @repeatable（1.8新增）\n\n----------------------------------------\n\n# @target\n\n官方解释：\n\n\t指示注解类型适用的上下文。注解类型可能适用的声明上下文和类型上下文在 jls 9.6.4.1 中指定，并在源代码中由java.lang.annotation.elementtype的枚举常量表示。\n\t如果注解类型t上不存在@target元注解，则类型t的注解可以写为除类型参数声明之外的任何声明的修饰符。\n\t如果存在@target元注解，编译器将强制执行elementtype枚举常量指示的使用限制，符合 jls 9.7.4。\n\n\n1\n2\n3\n\n * 它指明了它所修饰的注解使用的范围 如果自定义的注解为含有@target元注解修饰，那么默认可以是在（除类型参数之外的）任何项之上使用，若有@target元注解修饰那么根据value（elementtype枚举常量）的指定的目标进行规定。\n\n# elementtype\n\nelementtype.class\npublic enum elementtype {\n    /** 类、接口（包括注解类型）或枚举声明 */\n    type,\n\n    /** 字段声明（包括枚举常量） */\n    field,\n\n    /** 方法声明 */\n    method,\n\n    /** 参数声明 */\n    parameter,\n\n    /** 构造函数声明 */\n    constructor,\n\n    /** 局部变量声明 */\n    local_variable,\n\n    /** 注解类型声明 */\n    annotation_type,\n\n    /** 包装声明 */\n    package,\n\n    /**\n     * 类型参数声明 类型参数即map<string,integer>中的string和integer这里是作为类型\n     *\n     * @since 1.8\n     */\n    type_parameter,\n\n    /**\n     * 使用类型 对应于 jls 4.11 中的 15 个类型上下文，以及两个声明上下文：类型声明（包括注解类型声明）和类型参数声明。\n     *\n     * @since 1.8\n     */\n    type_use\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * elementtype的枚举常量指明了注解可以使用的目标。\n\n@target(elementtype.method)//可修饰在方法之上\n\n\n1\n\n\n----------------------------------------\n\n# @retention\n\n官方解释：\n\n指示要保留带注解类型的注解多长时间。如果注释类型声明中不存在保留注释，则保留策略默认为retentionpolicy.class 。\n仅当元注释类型直接用于注释时，保留元注释才有效。如果将元注释类型用作另一个注释类型中的成员类型，则它没有效果。\n\n\n1\n2\n\n * 即@retention用来约束注解的生命周期，分别有三个值，源码级别（source）、类文件级别（class）或者运行时级别（runtime）可以通过指定@retention中的值来实现（值为retentionpolicy枚举常量）。\n\n# retentionpolicy.class\n\npublic enum retentionpolicy {\n    /**\n     * 注解将被编译器丢弃。(该类型的注解信息指挥保留在源码中，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件中)\n     */\n    source,\n\n    /**\n     * 注解将由编译器记录在类文件中，但不需要在运行时由 vm 保留。这是默认行为.(该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中) 该类型也是未指定@retention值的缺省值\n     */\n    class,\n\n    /**\n     * 注解将由编译器记录在类文件中，并在运行时由 vm 保留，因此可以反射性地读取它们。(源码，class文件和执行时(vm)都保留注解的信息)\n     */\n    runtime\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意：生命周期大小排序为source < class < runtime，范围依次增大，前者能使用的地方后者一定能使用。如果需要在运行时去动态获取注解信息，那只能使用runtime；如果要在编译时进行一些预处理操作，比如生成一些辅助代码，就是用class；如果只是做一些检查性的操作，比如@override和@suppersswarning，可选择source\n\n----------------------------------------\n\n# @documented\n\n官方解释：\n\n表示默认情况下，带有类型的注释将由 javadoc 和类似工具记录。这种类型应该用于注解类型的声明，这些类型的注释会影响其客户对注释元素的使用。如果使用 documented 对类型声明进行注释，则其注释将成为注释元素的公共 api 的一部分。\n\n\n1\n\n * 带上该注解后的注解表明，在默认情况下这个注解是由javadoc和类似工具记录的，即带上了该文档化的注解被使用再生成文档时，会称为api的一部分。（默认情况下javadoc是不包含注解的，除非声明注解的时候使用了@documented）\n\nperson.java\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.method)\npublic @interface person {\n    string name() default "";\n}\n123456\nmain.java\npublic class main {\n    @person(name = "ding")\n    public static void main(string[] args) {\n\n        system.out.println("hello");\n    }\n    //@person(name = "ding")\n    @person(name = "yang")\n    public static void dosome(){\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 生成的文档\n\n\n\n * 不带@documented注解生成的文档\n\n\n\n----------------------------------------\n\n# @inherited\n\n官方解释：\n\n指示注解类型是自动继承的。如果注解类型声明中存在 inherited 元注解，并且用户在类声明中查询注解类型，并且类声明没有该类型的注解，则将自动查询该类的超类以获取注解类型。将重复此过程，直到找到此类型的注释，或到达类层次结构（对象）的顶部。如果没有超类具有此类型的注释，则查询将指示所讨论的类没有此类注释。\n请注意，如果注释类型用于注释类以外的任何内容，则此元注释类型无效。另请注意，此元注释仅导致注释从超类继承；已实现接口上的注解无效。\n12\n\n\n1\n2\n3\n\n * 被该元注解修饰的自定义注解再使用后会自动继承，如果使用了该自定义注解去修饰一个class那么这个注解也会作用于该class的子类。就是说如果某个类使用了被@inherited修饰的注解，则其子类将会自动具有该注释\n\n注意： @inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。\n\n@inherited //使用@inherited修饰的自定义注解\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.type)\npublic @interface person {\n    string name() default "";\n}\n1234567\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nmain.java\n\npublic class main {\n    public static void main(string[] args) {\n        system.out.println(father.class.getannotation(person.class));\n        system.out.println(son.class.getannotation(person.class));\n    }\n\n}\n\n@person\nclass father {\n}\nclass son extends com.dyw.annotation.obj.father {\n\n}\n1234567891011121314\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n----------------------------------------\n\n# @native\n\n官方解释：\n\n表示可以从本机代码引用定义常量值的字段。注释可以被生成本机头文件的工具用作提示，以确定是否需要头文件，如果需要，它应该包含哪些声明。\n1\n\n\n1\n2\n\n * 使用 @native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @native 注解不常使用，了解即可。\n\n----------------------------------------\n\n# @repeatable\n\n官方解释：\n\n注释类型java.lang.annotation.repeatable用于指示它（元）注释其声明的注释类型是可重复的。 @repeatable的值表示可重复注解类型的包含注解类型。\n1\n\n\n1\n2\n\n\n> @repeatable允许在相同的程序元素中重复注解（不报错）。在需要对同一种注解多次使用时，往往需要借助 @repeatable 注解。java 8 版本以前，同一个程序元素前最多只能有一个相同类型的注解，如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。\n\n不使用@repeatable修饰的自定义注解完成重复注解\n\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.method)\npublic @interface persons {\n    person[] value();\n}\n\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.method)\npublic @interface person {\n    string name() default "";\n}\n12345678910111213\n@persons(value = {@person(name = "ding"),@person(name = "yang")})\npublic static void dosome(){\n\n}\n1234\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n使用@repeatable修饰的自定义注解\n\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.method)\npublic @interface persons {\n    person[] value();\n}\n\n@repeatable(persons.class)\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.method)\npublic @interface person {\n    string name() default "";\n}\n\n@person(name = "ding")\n@person(name = "yang")\npublic static void dosome(){\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 两种方法不同的地方是，创建重复注解person时加上了@repeatable注解，指向存储注解persons，这样使用时就可以直接重复使用person注解。从上述例子可以看出使用@repeatable注解更符合常规思维，可读性强。\n * 但两种方法的效果相同，只是使用了@repeatable注解简化了写法，这种简化的底层依旧是多个重复注解使用了一个被称作“容器”注解的value的成员的数组元素处理。\n\n----------------------------------------\n\n\n# 2.2 jdk基本注解介绍\n\n基本注解包括\n\n>  * @override\n>  * @deprecated\n>  * @suppresswarnings\n>  * @safevarargs\n>  * @functionalinterface\n\n# @override\n\n官方解释：\n\n指示方法声明旨在覆盖超类型中的方法声明。如果使用此注解类型对方法进行注解，则编译器需要生成错误消息，除非至少满足以下条件之一：\n该方法确实覆盖或实现了在超类型中声明的方法。\n该方法的签名与object中声明的任何公共方法的签名等效。\n123\npublic class father {\n    public string msg(){\n        return "";\n    }\n}\n\npublic class son extends father{\n\n    @override\n    public string msg() {\n        return "";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 如果将子类中方法名msg改为mg会发生如下编译错误\n\n> java: 方法不会覆盖或实现超类型的方法\n\n * 所以@override的作用告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否者就会出错，这样可以帮助程序员避免一些低级错误。\n\n----------------------------------------\n\n# @deprecated\n\n官方解释：\n\n@deprecated 注释的程序元素是不鼓励程序员使用的程序元素，通常是因为它很危险，或者因为存在更好的替代方案。当在非弃用代码中使用或覆盖弃用的程序元素时，编译器会发出警告。\n1\n\n\n1\n2\n\n * 通俗的说被该注解修饰的目标项是已经过时的了，不推荐使用的。**\n\npublic class son extends father{\n    @deprecated\n    @override\n    public string msg() {\n        return "";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 使用@deprecated修饰了son中的msg方法后，调用该方法会出现删除线和编译警告。\n\n\n\n----------------------------------------\n\n# @suppresswarnings\n\n官方解释：\n\n/**\n 指示应在带注释的元素（以及带注释的元素中包含的所有程序元素）中抑制命名的编译器警告。请注意，给定元素中抑制的警告集是所有包含元素中抑制的警告的超集。例如，如果您注释一个类以抑制一个警告并注释一个方法以抑制另一个警告，则两个警告都将在方法中被抑制。\n作为风格问题，程序员应该始终在最有效的嵌套元素上使用此注释。如果您想在特定方法中抑制警告，您应该注释该方法而不是它的类。\n*/\n@target({type, field, method, parameter, constructor, local_variable})\n@retention(retentionpolicy.source)\npublic @interface suppresswarnings {\n    /**\n     *编译器要在带注释的元素中抑制的一组警告。允许重复名称。名称的第二次和连续出现将被忽略。存在无法识别的警告名称不是错误：编译器必须忽略它们无法识别的任何警告名称。但是，如果注释包含无法识别的警告名称，它们可以自由发出警告。\n字符串"unchecked"用于抑制未经检查的警告。编译器供应商应结合此注释类型记录他们支持的其他警告名称。鼓励他们合作以确保相同的名称在多个编译器中工作。\n回报：\n要抑制的警告集\n     */\n    string[] value();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * java中的@suppresswarnings 注解指示被该注解修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告，且会一直作用于该程序元素的所有子元素。\n * 如果你对于代码的规范不做要求又对编译器的警告感到烦躁那么你可以使用@suppresswarnings（仅仅只是取消显示，并没有消除），它可以让你免去这些烦恼，当然编译器报错他是无法帮你取消显示的。\n * 添加前：\n\n\n\n * 添加后：\n\n\n\n * 注解的使用有以下三种：\n   \n   * 抑制单类型的警告：@suppresswarnings("unchecked")\n   * 抑制多类型的警告：@suppresswarnings("unchecked","rawtypes")\n   * 抑制所有类型的警告：@suppresswarnings("unchecked")\n\n * 抑制警告的关键字如下表所示：\n   \n   关键字                        用途\n   all                        抑制所有警告\n   boxing                     抑制装箱、拆箱操作时候的警告\n   cast                       抑制映射相关的警告\n   dep-ann                    抑制启用注释的警告\n   deprecation                抑制过期方法警告\n   fallthrough                抑制在 switch 中缺失 breaks 的警告\n   finally                    抑制 finally 模块没有返回的警告\n   hiding                     抑制相对于隐藏变量的局部变量的警告\n   incomplete-switch          忽略不完整的 switch 语句\n   nls                        忽略非 nls 格式的字符\n   null                       忽略对 null 的操作\n   rawtypes                   使用 generics 时忽略没有指定相应的类型\n   restriction                抑制禁止使用劝阻或禁止引用的警告\n   serial                     忽略在 serializable 类中没有声明 serialversionuid 变量\n   static-access              抑制不正确的静态访问方式警告\n   synthetic-access           抑制子类没有按最优方法访问内部类的警告\n   unchecked                  抑制没有进行类型检查操作的警告\n   unqualified-field-access   抑制没有权限访问的域的警告\n   unused                     抑制没被使用过的代码的警告\n\n----------------------------------------\n\n# @safevarargs\n\n官方解释：\n\n/**\n程序员断言带注释的方法或构造函数的主体不会对其 varargs 参数执行潜在的不安全操作。将此注释应用于方法或构造函数会抑制有关不可具体化的变量 arity (vararg) 类型的未经检查的警告，并抑制有关在调用站点创建参数化数组的未经检查的警告。\n除了@target元注解施加的使用限制外，编译器还需要对该注解类型实施额外的使用限制；如果使用@safevarargs注释对方法或构造函数声明进行注释，则这是编译时错误，并且：\n声明是一个固定的arity方法或构造函数\n声明是一个既不是static也不是final的变量 arity 方法。\n鼓励编译器在将此注释类型应用于方法或构造函数声明时发出警告，其中：\n变量 arity 参数具有可具体化的元素类型，包括原始类型、 object和string 。 （对于可具体化的元素类型，此注释类型抑制的未经检查的警告已经不会出现。）\n方法或构造函数声明的主体执行潜在的不安全操作，例如对变量 arity 参数数组的元素的赋值会生成未经检查的警告。一些不安全的操作不会触发未经检查的警告。例如，别名在\n*/\n   @safevarargs // 实际上并不安全！\n   static void m(list<string>... stringlists) {\n     object[] array = stringlists;\n     list<integer> tmplist = arrays.aslist(42);\n     array[0] = tmplist; // 语义上无效，但可以编译\n     string s = stringlists[0].get(0); // 哦不，运行时的 classcastexception！\n   }\n   \n在运行时导致classcastexception 。\n该平台的未来版本可能会要求此类不安全操作出现编译器错误。\n1234567891011121314151617\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在学习@safevarargs之前先来看看下面有一段代码\n\npublic class main {\n    public static void main(string[] args) {\n        display("10",20,30);\n    }\n    public static <t> void display(t ...array){\n        for (t arg : array){\n            system.out.println(arg.getclass().getname()+":"+arg);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这段代码中我设计了一个接收可变参数的方法public static <t> void display(t ...array){}可变参数方法中的参数类型相同，为此声明参数是需要指定泛型。\n\n但是调用可变参数方法时，应该提供相同类型的参数，但是代码中传入了不同类型的参数集合，此时可以看到display签名处有如下警告\n\n\n\n翻译过来就是参数化可变参数类型可能造成的堆污染并且提示添加@safevarargs注解（仅仅起一个取消显示的作用，某种方面上来说是和 @suppresswarnings 作用相同的）。\n\n这个警告是 unchecked（未检查不安全代码），就是因为将非泛型变量赋值给泛型变量所发生的。\n\n\n\n可以发现加上了@safevarargs注解后编译器警告没有显示了，你肯定会说我使用@suppresswarnings效果也是一样的，效果虽然一样，但是两者相较来说这里使用@safevarargs注解更合适\n\n注意：@safevarargs注解不适用于非 static 或非 final 声明的方法，对于未声明为 static 或 final 的方法，如果要抑制 unchecked 警告，可以使用 @suppresswarnings 注解。\n\n----------------------------------------\n\n# @functionalinterface\n\n官方解释：\n\n一种信息性注解类型，用于指示接口类型声明旨在成为 java 语言规范定义的功能接口。从概念上讲，函数式接口只有一个抽象方法。由于默认方法有一个实现，它们不是抽象的。如果接口声明了一个覆盖java.lang.object的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数，因为接口的任何实现都将具有来自java.lang.object或其他地方的实现(接口的实现是类,所有类的父类都是object)。\n请注意，函数式接口的实例可以使用 lambda 表达式、方法引用或构造函数引用来创建。\n如果使用此注解类型对类型进行注解，则编译器需要生成错误消息，除非：\n该类型是接口类型，而不是注解类型、枚举或类。\n带注解的类型满足功能接口的要求。\n但是，无论接口声明中是否存在functionalinterface注释，编译器都会将满足功能接口定义的任何接口视为功能接口。\n\n\n1\n2\n3\n4\n5\n6\n\n\n在学习lambda表达式时，我们了解过函数式接口（接口中只有个一个抽象方法可以存在多个默认方法或多个static方法）。\n\n * @functionalinterface作用就是用来指定某一个接口必须是函数式接口的，所以@functionalinterface只能修饰接口。\n * 这里我写了两个抽象方法出现了编译器报错\n\n\n\n * 这里我只写了一个抽象方法 一个static方法和一个默认方法 符合要求没有报错\n\n\n\n注意：如果接口声明了一个覆盖java.lang.object的公共方法之一的抽象方法，这也不会计入接口的抽象方法计数\n\n得出结论：@functionalinterface只是告诉编译器去检查这个接口是不是函数式接口，保证该接口只能包含一个抽象方法，否者就会出现编译错误。\n\n----------------------------------------\n\n\n# 3. 写一个自己的注解\n\n注解的格式就是\n\n>  * 元注解\n>  * public @interface 注解名\n>  * 注解内容体\n\n@documented //这里我希望我的注解能够生成在javadoc生成的文档中\n@retention(retentionpolicy.class) //这里我希望我的注解能够在字节码文件中保留\n@target({elementtype.type,elementtype.method}) //这里我希望我的注解可以修饰于类、接口、抽象类和方法上\npublic @interface myannotation { //我声明了一个名为myannotation的注解\n    //定义带两个成员变量的注解\n    //注解中的成员以方法的形式命名（注解的本质是接口） 并且可以带有默认值\n    string name() default "";\n    int age() default 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n想要获取注解中的成员变量需要使用反射的知识、首先需要获取类的class对象，我们就可以通过的这个class对象反射得到注解的成员变量了。\n\n反射相关的可以参考这篇博客反射\n\npublic class main {\n    public static void main(string[] args) throws nosuchmethodexception {\n        new test().testmyannotation();\n    }\n\n}\nclass test{\n    @myannotation(name = "dyw",age = 20)//这里我们使用了我们刚才自定义的注解\n    public void testmyannotation() throws nosuchmethodexception {\n        //这里获取test类的class对象 当类被编译后会当jvm加载时会生成该class文件的class对象 通过这个class对象可以完成反射相关的操作\n        method testmyannotation = this.getclass().getmethod("testmyannotation");\n        //通过class对象的getannotation()方法反射得到我们的myannotation对象\n        myannotation annotation = testmyannotation.getannotation(myannotation.class);\n        //通过该对象可以获取注解类的成员\n        system.out.println("name :"+annotation.name());\n        system.out.println("age :"+annotation.age());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输出：\n\n\n\n这里只介绍了自定义注解类的简单用法，但是却完美展现了注解搭配反射可以碰撞出的巨大火花。熟悉掌握注解与反射后就有一定能力去学习那些大佬开发的框架的底层代码了。\n\n----------------------------------------\n\n\n# 4. 参考\n\njava注解 (biancheng.net)\n\njava.lang.annotation (java platform se 8 ) (oracle.com)\n\n理解注解中的@inherited - 掘金 (juejin.cn)\n\njava元注解@native && @repeatable （java8 新增）_似火似水的博客-csdn博客_native注解\n\n反射',charsets:{cjk:!0},lastUpdated:"2023/03/02, 18:32:33",lastUpdatedTimestamp:1677753153e3},{title:"JVM-JVM与Java体系结构",frontmatter:{title:"JVM-JVM与Java体系结构",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/9faa36/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/1.JVM-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html",relativePath:"01.语言/01.JAVA语言/02.JVM/1.JVM-JVM与Java体系结构.md",key:"v-b545df88",path:"/pages/9faa36/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:23},{level:2,title:"架构师每天都在思考什么？",slug:"架构师每天都在思考什么",normalizedTitle:"架构师每天都在思考什么？",charIndex:475},{level:2,title:"为什么要学习JVM",slug:"为什么要学习jvm",normalizedTitle:"为什么要学习jvm",charIndex:700},{level:2,title:"Java vs C++",slug:"java-vs-c",normalizedTitle:"java vs c++",charIndex:826},{level:2,title:"推荐书籍",slug:"推荐书籍",normalizedTitle:"推荐书籍",charIndex:986},{level:2,title:"Java生态圈",slug:"java生态圈",normalizedTitle:"java生态圈",charIndex:997},{level:2,title:"字节码",slug:"字节码",normalizedTitle:"字节码",charIndex:1421},{level:2,title:"多语言混合编程",slug:"多语言混合编程",normalizedTitle:"多语言混合编程",charIndex:1929},{level:2,title:"Java发展的重大事件",slug:"java发展的重大事件",normalizedTitle:"java发展的重大事件",charIndex:2333},{level:2,title:"虚拟机与Java虚拟机",slug:"虚拟机与java虚拟机",normalizedTitle:"虚拟机与java虚拟机",charIndex:3559},{level:3,title:"虚拟机",slug:"虚拟机",normalizedTitle:"虚拟机",charIndex:284},{level:3,title:"Java虚拟机",slug:"java虚拟机",normalizedTitle:"java虚拟机",charIndex:280},{level:2,title:"JVM的位置",slug:"jvm的位置",normalizedTitle:"jvm的位置",charIndex:4190},{level:2,title:"JVM整体结构",slug:"jvm整体结构",normalizedTitle:"jvm整体结构",charIndex:4244},{level:2,title:"Java代码执行流程",slug:"java代码执行流程",normalizedTitle:"java代码执行流程",charIndex:4390},{level:2,title:"JVM的架构模型",slug:"jvm的架构模型",normalizedTitle:"jvm的架构模型",charIndex:4448},{level:3,title:"举例",slug:"举例",normalizedTitle:"举例",charIndex:4855},{level:3,title:"字节码反编译",slug:"字节码反编译",normalizedTitle:"字节码反编译",charIndex:5106},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6161},{level:3,title:"栈",slug:"栈",normalizedTitle:"栈",charIndex:4479},{level:2,title:"JVM生命周期",slug:"jvm生命周期",normalizedTitle:"jvm生命周期",charIndex:6399},{level:3,title:"虚拟机的启动",slug:"虚拟机的启动",normalizedTitle:"虚拟机的启动",charIndex:6411},{level:3,title:"虚拟机的执行",slug:"虚拟机的执行",normalizedTitle:"虚拟机的执行",charIndex:6511},{level:3,title:"虚拟机的退出",slug:"虚拟机的退出",normalizedTitle:"虚拟机的退出",charIndex:6630},{level:2,title:"JVM发展历程",slug:"jvm发展历程",normalizedTitle:"jvm发展历程",charIndex:6888},{level:3,title:"Sun Classic VM",slug:"sun-classic-vm",normalizedTitle:"sun classic vm",charIndex:6900},{level:3,title:"Exact VM",slug:"exact-vm",normalizedTitle:"exact vm",charIndex:7184},{level:3,title:"HotSpot VM",slug:"hotspot-vm",normalizedTitle:"hotspot vm",charIndex:4256},{level:3,title:"JRockit",slug:"jrockit",normalizedTitle:"jrockit",charIndex:2972},{level:3,title:"IBM的J9",slug:"ibm的j9",normalizedTitle:"ibm的j9",charIndex:3241},{level:3,title:"KVM和CDC / CLDC  Hotspot",slug:"kvm和cdc-cldc-hotspot",normalizedTitle:"kvm和cdc / cldc  hotspot",charIndex:null},{level:3,title:"Azul VM",slug:"azul-vm",normalizedTitle:"azul vm",charIndex:8831},{level:3,title:"Liquid VM",slug:"liquid-vm",normalizedTitle:"liquid vm",charIndex:8878},{level:3,title:"Apache Marmony",slug:"apache-marmony",normalizedTitle:"apache marmony",charIndex:9372},{level:3,title:"Micorsoft JVM",slug:"micorsoft-jvm",normalizedTitle:"micorsoft jvm",charIndex:9596},{level:3,title:"Taobao JVM",slug:"taobao-jvm",normalizedTitle:"taobao jvm",charIndex:9791},{level:3,title:"Dalvik VM",slug:"dalvik-vm",normalizedTitle:"dalvik vm",charIndex:10338},{level:3,title:"Graal VM",slug:"graal-vm",normalizedTitle:"graal vm",charIndex:10685},{level:3,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:6161}],headersStr:"前言 架构师每天都在思考什么？ 为什么要学习JVM Java vs C++ 推荐书籍 Java生态圈 字节码 多语言混合编程 Java发展的重大事件 虚拟机与Java虚拟机 虚拟机 Java虚拟机 JVM的位置 JVM整体结构 Java代码执行流程 JVM的架构模型 举例 字节码反编译 总结 栈 JVM生命周期 虚拟机的启动 虚拟机的执行 虚拟机的退出 JVM发展历程 Sun Classic VM Exact VM HotSpot VM JRockit IBM的J9 KVM和CDC / CLDC  Hotspot Azul VM Liquid VM Apache Marmony Micorsoft JVM Taobao JVM Dalvik VM Graal VM 总结",content:'# JVM-JVM与Java体系结构\n\n\n# 前言\n\n作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？\n\n运行着的线上系统突然卡死，系统无法访问，甚至直接OOMM！\n\n * 想解决线上JVM GC问题，但却无从下手。\n * 新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了\n * 每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。\n\n\n\n大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。\n\n一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。\n\n计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言\n\n\n\n\n# 架构师每天都在思考什么？\n\n * 应该如何让我的系统更快？\n * 如何避免系统出现瓶颈？\n\n知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？\n\n * 参与现有系统的性能优化，重构，保证平台性能和稳定性\n * 根据业务场景和需求，决定技术方向，做技术选型\n * 能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求\n * 解决各类潜在系统风险，核心功能的架构与代码编写\n * 分析系统瓶颈，解决各种疑难杂症，性能调优等\n\n\n# 为什么要学习JVM\n\n * 面试的需要（BATJ、TMD，PKQ等面试都爱问）\n\n * 中高级程序员必备技能\n   \n   * 项目管理、调优的需求\n\n * 追求极客的精神\n   \n   * 比如：垃圾回收算法、JIT（及时编译器）、底层原理\n\n\n# Java vs C++\n\n垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。\n\n\n\nC语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。\n\n\n# 推荐书籍\n\n\n\n\n# Java生态圈\n\nJava是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。\n\n * 作为一个平台，Java虚拟机扮演着举足轻重的作用\n   \n   * Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分\n\n * 作为灯种文化，Java几乎成为了“开源”的代名词。\n   \n   * 第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。\n   * 就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。\n\n * 作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。\n\n\n\n每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理\n\n\n\n随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。\n\nJava虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。\n\n\n# 字节码\n\n我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。\n\n不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。\n\nJava虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。\n\n\n# 多语言混合编程\n\nJava平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。\n\n试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。\n\n对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。\n\n\n# Java发展的重大事件\n\n * 1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java\n\n * 1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。\n\n * 1996年1月23日sun Microsystems发布了JDK 1.0。\n\n * 1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。\n\n * 2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。\n\n * 2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。\n\n * 2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。\n\n * 2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。\n\n * 2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。\n\n * 2007年，Java平台迎来了新伙伴Clojure。\n\n * 2008年，oracle收购了BEA，得到了JRockit虚拟机。\n\n * 2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。\n\n * 2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit\n\n * 2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。\n\n * 2017年，JDK9发布。将G1设置为默认Gc，替代CMS\n\n * 同年，IBM的J9开源，形成了现在的open J9社区\n\n * 2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元\n\n * 同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会\n\n * 同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可\n\n * 2019年，JDK12发布，加入RedHat领导开发的shenandoah GC\n\n\n\n在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。\n\n\n# 虚拟机与Java虚拟机\n\n\n# 虚拟机\n\n所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。\n\n * 大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。\n * 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。\n\n无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。\n\n\n# Java虚拟机\n\nJava虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。\n\nJVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。\n\nJava技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。\n\nJava虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。\n\n特点：\n\n * 一次编译，到处运行\n * 自动内存管理\n * 自动垃圾回收功能\n\n\n# JVM的位置\n\nJVM是运行在操作系统之上的，它与硬件没有直接的交互\n\n\n\nJava的体系结构\n\n\n\n\n# JVM整体结构\n\n * HotSpot VM是目前市面上高性能虚拟机的代表作之一。\n * 它采用解释器与即时编译器并存的架构。\n * 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。\n\n\n\n执行引擎包含三部分：解释器，及时编译器，垃圾回收器\n\n\n# Java代码执行流程\n\n只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了\n\n\n# JVM的架构模型\n\nJava编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：\n\n基于栈式架构的特点\n\n * 设计和实现更简单，适用于资源受限的系统；\n * 避开了寄存器的分配难题：使用零地址指令方式分配。\n * 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。\n * 不需要硬件支持，可移植性更好，更好实现跨平台\n\n基于寄存器架构的特点\n\n * 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。\n * 指令集架构则完全依赖硬件，可移植性差\n * 性能优秀和执行更高效\n * 花费更少的指令去完成一项操作。\n * 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋\n\n\n# 举例\n\n同样执行2+3这种逻辑操作，其指令分别如下：\n\n基于栈的计算流程（以Java虚拟机为例）：\n\niconst_2 //常量2入栈\nistore_1\niconst_3 // 常量3入栈\nistore_2\niload_1\niload_2\niadd //常量2/3出栈，执行相加\nistore_0 // 结果5入栈\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n而基于寄存器的计算流程\n\nmov eax,2 //将eax寄存器的值设为1\nadd eax,3 //使eax寄存器的值加3\n\n\n1\n2\n\n\n\n# 字节码反编译\n\n我们编写一个简单的代码，然后查看一下字节码的反编译后的结果\n\n/**\n * @author: 陌溪\n * @create: 2020-07-04-21:17\n */\npublic class StackStruTest {\n    public static void main(String[] args) {\n        int i = 2 + 3;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后我们找到编译后的 class文件，使用下列命令进行反编译\n\njavap -v StackStruTest.class\n\n\n1\n\n\n得到的文件为:\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=4, args_size=1\n         0: iconst_2\n         1: istore_1\n         2: iconst_3\n         3: istore_2\n         4: iload_1\n         5: iload_2\n         6: iadd\n         7: istore_3\n         8: return\n      LineNumberTable:\n        line 9: 0\n        line 10: 2\n        line 11: 4\n        line 12: 8\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  args   [Ljava/lang/String;\n            2       7     1     i   I\n            4       5     2     j   I\n            8       1     3     k   I\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 总结\n\n由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。\n\n时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？\n\n\n# 栈\n\n * 跨平台性\n * 指令集小\n * 指令多\n * 执行性能比寄存器差\n\n\n# JVM生命周期\n\n\n# 虚拟机的启动\n\nJava虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。\n\n\n# 虚拟机的执行\n\n * 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。\n * 程序开始执行时他才运行，程序结束时他就停止。\n * 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。\n\n\n# 虚拟机的退出\n\n有如下的几种情况：\n\n * 程序正常执行结束\n\n * 程序在执行过程中遇到了异常或错误而异常终止\n\n * 由于操作系统用现错误而导致Java虚拟机进程终止\n\n * 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。\n\n * 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。\n\n\n# JVM发展历程\n\n\n# Sun Classic VM\n\n * 早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。\n * 这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。\n * 如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。\n * 现在hotspot内置了此虚拟机。\n\n\n# Exact VM\n\n为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 Exact Memory Management：准确式内存管理\n\n * 也可以叫Non-Conservative/Accurate Memory Management\n * 虚拟机可以知道内存中某个位置的数据具体是什么类型。|\n\n具备现代高性能虚拟机的维形\n\n * 热点探测（寻找出热点代码进行缓存）\n * 编译器与解释器混合工作模式\n\n只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换\n\n\n# HotSpot VM\n\nHotSpot历史\n\n * 最初由一家名为“Longview Technologies”的小公司设计\n * 1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。\n * JDK1.3时，HotSpot VM成为默认虚拟机\n\n目前Hotspot占有绝对的市场地位，称霸武林。\n\n * 不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot\n * Sun/oracle JDK和openJDK的默认虚拟机\n * 因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）\n\n从服务器、桌面到移动端、嵌入式都有应用。\n\n名称中的HotSpot指的就是它的热点代码探测技术。\n\n * 通过计数器找到最具编译价值代码，触发即时编译或栈上替换\n * 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡\n\n\n# JRockit\n\n专注于服务器端应用\n\n * 它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。\n\n大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。\n\n * 使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。\n\n优势：全面的Java运行时解决方案组合\n\n * JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要\n * MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。\n\n2008年，JRockit被oracle收购。\n\noracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。\n\n高斯林：目前就职于谷歌，研究人工智能和水下机器人\n\n\n# IBM的J9\n\n全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9\n\n市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。\n\n目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。\n\n2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9\n\nOpenJDK -> 是JDK开源了，包括了虚拟机\n\n\n# KVM和CDC / CLDC Hotspot\n\noracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。\n\nKVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场\n\n * 智能控制器、传感器\n * 老人手机、经济欠发达地区的功能手机\n\n所有的虚拟机的原则：一次编译，到处运行。\n\n\n# Azul VM\n\n前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I\n\n * 高性能Java虚拟机中的战斗机。\n\nAzul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。\n\n每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。\n\n2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。\n\n\n# Liquid VM\n\n高性能Java虚拟机中的战斗机。\n\nBEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），\n\nLiquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。\n\n随着JRockit虚拟机终止开发，Liquid vM项目也停止了。\n\n\n# Apache Marmony\n\nApache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。\n\n它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK\n\n虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。\n\n\n# Micorsoft JVM\n\n微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。\n\n只能在window平台下运行。但确是当时Windows下性能最好的Java VM。\n\n1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。\n\n\n# Taobao JVM\n\n由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。\n\n基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。\n\n基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。\n\n * 创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。\n * GCIH中的对象还能够在多个Java虚拟机进程中实现共享\n * 使用crc32指令实现JvM intrinsic降低JNI的调用开销\n * PMU hardware的Java profiling tool和诊断协助功能\n * 针对大数据场景的ZenGc\n\ntaobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能\n\n目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。\n\n\n# Dalvik VM\n\n谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。\n\nDalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范\n\n不能直接执行Java的Class文件\n\n基于寄存器架构，不是jvm的栈架构。\n\n执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。\n\n * 它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。\n\nAndroid 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。\n\n\n# Graal VM\n\n2018年4月，oracle Labs公开了GraalvM，号称 "Run Programs Faster Anywhere"，勃勃野心。与1995年java的”write once，run anywhere"遥相呼应。\n\nGraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等\n\n支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件\n\n工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。\n\n如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。\n\n\n# 总结\n\n具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。',normalizedContent:'# jvm-jvm与java体系结构\n\n\n# 前言\n\n作为java工程师的你曾被伤害过吗？你是否也遇到过这些问题？\n\n运行着的线上系统突然卡死，系统无法访问，甚至直接oomm！\n\n * 想解决线上jvm gc问题，但却无从下手。\n * 新项目上线，对各种jvm参数设置一脸茫然，直接默认吧然后就jj了\n * 每次面试之前都要重新背一遍jvm的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优vm参数，如何解决gc、oom等问题，一脸懵逼。\n\n\n\n大部分java开发人员，除会在项目中使用到与java平台相关的各种高精尖技术，对于java技术的核心java虚拟机了解甚少。\n\n一些有一定工作经验的开发人员，打心眼儿里觉得ssm、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的api比做数学公式的话，那么java虚拟机的知识就好比公式的推导过程。\n\n计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言\n\n\n\n\n# 架构师每天都在思考什么？\n\n * 应该如何让我的系统更快？\n * 如何避免系统出现瓶颈？\n\n知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？\n\n * 参与现有系统的性能优化，重构，保证平台性能和稳定性\n * 根据业务场景和需求，决定技术方向，做技术选型\n * 能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求\n * 解决各类潜在系统风险，核心功能的架构与代码编写\n * 分析系统瓶颈，解决各种疑难杂症，性能调优等\n\n\n# 为什么要学习jvm\n\n * 面试的需要（batj、tmd，pkq等面试都爱问）\n\n * 中高级程序员必备技能\n   \n   * 项目管理、调优的需求\n\n * 追求极客的精神\n   \n   * 比如：垃圾回收算法、jit（及时编译器）、底层原理\n\n\n# java vs c++\n\n垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得jvm内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是java工程师进阶的必备能力。\n\n\n\nc语言需要自己来分配内存和回收内存，java全部交给jvm进行分配和回收。\n\n\n# 推荐书籍\n\n\n\n\n# java生态圈\n\njava是目前应用最为广泛的软件开发平台之一。随着java以及java社区的不断壮大java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。\n\n * 作为一个平台，java虚拟机扮演着举足轻重的作用\n   \n   * groovy、scala、jruby、kotlin等都是java平台的一部分\n\n * 作为灯种文化，java几乎成为了“开源”的代名词。\n   \n   * 第三方开源软件和框架。如tomcat、struts，mybatis，spring等。\n   * 就连jdk和jvm自身也有不少开源的实现，如openjdk、harmony。\n\n * 作为一个社区，java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。\n\n\n\n每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过java虚拟机进行运行和处理\n\n\n\n随着java7的正式发布，java虚拟机的设计者们通过jsr-292规范基本实现在java虚拟机平台上运行非java语言编写的程序。\n\njava虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说java虚拟机拥有语言无关性，并不会单纯地与java语言“终身绑定”，只要其他编程语言的编译结果满足并包含java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。\n\n\n# 字节码\n\n我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。\n\n不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的jvm上运行。\n\njava虚拟机与java语言并没有必然的联系，它只与特定的二进制文件格式—class文件格式所关联，class文件中包含了java虚拟机指令集（或者称为字节码、bytecodes）和符号表，还有一些其他辅助信息。\n\n\n# 多语言混合编程\n\njava平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。\n\n试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用jruby/rails，中间层则是java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生api一样方便，因为它们最终都运行在一个虚拟机之上。\n\n对这些运行于java虚拟机之上、java之外的语言，来自系统级的、底层的支持正在迅速增强，以jsr-292为核心的一系列项目和功能改进（如da vinci machine项目、nashorn引擎、invokedynamic指令、java.lang.invoke包等），推动java虚拟机从“java语言的虚拟机”向 “多语言虚拟机”的方向发展。\n\n\n# java发展的重大事件\n\n * 1990年，在sun计算机公司中，由patrick naughton、mikesheridan及james gosling领导的小组green team，开发出的新的程序语言，命名为oak，后期命名为java\n\n * 1995年，sun正式发布java和hotjava产品，java首次公开亮相。\n\n * 1996年1月23日sun microsystems发布了jdk 1.0。\n\n * 1998年，jdk1.2版本发布。同时，sun发布了jsp/servlet、ejb规范，以及将java分成了j2ee、j2se和j2me。这表明了java开始向企业、桌面应用和移动设备应用3大领域挺进。\n\n * 2000年，jdk1.3发布，java hotspot virtual machine正式发布，成为java的默认虚拟机。\n\n * 2002年，jdk1.4发布，古老的classic虚拟机退出历史舞台。\n\n * 2003年年底，java平台的scala正式发布，同年groovy也加入了java阵营。\n\n * 2004年，jdk1.5发布。同时jdk1.5改名为javase5.0。\n\n * 2006年，jdk6发布。同年，java开源并建立了openjdk。顺理成章，hotspot虚拟机也成为了openjdk中的默认虚拟机。\n\n * 2007年，java平台迎来了新伙伴clojure。\n\n * 2008年，oracle收购了bea，得到了jrockit虚拟机。\n\n * 2009年，twitter宣布把后台大部分程序从ruby迁移到scala，这是java平台的又一次大规模应用。\n\n * 2010年，oracle收购了sun，获得java商标和最真价值的hotspot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机hotspot和jrockit，并计划在未来对它们进行整合：hotrockit\n\n * 2011年，jdk7发布。在jdk1.7u4中，正式启用了新的垃圾回收器g1。\n\n * 2017年，jdk9发布。将g1设置为默认gc，替代cms\n\n * 同年，ibm的j9开源，形成了现在的open j9社区\n\n * 2018年，android的java侵权案判决，google赔偿oracle计88亿美元\n\n * 同年，oracle宣告javage成为历史名词jdbc、jms、servlet赠予eclipse基金会\n\n * 同年，jdk11发布，lts版本的jdk，发布革命性的zgc，调整jdk授权许可\n\n * 2019年，jdk12发布，加入redhat领导开发的shenandoah gc\n\n\n\n在jdk11之前，oraclejdk中还会存在一些openjdk中没有的、闭源的功能。但在jdk11中，我们可以认为openjdk和oraclejdk代码实质上已经完全一致的程度。\n\n\n# 虚拟机与java虚拟机\n\n\n# 虚拟机\n\n所谓虚拟机（virtual machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。\n\n * 大名鼎鼎的visual box，mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。\n * 程序虚拟机的典型代表就是java虚拟机，它专门为执行单个计算机程序而设计，在java虚拟机中执行的指令我们称为java字节码指令。\n\n无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。\n\n\n# java虚拟机\n\njava虚拟机是一台执行java字节码的虚拟计算机，它拥有独立的运行机制，其运行的java字节码也未必由java语言编译而成。\n\njvm平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。\n\njava技术的核心就是java虚拟机（jvm，java virtual machine），因为所有的java程序都运行在java虚拟机内部。\n\njava虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条java指令，java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。\n\n特点：\n\n * 一次编译，到处运行\n * 自动内存管理\n * 自动垃圾回收功能\n\n\n# jvm的位置\n\njvm是运行在操作系统之上的，它与硬件没有直接的交互\n\n\n\njava的体系结构\n\n\n\n\n# jvm整体结构\n\n * hotspot vm是目前市面上高性能虚拟机的代表作之一。\n * 它采用解释器与即时编译器并存的架构。\n * 在今天，java程序的运行性能早已脱胎换骨，已经达到了可以和c/c++程序一较高下的地步。\n\n\n\n执行引擎包含三部分：解释器，及时编译器，垃圾回收器\n\n\n# java代码执行流程\n\n只是能生成被java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了\n\n\n# jvm的架构模型\n\njava编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：\n\n基于栈式架构的特点\n\n * 设计和实现更简单，适用于资源受限的系统；\n * 避开了寄存器的分配难题：使用零地址指令方式分配。\n * 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。\n * 不需要硬件支持，可移植性更好，更好实现跨平台\n\n基于寄存器架构的特点\n\n * 典型的应用是x86的二进制指令集：比如传统的pc以及android的davlik虚拟机。\n * 指令集架构则完全依赖硬件，可移植性差\n * 性能优秀和执行更高效\n * 花费更少的指令去完成一项操作。\n * 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋\n\n\n# 举例\n\n同样执行2+3这种逻辑操作，其指令分别如下：\n\n基于栈的计算流程（以java虚拟机为例）：\n\niconst_2 //常量2入栈\nistore_1\niconst_3 // 常量3入栈\nistore_2\niload_1\niload_2\niadd //常量2/3出栈，执行相加\nistore_0 // 结果5入栈\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n而基于寄存器的计算流程\n\nmov eax,2 //将eax寄存器的值设为1\nadd eax,3 //使eax寄存器的值加3\n\n\n1\n2\n\n\n\n# 字节码反编译\n\n我们编写一个简单的代码，然后查看一下字节码的反编译后的结果\n\n/**\n * @author: 陌溪\n * @create: 2020-07-04-21:17\n */\npublic class stackstrutest {\n    public static void main(string[] args) {\n        int i = 2 + 3;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后我们找到编译后的 class文件，使用下列命令进行反编译\n\njavap -v stackstrutest.class\n\n\n1\n\n\n得到的文件为:\n\n  public static void main(java.lang.string[]);\n    descriptor: ([ljava/lang/string;)v\n    flags: acc_public, acc_static\n    code:\n      stack=2, locals=4, args_size=1\n         0: iconst_2\n         1: istore_1\n         2: iconst_3\n         3: istore_2\n         4: iload_1\n         5: iload_2\n         6: iadd\n         7: istore_3\n         8: return\n      linenumbertable:\n        line 9: 0\n        line 10: 2\n        line 11: 4\n        line 12: 8\n      localvariabletable:\n        start  length  slot  name   signature\n            0       9     0  args   [ljava/lang/string;\n            2       7     1     i   i\n            4       5     2     j   i\n            8       1     3     k   i\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 总结\n\n由于跨平台性的设计，java的指令都是根据栈来设计的。不同平台cpu架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。\n\n时至今日，尽管嵌入式平台已经不是java程序的主流运行平台了（准确来说应该是hotspotvm的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？\n\n\n# 栈\n\n * 跨平台性\n * 指令集小\n * 指令多\n * 执行性能比寄存器差\n\n\n# jvm生命周期\n\n\n# 虚拟机的启动\n\njava虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。\n\n\n# 虚拟机的执行\n\n * 一个运行中的java虚拟机有着一个清晰的任务：执行java程序。\n * 程序开始执行时他才运行，程序结束时他就停止。\n * 执行一个所谓的java程序的时候，真真正正在执行的是一个叫做java虚拟机的进程。\n\n\n# 虚拟机的退出\n\n有如下的几种情况：\n\n * 程序正常执行结束\n\n * 程序在执行过程中遇到了异常或错误而异常终止\n\n * 由于操作系统用现错误而导致java虚拟机进程终止\n\n * 某线程调用runtime类或system类的exit方法，或runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作。\n\n * 除此之外，jni（java native interface）规范描述了用jni invocation api来加载或卸载 java虚拟机时，java虚拟机的退出情况。\n\n\n# jvm发展历程\n\n\n# sun classic vm\n\n * 早在1996年java1.0版本的时候，sun公司发布了一款名为sun classic vm的java虚拟机，它同时也是世界上第一款商用java虚拟机，jdk1.4时完全被淘汰。\n * 这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。\n * 如果使用jit编译器，就需要进行外挂。但是一旦使用了jit编译器，jit就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。\n * 现在hotspot内置了此虚拟机。\n\n\n# exact vm\n\n为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 exact memory management：准确式内存管理\n\n * 也可以叫non-conservative/accurate memory management\n * 虚拟机可以知道内存中某个位置的数据具体是什么类型。|\n\n具备现代高性能虚拟机的维形\n\n * 热点探测（寻找出热点代码进行缓存）\n * 编译器与解释器混合工作模式\n\n只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被hotspot虚拟机替换\n\n\n# hotspot vm\n\nhotspot历史\n\n * 最初由一家名为“longview technologies”的小公司设计\n * 1997年，此公司被sun收购；2009年，sun公司被甲骨文收购。\n * jdk1.3时，hotspot vm成为默认虚拟机\n\n目前hotspot占有绝对的市场地位，称霸武林。\n\n * 不管是现在仍在广泛使用的jdk6，还是使用比例较多的jdk8中，默认的虚拟机都是hotspot\n * sun/oracle jdk和openjdk的默认虚拟机\n * 因此本课程中默认介绍的虚拟机都是hotspot，相关机制也主要是指hotspot的gc机制。（比如其他两个商用虚机都没有方法区的概念）\n\n从服务器、桌面到移动端、嵌入式都有应用。\n\n名称中的hotspot指的就是它的热点代码探测技术。\n\n * 通过计数器找到最具编译价值代码，触发即时编译或栈上替换\n * 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡\n\n\n# jrockit\n\n专注于服务器端应用\n\n * 它可以不太关注程序启动速度，因此jrockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。\n\n大量的行业基准测试显示，jrockit jvm是世界上最快的jvm。\n\n * 使用jrockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。\n\n优势：全面的java运行时解决方案组合\n\n * jrockit面向延迟敏感型应用的解决方案jrockit real time提供以毫秒或微秒级的jvm响应时间，适合财务、军事指挥、电信网络的需要\n * missioncontrol服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。\n\n2008年，jrockit被oracle收购。\n\noracle表达了整合两大优秀虚拟机的工作，大致在jdk8中完成。整合的方式是在hotspot的基础上，移植jrockit的优秀特性。\n\n高斯林：目前就职于谷歌，研究人工智能和水下机器人\n\n\n# ibm的j9\n\n全称：ibm technology for java virtual machine，简称it4j，内部代号：j9\n\n市场定位与hotspot接近，服务器端、桌面应用、嵌入式等多用途vm广泛用于ibm的各种java产品。\n\n目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的java虚拟机。\n\n2017年左右，ibm发布了开源j9vm，命名为openj9，交给eclipse基金会管理，也称为eclipse openj9\n\nopenjdk -> 是jdk开源了，包括了虚拟机\n\n\n# kvm和cdc / cldc hotspot\n\noracle在java me产品线上的两款虚拟机为：cdc/cldc hotspot implementation vm kvm（kilobyte）是cldc-hi早期产品目前移动领域地位尴尬，智能机被angroid和ios二分天下。\n\nkvm简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场\n\n * 智能控制器、传感器\n * 老人手机、经济欠发达地区的功能手机\n\n所有的虚拟机的原则：一次编译，到处运行。\n\n\n# azul vm\n\n前面三大“高性能java虚拟机”使用在通用硬件平台上这里azu1vw和bealiquid vm是与特定硬件平台绑定、软硬件配合的专有虚拟机i\n\n * 高性能java虚拟机中的战斗机。\n\nazul vm是azu1systems公司在hotspot基础上进行大量改进，运行于azul systems公司的专有硬件vega系统上的ava虚拟机。\n\n每个azu1vm实例都可以管理至少数十个cpu和数百gb内存的硬件资源，并提供在巨大内存范围内实现可控的gc时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。\n\n2010年，azulsystems公司开始从硬件转向软件，发布了自己的zing jvm，可以在通用x86平台上提供接近于vega系统的特性。\n\n\n# liquid vm\n\n高性能java虚拟机中的战斗机。\n\nbea公司开发的，直接运行在自家hypervisor系统上liquid vm即是现在的jrockit ve（virtual edition），\n\nliquid vm不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。\n\n随着jrockit虚拟机终止开发，liquid vm项目也停止了。\n\n\n# apache marmony\n\napache也曾经推出过与jdk1.5和jdk1.6兼容的java运行平台apache harmony。\n\n它是ielf和inte1联合开发的开源jvm，受到同样开源的openjdk的压制，sun坚决不让harmony获得jcp认证，最终于2011年退役，ibm转而参与openjdk\n\n虽然目前并没有apache harmony被大规模商用的案例，但是它的java类库代码吸纳进了android sdk。\n\n\n# micorsoft jvm\n\n微软为了在ie3浏览器中支持java applets，开发了microsoft jvm。\n\n只能在window平台下运行。但确是当时windows下性能最好的java vm。\n\n1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsxpsp3中抹掉了其vm。现在windows上安装的jdk都是hotspot。\n\n\n# taobao jvm\n\n由alijvm团队发布。阿里，国内使用java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。\n\n基于openjdk开发了自己的定制版本alibabajdk，简称ajdk。是整个阿里java体系的基石。\n\n基于openjdk hotspot vm发布的国内第一个优化、深度定制且开源的高性能服务器版java虚拟机。\n\n * 创新的gcih（gcinvisible heap）技术实现了off-heap，即将生命周期较长的java对象从heap中移到heap之外，并且gc不能管理gcih内部的java对象，以此达到降低gc的回收频率和提升gc的回收效率的目的。\n * gcih中的对象还能够在多个java虚拟机进程中实现共享\n * 使用crc32指令实现jvm intrinsic降低jni的调用开销\n * pmu hardware的java profiling tool和诊断协助功能\n * 针对大数据场景的zengc\n\ntaobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能\n\n目前已经在淘宝、天猫上线，把oracle官方jvm版本全部替换了。\n\n\n# dalvik vm\n\n谷歌开发的，应用于android系统，并在android2.2中提供了jit，发展迅猛。\n\ndalvik y只能称作虚拟机，而不能称作“java虚拟机”，它没有遵循 java虚拟机规范\n\n不能直接执行java的class文件\n\n基于寄存器架构，不是jvm的栈架构。\n\n执行的是编译以后的dex（dalvik executable）文件。执行效率比较高。\n\n * 它执行的dex（dalvik executable）文件可以通过class文件转化而来，使用java语法编写应用程序，可以直接使用大部分的java api等。\n\nandroid 5.0使用支持提前编译（ahead of time compilation，aot）的art vm替换dalvik vm。\n\n\n# graal vm\n\n2018年4月，oracle labs公开了graalvm，号称 "run programs faster anywhere"，勃勃野心。与1995年java的”write once，run anywhere"遥相呼应。\n\ngraalvm在hotspot vm基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：java、scala、groovy、kotlin；c、c++、javascript、ruby、python、r等\n\n支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件\n\n工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被graal vm接受的中间表示。graal vm提供truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。\n\n如果说hotspot有一天真的被取代，graalvm希望最大。但是java的软件生态没有丝毫变化。\n\n\n# 总结\n\n具体jvm的内存结构，其实取决于其实现，不同厂商的jvm，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle hotspot vm为默认虚拟机。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-对象的实例化内存布局与访问定位",frontmatter:{title:"JVM-对象的实例化内存布局与访问定位",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/9fa953/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/10.JVM-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.html",relativePath:"01.语言/01.JAVA语言/02.JVM/10.JVM-对象的实例化内存布局与访问定位.md",key:"v-d4b0e508",path:"/pages/9fa953/",headers:[{level:2,title:"1. 对象实例化",slug:"_1-对象实例化",normalizedTitle:"1. 对象实例化",charIndex:88},{level:3,title:"1. 对象的实例化",slug:"_1-对象的实例化",normalizedTitle:"1. 对象的实例化",charIndex:101},{level:3,title:"2. 对象的创建字节码角度",slug:"_2-对象的创建字节码角度",normalizedTitle:"2. 对象的创建字节码角度",charIndex:117},{level:2,title:"2. 对象的内存布局",slug:"_2-对象的内存布局",normalizedTitle:"2. 对象的内存布局",charIndex:3066},{level:3,title:"1. 内存布局",slug:"_1-内存布局",normalizedTitle:"1. 内存布局",charIndex:3081},{level:3,title:"2. 图示",slug:"_2-图示",normalizedTitle:"2. 图示",charIndex:3095},{level:2,title:"3. 对象的访问定位",slug:"_3-对象的访问定位",normalizedTitle:"3. 对象的访问定位",charIndex:3107},{level:3,title:"1. JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？",slug:"_1-jvm是如何通过栈帧中的对象引用访问到其内部的对象实例的呢",normalizedTitle:"1. jvm是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？",charIndex:3122}],headersStr:"1. 对象实例化 1. 对象的实例化 2. 对象的创建字节码角度 2. 对象的内存布局 1. 内存布局 2. 图示 3. 对象的访问定位 1. JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？",content:'# JVM-对象的实例化内存布局与访问定位\n\n面试题\n\n 1. 对象在JVM中是怎么存储的？\n\n 2. 对象头信息里面有哪些东西？\n\n 3. Java对象头里有什么？\n\n\n# 1. 对象实例化\n\n\n# 1. 对象的实例化\n\n\n\n\n# 2. 对象的创建字节码角度\n\n 1. 源码\n\npublic class ObjectTest {\n\n    public static void main(String[] args) {\n        Object o = new Object();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 执行命令\n\njava -v -p ObjectTest.class\n\n\n1\n\n 3. 结果\n\nD:\\java-code\\java\\jvm\\target\\classes\\com\\chggx\\jvm\\chapter10>javap -v -p ObjectTest.class\nClassfile /D:/java-code/java/jvm/target/classes/com/chggx/jvm/chapter10/ObjectTest.class\n  Last modified 2020-12-27; size 468 bytes\n  MD5 checksum 2a4d696213cdd30c4a65ce13dcab2338\n  Compiled from "ObjectTest.java"\npublic class com.chggx.jvm.chapter10.ObjectTest\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #2.#19         // java/lang/Object."<init>":()V\n   #2 = Class              #20            // java/lang/Object\n   #3 = Class              #21            // com/chggx/jvm/chapter10/ObjectTest\n   #4 = Utf8               <init>\n   #5 = Utf8               ()V\n   #6 = Utf8               Code\n   #7 = Utf8               LineNumberTable\n   #8 = Utf8               LocalVariableTable\n   #9 = Utf8               this\n  #10 = Utf8               Lcom/chggx/jvm/chapter10/ObjectTest;\n  #11 = Utf8               main\n  #12 = Utf8               ([Ljava/lang/String;)V\n  #13 = Utf8               args\n  #14 = Utf8               [Ljava/lang/String;\n  #15 = Utf8               o\n  #16 = Utf8               Ljava/lang/Object;\n  #17 = Utf8               SourceFile\n  #18 = Utf8               ObjectTest.java\n  #19 = NameAndType        #4:#5          // "<init>":()V\n  #20 = Utf8               java/lang/Object\n  #21 = Utf8               com/chggx/jvm/chapter10/ObjectTest\n{\n  public com.chggx.jvm.chapter10.ObjectTest();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object."<init>":()V\n         4: return\n      LineNumberTable:\n        line 8: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/chggx/jvm/chapter10/ObjectTest;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code: \n      stack=2, locals=2, args_size=1 \n      \t// 创建对象的步骤\n         0: new           #2                  // class java/lang/Object\n         3: dup\n         4: invokespecial #1                  // Method java/lang/Object."<init>":()V\n         7: astore_1\n         8: return\n      LineNumberTable:\n        line 11: 0\n        line 12: 8\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  args   [Ljava/lang/String;\n            8       1     1     o   Ljava/lang/Object;\n}\nSourceFile: "ObjectTest.java"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n# 2. 对象的内存布局\n\n\n# 1. 内存布局\n\n\n\n\n# 2. 图示\n\n\n\n\n# 3. 对象的访问定位\n\n\n# 1. JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？\n\n\n\n句柄访问图示\n\n\n\n直接指针图示\n\n',normalizedContent:'# jvm-对象的实例化内存布局与访问定位\n\n面试题\n\n 1. 对象在jvm中是怎么存储的？\n\n 2. 对象头信息里面有哪些东西？\n\n 3. java对象头里有什么？\n\n\n# 1. 对象实例化\n\n\n# 1. 对象的实例化\n\n\n\n\n# 2. 对象的创建字节码角度\n\n 1. 源码\n\npublic class objecttest {\n\n    public static void main(string[] args) {\n        object o = new object();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 执行命令\n\njava -v -p objecttest.class\n\n\n1\n\n 3. 结果\n\nd:\\java-code\\java\\jvm\\target\\classes\\com\\chggx\\jvm\\chapter10>javap -v -p objecttest.class\nclassfile /d:/java-code/java/jvm/target/classes/com/chggx/jvm/chapter10/objecttest.class\n  last modified 2020-12-27; size 468 bytes\n  md5 checksum 2a4d696213cdd30c4a65ce13dcab2338\n  compiled from "objecttest.java"\npublic class com.chggx.jvm.chapter10.objecttest\n  minor version: 0\n  major version: 52\n  flags: acc_public, acc_super\nconstant pool:\n   #1 = methodref          #2.#19         // java/lang/object."<init>":()v\n   #2 = class              #20            // java/lang/object\n   #3 = class              #21            // com/chggx/jvm/chapter10/objecttest\n   #4 = utf8               <init>\n   #5 = utf8               ()v\n   #6 = utf8               code\n   #7 = utf8               linenumbertable\n   #8 = utf8               localvariabletable\n   #9 = utf8               this\n  #10 = utf8               lcom/chggx/jvm/chapter10/objecttest;\n  #11 = utf8               main\n  #12 = utf8               ([ljava/lang/string;)v\n  #13 = utf8               args\n  #14 = utf8               [ljava/lang/string;\n  #15 = utf8               o\n  #16 = utf8               ljava/lang/object;\n  #17 = utf8               sourcefile\n  #18 = utf8               objecttest.java\n  #19 = nameandtype        #4:#5          // "<init>":()v\n  #20 = utf8               java/lang/object\n  #21 = utf8               com/chggx/jvm/chapter10/objecttest\n{\n  public com.chggx.jvm.chapter10.objecttest();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // method java/lang/object."<init>":()v\n         4: return\n      linenumbertable:\n        line 8: 0\n      localvariabletable:\n        start  length  slot  name   signature\n            0       5     0  this   lcom/chggx/jvm/chapter10/objecttest;\n\n  public static void main(java.lang.string[]);\n    descriptor: ([ljava/lang/string;)v\n    flags: acc_public, acc_static\n    code: \n      stack=2, locals=2, args_size=1 \n      \t// 创建对象的步骤\n         0: new           #2                  // class java/lang/object\n         3: dup\n         4: invokespecial #1                  // method java/lang/object."<init>":()v\n         7: astore_1\n         8: return\n      linenumbertable:\n        line 11: 0\n        line 12: 8\n      localvariabletable:\n        start  length  slot  name   signature\n            0       9     0  args   [ljava/lang/string;\n            8       1     1     o   ljava/lang/object;\n}\nsourcefile: "objecttest.java"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n# 2. 对象的内存布局\n\n\n# 1. 内存布局\n\n\n\n\n# 2. 图示\n\n\n\n\n# 3. 对象的访问定位\n\n\n# 1. jvm是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？\n\n\n\n句柄访问图示\n\n\n\n直接指针图示\n\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-执行引擎",frontmatter:{title:"JVM-执行引擎",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/64de09/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/12.JVM-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html",relativePath:"01.语言/01.JAVA语言/02.JVM/12.JVM-执行引擎.md",key:"v-397f7974",path:"/pages/64de09/",headers:[{level:2,title:"1. 执行引擎概述",slug:"_1-执行引擎概述",normalizedTitle:"1. 执行引擎概述",charIndex:15},{level:3,title:"执行引擎的工作流程",slug:"执行引擎的工作流程",normalizedTitle:"执行引擎的工作流程",charIndex:474},{level:2,title:"2. Java代码编译和执行过程",slug:"_2-java代码编译和执行过程",normalizedTitle:"2. java代码编译和执行过程",charIndex:736},{level:3,title:"1. 什么是解释器（Interpreter）",slug:"_1-什么是解释器-interpreter",normalizedTitle:"1. 什么是解释器（interpreter）",charIndex:901},{level:3,title:"2. 什么是IT编译器",slug:"_2-什么是it编译器",normalizedTitle:"2. 什么是it编译器",charIndex:997},{level:3,title:"3. 为什么Java是半编译半解释型语言",slug:"_3-为什么java是半编译半解释型语言",normalizedTitle:"3. 为什么java是半编译半解释型语言",charIndex:1074},{level:2,title:"3. 机器码、指令、汇编语言",slug:"_3-机器码、指令、汇编语言",normalizedTitle:"3. 机器码、指令、汇编语言",charIndex:1231},{level:3,title:"1. 机器码",slug:"_1-机器码",normalizedTitle:"1. 机器码",charIndex:1250},{level:3,title:"2. 指令",slug:"_2-指令",normalizedTitle:"2. 指令",charIndex:1450},{level:3,title:"3. 指令集",slug:"_3-指令集",normalizedTitle:"3. 指令集",charIndex:1618},{level:3,title:"4. 汇编语言",slug:"_4-汇编语言",normalizedTitle:"4. 汇编语言",charIndex:1730},{level:3,title:"5. 高级语言",slug:"_5-高级语言",normalizedTitle:"5. 高级语言",charIndex:1934},{level:3,title:"6. C、C++源程序执行过程",slug:"_6-c、c-源程序执行过程",normalizedTitle:"6. c、c++源程序执行过程",charIndex:2108},{level:3,title:"7. 字节码",slug:"_7-字节码",normalizedTitle:"7. 字节码",charIndex:2232},{level:2,title:"4. 解释器",slug:"_4-解释器",normalizedTitle:"4. 解释器",charIndex:2424},{level:3,title:"1. 解释器分类",slug:"_1-解释器分类",normalizedTitle:"1. 解释器分类",charIndex:2691},{level:3,title:"2. 现状",slug:"_2-现状",normalizedTitle:"2. 现状",charIndex:2965},{level:2,title:"5. JIT编译器",slug:"_5-jit编译器",normalizedTitle:"5. jit编译器",charIndex:3236},{level:3,title:"1. Java代码的执行分类",slug:"_1-java代码的执行分类",normalizedTitle:"1. java代码的执行分类",charIndex:3250},{level:3,title:"2. 问题来了",slug:"_2-问题来了",normalizedTitle:"2. 问题来了",charIndex:3563},{level:3,title:"3. HotSpot JVM执行方式",slug:"_3-hotspot-jvm执行方式",normalizedTitle:"3. hotspot jvm执行方式",charIndex:4157},{level:3,title:"4. 案例",slug:"_4-案例",normalizedTitle:"4. 案例",charIndex:4307},{level:3,title:"5. 概念解释",slug:"_5-概念解释",normalizedTitle:"5. 概念解释",charIndex:4626},{level:3,title:"6. 热点探测技术",slug:"_6-热点探测技术",normalizedTitle:"6. 热点探测技术",charIndex:4993},{level:3,title:"7. 方法调用计数器",slug:"_7-方法调用计数器",normalizedTitle:"7. 方法调用计数器",charIndex:5423},{level:3,title:"8. 热点衰减",slug:"_8-热点衰减",normalizedTitle:"8. 热点衰减",charIndex:5713},{level:3,title:"9. 回边计数器",slug:"_9-回边计数器",normalizedTitle:"9. 回边计数器",charIndex:6127},{level:3,title:"10. HotSpotVM 可以设置程序执行方法",slug:"_10-hotspotvm-可以设置程序执行方法",normalizedTitle:"10. hotspotvm 可以设置程序执行方法",charIndex:6349},{level:3,title:"11. HotSpotVM中 JIT 分类",slug:"_11-hotspotvm中-jit-分类",normalizedTitle:"11. hotspotvm中 jit 分类",charIndex:6592},{level:3,title:"12. C1 和 C2编译器不同的优化策略",slug:"_12-c1-和-c2编译器不同的优化策略",normalizedTitle:"12. c1 和 c2编译器不同的优化策略",charIndex:6952},{level:3,title:"13. 分层编译策略",slug:"_13-分层编译策略",normalizedTitle:"13. 分层编译策略",charIndex:7255},{level:3,title:"14. 总结",slug:"_14-总结",normalizedTitle:"14. 总结",charIndex:7454},{level:3,title:"15. AOT编译器",slug:"_15-aot编译器",normalizedTitle:"15. aot编译器",charIndex:7537},{level:3,title:"写到最后",slug:"写到最后",normalizedTitle:"写到最后",charIndex:8030}],headersStr:"1. 执行引擎概述 执行引擎的工作流程 2. Java代码编译和执行过程 1. 什么是解释器（Interpreter） 2. 什么是IT编译器 3. 为什么Java是半编译半解释型语言 3. 机器码、指令、汇编语言 1. 机器码 2. 指令 3. 指令集 4. 汇编语言 5. 高级语言 6. C、C++源程序执行过程 7. 字节码 4. 解释器 1. 解释器分类 2. 现状 5. JIT编译器 1. Java代码的执行分类 2. 问题来了 3. HotSpot JVM执行方式 4. 案例 5. 概念解释 6. 热点探测技术 7. 方法调用计数器 8. 热点衰减 9. 回边计数器 10. HotSpotVM 可以设置程序执行方法 11. HotSpotVM中 JIT 分类 12. C1 和 C2编译器不同的优化策略 13. 分层编译策略 14. 总结 15. AOT编译器 写到最后",content:'# JVM-执行引擎\n\n\n# 1. 执行引擎概述\n\n执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器\n\n\n\n * 执行引擎是Java虚拟机核心的组成部分之一。\n\n * “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层次上的，而虚拟机的执行引擎则是有软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件支持的指令集格式。\n\n * JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。\n   \n   \n\n * 那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。\n   \n   \n\n\n# 执行引擎的工作流程\n\n\n\n * 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。\n * 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。\n * 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。\n\n从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。\n\n\n# 2. Java代码编译和执行过程\n\n\n\n大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图的各个步骤。\n\nJava代码编译是由Java源码编译器来完成，流程图如下所示：\n\n\n\nJava字节码的执行是由JVM执行引擎来完成，流程图 如下所示\n\n\n\n我们用一个总的图，来说说 解释器和编译器\n\n\n\n\n# 1. 什么是解释器（Interpreter）\n\n当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。\n\n\n# 2. 什么是IT编译器\n\nJIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。\n\n\n# 3. 为什么Java是半编译半解释型语言\n\nJDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。\n\n翻译成本地代码后，就可以做一个缓存操作，存储在方法区中\n\n\n# 3. 机器码、指令、汇编语言\n\n\n# 1. 机器码\n\n各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。\n\n机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。\n\n用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。\n\n机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。\n\n\n# 2. 指令\n\n由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。\n\n指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好\n\n由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。\n\n\n# 3. 指令集\n\n不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的\n\n * x86指令集，对应的是x86架构的平台\n * ARM指令集，对应的是ARM架构的平台\n\n\n# 4. 汇编语言\n\n由于指令的可读性还是太差，于是人们又发明了汇编语言。\n\n在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。\n\n在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。\n\n> 由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。\n\n\n# 5. 高级语言\n\n为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言。\n\n当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。\n\n\n\n高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++\n\n\n\n\n# 6. C、C++源程序执行过程\n\n编译过程又可以分成两个阶段：编译和汇编。\n\n编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码\n\n汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。\n\n\n# 7. 字节码\n\n字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码\n\n字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。\n\n字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。\n\n * 字节码典型的应用为：Java bytecode\n   \n   \n\n\n# 4. 解释器\n\nJVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。\n\n\n\n为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的\n\n解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。\n\n当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。\n\n\n# 1. 解释器分类\n\n在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。\n\n字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。\n\n而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。\n\n在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。\n\n * Interpreter模块：实现了解释器的核心功能\n * Code模块：用于管理HotSpot VM在运行时生成的本地机器指令\n\n\n# 2. 现状\n\n由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。\n\n为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。\n\n不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。\n\n\n\n\n# 5. JIT编译器\n\n\n# 1. Java代码的执行分类\n\n 1. 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行\n\n 2. 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行\n\nHotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。\n\n在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。\n\n\n# 2. 问题来了\n\n有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。\n\n * JRockit虚拟机是砍掉了解释器，也就是只采即时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能\n\n首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。\n\n所以： 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。\n\n在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。\n\n同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。\n\n\n# 3. HotSpot JVM执行方式\n\n当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。\n\n\n# 4. 案例\n\n注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。\n\n在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队\n\n\n\n\n# 5. 概念解释\n\n * Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；\n\n * 也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。\n\n * 还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。\n\n前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。\n\nJIT编译器：HotSpot VM的C1、C2编译器。\n\nAOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。\n\n\n# 6. 热点探测技术\n\n一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。\n\n一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。\n\n目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。\n\n采用基于计数器的热点探测，HotSpot V将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。\n\n * 方法调用计数器用于统计方法的调用次数\n * 回边计数器则用于统计循环体执行的循环次数\n\n\n# 7. 方法调用计数器\n\n这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。\n\n这个阀值可以通过虚拟机参数-XX:CompileThreshold来人为设定。\n\n当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。\n\n\n\n\n# 8. 热点衰减\n\n如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）\n\n * 半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄\n\n进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。\n\n另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。\n\n\n# 9. 回边计数器\n\n它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。\n\n![image-20210113133641936](/Users/lixiaochao/Library/Application Support/typora-user-images/image-20210113133641936.png)\n\n\n# 10. HotSpotVM 可以设置程序执行方法\n\n缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：\n\n * -Xint：完全采用解释器模式执行程序；\n * -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行\n * -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。\n\n\n\n\n# 11. HotSpotVM中 JIT 分类\n\nJIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：\n\n * -client：指定Java虚拟机运行在Client模式下，并使用C1编译器；\n   * C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。\n * -server：指定Java虚拟机运行在server模式下，并使用C2编译器。\n   * C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）【64位】\n\n\n# 12. C1 和 C2编译器不同的优化策略\n\n在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。\n\n * 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程\n * 去虚拟化：对唯一的实现樊进行内联\n * 冗余消除：在运行期间把一些不会执行的代码折叠掉\n\nC2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：【server模式】\n\n * 标量替换：用标量值代替聚合对象的属性值\n * 栈上分配：对于未逃逸的对象分配对象在栈而不是堆\n * 同步消除：清除同步操作，通常指synchronized\n\n\n# 13. 分层编译策略\n\n分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。\n\n不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server"时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。\n\n\n# 14. 总结\n\n * 一般来讲，JIT编译出来的机器码性能比解释器搞\n * C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器\n\n\n# 15. AOT编译器\n\njdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）\n\nJava 9引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。\n\n所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。\n\n.java -> .class -> (使用jaotc) -> .so\n\n\n1\n\n\n最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验\n\n缺点：\n\n * 破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包\n * 降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。\n * 还需要继续优化中，最初只支持Linux X64 java base\n\n\n# 写到最后\n\n * 自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器\n * 编译效果短短几年时间就追评了G2编译器，未来可期\n * 目前，带着实验状态标签，需要使用开关参数去激活才能使用\n\n-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler\n\n\n1\n',normalizedContent:'# jvm-执行引擎\n\n\n# 1. 执行引擎概述\n\n执行引擎属于jvm的下层，里面包括 解释器、及时编译器、垃圾回收器\n\n\n\n * 执行引擎是java虚拟机核心的组成部分之一。\n\n * “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层次上的，而虚拟机的执行引擎则是有软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件支持的指令集格式。\n\n * jvm的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被jvm所识别的字节码指令、符号表，以及其他辅助信息。\n   \n   \n\n * 那么，如果想要让一个java程序运行起来，执行引擎（execution engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，jvm中的执行引擎充当了将高级语言翻译为机器语言的译者。\n   \n   \n\n\n# 执行引擎的工作流程\n\n\n\n * 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于pc寄存器。\n * 每当执行完一项指令操作后，pc寄存器就会更新下一条需要被执行的指令地址。\n * 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。\n\n从外观上来看，所有的java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。\n\n\n# 2. java代码编译和执行过程\n\n\n\n大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图的各个步骤。\n\njava代码编译是由java源码编译器来完成，流程图如下所示：\n\n\n\njava字节码的执行是由jvm执行引擎来完成，流程图 如下所示\n\n\n\n我们用一个总的图，来说说 解释器和编译器\n\n\n\n\n# 1. 什么是解释器（interpreter）\n\n当java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。\n\n\n# 2. 什么是it编译器\n\njit（just in time compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。\n\n\n# 3. 为什么java是半编译半解释型语言\n\njdk1.0时代，将java语言定位为“解释执行”还是比较准确的。再后来，java也发展出可以直接生成本地代码的编译器。现在jvm在执行java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。\n\n翻译成本地代码后，就可以做一个缓存操作，存储在方法区中\n\n\n# 3. 机器码、指令、汇编语言\n\n\n# 1. 机器码\n\n各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。\n\n机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。\n\n用它编写的程序一经输入计算机，cpu直接读取运行，因此和其他语言编的程序相比，执行速度最快。\n\n机器指令与cpu紧密相关，所以不同种类的cpu所对应的机器指令也就不同。\n\n\n# 2. 指令\n\n由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。\n\n指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好\n\n由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。\n\n\n# 3. 指令集\n\n不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的\n\n * x86指令集，对应的是x86架构的平台\n * arm指令集，对应的是arm架构的平台\n\n\n# 4. 汇编语言\n\n由于指令的可读性还是太差，于是人们又发明了汇编语言。\n\n在汇编语言中，用助记符（mnemonics）代替机器指令的操作码，用地址符号（symbo1）或标号（labe1）代替指令或操作数的地址。\n\n在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。\n\n> 由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。\n\n\n# 5. 高级语言\n\n为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言。\n\n当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。\n\n\n\n高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的c和c++\n\n\n\n\n# 6. c、c++源程序执行过程\n\n编译过程又可以分成两个阶段：编译和汇编。\n\n编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码\n\n汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。\n\n\n# 7. 字节码\n\n字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码\n\n字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。\n\n字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。\n\n * 字节码典型的应用为：java bytecode\n   \n   \n\n\n# 4. 解释器\n\njvm设计者们的初衷仅仅只是单纯地为了满足java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。\n\n\n\n为什么java源文件不直接翻译成jmv，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的\n\n解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。\n\n当一条字节码指令被解释执行完成后，接着再根据pc寄存器中记录的下一条需要被执行的字节码指令执行解释操作。\n\n\n# 1. 解释器分类\n\n在java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。\n\n字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。\n\n而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。\n\n在hotspot vm中，解释器主要由interpreter模块和code模块构成。\n\n * interpreter模块：实现了解释器的核心功能\n * code模块：用于管理hotspot vm在运行时生成的本地机器指令\n\n\n# 2. 现状\n\n由于解释器在设计和实现上非常简单，因此除了java语言之外，还有许多高级语言同样也是基于解释器执行的，比如python、per1、ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些c/c++程序员所调侃。\n\n为了解决这个问题，jvm平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。\n\n不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。\n\n\n\n\n# 5. jit编译器\n\n\n# 1. java代码的执行分类\n\n 1. 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行\n\n 2. 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（jit，just in time）将方法编译成机器码后再执行\n\nhotspot vm是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。\n\n在今天，java程序的运行性能早已脱胎换骨，已经达到了可以和c/c++ 程序一较高下的地步。\n\n\n# 2. 问题来了\n\n有些开发人员会感觉到诧异，既然hotspot vm中已经内置jit编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如jrockit vm内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。\n\n * jrockit虚拟机是砍掉了解释器，也就是只采即时编译器。那是因为呢jrockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能\n\n首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。\n\n所以： 尽管jrockit vm中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。\n\n在此模式下，当java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。\n\n同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。\n\n\n# 3. hotspot jvm执行方式\n\n当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。\n\n\n# 4. 案例\n\n注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。\n\n在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的jvm均是解释执行，还没有进行热点代码统计和jit动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了jit的存在。—阿里团队\n\n\n\n\n# 5. 概念解释\n\n * java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；\n\n * 也可能是指虚拟机的后端运行期编译器（jit编译器，just in time compiler）把字节码转变成机器码的过程。\n\n * 还可能是指使用静态提前编译器（aot编译器，ahead of time compiler）直接把.java文件编译成本地机器代码的过程。\n\n前端编译器：sun的javac、eclipse jdt中的增量式编译器（ecj）。\n\njit编译器：hotspot vm的c1、c2编译器。\n\naot 编译器：gnu compiler for the java（gcj）、excelsior jet。\n\n\n# 6. 热点探测技术\n\n一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过jit编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为osr（on stack replacement）编译。\n\n一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，jit编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。\n\n目前hotspot vm所采用的热点探测方式是基于计数器的热点探测。\n\n采用基于计数器的热点探测，hotspot v将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（invocation counter）和回边计数器（back edge counter）。\n\n * 方法调用计数器用于统计方法的调用次数\n * 回边计数器则用于统计循环体执行的循环次数\n\n\n# 7. 方法调用计数器\n\n这个计数器就用于统计方法被调用的次数，它的默认阀值在client模式下是1500次，在server模式下是10000次。超过这个阈值，就会触发jit编译。\n\n这个阀值可以通过虚拟机参数-xx:compilethreshold来人为设定。\n\n当一个方法被调用时，会先检查该方法是否存在被jit编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。\n\n\n\n\n# 8. 热点衰减\n\n如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（counter decay），而这段时间就称为此方法统计的半衰周期（counter half life time）\n\n * 半衰周期是化学中的概念，比如出土的文物通过查看c60来获得文物的年龄\n\n进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -xx:-usecounterdecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。\n\n另外，可以使用-xx:counterhalflifetime参数设置半衰周期的时间，单位是秒。\n\n\n# 9. 回边计数器\n\n它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（back edge）。显然，建立回边计数器统计的目的就是为了触发osr编译。\n\n![image-20210113133641936](/users/lixiaochao/library/application support/typora-user-images/image-20210113133641936.png)\n\n\n# 10. hotspotvm 可以设置程序执行方法\n\n缺省情况下hotspot vm是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：\n\n * -xint：完全采用解释器模式执行程序；\n * -xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行\n * -xmixed：采用解释器+即时编译器的混合模式共同执行程序。\n\n\n\n\n# 11. hotspotvm中 jit 分类\n\njit的编译器还分为了两种，分别是c1和c2，在hotspot vm中内嵌有两个jit编译器，分别为client compiler和server compiler，但大多数情况下我们简称为c1编译器 和 c2编译器。开发人员可以通过如下命令显式指定java虚拟机在运行时到底使用哪一种即时编译器，如下所示：\n\n * -client：指定java虚拟机运行在client模式下，并使用c1编译器；\n   * c1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。\n * -server：指定java虚拟机运行在server模式下，并使用c2编译器。\n   * c2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用c++）【64位】\n\n\n# 12. c1 和 c2编译器不同的优化策略\n\n在不同的编译器上有不同的优化策略，c1编译器上主要有方法内联，去虚拟化、元余消除。\n\n * 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程\n * 去虚拟化：对唯一的实现樊进行内联\n * 冗余消除：在运行期间把一些不会执行的代码折叠掉\n\nc2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在c2上有如下几种优化：【server模式】\n\n * 标量替换：用标量值代替聚合对象的属性值\n * 栈上分配：对于未逃逸的对象分配对象在栈而不是堆\n * 同步消除：清除同步操作，通常指synchronized\n\n\n# 13. 分层编译策略\n\n分层编译（tiered compilation）策略：程序解释执行（不开启性能监控）可以触发c1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，c2编译会根据性能监控信息进行激进优化。\n\n不过在java7版本之后，一旦开发人员在程序中显式指定命令“-server"时，默认将会开启分层编译策略，由c1编译器和c2编译器相互协作共同来执行编译任务。\n\n\n# 14. 总结\n\n * 一般来讲，jit编译出来的机器码性能比解释器搞\n * c2编译器启动时长比c1慢，系统稳定执行以后，c2编译器执行速度远快于c1编译器\n\n\n# 15. aot编译器\n\njdk9引入了aot编译器（静态提前编译器，ahead of time compiler）\n\njava 9引入了实验性aot编译工具aotc。它借助了graal编译器，将所输入的java类文件转换为机器码，并存放至生成的动态共享库之中。\n\n所谓aot编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而aot编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。\n\n.java -> .class -> (使用jaotc) -> .so\n\n\n1\n\n\n最大的好处：java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少java应用给人带来“第一次运行慢” 的不良体验\n\n缺点：\n\n * 破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，os编译对应的发行包\n * 降低了java链接过程的动态性，加载的代码在编译器就必须全部已知。\n * 还需要继续优化中，最初只支持linux x64 java base\n\n\n# 写到最后\n\n * 自jdk10起，hotspot又加入了一个全新的及时编译器：graal编译器\n * 编译效果短短几年时间就追评了g2编译器，未来可期\n * 目前，带着实验状态标签，需要使用开关参数去激活才能使用\n\n-xx:+unlockexperimentalvmoptions -xx:+usejvmcicompiler\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Java8新特性",frontmatter:{title:"Java8新特性",date:"2023-02-26T16:00:07.000Z",permalink:"/pages/e31263/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/01.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/20.Java8%E6%96%B0%E7%89%B9%E6%80%A7.html",relativePath:"01.语言/01.JAVA语言/01.语言基础/20.Java8新特性.md",key:"v-eca6f7ba",path:"/pages/e31263/",headers:[{level:2,title:"1.  Lamda表达式 [函数式编程]",slug:"_1-lamda表达式-函数式编程",normalizedTitle:"1.  lamda表达式 [函数式编程]",charIndex:null},{level:3,title:"1.1 lambda表达式入门",slug:"_1-1-lambda表达式入门",normalizedTitle:"1.1 lambda表达式入门",charIndex:326},{level:4,title:"1. 匿名内部类(优化) ---》 lambad",slug:"_1-匿名内部类-优化-》-lambad",normalizedTitle:"1. 匿名内部类(优化) ---》 lambad",charIndex:345},{level:4,title:"2. lambda表达式基本结构",slug:"_2-lambda表达式基本结构",normalizedTitle:"2. lambda表达式基本结构",charIndex:732},{level:3,title:"1.2 lambda使用 list集合(遍历)",slug:"_1-2-lambda使用-list集合-遍历",normalizedTitle:"1.2 lambda使用 list集合(遍历)",charIndex:903},{level:3,title:"1.3 函数式接口  😄",slug:"_1-3-函数式接口",normalizedTitle:"1.3 函数式接口  😄",charIndex:null},{level:4,title:"1. 关于函数式接口:    :smile:",slug:"_1-关于函数式接口",normalizedTitle:"1. 关于函数式接口:    😄",charIndex:null},{level:4,title:"2. 函数式接口使用",slug:"_2-函数式接口使用",normalizedTitle:"2. 函数式接口使用",charIndex:2186},{level:5,title:"1. 入门",slug:"_1-入门",normalizedTitle:"1. 入门",charIndex:2200},{level:5,title:"2. 深入",slug:"_2-深入",normalizedTitle:"2. 深入",charIndex:3605},{level:3,title:"1.4 接口 😄",slug:"_1-4-接口",normalizedTitle:"1.4 接口 😄",charIndex:6504},{level:4,title:"1. 接口与类相似点：",slug:"_1-接口与类相似点",normalizedTitle:"1. 接口与类相似点：",charIndex:6809},{level:4,title:"2. 接口与类的区别：",slug:"_2-接口与类的区别",normalizedTitle:"2. 接口与类的区别：",charIndex:6936},{level:4,title:"3. 接口特性",slug:"_3-接口特性",normalizedTitle:"3. 接口特性",charIndex:7071},{level:4,title:"4. 抽象类和接口的区别",slug:"_4-抽象类和接口的区别",normalizedTitle:"4. 抽象类和接口的区别",charIndex:7292},{level:4,title:"5.  接口为什么引入静态方法?",slug:"_5-接口为什么引入静态方法",normalizedTitle:"5.  接口为什么引入静态方法?",charIndex:null},{level:2,title:"2. Funcation接口",slug:"_2-funcation接口",normalizedTitle:"2. funcation接口",charIndex:7610},{level:3,title:"2.1 Funcation ==apply (compose    andThen) identity==",slug:"_2-1-funcation-apply-compose-andthen-identity",normalizedTitle:"2.1 funcation ==apply (compose    andthen) identity==",charIndex:null},{level:4,title:"1. 接口",slug:"_1-接口",normalizedTitle:"1. 接口",charIndex:6809},{level:4,title:"2. 入门案例",slug:"_2-入门案例",normalizedTitle:"2. 入门案例",charIndex:10484},{level:4,title:"3. 深入 compose与andThen",slug:"_3-深入-compose与andthen",normalizedTitle:"3. 深入 compose与andthen",charIndex:12010},{level:3,title:"2.2 BiFunction ==apply andThen==",slug:"_2-2-bifunction-apply-andthen",normalizedTitle:"2.2 bifunction ==apply andthen==",charIndex:13747},{level:4,title:"1. 接口",slug:"_1-接口-2",normalizedTitle:"1. 接口",charIndex:6809},{level:4,title:"2. 用法示例",slug:"_2-用法示例",normalizedTitle:"2. 用法示例",charIndex:14194},{level:4,title:"3. 深入使用",slug:"_3-深入使用",normalizedTitle:"3. 深入使用",charIndex:17244},{level:3,title:"2.3 Predicate接口 ==test (and or negate) isEqual==",slug:"_2-3-predicate接口-test-and-or-negate-isequal",normalizedTitle:"2.3 predicate接口 ==test (and or negate) isequal==",charIndex:20559},{level:4,title:"1. 接口",slug:"_1-接口-3",normalizedTitle:"1. 接口",charIndex:6809},{level:4,title:"2. 入门案例",slug:"_2-入门案例-2",normalizedTitle:"2. 入门案例",charIndex:10484},{level:4,title:"3. 深入",slug:"_3-深入",normalizedTitle:"3. 深入",charIndex:12010},{level:3,title:"2.4 Supplier接口 ==get==",slug:"_2-4-supplier接口-get",normalizedTitle:"2.4 supplier接口 ==get==",charIndex:26164},{level:4,title:"1. 接口",slug:"_1-接口-4",normalizedTitle:"1. 接口",charIndex:6809},{level:4,title:"2. 入门",slug:"_2-入门",normalizedTitle:"2. 入门",charIndex:10484},{level:4,title:"3.深入",slug:"_3-深入-2",normalizedTitle:"3.深入",charIndex:26875},{level:3,title:"2.5  BinaryOperator接口 ==继承BiFunction==",slug:"_2-5-binaryoperator接口-继承bifunction",normalizedTitle:"2.5  binaryoperator接口 ==继承bifunction==",charIndex:null},{level:2,title:"3. Optional 函数式编程风格",slug:"_3-optional-函数式编程风格",normalizedTitle:"3. optional 函数式编程风格",charIndex:30839},{level:3,title:"3.1 源码",slug:"_3-1-源码",normalizedTitle:"3.1 源码",charIndex:30901},{level:3,title:"3.2 入门",slug:"_3-2-入门",normalizedTitle:"3.2 入门",charIndex:41476},{level:3,title:"3.3 深入",slug:"_3-3-深入",normalizedTitle:"3.3 深入",charIndex:42792},{level:4,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:14199},{level:2,title:"4. 方法引用[method reference]  ::",slug:"_4-方法引用-method-reference",normalizedTitle:"4. 方法引用[method reference]  ::",charIndex:null},{level:3,title:"4.1 概述",slug:"_4-1-概述",normalizedTitle:"4.1 概述",charIndex:46054},{level:3,title:"4.2 入门",slug:"_4-2-入门",normalizedTitle:"4.2 入门",charIndex:46278},{level:3,title:"4.3 方法引用的分类",slug:"_4-3-方法引用的分类",normalizedTitle:"4.3 方法引用的分类",charIndex:47053},{level:4,title:"1. 类名::静态方法名  ==[静态方法在实体类里面]==",slug:"_1-类名-静态方法名-静态方法在实体类里面",normalizedTitle:"1. 类名::静态方法名  ==[静态方法在实体类里面]==",charIndex:null},{level:4,title:"2. 引用名(对象名)::实例方法名",slug:"_2-引用名-对象名-实例方法名",normalizedTitle:"2. 引用名(对象名)::实例方法名",charIndex:49801},{level:4,title:"3. 类名::实例方法名",slug:"_3-类名-实例方法名",normalizedTitle:"3. 类名::实例方法名",charIndex:51994},{level:4,title:"4.  构造方法引用: ==类名::new==",slug:"_4-构造方法引用-类名-new",normalizedTitle:"4.  构造方法引用: ==类名::new==",charIndex:null},{level:3,title:"4. 案例",slug:"_4-案例",normalizedTitle:"4. 案例",charIndex:56104},{level:2,title:"5. Stream API",slug:"_5-stream-api",normalizedTitle:"5. stream api",charIndex:56130},{level:3,title:"5.1 Stream简介",slug:"_5-1-stream简介",normalizedTitle:"5.1 stream简介",charIndex:56148},{level:4,title:"1. 什么是流",slug:"_1-什么是流",normalizedTitle:"1. 什么是流",charIndex:56164},{level:4,title:"2. 流的操作种类",slug:"_2-流的操作种类",normalizedTitle:"2. 流的操作种类",charIndex:56618},{level:3,title:"5.2 Stream 创建流",slug:"_5-2-stream-创建流",normalizedTitle:"5.2 stream 创建流",charIndex:56891},{level:3,title:"5.3 Stream 中间操作",slug:"_5-3-stream-中间操作",normalizedTitle:"5.3 stream 中间操作",charIndex:58575},{level:4,title:"1. 筛选与切片",slug:"_1-筛选与切片",normalizedTitle:"1. 筛选与切片",charIndex:58594},{level:4,title:"2. 映射",slug:"_2-映射",normalizedTitle:"2. 映射",charIndex:60301},{level:4,title:"3. 排序",slug:"_3-排序",normalizedTitle:"3. 排序",charIndex:61906},{level:3,title:"5.4 Stream 终止操作",slug:"_5-4-stream-终止操作",normalizedTitle:"5.4 stream 终止操作",charIndex:62591},{level:4,title:"1 查找与匹配",slug:"_1-查找与匹配",normalizedTitle:"1 查找与匹配",charIndex:62610},{level:4,title:"2.  规约",slug:"_2-规约",normalizedTitle:"2.  规约",charIndex:null},{level:4,title:"3. 收集",slug:"_3-收集",normalizedTitle:"3. 收集",charIndex:66149},{level:2,title:"6. 日期API",slug:"_6-日期api",normalizedTitle:"6. 日期api",charIndex:70470},{level:3,title:"6.1 新旧版本API差别",slug:"_6-1-新旧版本api差别",normalizedTitle:"6.1 新旧版本api差别",charIndex:70503},{level:4,title:"1. 新版本计算准确(毫秒),旧版本有误差",slug:"_1-新版本计算准确-毫秒-旧版本有误差",normalizedTitle:"1. 新版本计算准确(毫秒),旧版本有误差",charIndex:70520},{level:4,title:"2. 老版本存在 线程不安全问题",slug:"_2-老版本存在-线程不安全问题",normalizedTitle:"2. 老版本存在 线程不安全问题",charIndex:71535},{level:4,title:"3. 开发规范",slug:"_3-开发规范",normalizedTitle:"3. 开发规范",charIndex:73077},{level:3,title:"6.2 Date-Time API基本类",slug:"_6-2-date-time-api基本类",normalizedTitle:"6.2 date-time api基本类",charIndex:73575},{level:4,title:"1. 常用类",slug:"_1-常用类",normalizedTitle:"1. 常用类",charIndex:73599},{level:4,title:"2. now 方法在日期/时间类中的使用",slug:"_2-now-方法在日期-时间类中的使用",normalizedTitle:"2. now 方法在日期/时间类中的使用",charIndex:74090},{level:4,title:"3. of方法在日期/时间类中的应用",slug:"_3-of方法在日期-时间类中的应用",normalizedTitle:"3. of方法在日期/时间类中的应用",charIndex:76145},{level:4,title:"4. LocalDateTime 时区信息",slug:"_4-localdatetime-时区信息",normalizedTitle:"4. localdatetime 时区信息",charIndex:78252},{level:4,title:"5. Month枚举类的使用",slug:"_5-month枚举类的使用",normalizedTitle:"5. month枚举类的使用",charIndex:79615},{level:4,title:"6. 测试",slug:"_6-测试",normalizedTitle:"6. 测试",charIndex:80208},{level:3,title:"6.3 根据现有实例创建日期与时间对象",slug:"_6-3-根据现有实例创建日期与时间对象",normalizedTitle:"6.3 根据现有实例创建日期与时间对象",charIndex:81606},{level:4,title:"1. plus在 LocalDate,LocalTime 中的使用",slug:"_1-plus在-localdate-localtime-中的使用",normalizedTitle:"1. plus在 localdate,localtime 中的使用",charIndex:81728},{level:4,title:"2.  minus方法在 LocalDate,LocalTime中的使用",slug:"_2-minus方法在-localdate-localtime中的使用",normalizedTitle:"2.  minus方法在 localdate,localtime中的使用",charIndex:null},{level:4,title:"3. plus/minus单独使用",slug:"_3-plus-minus单独使用",normalizedTitle:"3. plus/minus单独使用",charIndex:87339},{level:4,title:"4. with方法",slug:"_4-with方法",normalizedTitle:"4. with方法",charIndex:89967},{level:4,title:"5. 测试",slug:"_5-测试",normalizedTitle:"5. 测试",charIndex:92161},{level:3,title:"6.4 调节器TemporalAdjuster与查询TemporalQuery",slug:"_6-4-调节器temporaladjuster与查询temporalquery",normalizedTitle:"6.4 调节器temporaladjuster与查询temporalquery",charIndex:94550},{level:4,title:"1. 调节器TemporalAdjuster",slug:"_1-调节器temporaladjuster",normalizedTitle:"1. 调节器temporaladjuster",charIndex:94593},{level:4,title:"2. DayOfWeek的使用",slug:"_2-dayofweek的使用",normalizedTitle:"2. dayofweek的使用",charIndex:97200},{level:4,title:"3. 自定义TemporalAdjuster调节器",slug:"_3-自定义temporaladjuster调节器",normalizedTitle:"3. 自定义temporaladjuster调节器",charIndex:97943},{level:4,title:"4. TemporalQuery的应用",slug:"_4-temporalquery的应用",normalizedTitle:"4. temporalquery的应用",charIndex:99998},{level:4,title:"5. 测试",slug:"_5-测试-2",normalizedTitle:"5. 测试",charIndex:92161},{level:3,title:"6.5 Date和LocalDate转换",slug:"_6-5-date和localdate转换",normalizedTitle:"6.5 date和localdate转换",charIndex:103841},{level:4,title:"1. java.util.Date类的转换",slug:"_1-java-util-date类的转换",normalizedTitle:"1. java.util.date类的转换",charIndex:103992},{level:4,title:"2. java.sql.Date类的转换",slug:"_2-java-sql-date类的转换",normalizedTitle:"2. java.sql.date类的转换",charIndex:105816},{level:4,title:"3.  java.sql.Timestamp类的转换",slug:"_3-java-sql-timestamp类的转换",normalizedTitle:"3.  java.sql.timestamp类的转换",charIndex:null},{level:4,title:"4. java.util.Calendar类的转换",slug:"_4-java-util-calendar类的转换",normalizedTitle:"4. java.util.calendar类的转换",charIndex:106973},{level:4,title:"5. 日期的解析与格式化DateTimeFormatter",slug:"_5-日期的解析与格式化datetimeformatter",normalizedTitle:"5. 日期的解析与格式化datetimeformatter",charIndex:110478}],headersStr:"1.  Lamda表达式 [函数式编程] 1.1 lambda表达式入门 1. 匿名内部类(优化) ---》 lambad 2. lambda表达式基本结构 1.2 lambda使用 list集合(遍历) 1.3 函数式接口  😄 1. 关于函数式接口:    :smile: 2. 函数式接口使用 1. 入门 2. 深入 1.4 接口 😄 1. 接口与类相似点： 2. 接口与类的区别： 3. 接口特性 4. 抽象类和接口的区别 5.  接口为什么引入静态方法? 2. Funcation接口 2.1 Funcation ==apply (compose    andThen) identity== 1. 接口 2. 入门案例 3. 深入 compose与andThen 2.2 BiFunction ==apply andThen== 1. 接口 2. 用法示例 3. 深入使用 2.3 Predicate接口 ==test (and or negate) isEqual== 1. 接口 2. 入门案例 3. 深入 2.4 Supplier接口 ==get== 1. 接口 2. 入门 3.深入 2.5  BinaryOperator接口 ==继承BiFunction== 3. Optional 函数式编程风格 3.1 源码 3.2 入门 3.3 深入 示例 4. 方法引用[method reference]  :: 4.1 概述 4.2 入门 4.3 方法引用的分类 1. 类名::静态方法名  ==[静态方法在实体类里面]== 2. 引用名(对象名)::实例方法名 3. 类名::实例方法名 4.  构造方法引用: ==类名::new== 4. 案例 5. Stream API 5.1 Stream简介 1. 什么是流 2. 流的操作种类 5.2 Stream 创建流 5.3 Stream 中间操作 1. 筛选与切片 2. 映射 3. 排序 5.4 Stream 终止操作 1 查找与匹配 2.  规约 3. 收集 6. 日期API 6.1 新旧版本API差别 1. 新版本计算准确(毫秒),旧版本有误差 2. 老版本存在 线程不安全问题 3. 开发规范 6.2 Date-Time API基本类 1. 常用类 2. now 方法在日期/时间类中的使用 3. of方法在日期/时间类中的应用 4. LocalDateTime 时区信息 5. Month枚举类的使用 6. 测试 6.3 根据现有实例创建日期与时间对象 1. plus在 LocalDate,LocalTime 中的使用 2.  minus方法在 LocalDate,LocalTime中的使用 3. plus/minus单独使用 4. with方法 5. 测试 6.4 调节器TemporalAdjuster与查询TemporalQuery 1. 调节器TemporalAdjuster 2. DayOfWeek的使用 3. 自定义TemporalAdjuster调节器 4. TemporalQuery的应用 5. 测试 6.5 Date和LocalDate转换 1. java.util.Date类的转换 2. java.sql.Date类的转换 3.  java.sql.Timestamp类的转换 4. java.util.Calendar类的转换 5. 日期的解析与格式化DateTimeFormatter",content:'# Java8新特性\n\n\n# 1. Lamda表达式 [函数式编程]\n\nLambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。\n\njava中,我们无法将函数作为参数传递给一个方法,也无法声明一个函数的方法.\n\nlambda作用\n\nlambda : lambda表达式的"类型是函数",但在java中.lambda表达式是"对象",但他们必须依附于一类特别多对象类型---"函数式接口\n\n\n1\n\n * 传递行为,而不是值\n   * 提升抽象层次\n   * API重用性更好\n   * 更加灵活\n\nlambda概要\n\n * Java Lambda 表达式是一种匿名函数; 它是没有声明的方法, 即没有访问修饰符.返回值声明和名字\n\n\n# 1.1 lambda表达式入门\n\n# 1. 匿名内部类(优化) ---》 lambad\n\n// 匿名内部类 \njButton.addActionListener(new ActionListener() {\n       @Override\n       public void actionPerformed(ActionEvent e) {\n       System.out.println("Button Pressed");\n       }\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// lambda 表达式\n  jButton.addActionListener(event -> {\n      System.out.println("Button Pressed");\n      System.out.println("Button");\n  });\n\n\n1\n2\n3\n4\n5\n\n\n# 2. lambda表达式基本结构\n\n语法:\n\n (argument) -> {body}\n \n (atg1,arg2...) -> {body}\n (type1 arg1,type2 arg2...) -> {body}\n\n\n1\n2\n3\n4\n\n\n(param1.param2,param3) -> {\n\n}\n\n\n1\n2\n3\n\n\n结构\n\n\n# 1.2 lambda使用 list集合(遍历)\n\n   List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);\n        // 遍历方式一\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(list.get(i));\n        }\n        System.out.println("---------");\n        // 遍历方式二 1.5之后\n        for (Integer i : list) {\n            System.out.println(i);\n        }\n        System.out.println("---------");\n        // 遍历方式三 1.8 匿名内部类\n        list.forEach(new Consumer<Integer>() {\n            @Override\n            public void accept(Integer integer) {\n                System.out.println(integer);\n            }\n        });\n\t\t// lambda 表达式\n        list.forEach(l -> System.out.println(l));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nlambda 以及 方法引用\n\n \t\t// lambda 表达式\n        // list.forEach(l -> System.out.println(l));\n\t\t// 方法引用 优化\n        list.forEach(System.out::println);\n\n\n1\n2\n3\n4\n\n\n\n# 1.3 函数式接口 😄\n\n# 1. 关于函数式接口: 😄\n\n@FunctionalInterface\npublic interface MyInterface {\n    /**\n     * 抽象方法\n     */\n    void test();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 注意: 重载的方法,可以与共存 如: toString()\n\n1. 如果一个接口只有一个(抽象方法),那么该接口就是一个"函数式接口".\n2. 如果我们在某个接口上声明了FunctionalInterface(@FunctionalInterface注解),那么编译器就会按照"函数式接口"的定义来要求该接口.\n3. 如果某个接口只有一个(抽象方法),但我们并没有给该接口声明@FunctionalInterface注解,那么编译器依旧会将该接口看做"函数式接口".\n\n\n1\n2\n3\n\n\n# 2. 函数式接口使用\n\n# 1. 入门\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 0:08\n * @Description: <h1> 函数式接口 </h1>\n * 1. 当接口只有一个抽象方法时: 为函数式接口\n * 2. 多个抽象方法时: 不为函数式接口\n * 3. 重载的方法,可以与共存 toString()\n */\n@FunctionalInterface\ninterface MyInterface {\n    /**\n     * 抽象方法: 交给子类实现\n     */\n    void test();\n\n    /**\n     * 方法: 继承自Object类(顶级类), 本类实现\n     * @return\n     */\n    @Override\n    String toString();\n}\n\n/**\n * @author CHGGX\n * 函数式接口测试\n */\npublic class FunctionalInterfaceTest {\n\n    public void myTest(MyInterface myInterface) {\n        System.out.println(1);\n        myInterface.test();\n        System.out.println(2);\n    }\n\n    public static void main(String[] args) {\n        FunctionalInterfaceTest test = new FunctionalInterfaceTest();\n        // 匿名内部类\n        test.myTest(new MyInterface() {\n            @Override\n            public void test() {\n                System.out.println("myTest");\n            }\n        });\n        System.out.println("----------");\n            // lambda表达式\n            test.myTest(() -> {\n                System.out.println("myTest");\n            });\n        System.out.println(MyInterface.class);\n        System.out.println(MyInterface.class.getSuperclass());\n        System.out.println(MyInterface.class.getInterfaces()[0]);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n# 2. 深入\n\npackage com.chggx.jdk8.inter;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 1:27\n * @Description: <h1> 函数式接口测试 </h1>\n * 1. lambda表达式\n * 2. stream流\n * 3. 方法引用\n */\npublic class FunctionalInterfaceTest2 {\n\n    public static void main(String[] args) {\n        // 1. lambda表达式的类型根据 "上下文" 断定\n        TheInterface t1 = () -> {\n        };\n        System.out.println(t1.getClass().getInterfaces()[0]);\n\n        TheInterface2 t2 = () -> {\n        };\n        System.out.println(t2.getClass().getInterfaces()[0]);\n\n        // 2. 线程接口  Runnable: @FunctionalInterface 函数式接口\n        // 线程Thread 使用线程接口 Runnable(lambda) 由于是函数是接口,可以直接使用lambda\n        new Thread(() -> System.out.println("hello word!")).start();\n\n        // 3. 将集合中的每个元素变为"大写"\n        List<String> list = Arrays.asList("hello", "word", "hello word");\n        // 使用JAVA8 consumer 函数式接口\n        // toUpperCase() 方法将字符串小写字符转换为大写。\n        list.forEach(item -> System.out.println(item.toUpperCase()));\n\n        System.out.println("-------------------");\n\n        // 3.1 将值存入一个新的集合\n        // diamond  new ArrayList<String>(): String类型省略 1.6 后支持\n        List<String> targetList = new ArrayList<String>();\n        // 3.1.1 先遍历集合1,放入目标集合\n        list.forEach(item -> targetList.add(item.toUpperCase()));\n        // 3.1.2 遍历目标集合 System.out.println(target) ---\x3e  方法引用 System.out::println\n        targetList.forEach(System.out::println);\n\n\n        // 3.2 优化 3.1 步骤\n        // stream流 的方式\n        // lambda形式\n        System.out.println("------lambda形式------");\n        list.stream()\n                // 方法将字符串小写字符转换为大写。\n                .map(item -> item.toUpperCase())\n                .forEach(item -> System.out.println(item));\n        System.out.println("------方法引用------");\n        // 方法引用形式\n        list.stream()\n                // 方法将字符串小写字符转换为大写。\n                // item -> item.toUpperCase() ----\x3e String::toUpperCase(方法引用)\n                .map(String::toUpperCase)\n                // item -> System.out.println(item) --\x3e System.out::println\n                .forEach(System.out::println);\n\n\n    }\n\n}\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 0:08\n * @Description: <h1> 函数式接口 </h1>\n * 1. 当接口只有一个抽象方法时: 为函数式接口\n * 2. 多个抽象方法时: 不为函数式接口\n */\n@FunctionalInterface\ninterface TheInterface {\n    /**\n     * 抽象方法: 交给子类实现\n     */\n    void method();\n}\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 0:08\n * @Description: <h1> 函数式接口 </h1>\n * 1. 当接口只有一个抽象方法时: 为函数式接口\n * 2. 多个抽象方法时: 不为函数式接口\n */\n@FunctionalInterface\ninterface TheInterface2 {\n    /**\n     * 抽象方法: 交给子类实现\n     */\n    void method2();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n\n# 1.4 接口 😄\n\n接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n# 1. 接口与类相似点：\n\n * 一个接口可以有多个方法。\n * 接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n * 接口的字节码文件保存在 .class 结尾的文件中。\n * 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n# 2. 接口与类的区别：\n\n * 接口不能用于实例化对象。\n * 接口没有构造方法。\n * 接口中所有的方法必须是抽象方法。\n * 接口不能包含成员变量，除了 static 和 final 变量。\n * 接口不是被类继承了，而是要被类实现。\n * 接口支持多继承。\n\n# 3. 接口特性\n\n * 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。\n * 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。\n * 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n# 4. 抽象类和接口的区别\n\n * 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n * 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。\n * 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n * 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n> 注：JDK 1.8 以后，接口里可以有静态方法和方法体了。\n\n# 5. 接口为什么引入静态方法?\n\n * 向后兼容 [Sort]\n\n----------------------------------------\n\n\n# 2. Funcation接口\n\n序号   接口 & 描述\n1    **BiConsumer(T,U)**代表了一个接受两个输入参数的操作，并且不返回任何结果\n2    **BiFunction(T,U,R)**代表了一个接受两个输入参数的方法，并且返回一个结果 ,继承\n3    **BinaryOperator(T)**代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果,BiFunction\n4    **BiPredicate(T,U)**代表了一个两个参数的boolean值方法\n5    BooleanSupplier代表了boolean值结果的提供方\n6    **Consumer(T)**代表了接受一个输入参数并且无返回的操作\n7    DoubleBinaryOperator代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。\n8    DoubleConsumer代表一个接受double值参数的操作，并且不返回结果。\n9    **DoubleFunction(R>**代表接受一个double值参数的方法，并且返回结果\n10   DoublePredicate代表一个拥有double值参数的boolean值方法\n11   DoubleSupplier代表一个double值结构的提供方\n12   DoubleToIntFunction接受一个double类型输入，返回一个int类型结果。\n13   DoubleToLongFunction接受一个double类型输入，返回一个long类型结果\n14   DoubleUnaryOperator接受一个参数同为类型double,返回值类型也为double 。\n15   **Function(T,R)**接受一个输入参数，返回一个结果。\n16   IntBinaryOperator接受两个参数同为类型int,返回值类型也为int 。\n17   IntConsumer接受一个int类型的输入参数，无返回值 。\n18   **IntFunction(R)**接受一个int类型输入参数，返回一个结果 。\n19   IntPredicate：接受一个int输入参数，返回一个布尔值的结果。\n20   IntSupplier无参数，返回一个int类型结果。\n21   IntToDoubleFunction接受一个int类型输入，返回一个double类型结果 。\n22   IntToLongFunction接受一个int类型输入，返回一个long类型结果。\n23   IntUnaryOperator接受一个参数同为类型int,返回值类型也为int 。\n24   LongBinaryOperator接受两个参数同为类型long,返回值类型也为long。\n25   LongConsumer接受一个long类型的输入参数，无返回值。\n26   **LongFunction(R)**接受一个long类型输入参数，返回一个结果。\n27   LongPredicateR接受一个long输入参数，返回一个布尔值类型结果。\n28   LongSupplier无参数，返回一个结果long类型的值。\n29   LongToDoubleFunction接受一个long类型输入，返回一个double类型结果。\n30   LongToIntFunction接受一个long类型输入，返回一个int类型结果。\n31   LongUnaryOperator接受一个参数同为类型long,返回值类型也为long。\n32   **ObjDoubleConsumer(T)**接受一个object类型和一个double类型的输入参数，无返回值。\n33   **ObjIntConsumer(T)**接受一个object类型和一个int类型的输入参数，无返回值。\n34   **ObjLongConsumer(T)**接受一个object类型和一个long类型的输入参数，无返回值。\n35   **Predicate(T)**接受一个输入参数，返回一个布尔值结果。\n36   **Supplier(T)**无参数，返回一个结果。\n37   **ToDoubleBiFunction(T,U)**接受两个输入参数，返回一个double类型结果\n38   **ToDoubleFunction(T)**接受一个输入参数，返回一个double类型结果\n39   **ToIntBiFunction(T,U)**接受两个输入参数，返回一个int类型结果。\n40   **ToIntFunction(T)**接受一个输入参数，返回一个int类型结果。\n41   **ToLongBiFunction(T,U)**接受两个输入参数，返回一个long类型结果。\n42   **ToLongFunction(T)**接受一个输入参数，返回一个long类型结果。\n43   **UnaryOperator(T)**接受一个参数为类型T,返回值类型也为T。\n\n注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 List(T) 指的是 List<T>. \n\n\n1\n\n\n\n# 2.1 Funcation ==apply (compose andThen) identity==\n\n接收一个参数,返回结果\n\nlambda 行为\n\n# 1. 接口\n\n@FunctionalInterface\npublic interface Function<T, R> {\n\n    R apply(T t);\n\t\n    // before\n    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {\n        Objects.requireNonNull(before);\n        return (V v) -> apply(before.apply(v));\n    }\n    \n\t// after\n    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {\n        Objects.requireNonNull(after);\n        return (T t) -> after.apply(apply(t));\n    }\n\n    static <T> Function<T, T> identity() {\n        return t -> t;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 2. 入门案例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 11:48\n * @Description: <h1> lambda传递的是"行为" </h1>\n */\npublic class FunctionTest {\n\n    public static void main(String[] args) {\n        FunctionTest test = new FunctionTest();\n        //// 普通的加减乘除[方法写死]\n        System.out.println(test.method1(1));\n        System.out.println(test.method2(2));\n        System.out.println(test.method3(3));\n\n        // lambda 行为 function[灵活]\n        // statement (return ....)\n        System.out.println(test.compute(\n                1, value -> {\n                    return 2 * value; \n                }\n        ));\n        // 改进  expression .... (无花括号)\n        System.out.println(test.compute(\n                2, value -> 5 + value\n        ));\n        System.out.println(test.compute(\n                3, value -> value * value\n        ));\n\n\t\t // 不同类型的数据运算\n        System.out.println(test.convert(\n                5, value -> String.valueOf(value + " hello word")\n        ));\n    }\n\n    public int compute(int a, Function<Integer, Integer> function) {\n        return function.apply(a);\n    }\n\n    public String convert(int a, Function<Integer, String> function) {\n        return function.apply(a);\n    }\n\n    public int method1(int a) {\n        return 2 * a;\n    }\n    public int method2(int a) {\n        return 5 + a;\n    }\n    public int method3(int a) {\n        return a * a;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 3. 深入 compose与andThen\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 12:27\n * @Description: <h1> Function使用 </h1>\n * 1. compose 先执行2在执行1 (先计算输入参数[2]的apply,把[2]的结果作为[1]的输入参数计算)\n * 2. andThen 先执行1在执行2\n */\npublic class FunctionTest2 {\n\n    public static void main(String[] args) {\n\n        FunctionTest2 test2 = new FunctionTest2();\n        System.out.println(\n                // 1.function1:  value * 3  2. function2: value * value\n                // compose: 先执行 function2 2 * 2 = 4\n                // 再执行 function1 4 * 3 = 12\n                test2.compute(2, value -> value * 3, value -> value * value)\n        );\n        System.out.println(\n                // andThen: 先执行 function1,后执行 function2\n                // 2 * 3 = 6 ---\x3e 6 * 6 = 36\n                test2.compute2(2, value -> value * 3, value -> value * value)\n        );\n\n    }\n\n\n   /**\n     *  default <V> Function<V, R> compose(Function<? super V, ? extends T> before)\n     * compose 先执行function2在执行function1 (先计算输入参数[2]的apply,把[2]的结果作为[1]的输入参数计算)\n     */\n    public int compute(int a, Function<Integer, Integer> function1,\n                       Function<Integer, Integer> function2) {\n        // compose  function2\n        return function1.compose(function2).apply(a);\n    }\n\n    /**\n     * default <V> Function<T, V> andThen(Function<? super R, ? extends V> after)\n     * andThen: 先执行 function1,后执行 function2\n     */\n    public int compute2(int a, Function<Integer, Integer> function1,\n                        Function<Integer, Integer> function2) {\n        // andThen\n        return function1.andThen(function2).apply(a);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 2.2 BiFunction ==apply andThen==\n\n接收两个参数,返回一个结果\n\n * 没有compose: 由于BiFunction(接收两个参数,返回一个结果) 先执行后面方法时,返回的结果只有一个,不能作为BiFunction的参数[不成立]\n\n# 1. 接口\n\n@FunctionalInterface\npublic interface BiFunction<T, U, R> {\n\n    R apply(T t, U u);\n\n    default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after) {\n        Objects.requireNonNull(after);\n        return (T t, U u) -> after.apply(apply(t, u));\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 2. 用法示例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 12:49\n * @Description: <h1> BiFunction </h1>\n * 接收两个参数,返回一个结果\n *  没有compose: 由于BiFunction(接收两个参数,返回一个结果) 先执行后面方法时,返回的结果只有一个,不能作为BiFunction的参数[不成立]\n */\npublic class BiFunctionTest {\n\n    public static void main(String[] args) {\n\n        BiFunctionTest test = new BiFunctionTest();\n        // 1.\n        System.out.println(\n                // 和\n//                test.compute(1, 2, (value1, value2) -> value1 + value2)\n                test.compute(1, 2, Integer::sum)\n        );\n        System.out.println(\n                // 差\n//                test.compute(1, 2, (value1, value2) -> value1 - value2)\n                test.compute(1, 2, (value1, value2) -> value1 - value2)\n        );\n        System.out.println(\n                // 乘\n                test.compute(1, 2, (value1, value2) -> value1 * value2)\n        );\n        System.out.println(\n                // 除\n                test.compute(1, 2, (value1, value2) -> value1 / value2)\n        );\n\n        // 2.\n        System.out.println(\n                // 和\n//                test.compute(2, 3, (value1, value2) -> value1 + value2,, value -> value * value)\n                // andThen: 先执行biFunction,在执行function 2+3=5 5*5=25\n                test.compute2(2, 3, Integer::sum, value -> value * value)\n        );\n        System.out.println(\n                // 差\n                // andThen: 先执行biFunction,在执行function 2-3=-1 -1*-1=1\n                test.compute2( 2, 3,(value1, value2) -> value1 - value2,value -> value * value)\n        );\n        System.out.println(\n                // 乘\n                // andThen: 先执行biFunction,在执行function 2*3=6 6*6=36\n                test.compute2(2,3, (value1, value2) -> value1 * value2,value -> value * value)\n        );\n        System.out.println(\n                // 除\n                // andThen: 先执行biFunction,在执行function 2/3=2/3 (2/3)*(2/3)\n                test.compute2( 2,3, (value1, value2) -> value1 / value2,value -> value * value)\n        );\n\n    }\n\n    /**\n     * BiFunction  接收两个参数,返回一个结果\n     *\n     * @param a          参数一\n     * @param b          参数二\n     * @param biFunction 函数\n     * @return 结果\n     */\n    public int compute(int a, int b, BiFunction<Integer, Integer, Integer> biFunction) {\n        return biFunction.apply(a, b);\n    }\n\n     /**\n     * default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after)\n     * andThen:  先执行biFunction,在执行function [接收两个参数,返回一个结果]\n     */\n    public int compute2(int a, int b, BiFunction<Integer, Integer, Integer> biFunction, Function<Integer, Integer> function) {\n\n        return biFunction.andThen(function).apply(a, b);\n    }\n\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public int subtract(int a, int b) {\n        return a - b;\n    }\n\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n# 3. 深入使用\n\nperson 实体类 第三种用法 BiFunction\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 16:46\n * @Description: <h1> BiFunction: 接收两个参数,返回一个结果 </h1>\n */\npublic class PersonTest {\n\n    public static void main(String[] args) {\n\n        Person person1 = new Person("zhangsan", 20);\n        Person person2 = new Person("lisi", 30);\n        Person person3 = new Person("wangwu", 40);\n\t\t// 将对象封装为集合\n        List<Person> personList = Arrays.asList(person1, person2, person3);\n\n        PersonTest test = new PersonTest();\n        // 1. 根据名称获取[必须规定name]getPersonByUsername\n        List<Person> personResult = test.getPersonByUsername("zhangsan", personList);\n        personResult.forEach(person -> System.out.println(person.getUsername()));\n\n        System.out.println("--------------");\n\n        // 2. 选出大于指定年龄的[必须规定age]getPersonsByAge\n        List<Person> personResult2 = test.getPersonsByAge(20, personList);\n        personResult2.forEach(person -> System.out.println(person.getAge()));\n\n        System.out.println("--------------");\n\n        // 3. 选出大于指定年龄的 [灵活应用]getPersonsByAge2\n        List<Person> personResult3 = test.getPersonsByAge2(\n                // 3个参数: 1.age 2.personList 3. BiFunction: 接收两个参数,返回一个结果\n                20, personList, (age, persons) -> persons.stream()\n                        // 大于指定年龄\n                        .filter(person -> person.getAge() > age)\n                        .collect(Collectors.toList())\n        );\n        personResult3.forEach(person -> System.out.println(person.getAge()));\n\n        System.out.println("--------------");\n\n        // 4. 选出小于等于指定年龄的 [灵活应用]getPersonsByAge2\n        List<Person> personResult4 = test.getPersonsByAge2(\n                20, personList, (age, persons) -> persons.stream()\n                        .filter(person -> person.getAge() <= age)\n                        .collect(Collectors.toList())\n        );\n        personResult4.forEach(person -> System.out.println(person.getAge()));\n\n    }\n\n    public List<Person> getPersonByUsername(String username, List<Person> personList) {\n        // stream 流\n        return personList.stream()\n                .filter(person -> person.getUsername().equals(username))\n                // 转换为 list\n                .collect(Collectors.toList());\n    }\n\n    /** stream流过滤 filter\n     * 年龄大于给定参数(age)\n     */\n    public List<Person> getPersonsByAge(int age, List<Person> personList) {\n        // BiFunction函数: 接收两个参数,返回一个结果\n        // lambda:  [expression lambda]\n        BiFunction<Integer, List<Person>, List<Person>> biFunction =\n                (ageOfPerson, persons) -> persons.stream()\n                        // 选择出 年龄大于给定的参数[age] person.getAge()>age\n                        .filter(person -> person.getAge() > age)\n                        .collect(Collectors.toList());\n        // 应用\n        return biFunction.apply(age, personList);\n    }\n\n    public List<Person> getPersonsByAge2(int age, List<Person> personList,\n                                         BiFunction<Integer, List<Person>, List<Person>> biFunction) {\n        return biFunction.apply(age, personList);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# 2.3 Predicate接口 ==test (and or negate) isEqual==\n\n * 接收参数,返回boolean值\n\n# 1. 接口\n\n**传递行为,**而不是传递值\n\n@FunctionalInterface\npublic interface Predicate<T> {\n\n    boolean test(T t);\n\n    default Predicate<T> and(Predicate<? super T> other) {\n        Objects.requireNonNull(other);\n        return (t) -> test(t) && other.test(t);\n    }\n\n    default Predicate<T> negate() {\n        return (t) -> !test(t);\n    }\n\n    default Predicate<T> or(Predicate<? super T> other) {\n        Objects.requireNonNull(other);\n        return (t) -> test(t) || other.test(t);\n    }\n\n    static <T> Predicate<T> isEqual(Object targetRef) {\n        return (null == targetRef)\n                ? Objects::isNull\n                : object -> targetRef.equals(object);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 2. 入门案例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 21:01\n * @Description: <h1> Predicate函数式接口 </h1>\n */\npublic class PredicateTest {\n\n    public static void main(String[] args) {\n        // 1. Predicate基本用法 boolean test(T t);  filter\n        Predicate<String> predicate = p -> p.length() > 5;\n        // 长度是否大于5  false\n        System.out.println(predicate.test("hello"));\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 3. 深入\n\n/**\n * @Author: CHGGX\n * @Date: 2020/03/29 21:14\n * @Description: <h1> Predicate函数式接口  </h1>\n * 1. test(); 判断给定的为true/false\n * 2. and()\n * 3. negate 否定(与原来相反)\n * 4. or\n */\npublic class PredicateTest2 {\n\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n        PredicateTest2 test2 = new PredicateTest2();\n\n        // 1. 获取当前集合的 偶数: 能被2整除\n        test2.conditionFilter(list, item -> item % 2 == 0);\n        System.out.println("-------------");\n\n        // 2. 获取当前集合的 奇数: 不能被2整除,模1\n        test2.conditionFilter(list, item -> item % 2 != 0);\n        System.out.println("-------------");\n\n        // 3. 集合中所有大于5的\n        test2.conditionFilter(list, item -> item > 5);\n        System.out.println("-------------");\n\n        // 4. 集合中所有小于3的\n        test2.conditionFilter(list, item -> item < 3);\n        System.out.println("-------------");\n\n        // 5. 打印出所有数据\n        test2.conditionFilter(list, item -> true);\n        System.out.println("-------------");\n\n        // 6. 不打印出任何数据\n        test2.conditionFilter(list, item -> false);\n        System.out.println("-------------");\n\n        System.out.println("------ and -------");\n\n        // 7. 添加: 既要大于5, 又要为偶数 6 8 10\n        // 大于5: item -> item > 5  ; 偶数:item -> item % 2 == 0\n        test2.conditionFilter2(list, item -> item > 5, item -> item % 2 == 0);\n\n        System.out.println("------ or -------");\n\n        // 8. or 2 4 6 7 8 9 0\n        // 大于5: item -> item > 5  ; 偶数:item -> item % 2 == 0\n        test2.conditionFilter3(list, item -> item > 5, item -> item % 2 == 0);\n\n\n        System.out.println("------ and -------");\n\n        // 7. negate 1 2 3 4 5 7 9\n        // 大于5: item -> item > 5  ; 偶数:item -> item % 2 == 0\n        test2.conditionFilter4(list, item -> item > 5, item -> item % 2 == 0);\n\n        System.out.println("------ isEqual -------");\n        // 8. 判断2个参数是否相等\n        System.out.println(test2.isEqual("test").test("test"));\n    }\n\n    /** boolean test(T t);\n     * 函数式编程: 将参数处理,由方法体里面处理-----\x3e执行者里处理[处理逻辑有方法里面编写---\x3e时下时编写体现]\n     * <h2> Predicate: 方法 test(); </h2>\n     */\n    public void conditionFilter(List<Integer> list, Predicate<Integer> predicate) {\n        for (Integer integer : list) {\n            // 判断是否为 true\n            if (predicate.test(integer)) {\n                // 是\n                System.out.println(integer);\n            }\n        }\n    }\n\n    /**  default Predicate<T> and(Predicate<? super T> other)\n     * <h2> 与或非:与and </h2>\n     */\n    public void conditionFilter2(List<Integer> list, Predicate<Integer> predicate1, Predicate<Integer> predicate2) {\n        for (Integer integer : list) {\n            // 给定集合,既要满足predicate1,又要满足predicate2\n            if (predicate1.and(predicate2).test(integer)) {\n                System.out.println(integer);\n            }\n        }\n    }\n    /**  default Predicate<T> or(Predicate<? super T> other)\n     * <h2> 与或非: 或or </h2>\n     */\n    public void conditionFilter3(List<Integer> list, Predicate<Integer> predicate1, Predicate<Integer> predicate2) {\n        for (Integer integer : list) {\n            // 给定集合,既要满足predicate1,又要满足predicate2\n            if (predicate1.or(predicate2).test(integer)) {\n                System.out.println(integer);\n            }\n        }\n    }\n\n    /**  default Predicate<T> negate()\n     * <h2> 与或非: 非negate </h2>\n     */\n    public void conditionFilter4(List<Integer> list, Predicate<Integer> predicate1, Predicate<Integer> predicate2) {\n        for (Integer integer : list) {\n            // 给定集合,既要满足predicate1,又要满足predicate2, negate: 取之前的相反结果\n            if (predicate1.and(predicate2).negate().test(integer)) {\n                System.out.println(integer);\n            }\n        }\n    }\n \n    /** static <T> Predicate<T> isEqual(Object targetRef)\n     * <h2> 判断2个参数是否相等 </h2>\n     */\n    public Predicate<String> isEqual(Object o){\n        return Predicate.isEqual(o);\n    }\n    // TODO 原来的面向对象编程,执行逻辑在方法体里面,方法写死.函数式接口,执行者实现.更加灵活\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n\n\n\n# 2.4 Supplier接口 ==get==\n\n * 不接受参数,返回结果\n\n# 1. 接口\n\n@FunctionalInterface\npublic interface Supplier<T> {\n\n    /**\n     * Gets a result.\n     *\n     * @return a result\n     */\n    T get();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2. 入门\n\npackage com.chggx.jdk8.supplier;\n\nimport java.util.function.Supplier;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 13:39\n * @Description: <h1> </h1>\n * supplier: 不接受参数,同时返回一个结果\n */\npublic class SupplierTest {\n\n    /**\n     *  T get();\n     *  supplier: 不接受参数,同时返回一个结果\n     */\n    public static void main(String[] args) {\n        Supplier<String> supplier = () -> "hello word";\n        System.out.println(supplier.get());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 3.深入\n\n * student实体类\n\npackage com.chggx.jdk8.pojo;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 13:46\n * @Description: <h1> </h1>\n */\npublic class Student {\n\n    private String name = "zhangsan";\n\n    private int age = 20;\n\n    // 无参构造重点\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n * 实现\n\npackage com.chggx.jdk8.java.util.function.supplier;\n\nimport com.chggx.jdk8.pojo.Student;\n\nimport java.util.function.Supplier;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 13:39\n * @Description: <h1> supplier应用 </h1>\n * supplier: 不接受参数,同时返回一个结果\n */\npublic class StudentTest {\n\n    /**\n     * T get();\n     * supplier: 不接受参数,同时返回一个结果\n     */\n    public static void main(String[] args) {\n\n        // 1. 以前方式\n        Student student = new Student();\n        String name = student.getName();\n        int age = student.getAge();\n        System.out.println("name: " + name + ", age: " + age);\n\n        System.out.println("===============================");\n\n        // 2. 现在Supplier函数式编程方式\n        // lambda : () -> new Student();\n        Supplier<Student> supplier = () -> new Student();\n        System.out.println("name: " + supplier.get().getName() + ", age: " + supplier.get().getAge());\n\n        System.out.println("===============================");\n\n        // 3. 构造方法引用(无参构造) Student::new\n        Supplier<Student> supplier1 = Student::new;\n        System.out.println("name: " + supplier.get().getName() + ", age: " + supplier.get().getAge());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 2.5 BinaryOperator接口 ==继承BiFunction==\n\npackage com.chggx.jdk8.java.util.function.binaryOperator;\n\nimport java.util.Comparator;\nimport java.util.function.BinaryOperator;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 14:14\n * @Description: <h1> </h1>\n * BinaryOperator: 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果\n *  继承自BiFunction\n */\npublic class BinaryOperatorTest {\n\n    public static void main(String[] args) {\n\n        // 两个整数的运算\n        BinaryOperatorTest binaryOperatorTest = new BinaryOperatorTest();\n        // +\n        System.out.println(binaryOperatorTest.compute(1, 2, Integer::sum));\n        // -\n        System.out.println(binaryOperatorTest.compute(1, 2, (a, b) -> a - b));\n        // *\n        System.out.println(binaryOperatorTest.compute(1, 2, (a, b) -> a * b));\n        // /\n        System.out.println(binaryOperatorTest.compute(1, 2, (a, b) -> a / b));\n\n        // getShort 比较获取小的\n        System.out.println(binaryOperatorTest.getShort("hello", "word", (a, b) ->a.length()-b.length()));\n        System.out.println(binaryOperatorTest.getLong("hello", "word", (a, b) ->a.charAt(0)-b.charAt(0)));\n        // getLong 比较获取大的\n        System.out.println(binaryOperatorTest.getLong("hello", "word", (a, b) ->a.length()-b.length()));\n\n    }\n\n    /**\n     * BinaryOperator\n     * R apply(T t, U u);\n     */\n    public int compute(int a, int b, BinaryOperator<Integer> binaryOperator) {\n        return binaryOperator.apply(a, b);\n    }\n\n    /**\n     * 比较\n     */\n    public String getShort(String a, String b, Comparator<String> comparator) {\n        return BinaryOperator.minBy(comparator).apply(a, b);\n    }\n    public String getLong(String a, String b, Comparator<String> comparator) {\n        return BinaryOperator.maxBy(comparator).apply(a, b);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n----------------------------------------\n\n\n# 3. Optional 函数式编程风格\n\n * 解决 NPE NullPointerException 空指针异常\n\n\n# 3.1 源码\n\n/**\n * Common instance for {@code empty()}.\n */\nprivate static final Optional<?> EMPTY = new Optional<>();\n\n/**\n * If non-null, the value; if null, indicates no value is present\n */\nprivate final T value;\n\n/**\n * Constructs an empty instance.\n *\n * @implNote Generally only one empty instance, {@link Optional#EMPTY},\n * should exist per VM.\n */\nprivate Optional() {\n    this.value = null;\n}\n\n/**\n * Returns an empty {@code Optional} instance.  No value is present for this\n * Optional.\n *\n * @apiNote Though it may be tempting to do so, avoid testing if an object\n * is empty by comparing with {@code ==} against instances returned by\n * {@code Option.empty()}. There is no guarantee that it is a singleton.\n * Instead, use {@link #isPresent()}.\n *\n * @param <T> Type of the non-existent value\n * @return an empty {@code Optional}\n */\npublic static<T> Optional<T> empty() {\n    @SuppressWarnings("unchecked")\n    Optional<T> t = (Optional<T>) EMPTY;\n    return t;\n}\n\n/**\n * Constructs an instance with the value present.\n *\n * @param value the non-null value to be present\n * @throws NullPointerException if value is null\n */\nprivate Optional(T value) {\n    this.value = Objects.requireNonNull(value);\n}\n\n/**\n * Returns an {@code Optional} with the specified present non-null value.\n *\n * @param <T> the class of the value\n * @param value the value to be present, which must be non-null\n * @return an {@code Optional} with the value present\n * @throws NullPointerException if value is null\n */\npublic static <T> Optional<T> of(T value) {\n    return new Optional<>(value);\n}\n\n/**\n * Returns an {@code Optional} describing the specified value, if non-null,\n * otherwise returns an empty {@code Optional}.\n *\n * @param <T> the class of the value\n * @param value the possibly-null value to describe\n * @return an {@code Optional} with a present value if the specified value\n * is non-null, otherwise an empty {@code Optional}\n */\npublic static <T> Optional<T> ofNullable(T value) {\n    return value == null ? empty() : of(value);\n}\n\n/**\n * If a value is present in this {@code Optional}, returns the value,\n * otherwise throws {@code NoSuchElementException}.\n *\n * @return the non-null value held by this {@code Optional}\n * @throws NoSuchElementException if there is no value present\n *\n * @see Optional#isPresent()\n */\npublic T get() {\n    if (value == null) {\n        throw new NoSuchElementException("No value present");\n    }\n    return value;\n}\n\n/**\n * Return {@code true} if there is a value present, otherwise {@code false}.\n *\n * @return {@code true} if there is a value present, otherwise {@code false}\n */\npublic boolean isPresent() {\n    return value != null;\n}\n\n/**\n * If a value is present, invoke the specified consumer with the value,\n * otherwise do nothing.\n *\n * @param consumer block to be executed if a value is present\n * @throws NullPointerException if value is present and {@code consumer} is\n * null\n */\npublic void ifPresent(Consumer<? super T> consumer) {\n    if (value != null)\n        consumer.accept(value);\n}\n\n/**\n * If a value is present, and the value matches the given predicate,\n * return an {@code Optional} describing the value, otherwise return an\n * empty {@code Optional}.\n *\n * @param predicate a predicate to apply to the value, if present\n * @return an {@code Optional} describing the value of this {@code Optional}\n * if a value is present and the value matches the given predicate,\n * otherwise an empty {@code Optional}\n * @throws NullPointerException if the predicate is null\n */\npublic Optional<T> filter(Predicate<? super T> predicate) {\n    Objects.requireNonNull(predicate);\n    if (!isPresent())\n        return this;\n    else\n        return predicate.test(value) ? this : empty();\n}\n\n/**\n * If a value is present, apply the provided mapping function to it,\n * and if the result is non-null, return an {@code Optional} describing the\n * result.  Otherwise return an empty {@code Optional}.\n *\n * @apiNote This method supports post-processing on optional values, without\n * the need to explicitly check for a return status.  For example, the\n * following code traverses a stream of file names, selects one that has\n * not yet been processed, and then opens that file, returning an\n * {@code Optional<FileInputStream>}:\n *\n * <pre>{@code\n *     Optional<FileInputStream> fis =\n *         names.stream().filter(name -> !isProcessedYet(name))\n *                       .findFirst()\n *                       .map(name -> new FileInputStream(name));\n * }</pre>\n *\n * Here, {@code findFirst} returns an {@code Optional<String>}, and then\n * {@code map} returns an {@code Optional<FileInputStream>} for the desired\n * file if one exists.\n *\n * @param <U> The type of the result of the mapping function\n * @param mapper a mapping function to apply to the value, if present\n * @return an {@code Optional} describing the result of applying a mapping\n * function to the value of this {@code Optional}, if a value is present,\n * otherwise an empty {@code Optional}\n * @throws NullPointerException if the mapping function is null\n */\npublic<U> Optional<U> map(Function<? super T, ? extends U> mapper) {\n    Objects.requireNonNull(mapper);\n    if (!isPresent())\n        return empty();\n    else {\n        return Optional.ofNullable(mapper.apply(value));\n    }\n}\n\n/**\n * If a value is present, apply the provided {@code Optional}-bearing\n * mapping function to it, return that result, otherwise return an empty\n * {@code Optional}.  This method is similar to {@link #map(Function)},\n * but the provided mapper is one whose result is already an {@code Optional},\n * and if invoked, {@code flatMap} does not wrap it with an additional\n * {@code Optional}.\n *\n * @param <U> The type parameter to the {@code Optional} returned by\n * @param mapper a mapping function to apply to the value, if present\n *           the mapping function\n * @return the result of applying an {@code Optional}-bearing mapping\n * function to the value of this {@code Optional}, if a value is present,\n * otherwise an empty {@code Optional}\n * @throws NullPointerException if the mapping function is null or returns\n * a null result\n */\npublic<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper) {\n    Objects.requireNonNull(mapper);\n    if (!isPresent())\n        return empty();\n    else {\n        return Objects.requireNonNull(mapper.apply(value));\n    }\n}\n\n/**\n * Return the value if present, otherwise return {@code other}.\n *\n * @param other the value to be returned if there is no value present, may\n * be null\n * @return the value, if present, otherwise {@code other}\n */\npublic T orElse(T other) {\n    return value != null ? value : other;\n}\n\n/**\n * Return the value if present, otherwise invoke {@code other} and return\n * the result of that invocation.\n *\n * @param other a {@code Supplier} whose result is returned if no value\n * is present\n * @return the value if present otherwise the result of {@code other.get()}\n * @throws NullPointerException if value is not present and {@code other} is\n * null\n */\npublic T orElseGet(Supplier<? extends T> other) {\n    return value != null ? value : other.get();\n}\n\n/**\n * Return the contained value, if present, otherwise throw an exception\n * to be created by the provided supplier.\n *\n * @apiNote A method reference to the exception constructor with an empty\n * argument list can be used as the supplier. For example,\n * {@code IllegalStateException::new}\n *\n * @param <X> Type of the exception to be thrown\n * @param exceptionSupplier The supplier which will return the exception to\n * be thrown\n * @return the present value\n * @throws X if there is no value present\n * @throws NullPointerException if no value is present and\n * {@code exceptionSupplier} is null\n */\npublic <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n    if (value != null) {\n        return value;\n    } else {\n        throw exceptionSupplier.get();\n    }\n}\n\n/**\n * Indicates whether some other object is "equal to" this Optional. The\n * other object is considered equal if:\n * <ul>\n * <li>it is also an {@code Optional} and;\n * <li>both instances have no value present or;\n * <li>the present values are "equal to" each other via {@code equals()}.\n * </ul>\n *\n * @param obj an object to be tested for equality\n * @return {code true} if the other object is "equal to" this object\n * otherwise {@code false}\n */\n@Override\npublic boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n\n    if (!(obj instanceof Optional)) {\n        return false;\n    }\n\n    Optional<?> other = (Optional<?>) obj;\n    return Objects.equals(value, other.value);\n}\n\n/**\n * Returns the hash code value of the present value, if any, or 0 (zero) if\n * no value is present.\n *\n * @return hash code value of the present value or 0 if no value is present\n */\n@Override\npublic int hashCode() {\n    return Objects.hashCode(value);\n}\n\n/**\n * Returns a non-empty string representation of this Optional suitable for\n * debugging. The exact presentation format is unspecified and may vary\n * between implementations and versions.\n *\n * @implSpec If a value is present the result must include its string\n * representation in the result. Empty and present Optionals must be\n * unambiguously differentiable.\n *\n * @return the string representation of this instance\n */\n@Override\npublic String toString() {\n    return value != null\n        ? String.format("Optional[%s]", value)\n        : "Optional.empty";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n\n\n\n# 3.2 入门\n\n * 工厂方法 ==of empty ofNullable==\n * ==ifPresent orElse orElseGet==\n\npackage com.chggx.jdk8.java.util.optional;\n\nimport java.util.Optional;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 17:26\n * @Description: <h1> optional测试 </h1>\n */\npublic class OptionalTest {\n\n    public static void main(String[] args) {\n\n        // 构造optional对象(不能new,私有的)\n        // 1. of\n//        Optional<String> optional = Optional.of("hello");\n        // 2. empty\n        Optional<String> optional = Optional.empty();\n\n        // 如果存在\n//        if (optional.isPresent()) {\n//            System.out.println(optional.get());\n//        }\n        // 3. 函数式编程风格 optional.isPresent() -------\x3e optional.ifPresent\n        optional.ifPresent(item-> System.out.println(item));\n\n        // 4. orElse 如果里面没有值,打印下面的值"world" (备选值)\n        System.out.println(optional.orElse("world"));\n\n        // 5. public T orElseGet(Supplier<? extends T> other)\n        // 如果里面的值为空的话,接单后空的参数,输出结果\n        System.out.println(optional.orElseGet(()->"nihao"));\n\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nPS: 使用optional使用**==函数式编程风格==**写代码,不使用之前的方式\n\n    // 如果存在\n    if (optional.isPresent()) {\n    \tSystem.out.println(optional.get());   \n    }else{\n        .....\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.3 深入\n\n * optional 没有 ==序列化==\n * optional通常只作为方法的返回值,来规避空指针异常\n\n员工表\n\npackage com.chggx.jdk8.pojo;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 17:50\n * @Description: <h1> 员工表 </h1>\n */\npublic class Employee {\n\n    private String name;\n\n    public Employee() {\n    }\n\n    public Employee(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n公司表\n\npackage com.chggx.jdk8.pojo;\n\nimport java.util.List;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 17:52\n * @Description: <h1> 公司表 </h1>\n */\npublic class Company {\n\n    private String name;\n\n    private List<Employee> employees;\n\n    public Company() {\n    }\n\n    public Company(String name, List<Employee> employees) {\n        this.name = name;\n        this.employees = employees;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public List<Employee> getEmployees() {\n        return employees;\n    }\n\n    public void setEmployees(List<Employee> employees) {\n        this.employees = employees;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 示例\n\npackage com.chggx.jdk8.java.util.optional;\n\nimport com.chggx.jdk8.pojo.Company;\nimport com.chggx.jdk8.pojo.Employee;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 17:54\n * @Description: <h1> 测试一对多(employee,company) </h1>\n */\npublic class OptionalTest2 {\n\n    public static void main(String[] args) {\n        Employee employee = new Employee();\n        employee.setName("zhangsan");\n\n        Employee employee2 = new Employee();\n        employee2.setName("lisi");\n\n        Company company = new Company();\n        company.setName("company1");\n        List<Employee> employees = Arrays.asList(employee, employee2);\n        // 1. employees不为空,调用optional的map获取结果\n        // 2. 结果为空,调用optional的orElse返回空结果 []\n        company.setEmployees(employees);\n\n        // 传统方式\n //       List<Employee> list = company.getEmployees();\n//        if (null != list) {\n//            return list;\n//        } else {\n//            return new ArrayList<Employee>();\n//        }\n\n        // 函数式编程风格 Optional\n        // 1. 构造工厂\n        Optional<Company> optional = Optional.ofNullable(company);\n\n        // map\n        //  public<U> Optional<U> map(Function<? super T, ? extends U> mapper)\n        System.out.println(\n                // map: 有结果情况\n                optional.map(theCompany -> theCompany.getEmployees())\n                        // 无结果情况 []\n                        .orElse(Collections.emptyList()));\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 4. 方法引用[method reference] ::\n\n * lambda表达式的一种语法糖(特殊情况),替换lambda,代码更精炼\n\n // 方法引用实现的接口 (接受一个参数,返回一个结果)\n        Function<String,String> function = String::toUpperCase;\n        System.out.println(function.getClass().getInterfaces()[0]);\n\n\n1\n2\n3\n\n\n\n# 4.1 概述\n\n 1. 方法引用(method reference): lambda表达式的一种语法糖(特殊情况)\n\n 2. 我们可以将"方法引用"看做是一个『函数式指针』,function pointer,指向另一个函数\n\n 3. 方法引用的分类(4类)\n    \n    * 类名::静态方法名 classname::staticmethod 『函数式指针』\n    * 引用名(对象名)::实例方法名\n    * 类名::实例方法名\n\n\n# 4.2 入门\n\n * 对比lambda\n\npackage com.chggx.jdk8.lambda.methodReference;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 18:33\n * @Description: <h1> 方法引用 :: </h1>\n *  1. 方法引用(method reference): lambda表达式的一种语法糖(特殊情况)\n *  2. 我们可以将"方法引用"看做是一个『函数式指针』,function pointer,指向另一个函数\n *  3. 方法引用的分类(4类)\n *      1). 类名::静态方法名\n *      2). 引用名(对象名)::实例方法名\n */\npublic class MethodReferenceTest {\n\n    public static void main(String[] args) {\n\n        List<String> list = Arrays.asList("hello","world","hello world");\n\n        // lambda方式\n        list.forEach(item-> System.out.println(item));\n\n        // 方法引用\n        list.forEach(System.out::println);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 4.3 方法引用的分类\n\n# 1. 类名::静态方法名 ==[静态方法在实体类里面]==\n\n * 实体类Stu\n\npackage com.chggx.jdk8.lambda.methodReference;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 18:45\n * @Description: <h1> </h1>\n */\npublic class Stu {\n    private String name;\n    private int score;\n\n    public Stu() {\n    }\n\n    public Stu(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getScore() {\n        return score;\n    }\n\n    public void setScore(int score) {\n        this.score = score;\n    }\n\n    /**\n     * 静态方法比较(分数)\n     */\n    public static int compareStuByScore(Stu stu1, Stu stu2) {\n        return stu1.getScore() - stu2.getScore();\n    }\n\n    /**\n     * 静态方法比较(名字)\n     */\n    public static int compareStuByName(Stu stu1, Stu stu2) {\n        return stu1.getName().compareToIgnoreCase(stu2.getName());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * 测试\n\npackage com.chggx.jdk8.lambda.methodReference;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 18:44\n * @Description: <h1> </h1>\n * 方法引用的第一类:  1). 类名::静态方法名 [静态方法在实体类里面]\n */\npublic class MethodReferenceTest2 {\n\n    public static void main(String[] args) {\n        Stu stu1 = new Stu("zhangsan", 10);\n        Stu stu2 = new Stu("lisi", 90);\n        Stu stu3 = new Stu("wangwu", 50);\n        Stu stu4 = new Stu("zhaoliu", 40);\n\n        List<Stu> stuList = Arrays.asList(stu1, stu2, stu3, stu4);\n\n        // 1. 根据分数排序\n        // 1.1 lambda\n        // 排序(在原有集合上排序,不创建新集合) sort\n        // 传递两个参数 (compare)\n        stuList.sort((stuParam1, stuParam2) ->\n                Stu.compareStuByScore(stuParam1, stuParam2));\n        stuList.forEach(stu -> System.out.println(stu.getScore()));\n\n        // 1.2 方法引用(Stu里的静态方法) [类名::静态方法名]\n        // :: Comparator\n        stuList.sort(Stu::compareStuByScore);\n        stuList.forEach(stu -> System.out.println(stu.getScore()));\n\n        // 2. 根据名字排序\n        // 2.1 lambda\n        // 排序(在原有集合上排序,不创建新集合) sort\n        // 传递两个参数 (compare)\n        stuList.sort((stuParam1, stuParam2) ->\n                Stu.compareStuByName(stuParam1, stuParam2));\n        stuList.forEach(stu -> System.out.println(stu.getName()));\n\n        // 2.2 方法引用(Stu里的静态方法) [类名::静态方法名]\n        // :: Comparator\n        stuList.sort(Stu::compareStuByName);\n        stuList.forEach(stu -> System.out.println(stu.getName()));\n\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n# 2. 引用名(对象名)::实例方法名\n\n * 引用的类\n\npackage com.chggx.jdk8.lambda.methodReference;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 20:40\n * @Description: <h1> </h1>\n */\npublic class StuComparator {\n\n    /**\n     * 比较分数\n     */\n    public int comparatorStuByScore(Stu stu1, Stu stu2) {\n        return stu1.getScore() - stu2.getScore();\n    }\n\n    /**\n     * 比较分数\n     */\n    public int comparatorStuByName(Stu stu1, Stu stu2) {\n        return stu1.getName().compareToIgnoreCase(stu2.getName());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 测试\n\npackage com.chggx.jdk8.lambda.methodReference;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 18:44\n * @Description: <h1> </h1>\n * 方法引用的第二类:  1). 引用名(对象名)::实例方法名\n */\npublic class MethodReferenceTest3 {\n    public static void main(String[] args) {\n        Stu stu1 = new Stu("zhangsan", 10);\n        Stu stu2 = new Stu("lisi", 90);\n        Stu stu3 = new Stu("wangwu", 50);\n        Stu stu4 = new Stu("zhaoliu", 40);\n\n        List<Stu> stuList = Arrays.asList(stu1, stu2, stu3, stu4);\n\n        // 创建stu比较对象\n        StuComparator stuComparator = new StuComparator();\n\n        // 1. 排序 比较分数\n        // 1.1 lambda\n        stuList.sort((stuParam1, stuParam2) ->\n                stuComparator.comparatorStuByScore(stuParam1, stuParam2));\n        stuList.forEach(stu -> System.out.println(stu.getScore()));\n        // 1.2 方法引用 stuComparator的方法 [引用名(对象名)::实例方法名]\n        // :: Comparator\n        stuList.sort(stuComparator::comparatorStuByScore);\n        stuList.forEach(stu -> System.out.println(stu.getScore()));\n\n        // 2. 排序 比较名字\n        // 2.1 lambda\n        stuList.sort((stuParam1, stuParam2) ->\n                stuComparator.comparatorStuByName(stuParam1, stuParam2));\n        stuList.forEach(stu -> System.out.println(stu.getName()));\n        // 2.2 方法引用 stuComparator的方法 [引用名(对象名)::实例方法名]\n        // :: Comparator\n        stuList.sort(stuComparator::comparatorStuByName);\n        stuList.forEach(stu -> System.out.println(stu.getName()));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n# 3. 类名::实例方法名\n\n * 实体类\n\npackage com.chggx.jdk8.lambda.methodReference;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 18:45\n * @Description: <h1> </h1>\n */\npublic class Stu {\n    private String name;\n    private int score;\n\n    public Stu() {\n    }\n\n    public Stu(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getScore() {\n        return score;\n    }\n\n    public void setScore(int score) {\n        this.score = score;\n    }\n\n    /**\n     * 静态方法比较(分数)\n     */\n    public static int comparatorStuByScore(Stu stu1, Stu stu2) {\n        return stu1.getScore() - stu2.getScore();\n    }\n\n    /**\n     * 静态方法比较(名字)\n     */\n    public static int comparatorStuByName(Stu stu1, Stu stu2) {\n        return stu1.getName().compareToIgnoreCase(stu2.getName());\n    }\n\n    //================================================================================================/\n\n    /**\n     * 改造上面的方法\n     */\n    public int comparatorByScore(Stu stu1) {\n        return this.getScore() - stu1.getScore();\n    }\n\n    public int comparatorByName(Stu stu1) {\n        return this.getName().compareToIgnoreCase(stu1.getName());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n * 测试\n\npackage com.chggx.jdk8.lambda.methodReference;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 18:44\n * @Description: <h1> </h1>\n * 方法引用的第三类:  3). 类名::实例方法名\n */\npublic class MethodReferenceTest4 {\n    public static void main(String[] args) {\n\n        Stu stu1 = new Stu("zhangsan", 10);\n        Stu stu2 = new Stu("lisi", 90);\n        Stu stu3 = new Stu("wangwu", 50);\n        Stu stu4 = new Stu("zhaoliu", 40);\n\n        List<Stu> stuList = Arrays.asList(stu1, stu2, stu3, stu4);\n\n        // 1. 方法引用  类名::实例方法名\n        //  排序 比较分数\n        // 类名::实例方法名 Stu::comparatorByScore [实例为类的非静态方法]\n        stuList.sort(Stu::comparatorByScore);\n        stuList.forEach(stu -> System.out.println(stu.getScore()));\n\n        // 排序 比较分数\n        // 类名::实例方法名 Stu::comparatorByScore [实例为类的非静态方法]\n        stuList.sort(Stu::comparatorByName);\n        stuList.forEach(stu -> System.out.println(stu.getName()));\n\n        // 2. JDK自带排序\n        List<String> cities = Arrays.asList("beijing", "shanghai", "tianjin", "chongqing");\n\n        // 2.1 Collections.sort\n        Collections.sort(cities, (cities1, cities2) -> cities1.compareToIgnoreCase(cities2));\n        cities.forEach(city -> System.out.println(city));\n\n        // 2.2 方法引用改进\n        //  public int compareToIgnoreCase(String str)\n        cities.sort(String::compareToIgnoreCase);\n        cities.forEach(System.out::println);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n# 4. 构造方法引用: ==类名::new==\n\npackage com.chggx.jdk8.lambda.methodReference;\n\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/19 18:44\n * @Description: <h1> </h1>\n * 方法引用的第四类:  4). 构造方法: 类名::new\n */\npublic class MethodReferenceTest5 {\n\n    public static void main(String[] args) {\n\n        MethodReferenceTest5 test5 = new MethodReferenceTest5();\n        // 1.\n        // String::new : new String() 类名::new\n        System.out.println(test5.getString(String::new));\n\n        // 2. \n        System.out.println(test5.getString2("hello", String::new));\n\n\n    }\n\n    /**\n     * Supplier<T>: 不接收参数,返回值\n     */\n    public String getString(Supplier<String> supplier) {\n        return supplier.get() + "test";\n    }\n\n    /**\n     * Function<T,R>:\n     */\n    public String getString2(String str, Function<String, String> function) {\n        return function.apply(str);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 4. 案例\n\n持续更新..........\n\n\n# 5. Stream API\n\n\n# 5.1 Stream简介\n\n# 1. 什么是流\n\n流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。\n\n众所周知，集合操作非常麻烦，若要对集合进行筛选、投影，需要写大量的代码，而流是以声明的形式操作集合，它就像SQL语句，我们只需告诉流需要对集合进行什么操作，它就会自动进行操作，并将执行结果交给你，无需我们自己手写代码。\n\n因此，流的集合操作对我们来说是透明的，我们只需向流下达命令，它就会自动把我们想要的结果给我们。由于操作过程完全由Java处理，因此它可以根据当前硬件环境选择最优的方法处理，我们也无需编写复杂又容易出错的多线程代码了。\n\n> 总结\n\n流使用于操作数据源(集合.数组等)所生成的元素序列. 集合将的是数据,流讲的是计算.\n\n> 注意\n\n① Stream 自己不会存储元素 (不是数据结构，不会保存数据)\n\n② Stream 不会改变源对象. 相反,他们会返回一个持有结果的新Stream.\n\n③ Stream 操作是 延迟执行 的. 这意味着他们会等到需要结果的时候才执行.\n\n# 2. 流的操作种类\n\n> 创建 Stream\n\n一个数据源 (集合,数组等) , 获取一个流.\n\n> 中间操作\n\n当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为 “中间操作”。 中间操作仍然会返回一个流对象，因此多个中间操作可以串连起来形成一个流水线。除非流水线上触发终止操作,否则中间操作不会执行任何的处理! 而在终止操作是一次性全部处理,成为 "惰性求值"\n\n> 终端操作(终止操作)\n\n当所有的中间操作完成后，若要将数据从流水线上拿下来，则需要执行终端操作。 终端操作将返回一个执行结果，这就是你想要的数据。\n\n\n\n\n# 5.2 Stream 创建流\n\n> 集合流\n\n// 通过 Collection 系列集合提供的 stream() 或 parallelStream()\nList<String> list = new ArrayList<>();\n//获取一个顺序流\nStream<String> stream1 = list.stream();\n//获取一个并行流\nStream<String> parallelStream = list.parallelStream(); \n\n\n1\n2\n3\n4\n5\n6\n\n\n> 数组流: Arrays.stream()\n\n// 通过 Arrays 中的静态方法stream()获取\nString[] strings = new String[10];\nStream<String> stream2 = Arrays.stream(strings);\n\n\n1\n2\n3\n\n\n> Stream 类中的静态方法 of()、iterate()、generate()\n\n// 通过 Stream 类中的静态方法 of\nStream<java.lang.String> stream3 = Stream.of("aa", "bb", "cc");\n// 无限流\nStream<Integer> stream2 = Stream.iterate(0, (x) -> x + 2).limit(6); // 迭代\nstream2.forEach(System.out::println); \nStream<Double> stream3 = Stream.generate(Math::random).limit(2); // 生成\nstream3.forEach(System.out::println);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 无限流\n\n 1. 迭代 iterate()\n\nStream<Integer> stream4 = Stream.iterate(0, (x) -> x + 2);\n\n\n1\n\n 2. 生成 generate()\n\nStream.generate(Math::random).forEach(System.out::println);\n\n\n1\n\n\n> 文件生成流 BufferedReader.lines()\n\nBufferedReader reader = new BufferedReader(new FileReader("F:\\\\test_stream.txt"));\nStream<java.lang.String> lineStream = reader.lines();\nlineStream.forEach(System.out::println);\n\n\n1\n2\n3\n\n\n> 字符串分隔成流: Pattern.splitAsStream()\n\nPattern pattern = Pattern.compile(",");\nStream<java.lang.String> stringStream = pattern.splitAsStream("a,b,c,d");\nstringStream.forEach(System.out::println);\n\n\n1\n2\n3\n\n\n> 生成空流\n\nStream<Object> empty = Stream.empty();\n\n\n1\n\n\n> 数值范围生成流\n\n// 生成0到10的int流\nIntStream intStream = IntStream.rangeClosed(0, 10);\n// 生成0到9的int流\nIntStream intStream1 = IntStream.range(0, 10);\n\n\n1\n2\n3\n4\n\n\n> 手动生成流\n\n// 生成有字符串a和数字1的异构的流\nStream.builder().add("a").add(1).build().forEach(System.out::print);\n\n\n1\n2\n\n\n\n# 5.3 Stream 中间操作\n\n# 1. 筛选与切片\n\n方法                    描述\nfilter(Predicate p)   接收 Lambda ， 从流中排除某些元素。\ndistinct()            筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素\nlimit(long maxSize)   截断流，使其元素不超过给定数量。\nskip(long n)          跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素\n\n> filter——接收 Lambda ， 从流中排除某些元素。\n\n 1. 内部迭代\n\n@Test\npublic void screeningAndSlicing1() {\n    // 中间操作\n    Stream<Employee> stream = employeeList.stream()\n            // 年龄大于35\n            .filter(e -> e.getAge() > 35);\n    // 只有当做终止操作时，所有的中间操作会一次性的全部执行，称为“惰性求值”\n    stream.forEach(System.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 内部迭代\n\n// 外部迭代\n@Test\npublic void screeningAndSlicing2() {\n    Iterator<Employee> it = employeeList.iterator();\n    while (it.hasNext()) {\n        System.out.println(it.next());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> limit——截断流，使其元素不超过给定数量。\n\n@Test\npublic void screeningAndSlicing3() {\n    employeeList.stream()\n            .filter(e -> {\n                System.out.println("短路！"); // &&  ||\n                return e.getSalary() > 5000;\n            })\n            .limit(2)\n            .forEach(System.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补\n\n@Test\npublic void screeningAndSlicing4() {\n    employeeList.stream()\n            .filter(e -> e.getSalary() > 5000)\n            .skip(2)\n            .forEach(System.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素\n\n@Test\npublic void screeningAndSlicing5() {\n    // distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素\n    employeeList.stream()\n            .filter(e -> e.getSalary() > 5000)\n            .skip(2)\n            .distinct()\n            .forEach(System.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 2. 映射\n\n方法                                描述\nmap(Function f)                   接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\nmapToDouble(ToDoubleFunction f)   接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。\nmapToInt(ToIntFunction f)         接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。\nmapToLong(ToLongFunction f)       接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。\nflatMap(Function f)               接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流\n\n> map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n\nList<String> list = Arrays.asList("aaa", "bbb", "ccc", "ddd", "eee");\nlist.stream()\n        // str -> str.toUpperCase() 转换为大写\n        .map(String::toUpperCase)\n        .forEach(System.out::println);\n\nSystem.out.println("------------");\n\nemployeeList.stream()\n        .map(Employee::getName)\n        .forEach(System.out::println); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流\n\n// Map\nStream<Stream<Character>> stream1 = list.stream()\n        // 类名::静态方法\n        .map(StreamApiTest02::filterCharacter);\nstream1.forEach(sm -> {\n    sm.forEach(System.out::print);\n});\nSystem.out.println();\nSystem.out.println("------------");\n\n// 优化上面\n// flatMap\nStream<Character> stream2 = list.stream()\n        // 类名::静态方法\n        .flatMap(StreamApiTest02::filterCharacter);\nstream2.forEach(System.out::print);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n静态方法\n\npublic static Stream<Character> filterCharacter(String str) {\n    List<Character> list = new ArrayList<>();\n    for (Character ch : str.toCharArray()) {\n        list.add(ch);\n    }\n    return list.stream();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 3. 排序\n\n方法                        描述\nsorted()                  产生一个新流，其中按自然顺序排序\nsorted(Comparator comp)   产生一个新流，其中按比较器顺序排序\n\n> sorted()——自然排序(Comparable)\n\nList<String> list = Arrays.asList("aaa", "bbb", "ccc", "ddd", "eee");\n// 自然排序\nlist.stream()\n        .sorted()\n        .forEach(System.out::println);\n\n\n1\n2\n3\n4\n5\n\n\n> sorted(Comparator com)——定制排序(Comparator)\n\nemployeeList.stream()\n        .sorted((e1, e2) -> {\n            if (e1.getAge() == e2.getAge()) {\n                return e1.getName().compareTo(e2.getName());\n            } else {\n                return Integer.compare(e1.getAge(), e2.getAge());\n            }\n        }).forEach(System.out::println);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5.4 Stream 终止操作\n\n# 1 查找与匹配\n\n方法                       描述\nallMatch(Predicate p)    检查是否匹配所有元素\nanyMatch(Predicate p)    检查是否至少匹配一个元素\nnoneMatch(Predicate p)   检查是否没有匹配所有元素\nfindFirst()              返回第一个元素\nfindAny()                返回当前流中的任意元素\ncount                    返回流中元素总数\nmax(Comparator c)        返回流中大值\nmin(Comparator c)        返回流中最小值\nforEach(Consumer c)      内部迭代(使用 Collection 接口需要用户去做迭代，称为 外部迭代。相反，Stream API 使用内部\n                         迭代——它帮你把迭代做了)\n\n> allMatch——检查是否匹配所有元素\n\nboolean b1 = employeeList.stream()\n        .allMatch(e -> e.getStatus().equals(Employee.Status.BUSY));\nSystem.out.println(b1);\n\n\n1\n2\n3\n\n\n> anyMatch——检查是否至少匹配一个元素\n\nboolean b2 = employeeList.stream()\n        .anyMatch(e -> e.getStatus().equals(Employee.Status.BUSY));\nSystem.out.println(b2);\n\n\n1\n2\n3\n\n\n> noneMatch——检查是否没有匹配的元素\n\nboolean b3 = employeeList.stream()\n        .noneMatch(e -> e.getStatus().equals(Employee.Status.BUSY));\nSystem.out.println(b3);\n\n\n1\n2\n3\n\n\n> findFirst——返回第一个元素\n\n工资排序\n\nOptional<Employee> opA = employeeList.stream()\n        // 工资排序 正序\n        .sorted((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()))\n        .findFirst();\nif (opA.isPresent()) {\n    System.out.println(opA.get());\n}\nOptional<Employee> opD = employeeList.stream()\n        // 工资排序  倒序\n        .sorted((e1, e2) -> -Double.compare(e1.getSalary(), e2.getSalary()))\n        .findFirst();\nif (opD.isPresent()) {\n    System.out.println(opD.get());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用 max(),min() 优化\n\nOptional<Employee> op1 = employeeList.stream().min(Comparator.comparingDouble(Employee::getSalary));\nop1.ifPresent(System.out::println);\nOptional<Employee> op2 = employeeList.stream().max(Comparator.comparingDouble(Employee::getSalary));\nop2.ifPresent(System.out::println);\n\n\n1\n2\n3\n4\n\n\n> findAny——返回当前流中的任意元素\n\nOptional<Employee> any = employeeList.stream()\n        .filter(e -> e.getStatus().equals(Employee.Status.FREE))\n        .findAny();\nany.ifPresent(System.out::println);\n\n\n1\n2\n3\n4\n\n\n> count——返回流中元素的总个数\n\nlong count = employeeList.stream()\n        .count();\nSystem.out.println(count);\n\n\n1\n2\n3\n\n\n> max——返回流中最大值\n\n获取最大工资员工\n\nOptional<Employee> max = employeeList.stream()\n        .max((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()));\nif (max.isPresent()){\n    System.out.println(max.get());\n}\n\n\n1\n2\n3\n4\n5\n\n\n优化:\n\n 1. 方式一\n\nOptional<Employee> max1 = employeeList.stream()\n        .max(Comparator.comparingDouble(Employee::getSalary));\nmax1.ifPresent(System.out::println);\n\n\n1\n2\n3\n\n 2. 方式二 最大工资\n\nOptional<Double> max2 = employeeList.stream()\n        .map(Employee::getSalary)\n        .max(Double::compare);\nmax2.ifPresent(System.out::println);\n\n\n1\n2\n3\n4\n\n\n> min——返回流中最小值\n\nOptional<Employee> min = employeeList.stream()\n        .min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()));\nif (max.isPresent()){\n    System.out.println(min.get());\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 2. 规约\n\n方法                                 描述\nreduce(T iden, BinaryOperator b)   可以将流中元素反复结合起来，得到一个值。返回 T\nreduce(BinaryOperator b)           可以将流中元素反复结合起来，得到一个值。返回 Optional<T>\n\n> reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。\n\nList<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nInteger sum = list.stream()\n        // 参数一: 起始值\n        // (x,y)-> x+y[求和] 转换为 Integer::sum\n        .reduce(0, Integer::sum);\nSystem.out.println(sum);\n\n\n1\n2\n3\n4\n5\n6\n\n\n> reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值,返回 Optional<T>。\n\nOptional<Double> reduce = employeeList.stream()\n        .map(Employee::getSalary)\n        .reduce(Double::sum);\nreduce.ifPresent(System.out::println);\n\n\n1\n2\n3\n4\n\n\n# 3. 收集\n\n方法                     描述\ncollect(Collector c)   将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法\n\nCollector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：\n\n方法                  返回类型                      作用\ntoList              List(T)                   把流中元素收集到List\ntoSet               Set(T)                    把流中元素收集到Set\ntoCollection        Collection(T)             把流中元素收集到创建的集合\ncounting            Long                      计算流中元素的个数\naveragingDouble     Double                    平均值\naveragingInt        Integer                   \naveragingLong       Long                      \nsummingInt          Integer                   对流中元素的整数属性求和\nsummingDouble       Double                    \nsummingLong         Long                      \nsummarizingDouble   DoubleSummaryStatistics   用于int、long、double类型数据一个求总操作\nsummarizingInt                                \nsummarizingLong                               \njoining             String                    连接流中每个字符串\nmaxBy               Optional(T)               根据比较器选择最大值\nminBy               Optional(T)               根据比较器选择最小值\nreducing            归约产生的类型                   从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值\ncollectingAndThen   转换函数返回的类型                 包裹另一个收集器，对其结果转换函数\ngroupingBy          Map(K, List(T))           根据某属性值对流分组，属性为K，结果为V\npartitioningBy      Map(Boolean, List(T))     根据true或false进行分区\n\n注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 List(T) 指的是 List<T>. \n\n\n1\n\n\n> toList\n\nList<String> list = employeeList.stream()\n        .map((Employee::getName))\n        .collect(Collectors.toList());\nlist.forEach(System.out::println);\n\n\n1\n2\n3\n4\n\n\n> toSet\n\nSet<String> set = employeeList.stream()\n                .map((Employee::getName))\n                .collect(Collectors.toSet());\n        set.forEach(System.out::println);\n\n\n1\n2\n3\n4\n\n\n> toCollection\n\nHashSet<String> collect = employeeList.stream()\n        .map((Employee::getName))\n        .collect(Collectors.toCollection(HashSet::new));\ncollect.forEach(System.out::println);\n\n\n1\n2\n3\n4\n\n\n> counting\n\nLong count = employeeList.stream()\n        .collect(Collectors.counting());\nSystem.out.println(count);\n\n\n1\n2\n3\n\n\n> averagingDouble 平均值\n\nDouble avg = employeeList.stream()\n        .collect(Collectors.averagingDouble(Employee::getSalary));\nSystem.out.println(avg);\n\n\n1\n2\n3\n\n\n> summingDouble 总和\n\nDouble summ = employeeList.stream()\n        .collect(Collectors.summingDouble(Employee::getSalary));\nSystem.out.println(summ);\n\n\n1\n2\n3\n\n\n> maxBy 最大值\n\nOptional<Employee> max = employeeList.stream()\n        .collect(Collectors.maxBy((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary())));\nmax.ifPresent(System.out::println);\n\n\n1\n2\n3\n\n\n> minBy 最小值\n\nOptional<Employee> min = employeeList.stream()\n        .collect(Collectors.minBy((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary())));\nmin.ifPresent(System.out::println);\n\n\n1\n2\n3\n\n\n> groupingBy 分组\n\n 1. 分组\n\nMap<Employee.Status, List<Employee>> groupBy = employeeList.stream()\n        .collect(Collectors.groupingBy(Employee::getStatus));\nSystem.out.println(groupBy);\n\n\n1\n2\n3\n\n 2. 多级分组\n\nMap<Employee.Status, Map<String, List<Employee>>> map = employeeList.stream()\n        .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy(e -> {\n            if (e.getAge() <= 35) {\n                return "青年";\n            } else if (e.getAge() <= 50) {\n                return "中年";\n            } else {\n                return "老年";\n            }\n        })));\nSystem.out.println(map);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> partitioningBy 分区\n\nMap<Boolean, List<Employee>> partitioningBy = employeeList.stream()\n        .collect(Collectors.partitioningBy(e -> e.getSalary() > 8000));\nSystem.out.println(partitioningBy);\n\n\n1\n2\n3\n\n\n> summarizingDouble\n\nDoubleSummaryStatistics dss = employeeList.stream()\n        .collect(Collectors.summarizingDouble(Employee::getSalary));\nSystem.out.println("总和 : " + dss.getSum());\nSystem.out.println("数量 : " + dss.getCount());\nSystem.out.println("平均值 : " + dss.getAverage());\nSystem.out.println("最大值 : " + dss.getMax());\nSystem.out.println("最小值 : " + dss.getMin());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> joining 连接\n\nString str = employeeList.stream()\n        .map(Employee::getName)\n        .collect(Collectors.joining(",","===","==="));\nSystem.out.println(str);\n\n\n1\n2\n3\n4\n\n\n\n# 6. 日期API\n\n> 参考：Calendar、Date\n\n\n# 6.1 新旧版本API差别\n\n# 1. 新版本计算准确(毫秒),旧版本有误差\n\npublic class dateApiTest01 {\n\n    /**\n     * 程序员小李出生于1995年12月26日,计算当前这个时间他已经出生多久了?\n     */\n    @Test\n    public void oldApi() {\n        Date d = new Date();\n        // 获取时间\n        long s1 = d.getTime();\n\n        //\n        Calendar c = Calendar.getInstance();\n        // 月份从 0-11 12月为: 11\n        c.set(1995, 11, 16);\n        Date d2 = c.getTime();\n        long s2 = d2.getTime();\n\n        long intervalDay = (s1 - s2) / 1000 / 60 / 60 / 24;\n\n        System.out.println("1995年12月距离现在已经过时了" + intervalDay + "天");\n        // 9013\n    }\n\n    /**\n     * 程序员小李出生于1995年12月26日,计算当前这个时间他已经出生多久了?\n     *  Java8新日期API计算准确\n     */\n    @Test\n    public void newApi() {\n\n        // 使用Jav8新版本的API获取\n        long intervalDay = ChronoUnit.DAYS.between(LocalDate.of(1995, 12, 16), LocalDate.now());\n\n        System.out.println("1995年12月距离现在已经过时了" + intervalDay + "天");\n        // 9014\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 2. 老版本存在 线程不安全问题\n\nSimpleDateFormat 类是线程不安全的,咋多线程的情况下,全局贡献一个 SimpleDateFormat 类中的 Calendar 对象有可能出现异常.\n\nfinal static SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n\n/**\n * 创建10个线程,将字符串"2020-08-08 12:12:12"转换为Date对象后,打印到控制台上\n */\n@Test\npublic void oldApi() {\n    for (int i = 0; i < 10; i++) {\n        // 创建线程(匿名内部类方式)\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Date date = SIMPLE_DATE_FORMAT.parse("2020-08-08 12:12:12");\n                    System.out.println(date);\n                } catch (ParseException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n控制台错误:\n\n java.lang.NumberFormatException: For input string: ""\n\n\n1\n\n\n问题原因: 线程问题\n\n\n\n> 解决: 锁\n\n@Test\npublic void oldApi() {\n    for (int i = 0; i < 10; i++) {\n        // 创建线程(匿名内部类方式)\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    // 通过加锁解决线程安全问题\n                    synchronized (SIMPLE_DATE_FORMAT) {\n                        Date date = SIMPLE_DATE_FORMAT.parse("2020-08-08 12:12:12");\n                        System.out.println(date);\n                    }\n                } catch (ParseException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 3. 开发规范\n\n不允许使用没有定义的魔法数字\n\npublic class dateApiTest03 {\n\n    /**\n     * 初始化Calendar对象,封装日期为2008年8月8日\n     */\n    @Test\n    public void oldApi() {\n        // 初始化Calendar对象\n        Calendar calendar = Calendar.getInstance();\n        // 设置年月日\n        // 不允许使用没有定义的魔法数字\n//        calendar.set(2008,7,8);\n        /**\n         * public final static int AUGUST = 7;\n         */\n        calendar.set(2008,Calendar.AUGUST,0); // 正确格式 august: 8月\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6.2 Date-Time API基本类\n\n# 1. 常用类\n\n常用类             功能概述\nInstant         Instant类对时间轴上的单一瞬时点建模,可以用于记录应用程序中的事件时间戳,在之后的类型转换中,均可以使用Instant类作为中间类完成转换.\nDuration        Duration类表示秒或纳秒时间间隔,适合处理较短的时间,需要更高的精确度.\nPeriod          Period类表示一段时间的年,月,日.\nLocalDate       LocalDate是一个不可变的日期时间对象,表示日期,通常视为年月日.\nLocalTime       LocalTime是一个不可变的日期时间对象,代表一个时间,通常看做是小时-秒,时间表示为纳秒精度.\nLocalDateTime   LocalDateTime是一个不可变得日期时间对象,代表日期时间,通常视为年-月-日-时-分-秒.\nZonedDateTime   ZonedDateTime是具有时区的日期的不可变表时,此类存储所有时间和时间字段,精确度为纳秒,时区为区域偏移量,用于处理模糊的本地日期时间.\n\n# 2. now 方法在日期/时间类中的使用\n\nDate-Time API 中的所有类均生成不可变的示例,它们是线程安全的,并且这些类不提供公共构造函数,也就是说没办法通过new的方式直接创建,需要曹勇工厂方法加以实例化.\n\n 1. now方法可以根据当前日期或时间创建实例对象\n\npublic class TimeClassMethodTest01 {\n\n    /**\n     * now方法可以根据当前日期或时间创建实例对象\n     * Instant,LocalDate,LocalTime,LocalDateTime,ZonedDateTime\n     */\n    @Test\n    public void test1() {\n        // 使用now方法创建Instant的实例方法对象\n        Instant instant = Instant.now();\n        // 使用now方法创建LocalDate的实例对象\n        LocalDate localDateNow = LocalDate.now();\n        // 使用now方法创建LocalTime的实例对象\n        LocalTime localTimeNow = LocalTime.now();\n        // 使用now方法创建LocalDateTime的实例对象\n        LocalDateTime LocalDateTimeNow = LocalDateTime.now();\n        // 使用now方法创建ZonedDateTime的实例对象\n        ZonedDateTime zonedDateTimeNow = ZonedDateTime.now();\n\n        // 将实例对象在到控制台输出\n        System.out.println("instant: " + instant); // instant: 2020-08-20T05:05:47.339Z 标准时间(国际)\n        System.out.println("localDateNow: " + localDateNow); // localDateNow: 2020-08-20\n        System.out.println("localTimeNow: " + localTimeNow); // localTimeNow: 13:05:47.440 (440: 表示纳秒)\n        System.out.println("LocalDateTimeNow: " + LocalDateTimeNow); // LocalDateTimeNow: 2020-08-20T13:05:47.440\n        System.out.println("zonedDateTimeNow: " + zonedDateTimeNow); // zonedDateTimeNow: 2020-08-20T13:05:47.440+08:00[Asia/Shanghai] 东八区\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 2. Java8的Time包下其他使用now方法的类.\n\n/**\n * 其他使用now方法的类\n * Year,YearMonth,MonthDay\n */\n@Test\npublic void test2() {\n    // 使用now方法创建Year的实例方法对象\n    Year yearNow = Year.now();\n    // 使用now方法创建Month的实例方法对象\n    YearMonth yearMonthNow = YearMonth.now();\n    // 使用now方法创建Day的实例方法对象\n    MonthDay monthDayNow = MonthDay.now();\n\n    // 将实例对象在到控制台输出\n    System.out.println("yearNow: " + yearNow); // yearNow: 2020\n    System.out.println("yearMonthNow: " + yearMonthNow); // yearMonthNow: 2020-08\n    System.out.println("monthDayNow: " + monthDayNow); // monthDayNow: --08-20\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> now(): 获取当前时间日期.\n\n# 3. of方法在日期/时间类中的应用\n\nof方法可以根据给定的参数生成对相应的日期/时间,基本上每个基本类都有of方法用于生成的对应的对象,而且重载形式多变,可以根据不同的参数生成对应的数据.\n\n 1. LocalDate.of 简单使用\n\n/**\n * 初始化2020年8月8日\n */\n@Test\npublic void test1() {\n    LocalDate localDate = LocalDate.of(2020, 8, 8);\n    System.out.println("localDate: "+ localDate); // localDate: 2020-08-08\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n 2. LocalTime.of 的使用\n    \n    LocalTime.of(int hour, int minute): 根据小时/分钟生成对象\n    \n    LocalTime.of(int hour, int minute,int second): 根据小时/分钟/秒生成对象\n    \n    LocalTime.of(int hour, int minute,int second, int nanoOfSecond): 根据小时/分钟/秒/纳秒生成对象.\n\n/**\n * 初始化晚上8点0分0秒的" LocalTime " 对象  -> 如果是晚上的时间,需要将12.\n */\n@Test\npublic void test2() {\n    // 方式一\n    LocalTime localTime1 = LocalTime.of(20, 0);\n    // 方式二\n    LocalTime localTime2 = LocalTime.of(20, 0,58);\n    // 方式三\n    LocalTime localTime3 = LocalTime.of(20, 0,34,1);\n    System.out.println("localTime1: " + localTime1); // localTime1: 20:00\n    System.out.println("localTime2: " + localTime2); // localTime2: 20:00:58\n    System.out.println("localTime3: " + localTime3); // localTime3: 20:00:34.000000001\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n 3. LocalDateTime.of的使用\n    \n    LocalDateTime.of(int year, int month, int dayOfMonth, int hour, int minute ,int second, int nanoOfSecond): 根据年/月/日/时/分/秒/纳秒生成对象\n    \n    LocalDateTime.of(int year, int month, int dayOfMonth, int hour, int minute): 根据年/月/日/时/分生成对象\n\n/**\n * 初始化2020年8月8日下午8点0分的 " LocalDateTime " 对象\n */\n@Test\npublic void test3(){\n    LocalDateTime localDateTime1 = LocalDateTime.of(2020, 8, 8, 20, 0);\n    System.out.println("localDateTime1: " + localDateTime1); // localDateTime1: 2020-08-08T20:00\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 特殊情况: LocalDateTime.of(LocalDate date, LocalTime time)\n\n/**\n * LocalDateTime: 特殊使用\n */\n@Test\npublic void test4() {\n    // localDate\n    LocalDate localDate = LocalDate.of(2020, 8, 8);\n    // localTime\n    LocalTime localTime = LocalTime.of(20, 0);\n\n    LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);\n    System.out.println("localDateTime: " + localDateTime); // localDateTime: 2020-08-08T20:00\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 4. LocalDateTime 时区信息\n\nZonedDateTime: 不仅封装有日期时间,并且还有偏移量 时区 (中国东八区)\n\n 1. 时区的获取\n    \n    通过 ZoneId 类 提供的 getAvailableZoneIds() 可以获取一个Set集合,集合中封装了600个时区.\n\npublic class TimeClassMethodTest03 {\n\n    @Test\n    public void test1(){\n        // 获取所有时区信息\n        Set<String> availableZoneIds = ZoneId.getAvailableZoneIds();\n        for (String availableZoneId : availableZoneIds) {\n//            System.out.println(availableZoneId);\n        }\n        // 获取当前系统默认的时区信息 -> 中国\n        ZoneId zoneId = ZoneId.systemDefault();\n        System.out.println(zoneId); // Asia/Shanghai\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 2. 添加时区信息 / 获取其他时区信息\n\n@Test\npublic void test2(){\n    // 1. 封装LocalDateTime对象,参数自定义->2020年11月11日 8点54分38秒\n    LocalDateTime time = LocalDateTime.of(2020, 11, 11, 8, 54, 38);\n    // 2. 封装完成后的time对象知识一个封装的时间对象,并没有时区相关的数据,所以添加时区到对象中,使用atZone()方法\n    ZonedDateTime zonedDateTime = time.atZone(ZoneId.of("Asia/Shanghai"));\n    System.out.println("zonedDateTime: " + zonedDateTime); // zonedDateTime: 2020-11-11T08:54:38+08:00[Asia/Shanghai]\n    // 3. 更改时区查看其它时区的当前时间 通过 withZoneSameInstant() 即可更改\n    ZonedDateTime AmericaZonedDateTime = zonedDateTime.withZoneSameInstant(ZoneId.of("Asia/Tokyo"));\n    System.out.println("同一时间的日本时间: " + AmericaZonedDateTime);\n    // 同一时间的日本时间: 2020-11-11T09:54:38+09:00[Asia/Tokyo]\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 5. Month枚举类的使用\n\njava.time包中引入了Month的枚举,Month中包含标准日历中的12个月份的常量(1-12)月,也提供了一些方便的方法共我们使用.\n\n推荐在初始化 LocalDate 和 LocalDateTime 对象的时候,月份使用枚举的方式传入,这样更简单易懂而且不易出错.(旧的API Calendar从0-11)\n\n/**\n * Month月份枚举使用\n */\n@Test\npublic void test(){\n    // 1. 初始化 LocalDate 和 LocalDateTime 对象的时候,月份使用枚举的方式传入 -> 2020年7月26日11时11分11面\n    LocalDateTime time = LocalDateTime.of(2020, Month.JULY, 26, 11, 11, 11);\n    System.out.println(time); // 2020-07-26T11:11:11\n\n    // 2. Month枚举类 -> of可以根据传入的数字返回对应月份的枚举\n    Month month = Month.of(12);\n    System.out.println(month); // DECEMBER\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 6. 测试\n\npublic class TimeClassMethodTest05 {\n\n    /**\n     * 创建当前时间(不带时区)\n     */\n    @Test\n    public void test1(){\n        LocalDateTime now = LocalDateTime.now();\n        System.out.println(now); // 2020-08-20T22:06:05.361\n    }\n\n    /**\n     * 创建当前时间(只包含年月日)\n     */\n    @Test\n    public void test2(){\n        LocalDate now = LocalDate.now();\n        System.out.println(now); // 2020-08-20\n    }\n\n    /**\n     * 创建当前时间(包含年月日时分秒并且带有时区)\n     */\n    @Test\n    public void test3(){\n        ZonedDateTime now = ZonedDateTime.now();\n        System.out.println(now); // 2020-08-20T22:09:06.124+08:00[Asia/Shanghai]\n    }\n\n    /**\n     * 创建2020年12日31日7时38分46秒的日期对象(月份使用枚举)\n     */\n    @Test\n    public void test4(){\n        LocalDateTime now = LocalDateTime.of(2020, Month.DECEMBER,31,7,38,46);\n        System.out.println(now); // 2020-12-31T07:38:46\n    }\n\n    /**\n     * 创建2020年12日31日的日期对象(月份使用枚举)\n     */\n    @Test\n    public void test5(){\n        LocalDate now = LocalDate.of(2020,Month.DECEMBER,31);\n        System.out.println(now); // 2020-12-31\n    }\n\n    /**\n     * 创建7时38分46秒的时间对象\n     */\n    @Test\n    public void test6(){\n        LocalTime now = LocalTime.of(7,38,46);\n        System.out.println(now); // 07:38:46\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 6.3 根据现有实例创建日期与时间对象\n\njava8中的日期时间相关的API的所有实例都是不可变的,一旦创建 LocalDate,LocalTime,LocalDateTime 就无法修改(类似于Spring), 这对于线程安全非常有利\n\n# 1. plus在 LocalDate,LocalTime 中的使用\n\n想要修改某个日期/时间的现有实力是,我们可以使用plus/minus方法来完成操作.\n\n 1. LocalDate中对日期进行递增/减操作的方法\n\n方法                                  作用\nLocalDate plusDays(long days)       增减天数\nLocalDate plusWeeks(long weeks)     增减周数\nLocalDate plusMonths(long months)   增减月数\nLocalDate plusYears(long years)     增减年数\n\n/**\n * Plus方法在localDate中的使用\n * LocalDate plusDays(long days)增减天数\n * LocalDate plusWeeks(long weeks)增减周数\n * LocalDate plusMonths(long months)增减月数\n * LocalDate plusYears(long years)增减年数\n */\n@Test\npublic void test1(){\n    // 封装localDate对象,参数为2020年2月13日\n    LocalDate localDate = LocalDate.of(2020, Month.FEBRUARY, 13);\n    System.out.println("当前时间: " + localDate); // 当前时间: 2020-02-13\n\n    // 计算当前时间的4天后的时间,并打印\n    LocalDate date1 = localDate.plusDays(4);\n    System.out.println("当前时间的4天后时间: " + date1); // 当前时间的4天后时间: 2020-02-17\n\n    // 计算当前时间的3周后的时间,并打印\n    LocalDate date2 = localDate.plusWeeks(3);\n    System.out.println("当前时间的4周后时间: " + date2); // 当前时间的4周后时间: 2020-03-05\n\n    // 计算当前时间的5个月后的时间,并打印\n    LocalDate date3 = localDate.plusMonths(5);\n    System.out.println("当前时间的5个月后时间: " + date3); // 当前时间的5个月后时间: 2020-07-13\n\n    // 计算当前时间的2年后的时间,并打印\n    LocalDate date = localDate.plusYears(3);\n    System.out.println("当前时间的2年后时间: " + date); // 当前时间的2年后时间: 2023-02-13\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n 2. LocalTime中对时间进行递增/减操作的方法\n\n方法                                    作用\nLocalTime plusNanos(long nanos)       增加纳秒\nLocalTime plusSeconds(long seconds)   增加秒\nLocalTime plusMenutes(long menutes)   增加分钟\nLocalTime plusHours(long hours)       增加小时\n\n/**\n * Plus方法在localTime中的使用\n * LocalTime plusNanos(long nanos)增加纳秒\n * LocalTime plusSeconds(long seconds)增加秒\n * LocalTime plusMenutes(long menutes)增加分钟\n * LocalTime plusHours(long hours)增加小时\n */\n@Test\npublic void test2() {\n    // 封装LocalTime对象参数为8点13分39秒218毫秒\n    LocalTime localTime = LocalTime.of(8, 13, 39, 218);\n    System.out.println("当前时间: " + localTime); // 当前时间: 08:13:39.000000218\n\n    // 计算当前时间500纳秒后的时间,并打印\n    LocalTime date1 = localTime.plusNanos(500);\n    System.out.println("当前时间500纳秒后的时间: " + date1); // 当前时间500纳秒后的时间: 08:13:39.000000718\n\n    // 计算当前时间45秒后的时间,并打印\n    LocalTime date2 = localTime.plusSeconds(45);\n    System.out.println("当前时间45秒后的时间: " + date2); // 当前时间45秒后的时间: 08:14:24.000000218\n\n\n    // 计算当前时间19分钟后的时间,并打印\n    LocalTime date3 = localTime.plusMinutes(19);\n    System.out.println("当前时间19分钟后的时间: " + date3); // 当前时间19分钟后的时间: 08:32:39.000000218\n\n    // 计算当前时间3小时后的时间,并打印\n    LocalTime date4 = localTime.plusHours(3);\n    System.out.println("当前时间3小时后的时间: " + date4); // 当前时间3小时后的时间: 11:13:39.000000218\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 2. minus方法在 LocalDate,LocalTime中的使用\n\n 1. LocalDate中对日期进行递增/减操作的方法\n\n方法                                             作用\nLocalDate minusDays(long daysToSubtract)       增减天数\nLocalDate minusWeeks(long weeksToSubtract)     增减周数\nLocalDate minusMonths(long monthsToSubtract)   增减月数\nLocalDate minusYears(long yearsToSubtract)     增减年数\n\n/**\n * Minus方法在localDate中的使用\n * LocalDate minusDays(long daysToSubtract)增减天数\n * LocalDate minusWeeks(long weeksToSubtract)增减周数\n * LocalDate minusMonths(long monthsToSubtract)增减月数\n * LocalDate minusYears(long yearsToSubtract)增减年数\n */\n@Test\npublic void test1() {\n    // 封装localDate对象,参数为2020年2月13日\n    LocalDate localDate = LocalDate.of(2020, Month.FEBRUARY, 13);\n    System.out.println("当前时间: " + localDate); // 当前时间: 2020-02-13\n\n    // 计算当前时间的4天后的时间,并打印\n    LocalDate date1 = localDate.minusDays(4);\n    System.out.println("当前时间的4天前时间: " + date1); // 当前时间的4天前时间: 2020-02-09\n\n    // 计算当前时间的3周后的时间,并打印\n    LocalDate date2 = localDate.minusWeeks(3);\n    System.out.println("当前时间的4周前时间: " + date2); // 当前时间的4周前时间: 2020-01-09\n\n    // 计算当前时间的5个月后的时间,并打印\n    LocalDate date3 = localDate.minusMonths(5);\n    System.out.println("当前时间的5个月前时间: " + date3); // 当前时间的5个月前时间: 2019-09-13\n\n    // 计算当前时间的2年后的时间,并打印\n    LocalDate date = localDate.minusYears(2);\n    System.out.println("当前时间的2年前时间: " + date); // 当前时间的2年前时间: 2018-02-13\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n 2. LocalTime中对时间进行递增/减操作的方法\n\n方法                                               作用\nLocalTime minusNanos(long nanosToSubtract)       增加纳秒\nLocalTime minusSeconds(long secondsToSubtract)   增加秒\nLocalTime minusMinutes(long menutes)             增加分钟\nLocalTime minusHours(long hoursToSubtract)       增加小时\n\n/**\n * Minus方法在localTime中的使用\n * LocalTime minusNanos(long nanosToSubtract)增加纳秒\n * LocalTime minusSeconds(long secondsToSubtract)增加秒\n * LocalTime minusMinutes(long menutes)增加分钟\n * LocalTime minusHours(long hoursToSubtract)增加小时\n */\n@Test\npublic void test2() {\n    // 封装LocalTime对象参数为8点13分39秒218毫秒\n    LocalTime localTime = LocalTime.of(8, 13, 39, 218);\n    System.out.println("当前时间: " + localTime); // 当前时间: 08:13:39.000000218\n\n    // 计算当前时间500纳秒后的时间,并打印\n    LocalTime date1 = localTime.minusNanos(500);\n    System.out.println("当前时间500纳秒后的时间: " + date1); // 当前时间500纳秒后的时间: 08:13:39.000000718\n\n    // 计算当前时间45秒后的时间,并打印\n    LocalTime date2 = localTime.minusSeconds(45);\n    System.out.println("当前时间45秒后的时间: " + date2); // 当前时间45秒后的时间: 08:14:24.000000218\n\n\n    // 计算当前时间19分钟后的时间,并打印\n    LocalTime date3 = localTime.minusMinutes(19);\n    System.out.println("当前时间19分钟后的时间: " + date3); // 当前时间19分钟后的时间: 08:32:39.000000218\n\n    // 计算当前时间3小时后的时间,并打印\n    LocalTime date4 = localTime.minusHours(3);\n    System.out.println("当前时间3小时后的时间: " + date4); // 当前时间3小时后的时间: 11:13:39.000000218\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 3. plus/minus单独使用\n\n 1. plus方法\n\n方法                                                         作用\nLocalDate/LocalTime/LocalDateTime plus(TemporalAmount      \namountToAdd)\nLocalDate/LocalTime/LocalDateTime plus(long amountToAdd,   \nTemporalUnit unit)\n\n * TemporalAmount 是一个接口,当借口作为方法的参数的时候,实际上传入的是接口的实现类对象,根据查看这个接口的体系,可以看到这个接口有一个实现类,名字叫做 Period (表示一段时间)\n   \n   \n\n> Period of(int years, int months, int days): Period.of(1,2,3) 返回对象表示即为1年2月3天\n\n/**\n * 今天程序员小张查看自己的车辆的保险记录的时候看到还有2年3月8天就到期了,计算到期的时间是什么时候.\n * LocalDate plus(TemporalAmount amountToAdd)\n * Period.of(int years, int months, int days)\n */\n@Test\npublic void test3(){\n\n    // 1. 封装当前时间 -> now方法\n    LocalDateTime now = LocalDateTime.now();\n    System.out.println("当前时间: " + now); // 当前时间: 2020-08-21T06:34:36.627\n\n    // 2. 在当前时间的基础上,进行+年月日操作,获取一个截止日期对象,这个对象就是保险的到期时间\n    LocalDateTime endTime1 = now.plusYears(2).plusMonths(3).plusDays(8);\n    System.out.println("保险到期时间: " + endTime1); // 保险到期时间: 2022-11-29T06:34:36.627\n\n    // 3. 使用 plus 方法改进 TemporalAmount ---\x3e Period(实现类)\n    // Period.of(int years, int months, int days)\n    Period period = Period.of(2, 3, 8);\n    LocalDateTime endTime2 = now.plus(period); // 在当前时间的基础上增加\n    System.out.println("保险到期时间: " + endTime2); // 保险到期时间: 2022-11-29T06:34:36.627\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n * 在实际开发过程中可能还会更准确的操作日期或者说增加一些特殊的时间,比如说1个世纪,一个半天,一年...,Java8已经提供了这些日期的表示方法而不需要去单独进行计算了.\n   \n   TemporalUnit 是一个接口,通过查看体系接口发现,可以使用子类 ChronoUnit 来表示.\n   \n   \n\n * chronoUnit\n   \n   一组标准的日期时间单位。\n   \n   \n   \n   > 图片来源: jdk文档\n\n/**\n * 结婚10年称为锡婚,2020年2月2日11点11分11秒称为对称日,很多情侣准备在那天结婚,如果在那天结婚了,那么锡婚会发生在什么时候?\n * LocalDate/LocalTime/LocalDateTime plus(long amountToAdd, TemporalUnit unit)\n */\n@Test\npublic void test4() {\n    // 封装日期 -> 表示结婚的时间点\n    LocalDateTime marryTime = LocalDateTime.of(2020, Month.FEBRUARY, 2, 11, 11, 11);\n\n    // 1. 使用 plus() 进行计算,加上一个十年  ChronoUnit.DECADES : 代表十年\n    LocalDateTime time = marryTime.plus(1, ChronoUnit.DECADES);\n    System.out.println("如果在: " + marryTime + " 结婚, 那么锡婚的时间是: " + time); // 如果在: 2020-02-02T11:11:11 结婚, 那么锡婚的时间是: 2030-02-02T11:11:11\n\n    // 2. 如果锡婚后的半天,需要请所有的亲朋好友吃饭,计算吃饭的时间. ChronoUnit.HALF_DAYS : 代表半天\n    LocalDateTime cTime = time.plus(1, ChronoUnit.HALF_DAYS);\n    System.out.println("半天后, 请客吃放的时间为: " + cTime); // 半天后,请客吃放的时间为: 2030-02-02T23:11:11\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 2. minus方法\n\n方法                                                       作用\nLocalDate/LocalTime/LocalDateTime minus(long             \namountToSubtract, TemporalUnit unit)\nLocalDate/LocalTime/LocalDateTime minus(TemporalAmount   \namountToSubtract)\n\n> 使用方法同 plus\n\n# 4. with方法\n\n如果不需要对日期进行加减而是直接修改日期的话,那么可以使用with方法,with方法提供了许多种修改时间的方法.\n\n 1. 在LocalDateTime中的使用\n\n方法                                             作用\nLocalDateTime withNano(int nanoOfSecond)       修改纳秒\nLocalDateTime withSecond(int second)           修改秒\nLocalDateTime withMinute(int minute)           修改分钟\nLocalDateTime withHour(int hour)               修改小时\nLocalDateTime withDayOfMonth(int dayOfMonth)   修改日\nLocalDateTime withDayOfYear(int dayOfYear)     \nLocalDateTime withMonth(int month)             修改月\nLocalDateTime withYear(int year)               修改年\n\npublic static LocalDateTime getTime(){\n    // 2020.12.12 12:12:0\n    return LocalDateTime.of(1999, Month.DECEMBER,12,12,12,0);\n}\n\n/**\n *\n */\n@Test\npublic void test1(){\n    LocalDateTime time = getTime();\n    // 使用 with 方法修改\n    // 1. 经过使用发现 time 存在问题, 时间应为 1 号\n    LocalDateTime resultTime1 = time.withDayOfMonth(1);\n    System.out.println("修改前的错误时间: "+ time); // 修改前的错误时间: 1999-12-12T12:12\n    System.out.println("修改后的正确时间1: "+ resultTime1); //  修改后的正确时间: 1999-12-01T12:12\n\n    // 2. 修改为 2020.8.8 11:11:11:1\n    LocalDateTime resultTime2 = time.withYear(2020).withMonth(8).withDayOfMonth(8).withHour(11).withMinute(11).withSecond(11).withNano(1);\n    System.out.println("修改前的错误时间: "+ time); // 修改前的错误时间: 1999-12-12T12:12\n    System.out.println("修改后的正确时间2: "+ resultTime2); // 修改后的正确时间2: 2020-08-08T11:11:11.000000001\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n 2. with单独使用\n\n方法                                         作用\nwith(TemporalField field, long newValue)   \nwith(TemporalAdjuster adjuster)            \n\n * TemporalField是一个接口,通过查看体系结构,可以使用它的子类ChronoField\n   \n   \n\n * ChronoField中封装了一些日期时间中的组成部分,可以直接选择之后传入第二个参数进行修改.(参考)\n   \n   例; with(ChronoField.DAY_OF_MONTH,1): 将日期中的月份中的天数修改为1\n\n/**\n * with(TemporalField field, long newValue)\n */\n@Test\npublic void test2(){\n    LocalDateTime time = getTime();\n    // 使用 with 方法修改\n    // 1. 经过使用发现 time 存在问题, 时间应为 1 号\n    LocalDateTime resultTime1 = time.with(ChronoField.DAY_OF_MONTH, 1);\n    System.out.println("修改前的错误时间: "+ time); // 修改前的错误时间: 1999-12-12T12:12\n    System.out.println("修改后的正确时间1: "+ resultTime1); //  修改后的正确时间: 1999-12-01T12:12\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 5. 测试\n\n/**\n * @Description: <h1> 测试plus/with </h1>\n * 使用三种方式计算2019年7月19日14是38分34秒后的3年7个月18天后是什么时候\n */\npublic class TimeClassMethodPlusWithTest {\n\n    /**\n     * plus() Period\n     */\n    @Test\n    public void test1(){\n        // 封装当前时间 -> of()\n        LocalDateTime time = LocalDateTime.of(2019, Month.JULY, 19, 14, 38, 34);\n        // 通过Period封装一个时间段表示: 3年7个月18天后\n        Period period = Period.of(3, 7, 18);\n        // 通过plus()增加 Period 是 TemporalAmount 的一个实现类\n        LocalDateTime endTime = time.plus(period);\n        System.out.println("当前时间是: " + time + ", 3年7个月18天后: " + endTime);\n        // 当前时间是: 2019-07-19T14:38:34 3年7个月18天后: 2023-03-09T14:38:34\n    }\n\n    /**\n     * plus()\n     */\n    @Test\n    public void test2(){\n        // 封装当前时间 -> of()\n        LocalDateTime time = LocalDateTime.of(2019, Month.JULY, 19, 14, 38, 34);\n        // 通过plus()增加 3年7个月18天后\n        LocalDateTime endTime = time\n                .plusYears(3)\n                .withMonth(7)\n                .withDayOfMonth(18);\n        System.out.println("当前时间是: " + time + ", 3年7个月18天后: " + endTime);\n        // 当前时间是: 2019-07-19T14:38:34 3年7个月18天后: 2023-03-09T14:38:34\n    }\n\n    /**\n     * with()\n     */\n    @Test\n    public void test3(){\n        // 封装当前时间 -> of()\n        LocalDateTime time = LocalDateTime.of(2019, Month.JULY, 19, 14, 38, 34);\n        // 通过with 修改到 3年7个月18天后\n        LocalDateTime endTime = time\n                .withYear(2023)\n                .withMonth(3)\n                .withDayOfMonth(9);\n        System.out.println("当前时间是: " + time + ", 3年7个月18天后: " + endTime);\n        // 当前时间是: 2019-07-19T14:38:34 3年7个月18天后: 2023-03-09T14:38:34\n    }\n\n    /**\n     * with()\n     */\n    @Test\n    public void test4(){\n        // 封装当前时间 -> of()\n        LocalDateTime time = LocalDateTime.of(2019, Month.JULY, 19, 14, 38, 34);\n        // 通过with 修改到 3年7个月18天后\n        LocalDateTime endTime = time\n                .with(ChronoField.YEAR,2023)\n                .with(ChronoField.MONTH_OF_YEAR,3)\n                .with(ChronoField.DAY_OF_MONTH,9);\n        System.out.println("当前时间是: " + time + ", 3年7个月18天后: " + endTime);\n        // 当前时间是: 2019-07-19T14:38:34 3年7个月18天后: 2023-03-09T14:38:34\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 6.4 调节器TemporalAdjuster与查询TemporalQuery\n\n# 1. 调节器TemporalAdjuster\n\n在上一篇中介绍了,我们可以通过with方法修改日期时间对象中封装的数据,但是有一些时候可能会做一些复杂的操作,比如说将时间调整到下个周的周日,下一个工作日,又或者本月中的某一天,这个时候我们可以使用TemporalAdjuster来更方便的处理日期.\n\n方法                                作用\nwith(TemporalAdjuster adjuster)   \n\n> TemporalAdjuster: 是一个接口,with方法实际上传入的是这个接口的实现类对象, TemporalAdjusters并不是TemporalAdjuster的一个实现类,只不过TemporalAdjusters的静态方法石祥路TemporalAdjuster.并且将实现类对象返回了.\n\n方法                                                          作用\nstatic TemporalAdjuster firstDayOfMonth()                   当月的第一天\nstatic TemporalAdjuster lastDayOfMonth()                    当月的第一天\nstatic TemporalAdjuster firstDayOfNextMonth()               下一个月的第一天\nstatic TemporalAdjuster firstDayOfYear()                    当年的第一天\nstatic TemporalAdjuster lastDayOfYear()                     当年的第一天\nstatic TemporalAdjuster firstDayOfNextYear()                下一年的第一天\nstatic TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)   当月的第一个周x(通过参数确定)\nstatic TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)    当月的最后一个周x(通过参数确定)\n\nstatic TemporalAdjuster ofDateAdjuster(UnaryOperator<LocalDate> dateBasedAdjuster)\n\n\n1\n\n\n> TemporalAdjuster 是一个函数是接口,里面有一个抽象方法叫做 Temporal adjustInto(Temporal temporal) ;传入一个 Temporal 对象通过实现逻辑返回一个 Temporal 对象,Temporal 是 LocalDate,localTime相关日期类的父接口,\n\n@Test\npublic void test1() {\n    // 封装日期时间对象为当前对象\n    LocalDate now = LocalDate.now();\n\n    // 通过with()传入TemporalAdjuster类的实现类对象,就可以更改,实现类对象是由TemporalAdjuster s类的静态方法来提供.\n    // 1. 修改时间为当月的第一天\n    LocalDate firstDayOfMonth = now.with(TemporalAdjusters.firstDayOfMonth());\n    System.out.println("当月的第一天: " + firstDayOfMonth); // 当月的第一天: 2020-08-01\n\n    // 2. 修改时间为当月的最后第一天\n    LocalDate lastDayOfMonth = now.with(TemporalAdjusters.lastDayOfMonth());\n    System.out.println("当月的最后第一天: " + lastDayOfMonth); // 当月的最后第一天: 2020-08-31\n\n    // 3. 修改时间为下一个月的第一天\n    LocalDate firstDayOfNextMonth = now.with(TemporalAdjusters.firstDayOfNextMonth());\n    System.out.println("下一个月的第一天: " + firstDayOfNextMonth); // 下一个月的第一天: 2020-09-01\n\n    // 4. 修改时间为当年的第一天\n    LocalDate firstDayOfYear = now.with(TemporalAdjusters.firstDayOfYear());\n    System.out.println("当年的第一天: " + firstDayOfYear); // 当年的第一天: 2020-01-01\n\n    // 5. 修改时间为下一年的第一天\n    LocalDate firstDayOfNextYear = now.with(TemporalAdjusters.firstDayOfNextYear());\n    System.out.println("下一年的第一天: " + firstDayOfNextYear); // 下一年的第一天: 2021-01-01\n\n    // 6. 修改时间为当年的最后第一天\n    LocalDate lastDayOfYear = now.with(TemporalAdjusters.lastDayOfYear());\n    System.out.println("当年的最后第一天: " + lastDayOfYear); // 当年的最后第一天: 2020-12-31\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 2. DayOfWeek的使用\n\nDayOfWeek是一周中星期几的枚举类,其中封装了从周一到周日.\n\n/**\n * DayOfWeek\n * static TemporalAdjuster next(DayOfWeek dayOfWeek): 下一个周x\n * static TemporalAdjuster previous(DayOfWeek dayOfWeek): 上一个周x\n */\n@Test\npublic void test2(){\n    // 封装日期时间对象为当前对象\n    LocalDate now = LocalDate.now();\n\n    // 1. 将当前时间修改为下一月的周日\n    LocalDate date1 = now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));\n    System.out.println("当前日期: "+ now+ ", 下一月的周日; " + date1); // 当前日期: 2020-08-22, 下一月的周日; 2020-08-23\n\n    // 2. 将当前时间修改为上一个周三\n    LocalDate date2 = now.with(TemporalAdjusters.previous(DayOfWeek.WEDNESDAY));\n    System.out.println("当前日期: "+ now+ ", 上一月的周三; " + date2); // 当前日期: 2020-08-22, 上一月的周三; 2020-08-19\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3. 自定义TemporalAdjuster调节器\n\n通过Java8本身提供的TemporalAdjusters中的方法可以完成一些常用的操作,如果需要自定义日期时间的更改逻辑,可以通过实现TemporalAdjuster类的接口中的方式来完成.\n\n * 创建类实现TemporalAdjuster接口\n * 实现TemporalAdjuster中的adjustInto方法,传入一个日期时间对象,完成逻辑之后日期时间对象\n * 通过with方法传入自定义调节器对象完成更改.\n\n /**\n     * 例如员工一个月中领取工资,发薪日是每个月的15号,如果发薪日是周末,则调整为周五\n     * <p>\n     * 之后会传入一个日期类时间对象,判断日期类时间对象是不是15号,如果不是15号则修改为15号,如果是周六或者周日,则改为周五(上一个)\n     */\n    class PayDayAdjuster implements TemporalAdjuster {\n\n        @Override\n        public Temporal adjustInto(Temporal temporal) {\n            // 1. Temporal: 日期时间类对象的父接口,实际上可以理解为传入的就是LocalDate或者LocalTime对象.需要将temporal转换为LocalDate对象\n            LocalDate payDay = LocalDate.from(temporal);\n            // 2. 判断日期类时间对象是不是15号,如果不是15号则修改为15号\n            int day = 0;\n            if (payDay.getDayOfMonth() != 15) {\n                day = 15;\n            } else {\n                day = payDay.getDayOfMonth();\n            }\n            // with修改日期\n            LocalDate realPayDay = payDay.withDayOfMonth(day);\n            // 3. 判断readPayDay,如果是周六或者周日,则改为周五(上一个)\n            if (realPayDay.getDayOfWeek() == DayOfWeek.SATURDAY || realPayDay.getDayOfWeek() == DayOfWeek.SUNDAY) {\n                // 是周六/周日,修改为上一个周五\n                realPayDay = realPayDay.with(TemporalAdjusters.previous(DayOfWeek.FRIDAY));\n            }\n            return realPayDay;\n        }\n    }\n\n    /**\n     * 测试上面类是否可用\n     */\n    @Test\n    public void tes3() {\n        // 封装localDate对象为2018年12月1日\n        LocalDate payDay = LocalDate.of(2018, Month.DECEMBER, 1);\n\n        // 计算payDay的真实发薪日\n        Temporal temporal = new PayDayAdjuster().adjustInto(payDay);\n        // 转换\n        LocalDate localDate = LocalDate.from(temporal);\n        System.out.println("预计的发薪日: " + payDay + ", 真是的发薪日: " + localDate);\n        // 预计的发薪日: 2018-12-01, 真是的发薪日: 2018-12-14\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n> Temporal: 日期时间类对象的父接口,实际上可以理解为传入的就是LocalDate或者LocalTime对象.需要将temporal转换为LocalDate对象\n> \n> LocalDate.from():\n\n# 4. TemporalQuery的应用\n\n学习的是时态类对象(LocalDate,LocalTime)都有一个方法叫做query,可以针对日期进行查询.\n\nR query(TemporalQuery query)这个方法是一个泛型方法,返回的数据就是传入的泛型类的类型 TemporalQuery是一个泛型接口,包含一个抽象方法:\n\n方法\nR queryFrom(TemporalAccessor temporal)\n\n> TemporalAccessor: 是Temporal的父接口,实际上也就是LocalDate,LocalDateTime相关类的顶级父接口,这个queryFrom的方法的实现逻辑就是传入一个日期/时间通过自定义逻辑返回数据.\n\n/**\n * @Description: <h1> TemporalQuery查询使用 </h1>\n * 获取某一天距离下一个劳动节相隔天数的实现\n */\npublic class TimeClassTemporalQueryTest implements TemporalQuery<Long> {\n\n    @Override\n    public Long queryFrom(TemporalAccessor temporal) {\n        // 1. TemporalAccessor时localDate和localDateTime的顶级父接口,相当于localDate就是这个接口的实现类.将这个参数转换为LocalDate使用\n        LocalDate now = LocalDate.from(temporal); // now > 2020.1.17\n        // 2. 封装当年劳动节的时间 年份: now 月份: 5 日: 1\n        LocalDate laborDay = LocalDate.of(now.getYear(), Month.MAY, 1);\n        // 3. 判断当前时间是否已过当年的劳动节,则laborDay加一年 (判断月份是否为5月)\n//        if (laborDay.getMonth()==Month.MAY)\n        if (now.isAfter(laborDay)) { // isAfter() 现在的日期是否在当年5月1日之后\n            laborDay = laborDay.plusYears(1); // plus() 年份+1\n        }\n        // 4. 通过ChronoUnit的between()计算两个时间之间的差值\n        return ChronoUnit.DAYS.between(now, laborDay);\n    }\n\n    /**\n     * 计算当前时间距离下个劳动节多少天\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        // 封装当前时间\n        LocalDate now = LocalDate.now();\n        // 调用now的query方法,然后将我们自己的实现类TimeClassTemporalQueryTest作为参数传入\n        Long day = now.query(new TimeClassTemporalQueryTest());\n        System.out.println("当前的时间是: " + now + ", 计算当前时间距离下个劳动节多少天: " + day);\n        // 当前的时间是: 2020-08-22计算当前时间距离下个劳动节多少天: 252\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n# 5. 测试\n\n/**\n * @Description: <h1> 测试 </h1>\n * 计算任意时间与下一个圣诞季/儿童节/劳动节相差多少天?\n */\npublic class TemporalAdjusterAndTemporalQueryTest implements TemporalQuery<Long[]> {\n\n    /**\n     * @return 表示距离 圣诞季/儿童节/劳动节 三个节日的天数差额,0索引表示距离圣诞节,1索引表示距离儿童及,2索引表示劳动节\n     */\n    @Override\n    public Long[] queryFrom(TemporalAccessor temporal) {\n        // 1. 将temporal转换为localDate\n        LocalDate now = LocalDate.from(temporal);\n\n        // 2. 封装当年的 圣诞季/儿童节/劳动节 的日期对象 年: now的year 月+日: 各自对应日期\n        LocalDate date1 = LocalDate.of(now.getYear(), Month.DECEMBER, 25);\n        LocalDate date2 = LocalDate.of(now.getYear(), Month.JUNE, 1);\n        LocalDate date3 = LocalDate.of(now.getYear(), Month.MAY, 1);\n\n        // 3. 判断now是否超过了当 date1,date2,date3三个节日,如果超过则计算下一年的日期\n        if (now.isAfter(date1)) {\n            date1 = date1.plusYears(1); // +1\n        }\n        if (now.isAfter(date2)) {\n            date2 = date2.plusYears(1); // +1\n        }\n        if (now.isAfter(date3)) {\n            date3 = date3.plusYears(1); // +1\n        }\n\n        // 4. 通过ChronoUnit的between()计算两个时间之间的差值\n        Long[] longs = {ChronoUnit.DAYS.between(now, date1), ChronoUnit.DAYS.between(now, date2), ChronoUnit.DAYS.between(now, date3)};\n        return longs;\n    }\n\n    /**\n     * 计算任意时间与下一个圣诞季/儿童节/劳动节相差多少天?\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        // 1. 封装任意日期\n        LocalDate now = LocalDate.of(2020, Month.MAY, 30);\n\n        // 2. 调用now的query的方法查询三个节日的差值\n        Long[] longs = now.query(new TemporalAdjusterAndTemporalQueryTest());\n\n        // 3. 打印结果\n        System.out.println("当前时期: " + now + ", 距离下一个圣诞节: " + longs[0] + "天");\n        System.out.println("当前时期: " + now + ", 距离下一个儿童节: " + longs[1] + "天");\n        System.out.println("当前时期: " + now + ", 距离下一个劳动节: " + longs[2] + "天");\n        // 当前时期: 2020-05-30, 距离下一个圣诞节: 209天\n        // 当前时期: 2020-05-30, 距离下一个儿童节: 2天\n        // 当前时期: 2020-05-30, 距离下一个劳动节: 336天 \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 6.5 Date和LocalDate转换\n\nJava8中的java.time包中并没有提供太多的内置方式类转换java.util包中用预处理标准日期和时间的类,我们可以使用Instant类作为中介,也可以使用java.sql.Date和java.sql.Timestamp类提供的方法进行转换.\n\n# 1. java.util.Date类的转换\n\n 1. 使用Instant将java.util.Date转换为java.time.LocalDate\n\njava.time包中没有提供很多方式来进行直接转换,但是给之前的Date类,Calendar类在Java8都提供了一个新的方法: toInstant,可以将当前的对象,通过给Instant添加时区信息之后就可转换为LocalDate对象.\n\n /**\n     * java.util.Date ---\x3e LocalDate 对象之间的转换\n     */\n    @Test\n    public void test1() {\n        // 初始化Date对象\n        java.util.Date date = new java.util.Date();\n        // 1. 将Date对象转换为Instant对象 toInstant\n        Instant instant = date.toInstant();\n        // 2. Date类中国包含日期和时间信息,但是并不提供时区信息,和Instant类一样,通过Instant类的atZone()添加时区信息进行转换\n        ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());\n        // 3. 将ZonedDateTime通过toLocalDate()转换为LocalDate对象\n        LocalDate localDate = zonedDateTime.toLocalDate();\n        System.out.println("之前的Date对象: " + date + ", 转换之后LocalDate对象: " + localDate);\n        // 之前的Date对象: Sat Aug 22 16:14:27 CST 2020, 转换之后LocalDate对象: 2020-08-22\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> Date类中包含日期和时间信息,但是并不提供时区信息,和Instant类一样,通过Instant类的atZone()添加时区信息进行转换\n\n 2. 第二种方式\n\n将java.util.Date -> java.sql.Date -> java.util.Date方法通过构造方法传入毫秒值 --\x3e toLocalDate().(毫秒是可以通过java.util.Date的getTime方法类获取)\n\n/**\n * java.util.Date ---\x3e LocalDate 对象之间的转换 2\n */\n@Test\npublic void test2() {\n    // 初始化Date对象\n    java.util.Date ud = new java.util.Date();\n    // 1. 将 java.util.Date -> java.sql.Date  -> java.util.Date方法通过构造方法传入毫秒值 --\x3e toLocalDate()\n    java.sql.Date sd = new java.sql.Date(ud.getTime());\n    LocalDate localDate = sd.toLocalDate();\n    System.out.println("之前的java.util.Date对象: "+ ud);\n    System.out.println("之前的java.sql.Date对象: "+ sd);\n    System.out.println("之后的LocalDate对象: "+ localDate);\n    // 之前的java.util.Date对象: Sat Aug 22 16:42:08 CST 2020\n    // 之前的java.sql.Date对象: 2020-08-22\n    // 之后的LocalDate对象: 2020-08-22\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 2. java.sql.Date类的转换\n\njava.sql.Date类中,通过传入的一个毫秒值对象进行初始化,提供直接转换为localDate的方法: toLocalDate\n\n/**\n * java.sql.Date ---\x3e LocalDate\n */\n@Test\npublic void test2(){\n    // 初始化一个java.sql.Date对象\n    java.sql.Date date = new java.sql.Date(System.currentTimeMillis());\n    // java.sql.Date类中自带转换为LocalDate的方法,toLocalDate();\n    LocalDate localDate = date.toLocalDate();\n    System.out.println("之前的Date对象: " + date + ", 转换之后LocalDate对象: " + localDate);\n    // 之前的Date对象: 2020-08-22, 转换之后LocalDate对象: 2020-08-22\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 3. java.sql.Timestamp类的转换\n\nTimestamp是时间戳对象,通过传入的一个毫秒值对象进行初始化.提供直接转换为localDateTime的方法: toLocalDateTime\n\n/**\n * java.sql.Timestamp ---\x3e LocalDate\n */\n@Test\npublic void test3(){\n    // 初始化一个java.sql.timestamp对象\n    Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n    // java.sql.Timestamp类中自带转换为LocalDate的方法,toLocalDateTime();\n    LocalDateTime localDateTime = timestamp.toLocalDateTime();\n    System.out.println("之前的Timestamp对象: " + timestamp + ", 转换之后LocalDate对象: " + localDateTime);\n    // 之前的Timestamp对象: 2020-08-22 16:31:17.165, 转换之后LocalDate对象: 2020-08-22T16:31:17.165\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 4. java.util.Calendar类的转换\n\n 1. Calendar转换为ZonedDateTime\n\nCalendar对象字java1.1开始提供了一个方法获取时区对象的方法,getTimeZone,要将Calendar对象转换为ZonedDateTime需要现获取到时区对象,自java8开始TImeZone类提供了一个方法可以获取到ZoneId,获取到ZoneID之后就可以初始化ZonedDateTime对象了,ZonedDateTime类有一个ofInstant方法,可以将Instant对象和ZonedId对象作为参数传入构造一个ZonedDateTime对象.\n\n方法                                                      作用\nCalendar.getInstance()                                  初始化Calendar对象\nTimeZone getTimeZone()                                  获取时区\nZoneId toZoneId()                                       根据时区获取 ZoneId\nZonedDateTime ofInstant(Instant instant, ZoneId zone)   将一个Instant对象和ZoneId队形封装为ZonedDateTime\n\n/**\n * Calendar ---\x3e ZonedDateTime\n */\n@Test\npublic void test1(){\n    // 1. 初始化Calendar对象 (Date和Calendar提供 转换为Instant的方法: toInstant)\n    Calendar calendar = Calendar.getInstance();\n    // 2. Calendar对象自java1.1提供了一个方法用于获取时区对象getTimeZone(),要将Calendar对象转换为ZonedDateTime对象要现获取到市区对象\n    TimeZone timeZone = calendar.getTimeZone();\n    // 3. TimeZone从1.8开始提供一个方法(toZoneId)获取到ZoneId -> 根据ZoneId构建ZonedDateTime对象\n    ZoneId zoneId = timeZone.toZoneId();\n    // 4. ZonedDateTime类有一个ofInstant方法,可以将一个Instant对象和ZoneId队形封装为ZonedDateTime\n    ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(calendar.toInstant(), zoneId);\n    System.out.println("之前的Calendar对象: " + calendar);\n    System.out.println("之后的ZonedDateTime对象: " + zonedDateTime);\n    // 之前的Calendar对象: java.util.GregorianCalendar[time=1598087373926,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=7,WEEK_OF_YEAR=34,WEEK_OF_MONTH=4,DAY_OF_MONTH=22,DAY_OF_YEAR=235,DAY_OF_WEEK=7,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=5,HOUR_OF_DAY=17,MINUTE=9,SECOND=33,MILLISECOND=926,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    // 之后的ZonedDateTime对象: 2020-08-22T17:09:33.926+08:00[Asia/Shanghai]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. Calendar转换为LocalDateTime\n\nCalendar对象可以获取到年月日时分秒的信息,这些信息可以作为LocalDateTime构造方法的参数\n\n/**\n * Calendar ---\x3e LocalDateTime\n */\n@Test\npublic void test2() {\n    // 1. 初始化Calendar对象 (Date和Calendar提供 转换为Instant的方法: toInstant)\n    Calendar calendar = Calendar.getInstance();\n    // 2. 通过get()获取Calendar中封装的数\n    int year = calendar.get(Calendar.YEAR);\n    int month = calendar.get(Calendar.MONTH);\n    int day = calendar.get(Calendar.DAY_OF_MONTH);\n    int hor = calendar.get(Calendar.HOUR_OF_DAY);\n    int minute = calendar.get(Calendar.MINUTE);\n    int second = calendar.get(Calendar.SECOND);\n    // 3. 将上述结果作为LocalDateTime的of()的参数 注意: Calendar的月份 需要+1\n    LocalDateTime localDateTime = LocalDateTime.of(year, month + 1, day, hor, minute, second);\n    System.out.println("之前的Calendar对象: " + calendar);\n    System.out.println("之后的ZonedDateTime对象: " + localDateTime);\n    // 之前的Calendar对象: java.util.GregorianCalendar[time=1598088161179,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=7,WEEK_OF_YEAR=34,WEEK_OF_MONTH=4,DAY_OF_MONTH=22,DAY_OF_YEAR=235,DAY_OF_WEEK=7,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=5,HOUR_OF_DAY=17,MINUTE=22,SECOND=41,MILLISECOND=179,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    // 之后的ZonedDateTime对象: 2020-08-22T17:25:28\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 5. 日期的解析与格式化DateTimeFormatter\n\nSimpleDateFormat类是线程不安全的,Java8提供了新的格式化类 DateTimeFormatter.\n\nDateTimeFormatter: 提供了大量预定义格式化器,包括常量(如: ISO_LOCAL_DATE),模式字母(如: yyyy-MM-dd)以及本地化样式.\n\n与SimpleDateFormat不同的是,新版本的日期/时间API的格式化与解析不需要创建转换器对象在进行转换了,通过日期时间对象的parse/format方法可以直接尽心转化.\n\n 1. LocalDateTime的parse/format\n\n@Override  // override for Javadoc and performance\npublic String format(DateTimeFormatter formatter) {\n    Objects.requireNonNull(formatter, "formatter");\n    return formatter.format(this);\n}\n\n\n1\n2\n3\n4\n5\n\n\n> format方法需要传入一个DateTimeFormatter对象.\n\n/**\n * 对LocalDateTime进行格式化和解析\n */\n@Test\npublic void test1(){\n    // 初始化LocalDateTime对象\n    LocalDateTime now = LocalDateTime.now();\n\n    // now可以直接调用format进行格式化\n    String s1 = now.format(DateTimeFormatter.ISO_DATE_TIME);\n    String s2 = now.format(DateTimeFormatter.ISO_DATE);\n    System.out.println("ISO_DATE_TIME格式化后: " + s1);\n    System.out.println("ISO_DATE格式化后: " + s2);\n    // ISO_DATE_TIME格式化后: 2020-08-22T17:39:37.916\n    // ISO_DATE格式化后: 2020-08-22\n\n    // 解析parse\n    LocalDateTime localDateTime1 = LocalDateTime.parse(s1);\n    System.out.println(localDateTime1); // 2020-08-22T17:41:06.634\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 2. DateTimeFormatter的ofLocalizedDate()\n\npublic static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle) {\n    Objects.requireNonNull(dateStyle, "dateStyle");\n    return new DateTimeFormatterBuilder().appendLocalized(dateStyle, null)\n            .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n}\n\n\n1\n2\n3\n4\n5\n\n\n此方法需要传入一个FormStyle类对象,查看后发现FormatStyle对象是一个枚举类:\n\n值        描述\nFULL     全显示(年月日+星期)\nLONG     全显示(年月日)\nMEDIUM   缩略显示(没有年月日汉字)\nSHORT    精简显示(精简年+月日)\n\n/**\n * ofLocalizedDate()使用\n */\n@Test\npublic void test2(){\n    // 初始化LocalDateTime对象\n    LocalDateTime now = LocalDateTime.now();\n\n    // 通过DateTimeFormatter的ofLocalizedDate指定解析格式\n    String s1 = now.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL));\n    String s2 = now.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG));\n    String s3 = now.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM));\n    String s4 = now.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT));\n\n    System.out.println("FULL: " + s1);\n    System.out.println("LONG: " + s2);\n    System.out.println("MEDIUM: " + s3);\n    System.out.println("SHORT: " + s4);\n    // FULL: 2020年8月22日 星期六\n    // LONG: 2020年8月22日\n    // MEDIUM: 2020-8-22\n    // SHORT: 20-8-22\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 注意: 此种方式在不同时区的显示方式不一样,在其他时区不会显示中文,会根据当先系统默认的时区类进行区别显示.\n\n 3. 自定义格式化日期\n\n除了系统自带的方式之外,也可以通过DateTimeFormatter类提供的orPattern方式创建自定义的格式化器,格式化的写法与之前使用到的SimpleDateFormat相同\n\n\n\n/**\n * 自定义格式化器\n */\n@Test\npublic void test3() {\n    // 初始化LocalDateTime对象\n    LocalDateTime now = LocalDateTime.now();\n\n    String s = now.format(DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss:SSS"));\n\n    System.out.println("LocalDateTime格式化后的内容:  " + s);\n    // LocalDateTime格式化后的内容:  2020/08/22 18:01:44:189\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 4. 测试\n\n/**\n * 将1998年3月18日17时19分28秒格式化为以下格式化和或或或或i:1998-03月-8---17:19分:28秒\n * <p>\n * 格式: yyyy-MM月-dd---HH:mm分:ss秒\n */\n@Test\npublic void test4() {\n    // 初始化LocalDateTime对象\n    LocalDateTime now = LocalDateTime.of(1998,\n            Month.MARCH,\n            18,\n            17,\n            19,\n            28);\n    String s = now.format(DateTimeFormatter.ofPattern("yyyy-MM月-dd---HH:mm分:ss秒"));\n    System.out.println("之前: " + now);\n    System.out.println("之后: " + s);\n    // 之前: 1998-03-18T17:19:28\n    // 之后: 1998-03月-18---17:19分:28秒\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',normalizedContent:'# java8新特性\n\n\n# 1. lamda表达式 [函数式编程]\n\nlambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。\n\njava中,我们无法将函数作为参数传递给一个方法,也无法声明一个函数的方法.\n\nlambda作用\n\nlambda : lambda表达式的"类型是函数",但在java中.lambda表达式是"对象",但他们必须依附于一类特别多对象类型---"函数式接口\n\n\n1\n\n * 传递行为,而不是值\n   * 提升抽象层次\n   * api重用性更好\n   * 更加灵活\n\nlambda概要\n\n * java lambda 表达式是一种匿名函数; 它是没有声明的方法, 即没有访问修饰符.返回值声明和名字\n\n\n# 1.1 lambda表达式入门\n\n# 1. 匿名内部类(优化) ---》 lambad\n\n// 匿名内部类 \njbutton.addactionlistener(new actionlistener() {\n       @override\n       public void actionperformed(actionevent e) {\n       system.out.println("button pressed");\n       }\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// lambda 表达式\n  jbutton.addactionlistener(event -> {\n      system.out.println("button pressed");\n      system.out.println("button");\n  });\n\n\n1\n2\n3\n4\n5\n\n\n# 2. lambda表达式基本结构\n\n语法:\n\n (argument) -> {body}\n \n (atg1,arg2...) -> {body}\n (type1 arg1,type2 arg2...) -> {body}\n\n\n1\n2\n3\n4\n\n\n(param1.param2,param3) -> {\n\n}\n\n\n1\n2\n3\n\n\n结构\n\n\n# 1.2 lambda使用 list集合(遍历)\n\n   list<integer> list = arrays.aslist(1, 2, 3, 4, 5, 6, 7, 8);\n        // 遍历方式一\n        for (int i = 0; i < list.size(); i++) {\n            system.out.println(list.get(i));\n        }\n        system.out.println("---------");\n        // 遍历方式二 1.5之后\n        for (integer i : list) {\n            system.out.println(i);\n        }\n        system.out.println("---------");\n        // 遍历方式三 1.8 匿名内部类\n        list.foreach(new consumer<integer>() {\n            @override\n            public void accept(integer integer) {\n                system.out.println(integer);\n            }\n        });\n\t\t// lambda 表达式\n        list.foreach(l -> system.out.println(l));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nlambda 以及 方法引用\n\n \t\t// lambda 表达式\n        // list.foreach(l -> system.out.println(l));\n\t\t// 方法引用 优化\n        list.foreach(system.out::println);\n\n\n1\n2\n3\n4\n\n\n\n# 1.3 函数式接口 😄\n\n# 1. 关于函数式接口: 😄\n\n@functionalinterface\npublic interface myinterface {\n    /**\n     * 抽象方法\n     */\n    void test();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 注意: 重载的方法,可以与共存 如: tostring()\n\n1. 如果一个接口只有一个(抽象方法),那么该接口就是一个"函数式接口".\n2. 如果我们在某个接口上声明了functionalinterface(@functionalinterface注解),那么编译器就会按照"函数式接口"的定义来要求该接口.\n3. 如果某个接口只有一个(抽象方法),但我们并没有给该接口声明@functionalinterface注解,那么编译器依旧会将该接口看做"函数式接口".\n\n\n1\n2\n3\n\n\n# 2. 函数式接口使用\n\n# 1. 入门\n\n/**\n * @author: chggx\n * @date: 2020/03/29 0:08\n * @description: <h1> 函数式接口 </h1>\n * 1. 当接口只有一个抽象方法时: 为函数式接口\n * 2. 多个抽象方法时: 不为函数式接口\n * 3. 重载的方法,可以与共存 tostring()\n */\n@functionalinterface\ninterface myinterface {\n    /**\n     * 抽象方法: 交给子类实现\n     */\n    void test();\n\n    /**\n     * 方法: 继承自object类(顶级类), 本类实现\n     * @return\n     */\n    @override\n    string tostring();\n}\n\n/**\n * @author chggx\n * 函数式接口测试\n */\npublic class functionalinterfacetest {\n\n    public void mytest(myinterface myinterface) {\n        system.out.println(1);\n        myinterface.test();\n        system.out.println(2);\n    }\n\n    public static void main(string[] args) {\n        functionalinterfacetest test = new functionalinterfacetest();\n        // 匿名内部类\n        test.mytest(new myinterface() {\n            @override\n            public void test() {\n                system.out.println("mytest");\n            }\n        });\n        system.out.println("----------");\n            // lambda表达式\n            test.mytest(() -> {\n                system.out.println("mytest");\n            });\n        system.out.println(myinterface.class);\n        system.out.println(myinterface.class.getsuperclass());\n        system.out.println(myinterface.class.getinterfaces()[0]);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n# 2. 深入\n\npackage com.chggx.jdk8.inter;\n\nimport java.util.arraylist;\nimport java.util.arrays;\nimport java.util.list;\n\n/**\n * @author: chggx\n * @date: 2020/03/29 1:27\n * @description: <h1> 函数式接口测试 </h1>\n * 1. lambda表达式\n * 2. stream流\n * 3. 方法引用\n */\npublic class functionalinterfacetest2 {\n\n    public static void main(string[] args) {\n        // 1. lambda表达式的类型根据 "上下文" 断定\n        theinterface t1 = () -> {\n        };\n        system.out.println(t1.getclass().getinterfaces()[0]);\n\n        theinterface2 t2 = () -> {\n        };\n        system.out.println(t2.getclass().getinterfaces()[0]);\n\n        // 2. 线程接口  runnable: @functionalinterface 函数式接口\n        // 线程thread 使用线程接口 runnable(lambda) 由于是函数是接口,可以直接使用lambda\n        new thread(() -> system.out.println("hello word!")).start();\n\n        // 3. 将集合中的每个元素变为"大写"\n        list<string> list = arrays.aslist("hello", "word", "hello word");\n        // 使用java8 consumer 函数式接口\n        // touppercase() 方法将字符串小写字符转换为大写。\n        list.foreach(item -> system.out.println(item.touppercase()));\n\n        system.out.println("-------------------");\n\n        // 3.1 将值存入一个新的集合\n        // diamond  new arraylist<string>(): string类型省略 1.6 后支持\n        list<string> targetlist = new arraylist<string>();\n        // 3.1.1 先遍历集合1,放入目标集合\n        list.foreach(item -> targetlist.add(item.touppercase()));\n        // 3.1.2 遍历目标集合 system.out.println(target) ---\x3e  方法引用 system.out::println\n        targetlist.foreach(system.out::println);\n\n\n        // 3.2 优化 3.1 步骤\n        // stream流 的方式\n        // lambda形式\n        system.out.println("------lambda形式------");\n        list.stream()\n                // 方法将字符串小写字符转换为大写。\n                .map(item -> item.touppercase())\n                .foreach(item -> system.out.println(item));\n        system.out.println("------方法引用------");\n        // 方法引用形式\n        list.stream()\n                // 方法将字符串小写字符转换为大写。\n                // item -> item.touppercase() ----\x3e string::touppercase(方法引用)\n                .map(string::touppercase)\n                // item -> system.out.println(item) --\x3e system.out::println\n                .foreach(system.out::println);\n\n\n    }\n\n}\n\n/**\n * @author: chggx\n * @date: 2020/03/29 0:08\n * @description: <h1> 函数式接口 </h1>\n * 1. 当接口只有一个抽象方法时: 为函数式接口\n * 2. 多个抽象方法时: 不为函数式接口\n */\n@functionalinterface\ninterface theinterface {\n    /**\n     * 抽象方法: 交给子类实现\n     */\n    void method();\n}\n\n/**\n * @author: chggx\n * @date: 2020/03/29 0:08\n * @description: <h1> 函数式接口 </h1>\n * 1. 当接口只有一个抽象方法时: 为函数式接口\n * 2. 多个抽象方法时: 不为函数式接口\n */\n@functionalinterface\ninterface theinterface2 {\n    /**\n     * 抽象方法: 交给子类实现\n     */\n    void method2();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n\n# 1.4 接口 😄\n\n接口（英文：interface），在java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n# 1. 接口与类相似点：\n\n * 一个接口可以有多个方法。\n * 接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n * 接口的字节码文件保存在 .class 结尾的文件中。\n * 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n# 2. 接口与类的区别：\n\n * 接口不能用于实例化对象。\n * 接口没有构造方法。\n * 接口中所有的方法必须是抽象方法。\n * 接口不能包含成员变量，除了 static 和 final 变量。\n * 接口不是被类继承了，而是要被类实现。\n * 接口支持多继承。\n\n# 3. 接口特性\n\n * 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。\n * 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。\n * 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n# 4. 抽象类和接口的区别\n\n * 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n * 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。\n * 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n * 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n> 注：jdk 1.8 以后，接口里可以有静态方法和方法体了。\n\n# 5. 接口为什么引入静态方法?\n\n * 向后兼容 [sort]\n\n----------------------------------------\n\n\n# 2. funcation接口\n\n序号   接口 & 描述\n1    **biconsumer(t,u)**代表了一个接受两个输入参数的操作，并且不返回任何结果\n2    **bifunction(t,u,r)**代表了一个接受两个输入参数的方法，并且返回一个结果 ,继承\n3    **binaryoperator(t)**代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果,bifunction\n4    **bipredicate(t,u)**代表了一个两个参数的boolean值方法\n5    booleansupplier代表了boolean值结果的提供方\n6    **consumer(t)**代表了接受一个输入参数并且无返回的操作\n7    doublebinaryoperator代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。\n8    doubleconsumer代表一个接受double值参数的操作，并且不返回结果。\n9    **doublefunction(r>**代表接受一个double值参数的方法，并且返回结果\n10   doublepredicate代表一个拥有double值参数的boolean值方法\n11   doublesupplier代表一个double值结构的提供方\n12   doubletointfunction接受一个double类型输入，返回一个int类型结果。\n13   doubletolongfunction接受一个double类型输入，返回一个long类型结果\n14   doubleunaryoperator接受一个参数同为类型double,返回值类型也为double 。\n15   **function(t,r)**接受一个输入参数，返回一个结果。\n16   intbinaryoperator接受两个参数同为类型int,返回值类型也为int 。\n17   intconsumer接受一个int类型的输入参数，无返回值 。\n18   **intfunction(r)**接受一个int类型输入参数，返回一个结果 。\n19   intpredicate：接受一个int输入参数，返回一个布尔值的结果。\n20   intsupplier无参数，返回一个int类型结果。\n21   inttodoublefunction接受一个int类型输入，返回一个double类型结果 。\n22   inttolongfunction接受一个int类型输入，返回一个long类型结果。\n23   intunaryoperator接受一个参数同为类型int,返回值类型也为int 。\n24   longbinaryoperator接受两个参数同为类型long,返回值类型也为long。\n25   longconsumer接受一个long类型的输入参数，无返回值。\n26   **longfunction(r)**接受一个long类型输入参数，返回一个结果。\n27   longpredicater接受一个long输入参数，返回一个布尔值类型结果。\n28   longsupplier无参数，返回一个结果long类型的值。\n29   longtodoublefunction接受一个long类型输入，返回一个double类型结果。\n30   longtointfunction接受一个long类型输入，返回一个int类型结果。\n31   longunaryoperator接受一个参数同为类型long,返回值类型也为long。\n32   **objdoubleconsumer(t)**接受一个object类型和一个double类型的输入参数，无返回值。\n33   **objintconsumer(t)**接受一个object类型和一个int类型的输入参数，无返回值。\n34   **objlongconsumer(t)**接受一个object类型和一个long类型的输入参数，无返回值。\n35   **predicate(t)**接受一个输入参数，返回一个布尔值结果。\n36   **supplier(t)**无参数，返回一个结果。\n37   **todoublebifunction(t,u)**接受两个输入参数，返回一个double类型结果\n38   **todoublefunction(t)**接受一个输入参数，返回一个double类型结果\n39   **tointbifunction(t,u)**接受两个输入参数，返回一个int类型结果。\n40   **tointfunction(t)**接受一个输入参数，返回一个int类型结果。\n41   **tolongbifunction(t,u)**接受两个输入参数，返回一个long类型结果。\n42   **tolongfunction(t)**接受一个输入参数，返回一个long类型结果。\n43   **unaryoperator(t)**接受一个参数为类型t,返回值类型也为t。\n\n注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 list(t) 指的是 list<t>. \n\n\n1\n\n\n\n# 2.1 funcation ==apply (compose andthen) identity==\n\n接收一个参数,返回结果\n\nlambda 行为\n\n# 1. 接口\n\n@functionalinterface\npublic interface function<t, r> {\n\n    r apply(t t);\n\t\n    // before\n    default <v> function<v, r> compose(function<? super v, ? extends t> before) {\n        objects.requirenonnull(before);\n        return (v v) -> apply(before.apply(v));\n    }\n    \n\t// after\n    default <v> function<t, v> andthen(function<? super r, ? extends v> after) {\n        objects.requirenonnull(after);\n        return (t t) -> after.apply(apply(t));\n    }\n\n    static <t> function<t, t> identity() {\n        return t -> t;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 2. 入门案例\n\n/**\n * @author: chggx\n * @date: 2020/03/29 11:48\n * @description: <h1> lambda传递的是"行为" </h1>\n */\npublic class functiontest {\n\n    public static void main(string[] args) {\n        functiontest test = new functiontest();\n        //// 普通的加减乘除[方法写死]\n        system.out.println(test.method1(1));\n        system.out.println(test.method2(2));\n        system.out.println(test.method3(3));\n\n        // lambda 行为 function[灵活]\n        // statement (return ....)\n        system.out.println(test.compute(\n                1, value -> {\n                    return 2 * value; \n                }\n        ));\n        // 改进  expression .... (无花括号)\n        system.out.println(test.compute(\n                2, value -> 5 + value\n        ));\n        system.out.println(test.compute(\n                3, value -> value * value\n        ));\n\n\t\t // 不同类型的数据运算\n        system.out.println(test.convert(\n                5, value -> string.valueof(value + " hello word")\n        ));\n    }\n\n    public int compute(int a, function<integer, integer> function) {\n        return function.apply(a);\n    }\n\n    public string convert(int a, function<integer, string> function) {\n        return function.apply(a);\n    }\n\n    public int method1(int a) {\n        return 2 * a;\n    }\n    public int method2(int a) {\n        return 5 + a;\n    }\n    public int method3(int a) {\n        return a * a;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 3. 深入 compose与andthen\n\n/**\n * @author: chggx\n * @date: 2020/03/29 12:27\n * @description: <h1> function使用 </h1>\n * 1. compose 先执行2在执行1 (先计算输入参数[2]的apply,把[2]的结果作为[1]的输入参数计算)\n * 2. andthen 先执行1在执行2\n */\npublic class functiontest2 {\n\n    public static void main(string[] args) {\n\n        functiontest2 test2 = new functiontest2();\n        system.out.println(\n                // 1.function1:  value * 3  2. function2: value * value\n                // compose: 先执行 function2 2 * 2 = 4\n                // 再执行 function1 4 * 3 = 12\n                test2.compute(2, value -> value * 3, value -> value * value)\n        );\n        system.out.println(\n                // andthen: 先执行 function1,后执行 function2\n                // 2 * 3 = 6 ---\x3e 6 * 6 = 36\n                test2.compute2(2, value -> value * 3, value -> value * value)\n        );\n\n    }\n\n\n   /**\n     *  default <v> function<v, r> compose(function<? super v, ? extends t> before)\n     * compose 先执行function2在执行function1 (先计算输入参数[2]的apply,把[2]的结果作为[1]的输入参数计算)\n     */\n    public int compute(int a, function<integer, integer> function1,\n                       function<integer, integer> function2) {\n        // compose  function2\n        return function1.compose(function2).apply(a);\n    }\n\n    /**\n     * default <v> function<t, v> andthen(function<? super r, ? extends v> after)\n     * andthen: 先执行 function1,后执行 function2\n     */\n    public int compute2(int a, function<integer, integer> function1,\n                        function<integer, integer> function2) {\n        // andthen\n        return function1.andthen(function2).apply(a);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 2.2 bifunction ==apply andthen==\n\n接收两个参数,返回一个结果\n\n * 没有compose: 由于bifunction(接收两个参数,返回一个结果) 先执行后面方法时,返回的结果只有一个,不能作为bifunction的参数[不成立]\n\n# 1. 接口\n\n@functionalinterface\npublic interface bifunction<t, u, r> {\n\n    r apply(t t, u u);\n\n    default <v> bifunction<t, u, v> andthen(function<? super r, ? extends v> after) {\n        objects.requirenonnull(after);\n        return (t t, u u) -> after.apply(apply(t, u));\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 2. 用法示例\n\n/**\n * @author: chggx\n * @date: 2020/03/29 12:49\n * @description: <h1> bifunction </h1>\n * 接收两个参数,返回一个结果\n *  没有compose: 由于bifunction(接收两个参数,返回一个结果) 先执行后面方法时,返回的结果只有一个,不能作为bifunction的参数[不成立]\n */\npublic class bifunctiontest {\n\n    public static void main(string[] args) {\n\n        bifunctiontest test = new bifunctiontest();\n        // 1.\n        system.out.println(\n                // 和\n//                test.compute(1, 2, (value1, value2) -> value1 + value2)\n                test.compute(1, 2, integer::sum)\n        );\n        system.out.println(\n                // 差\n//                test.compute(1, 2, (value1, value2) -> value1 - value2)\n                test.compute(1, 2, (value1, value2) -> value1 - value2)\n        );\n        system.out.println(\n                // 乘\n                test.compute(1, 2, (value1, value2) -> value1 * value2)\n        );\n        system.out.println(\n                // 除\n                test.compute(1, 2, (value1, value2) -> value1 / value2)\n        );\n\n        // 2.\n        system.out.println(\n                // 和\n//                test.compute(2, 3, (value1, value2) -> value1 + value2,, value -> value * value)\n                // andthen: 先执行bifunction,在执行function 2+3=5 5*5=25\n                test.compute2(2, 3, integer::sum, value -> value * value)\n        );\n        system.out.println(\n                // 差\n                // andthen: 先执行bifunction,在执行function 2-3=-1 -1*-1=1\n                test.compute2( 2, 3,(value1, value2) -> value1 - value2,value -> value * value)\n        );\n        system.out.println(\n                // 乘\n                // andthen: 先执行bifunction,在执行function 2*3=6 6*6=36\n                test.compute2(2,3, (value1, value2) -> value1 * value2,value -> value * value)\n        );\n        system.out.println(\n                // 除\n                // andthen: 先执行bifunction,在执行function 2/3=2/3 (2/3)*(2/3)\n                test.compute2( 2,3, (value1, value2) -> value1 / value2,value -> value * value)\n        );\n\n    }\n\n    /**\n     * bifunction  接收两个参数,返回一个结果\n     *\n     * @param a          参数一\n     * @param b          参数二\n     * @param bifunction 函数\n     * @return 结果\n     */\n    public int compute(int a, int b, bifunction<integer, integer, integer> bifunction) {\n        return bifunction.apply(a, b);\n    }\n\n     /**\n     * default <v> bifunction<t, u, v> andthen(function<? super r, ? extends v> after)\n     * andthen:  先执行bifunction,在执行function [接收两个参数,返回一个结果]\n     */\n    public int compute2(int a, int b, bifunction<integer, integer, integer> bifunction, function<integer, integer> function) {\n\n        return bifunction.andthen(function).apply(a, b);\n    }\n\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public int subtract(int a, int b) {\n        return a - b;\n    }\n\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n# 3. 深入使用\n\nperson 实体类 第三种用法 bifunction\n\n/**\n * @author: chggx\n * @date: 2020/03/29 16:46\n * @description: <h1> bifunction: 接收两个参数,返回一个结果 </h1>\n */\npublic class persontest {\n\n    public static void main(string[] args) {\n\n        person person1 = new person("zhangsan", 20);\n        person person2 = new person("lisi", 30);\n        person person3 = new person("wangwu", 40);\n\t\t// 将对象封装为集合\n        list<person> personlist = arrays.aslist(person1, person2, person3);\n\n        persontest test = new persontest();\n        // 1. 根据名称获取[必须规定name]getpersonbyusername\n        list<person> personresult = test.getpersonbyusername("zhangsan", personlist);\n        personresult.foreach(person -> system.out.println(person.getusername()));\n\n        system.out.println("--------------");\n\n        // 2. 选出大于指定年龄的[必须规定age]getpersonsbyage\n        list<person> personresult2 = test.getpersonsbyage(20, personlist);\n        personresult2.foreach(person -> system.out.println(person.getage()));\n\n        system.out.println("--------------");\n\n        // 3. 选出大于指定年龄的 [灵活应用]getpersonsbyage2\n        list<person> personresult3 = test.getpersonsbyage2(\n                // 3个参数: 1.age 2.personlist 3. bifunction: 接收两个参数,返回一个结果\n                20, personlist, (age, persons) -> persons.stream()\n                        // 大于指定年龄\n                        .filter(person -> person.getage() > age)\n                        .collect(collectors.tolist())\n        );\n        personresult3.foreach(person -> system.out.println(person.getage()));\n\n        system.out.println("--------------");\n\n        // 4. 选出小于等于指定年龄的 [灵活应用]getpersonsbyage2\n        list<person> personresult4 = test.getpersonsbyage2(\n                20, personlist, (age, persons) -> persons.stream()\n                        .filter(person -> person.getage() <= age)\n                        .collect(collectors.tolist())\n        );\n        personresult4.foreach(person -> system.out.println(person.getage()));\n\n    }\n\n    public list<person> getpersonbyusername(string username, list<person> personlist) {\n        // stream 流\n        return personlist.stream()\n                .filter(person -> person.getusername().equals(username))\n                // 转换为 list\n                .collect(collectors.tolist());\n    }\n\n    /** stream流过滤 filter\n     * 年龄大于给定参数(age)\n     */\n    public list<person> getpersonsbyage(int age, list<person> personlist) {\n        // bifunction函数: 接收两个参数,返回一个结果\n        // lambda:  [expression lambda]\n        bifunction<integer, list<person>, list<person>> bifunction =\n                (ageofperson, persons) -> persons.stream()\n                        // 选择出 年龄大于给定的参数[age] person.getage()>age\n                        .filter(person -> person.getage() > age)\n                        .collect(collectors.tolist());\n        // 应用\n        return bifunction.apply(age, personlist);\n    }\n\n    public list<person> getpersonsbyage2(int age, list<person> personlist,\n                                         bifunction<integer, list<person>, list<person>> bifunction) {\n        return bifunction.apply(age, personlist);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# 2.3 predicate接口 ==test (and or negate) isequal==\n\n * 接收参数,返回boolean值\n\n# 1. 接口\n\n**传递行为,**而不是传递值\n\n@functionalinterface\npublic interface predicate<t> {\n\n    boolean test(t t);\n\n    default predicate<t> and(predicate<? super t> other) {\n        objects.requirenonnull(other);\n        return (t) -> test(t) && other.test(t);\n    }\n\n    default predicate<t> negate() {\n        return (t) -> !test(t);\n    }\n\n    default predicate<t> or(predicate<? super t> other) {\n        objects.requirenonnull(other);\n        return (t) -> test(t) || other.test(t);\n    }\n\n    static <t> predicate<t> isequal(object targetref) {\n        return (null == targetref)\n                ? objects::isnull\n                : object -> targetref.equals(object);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 2. 入门案例\n\n/**\n * @author: chggx\n * @date: 2020/03/29 21:01\n * @description: <h1> predicate函数式接口 </h1>\n */\npublic class predicatetest {\n\n    public static void main(string[] args) {\n        // 1. predicate基本用法 boolean test(t t);  filter\n        predicate<string> predicate = p -> p.length() > 5;\n        // 长度是否大于5  false\n        system.out.println(predicate.test("hello"));\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 3. 深入\n\n/**\n * @author: chggx\n * @date: 2020/03/29 21:14\n * @description: <h1> predicate函数式接口  </h1>\n * 1. test(); 判断给定的为true/false\n * 2. and()\n * 3. negate 否定(与原来相反)\n * 4. or\n */\npublic class predicatetest2 {\n\n    public static void main(string[] args) {\n        list<integer> list = arrays.aslist(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n        predicatetest2 test2 = new predicatetest2();\n\n        // 1. 获取当前集合的 偶数: 能被2整除\n        test2.conditionfilter(list, item -> item % 2 == 0);\n        system.out.println("-------------");\n\n        // 2. 获取当前集合的 奇数: 不能被2整除,模1\n        test2.conditionfilter(list, item -> item % 2 != 0);\n        system.out.println("-------------");\n\n        // 3. 集合中所有大于5的\n        test2.conditionfilter(list, item -> item > 5);\n        system.out.println("-------------");\n\n        // 4. 集合中所有小于3的\n        test2.conditionfilter(list, item -> item < 3);\n        system.out.println("-------------");\n\n        // 5. 打印出所有数据\n        test2.conditionfilter(list, item -> true);\n        system.out.println("-------------");\n\n        // 6. 不打印出任何数据\n        test2.conditionfilter(list, item -> false);\n        system.out.println("-------------");\n\n        system.out.println("------ and -------");\n\n        // 7. 添加: 既要大于5, 又要为偶数 6 8 10\n        // 大于5: item -> item > 5  ; 偶数:item -> item % 2 == 0\n        test2.conditionfilter2(list, item -> item > 5, item -> item % 2 == 0);\n\n        system.out.println("------ or -------");\n\n        // 8. or 2 4 6 7 8 9 0\n        // 大于5: item -> item > 5  ; 偶数:item -> item % 2 == 0\n        test2.conditionfilter3(list, item -> item > 5, item -> item % 2 == 0);\n\n\n        system.out.println("------ and -------");\n\n        // 7. negate 1 2 3 4 5 7 9\n        // 大于5: item -> item > 5  ; 偶数:item -> item % 2 == 0\n        test2.conditionfilter4(list, item -> item > 5, item -> item % 2 == 0);\n\n        system.out.println("------ isequal -------");\n        // 8. 判断2个参数是否相等\n        system.out.println(test2.isequal("test").test("test"));\n    }\n\n    /** boolean test(t t);\n     * 函数式编程: 将参数处理,由方法体里面处理-----\x3e执行者里处理[处理逻辑有方法里面编写---\x3e时下时编写体现]\n     * <h2> predicate: 方法 test(); </h2>\n     */\n    public void conditionfilter(list<integer> list, predicate<integer> predicate) {\n        for (integer integer : list) {\n            // 判断是否为 true\n            if (predicate.test(integer)) {\n                // 是\n                system.out.println(integer);\n            }\n        }\n    }\n\n    /**  default predicate<t> and(predicate<? super t> other)\n     * <h2> 与或非:与and </h2>\n     */\n    public void conditionfilter2(list<integer> list, predicate<integer> predicate1, predicate<integer> predicate2) {\n        for (integer integer : list) {\n            // 给定集合,既要满足predicate1,又要满足predicate2\n            if (predicate1.and(predicate2).test(integer)) {\n                system.out.println(integer);\n            }\n        }\n    }\n    /**  default predicate<t> or(predicate<? super t> other)\n     * <h2> 与或非: 或or </h2>\n     */\n    public void conditionfilter3(list<integer> list, predicate<integer> predicate1, predicate<integer> predicate2) {\n        for (integer integer : list) {\n            // 给定集合,既要满足predicate1,又要满足predicate2\n            if (predicate1.or(predicate2).test(integer)) {\n                system.out.println(integer);\n            }\n        }\n    }\n\n    /**  default predicate<t> negate()\n     * <h2> 与或非: 非negate </h2>\n     */\n    public void conditionfilter4(list<integer> list, predicate<integer> predicate1, predicate<integer> predicate2) {\n        for (integer integer : list) {\n            // 给定集合,既要满足predicate1,又要满足predicate2, negate: 取之前的相反结果\n            if (predicate1.and(predicate2).negate().test(integer)) {\n                system.out.println(integer);\n            }\n        }\n    }\n \n    /** static <t> predicate<t> isequal(object targetref)\n     * <h2> 判断2个参数是否相等 </h2>\n     */\n    public predicate<string> isequal(object o){\n        return predicate.isequal(o);\n    }\n    // todo 原来的面向对象编程,执行逻辑在方法体里面,方法写死.函数式接口,执行者实现.更加灵活\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n\n\n\n# 2.4 supplier接口 ==get==\n\n * 不接受参数,返回结果\n\n# 1. 接口\n\n@functionalinterface\npublic interface supplier<t> {\n\n    /**\n     * gets a result.\n     *\n     * @return a result\n     */\n    t get();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2. 入门\n\npackage com.chggx.jdk8.supplier;\n\nimport java.util.function.supplier;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 13:39\n * @description: <h1> </h1>\n * supplier: 不接受参数,同时返回一个结果\n */\npublic class suppliertest {\n\n    /**\n     *  t get();\n     *  supplier: 不接受参数,同时返回一个结果\n     */\n    public static void main(string[] args) {\n        supplier<string> supplier = () -> "hello word";\n        system.out.println(supplier.get());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 3.深入\n\n * student实体类\n\npackage com.chggx.jdk8.pojo;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 13:46\n * @description: <h1> </h1>\n */\npublic class student {\n\n    private string name = "zhangsan";\n\n    private int age = 20;\n\n    // 无参构造重点\n    public student() {\n    }\n\n    public student(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n * 实现\n\npackage com.chggx.jdk8.java.util.function.supplier;\n\nimport com.chggx.jdk8.pojo.student;\n\nimport java.util.function.supplier;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 13:39\n * @description: <h1> supplier应用 </h1>\n * supplier: 不接受参数,同时返回一个结果\n */\npublic class studenttest {\n\n    /**\n     * t get();\n     * supplier: 不接受参数,同时返回一个结果\n     */\n    public static void main(string[] args) {\n\n        // 1. 以前方式\n        student student = new student();\n        string name = student.getname();\n        int age = student.getage();\n        system.out.println("name: " + name + ", age: " + age);\n\n        system.out.println("===============================");\n\n        // 2. 现在supplier函数式编程方式\n        // lambda : () -> new student();\n        supplier<student> supplier = () -> new student();\n        system.out.println("name: " + supplier.get().getname() + ", age: " + supplier.get().getage());\n\n        system.out.println("===============================");\n\n        // 3. 构造方法引用(无参构造) student::new\n        supplier<student> supplier1 = student::new;\n        system.out.println("name: " + supplier.get().getname() + ", age: " + supplier.get().getage());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 2.5 binaryoperator接口 ==继承bifunction==\n\npackage com.chggx.jdk8.java.util.function.binaryoperator;\n\nimport java.util.comparator;\nimport java.util.function.binaryoperator;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 14:14\n * @description: <h1> </h1>\n * binaryoperator: 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果\n *  继承自bifunction\n */\npublic class binaryoperatortest {\n\n    public static void main(string[] args) {\n\n        // 两个整数的运算\n        binaryoperatortest binaryoperatortest = new binaryoperatortest();\n        // +\n        system.out.println(binaryoperatortest.compute(1, 2, integer::sum));\n        // -\n        system.out.println(binaryoperatortest.compute(1, 2, (a, b) -> a - b));\n        // *\n        system.out.println(binaryoperatortest.compute(1, 2, (a, b) -> a * b));\n        // /\n        system.out.println(binaryoperatortest.compute(1, 2, (a, b) -> a / b));\n\n        // getshort 比较获取小的\n        system.out.println(binaryoperatortest.getshort("hello", "word", (a, b) ->a.length()-b.length()));\n        system.out.println(binaryoperatortest.getlong("hello", "word", (a, b) ->a.charat(0)-b.charat(0)));\n        // getlong 比较获取大的\n        system.out.println(binaryoperatortest.getlong("hello", "word", (a, b) ->a.length()-b.length()));\n\n    }\n\n    /**\n     * binaryoperator\n     * r apply(t t, u u);\n     */\n    public int compute(int a, int b, binaryoperator<integer> binaryoperator) {\n        return binaryoperator.apply(a, b);\n    }\n\n    /**\n     * 比较\n     */\n    public string getshort(string a, string b, comparator<string> comparator) {\n        return binaryoperator.minby(comparator).apply(a, b);\n    }\n    public string getlong(string a, string b, comparator<string> comparator) {\n        return binaryoperator.maxby(comparator).apply(a, b);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n----------------------------------------\n\n\n# 3. optional 函数式编程风格\n\n * 解决 npe nullpointerexception 空指针异常\n\n\n# 3.1 源码\n\n/**\n * common instance for {@code empty()}.\n */\nprivate static final optional<?> empty = new optional<>();\n\n/**\n * if non-null, the value; if null, indicates no value is present\n */\nprivate final t value;\n\n/**\n * constructs an empty instance.\n *\n * @implnote generally only one empty instance, {@link optional#empty},\n * should exist per vm.\n */\nprivate optional() {\n    this.value = null;\n}\n\n/**\n * returns an empty {@code optional} instance.  no value is present for this\n * optional.\n *\n * @apinote though it may be tempting to do so, avoid testing if an object\n * is empty by comparing with {@code ==} against instances returned by\n * {@code option.empty()}. there is no guarantee that it is a singleton.\n * instead, use {@link #ispresent()}.\n *\n * @param <t> type of the non-existent value\n * @return an empty {@code optional}\n */\npublic static<t> optional<t> empty() {\n    @suppresswarnings("unchecked")\n    optional<t> t = (optional<t>) empty;\n    return t;\n}\n\n/**\n * constructs an instance with the value present.\n *\n * @param value the non-null value to be present\n * @throws nullpointerexception if value is null\n */\nprivate optional(t value) {\n    this.value = objects.requirenonnull(value);\n}\n\n/**\n * returns an {@code optional} with the specified present non-null value.\n *\n * @param <t> the class of the value\n * @param value the value to be present, which must be non-null\n * @return an {@code optional} with the value present\n * @throws nullpointerexception if value is null\n */\npublic static <t> optional<t> of(t value) {\n    return new optional<>(value);\n}\n\n/**\n * returns an {@code optional} describing the specified value, if non-null,\n * otherwise returns an empty {@code optional}.\n *\n * @param <t> the class of the value\n * @param value the possibly-null value to describe\n * @return an {@code optional} with a present value if the specified value\n * is non-null, otherwise an empty {@code optional}\n */\npublic static <t> optional<t> ofnullable(t value) {\n    return value == null ? empty() : of(value);\n}\n\n/**\n * if a value is present in this {@code optional}, returns the value,\n * otherwise throws {@code nosuchelementexception}.\n *\n * @return the non-null value held by this {@code optional}\n * @throws nosuchelementexception if there is no value present\n *\n * @see optional#ispresent()\n */\npublic t get() {\n    if (value == null) {\n        throw new nosuchelementexception("no value present");\n    }\n    return value;\n}\n\n/**\n * return {@code true} if there is a value present, otherwise {@code false}.\n *\n * @return {@code true} if there is a value present, otherwise {@code false}\n */\npublic boolean ispresent() {\n    return value != null;\n}\n\n/**\n * if a value is present, invoke the specified consumer with the value,\n * otherwise do nothing.\n *\n * @param consumer block to be executed if a value is present\n * @throws nullpointerexception if value is present and {@code consumer} is\n * null\n */\npublic void ifpresent(consumer<? super t> consumer) {\n    if (value != null)\n        consumer.accept(value);\n}\n\n/**\n * if a value is present, and the value matches the given predicate,\n * return an {@code optional} describing the value, otherwise return an\n * empty {@code optional}.\n *\n * @param predicate a predicate to apply to the value, if present\n * @return an {@code optional} describing the value of this {@code optional}\n * if a value is present and the value matches the given predicate,\n * otherwise an empty {@code optional}\n * @throws nullpointerexception if the predicate is null\n */\npublic optional<t> filter(predicate<? super t> predicate) {\n    objects.requirenonnull(predicate);\n    if (!ispresent())\n        return this;\n    else\n        return predicate.test(value) ? this : empty();\n}\n\n/**\n * if a value is present, apply the provided mapping function to it,\n * and if the result is non-null, return an {@code optional} describing the\n * result.  otherwise return an empty {@code optional}.\n *\n * @apinote this method supports post-processing on optional values, without\n * the need to explicitly check for a return status.  for example, the\n * following code traverses a stream of file names, selects one that has\n * not yet been processed, and then opens that file, returning an\n * {@code optional<fileinputstream>}:\n *\n * <pre>{@code\n *     optional<fileinputstream> fis =\n *         names.stream().filter(name -> !isprocessedyet(name))\n *                       .findfirst()\n *                       .map(name -> new fileinputstream(name));\n * }</pre>\n *\n * here, {@code findfirst} returns an {@code optional<string>}, and then\n * {@code map} returns an {@code optional<fileinputstream>} for the desired\n * file if one exists.\n *\n * @param <u> the type of the result of the mapping function\n * @param mapper a mapping function to apply to the value, if present\n * @return an {@code optional} describing the result of applying a mapping\n * function to the value of this {@code optional}, if a value is present,\n * otherwise an empty {@code optional}\n * @throws nullpointerexception if the mapping function is null\n */\npublic<u> optional<u> map(function<? super t, ? extends u> mapper) {\n    objects.requirenonnull(mapper);\n    if (!ispresent())\n        return empty();\n    else {\n        return optional.ofnullable(mapper.apply(value));\n    }\n}\n\n/**\n * if a value is present, apply the provided {@code optional}-bearing\n * mapping function to it, return that result, otherwise return an empty\n * {@code optional}.  this method is similar to {@link #map(function)},\n * but the provided mapper is one whose result is already an {@code optional},\n * and if invoked, {@code flatmap} does not wrap it with an additional\n * {@code optional}.\n *\n * @param <u> the type parameter to the {@code optional} returned by\n * @param mapper a mapping function to apply to the value, if present\n *           the mapping function\n * @return the result of applying an {@code optional}-bearing mapping\n * function to the value of this {@code optional}, if a value is present,\n * otherwise an empty {@code optional}\n * @throws nullpointerexception if the mapping function is null or returns\n * a null result\n */\npublic<u> optional<u> flatmap(function<? super t, optional<u>> mapper) {\n    objects.requirenonnull(mapper);\n    if (!ispresent())\n        return empty();\n    else {\n        return objects.requirenonnull(mapper.apply(value));\n    }\n}\n\n/**\n * return the value if present, otherwise return {@code other}.\n *\n * @param other the value to be returned if there is no value present, may\n * be null\n * @return the value, if present, otherwise {@code other}\n */\npublic t orelse(t other) {\n    return value != null ? value : other;\n}\n\n/**\n * return the value if present, otherwise invoke {@code other} and return\n * the result of that invocation.\n *\n * @param other a {@code supplier} whose result is returned if no value\n * is present\n * @return the value if present otherwise the result of {@code other.get()}\n * @throws nullpointerexception if value is not present and {@code other} is\n * null\n */\npublic t orelseget(supplier<? extends t> other) {\n    return value != null ? value : other.get();\n}\n\n/**\n * return the contained value, if present, otherwise throw an exception\n * to be created by the provided supplier.\n *\n * @apinote a method reference to the exception constructor with an empty\n * argument list can be used as the supplier. for example,\n * {@code illegalstateexception::new}\n *\n * @param <x> type of the exception to be thrown\n * @param exceptionsupplier the supplier which will return the exception to\n * be thrown\n * @return the present value\n * @throws x if there is no value present\n * @throws nullpointerexception if no value is present and\n * {@code exceptionsupplier} is null\n */\npublic <x extends throwable> t orelsethrow(supplier<? extends x> exceptionsupplier) throws x {\n    if (value != null) {\n        return value;\n    } else {\n        throw exceptionsupplier.get();\n    }\n}\n\n/**\n * indicates whether some other object is "equal to" this optional. the\n * other object is considered equal if:\n * <ul>\n * <li>it is also an {@code optional} and;\n * <li>both instances have no value present or;\n * <li>the present values are "equal to" each other via {@code equals()}.\n * </ul>\n *\n * @param obj an object to be tested for equality\n * @return {code true} if the other object is "equal to" this object\n * otherwise {@code false}\n */\n@override\npublic boolean equals(object obj) {\n    if (this == obj) {\n        return true;\n    }\n\n    if (!(obj instanceof optional)) {\n        return false;\n    }\n\n    optional<?> other = (optional<?>) obj;\n    return objects.equals(value, other.value);\n}\n\n/**\n * returns the hash code value of the present value, if any, or 0 (zero) if\n * no value is present.\n *\n * @return hash code value of the present value or 0 if no value is present\n */\n@override\npublic int hashcode() {\n    return objects.hashcode(value);\n}\n\n/**\n * returns a non-empty string representation of this optional suitable for\n * debugging. the exact presentation format is unspecified and may vary\n * between implementations and versions.\n *\n * @implspec if a value is present the result must include its string\n * representation in the result. empty and present optionals must be\n * unambiguously differentiable.\n *\n * @return the string representation of this instance\n */\n@override\npublic string tostring() {\n    return value != null\n        ? string.format("optional[%s]", value)\n        : "optional.empty";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n\n\n\n# 3.2 入门\n\n * 工厂方法 ==of empty ofnullable==\n * ==ifpresent orelse orelseget==\n\npackage com.chggx.jdk8.java.util.optional;\n\nimport java.util.optional;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 17:26\n * @description: <h1> optional测试 </h1>\n */\npublic class optionaltest {\n\n    public static void main(string[] args) {\n\n        // 构造optional对象(不能new,私有的)\n        // 1. of\n//        optional<string> optional = optional.of("hello");\n        // 2. empty\n        optional<string> optional = optional.empty();\n\n        // 如果存在\n//        if (optional.ispresent()) {\n//            system.out.println(optional.get());\n//        }\n        // 3. 函数式编程风格 optional.ispresent() -------\x3e optional.ifpresent\n        optional.ifpresent(item-> system.out.println(item));\n\n        // 4. orelse 如果里面没有值,打印下面的值"world" (备选值)\n        system.out.println(optional.orelse("world"));\n\n        // 5. public t orelseget(supplier<? extends t> other)\n        // 如果里面的值为空的话,接单后空的参数,输出结果\n        system.out.println(optional.orelseget(()->"nihao"));\n\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nps: 使用optional使用**==函数式编程风格==**写代码,不使用之前的方式\n\n    // 如果存在\n    if (optional.ispresent()) {\n    \tsystem.out.println(optional.get());   \n    }else{\n        .....\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.3 深入\n\n * optional 没有 ==序列化==\n * optional通常只作为方法的返回值,来规避空指针异常\n\n员工表\n\npackage com.chggx.jdk8.pojo;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 17:50\n * @description: <h1> 员工表 </h1>\n */\npublic class employee {\n\n    private string name;\n\n    public employee() {\n    }\n\n    public employee(string name) {\n        this.name = name;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n公司表\n\npackage com.chggx.jdk8.pojo;\n\nimport java.util.list;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 17:52\n * @description: <h1> 公司表 </h1>\n */\npublic class company {\n\n    private string name;\n\n    private list<employee> employees;\n\n    public company() {\n    }\n\n    public company(string name, list<employee> employees) {\n        this.name = name;\n        this.employees = employees;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public list<employee> getemployees() {\n        return employees;\n    }\n\n    public void setemployees(list<employee> employees) {\n        this.employees = employees;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 示例\n\npackage com.chggx.jdk8.java.util.optional;\n\nimport com.chggx.jdk8.pojo.company;\nimport com.chggx.jdk8.pojo.employee;\n\nimport java.util.arrays;\nimport java.util.collections;\nimport java.util.list;\nimport java.util.optional;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 17:54\n * @description: <h1> 测试一对多(employee,company) </h1>\n */\npublic class optionaltest2 {\n\n    public static void main(string[] args) {\n        employee employee = new employee();\n        employee.setname("zhangsan");\n\n        employee employee2 = new employee();\n        employee2.setname("lisi");\n\n        company company = new company();\n        company.setname("company1");\n        list<employee> employees = arrays.aslist(employee, employee2);\n        // 1. employees不为空,调用optional的map获取结果\n        // 2. 结果为空,调用optional的orelse返回空结果 []\n        company.setemployees(employees);\n\n        // 传统方式\n //       list<employee> list = company.getemployees();\n//        if (null != list) {\n//            return list;\n//        } else {\n//            return new arraylist<employee>();\n//        }\n\n        // 函数式编程风格 optional\n        // 1. 构造工厂\n        optional<company> optional = optional.ofnullable(company);\n\n        // map\n        //  public<u> optional<u> map(function<? super t, ? extends u> mapper)\n        system.out.println(\n                // map: 有结果情况\n                optional.map(thecompany -> thecompany.getemployees())\n                        // 无结果情况 []\n                        .orelse(collections.emptylist()));\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 4. 方法引用[method reference] ::\n\n * lambda表达式的一种语法糖(特殊情况),替换lambda,代码更精炼\n\n // 方法引用实现的接口 (接受一个参数,返回一个结果)\n        function<string,string> function = string::touppercase;\n        system.out.println(function.getclass().getinterfaces()[0]);\n\n\n1\n2\n3\n\n\n\n# 4.1 概述\n\n 1. 方法引用(method reference): lambda表达式的一种语法糖(特殊情况)\n\n 2. 我们可以将"方法引用"看做是一个『函数式指针』,function pointer,指向另一个函数\n\n 3. 方法引用的分类(4类)\n    \n    * 类名::静态方法名 classname::staticmethod 『函数式指针』\n    * 引用名(对象名)::实例方法名\n    * 类名::实例方法名\n\n\n# 4.2 入门\n\n * 对比lambda\n\npackage com.chggx.jdk8.lambda.methodreference;\n\nimport java.util.arrays;\nimport java.util.list;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 18:33\n * @description: <h1> 方法引用 :: </h1>\n *  1. 方法引用(method reference): lambda表达式的一种语法糖(特殊情况)\n *  2. 我们可以将"方法引用"看做是一个『函数式指针』,function pointer,指向另一个函数\n *  3. 方法引用的分类(4类)\n *      1). 类名::静态方法名\n *      2). 引用名(对象名)::实例方法名\n */\npublic class methodreferencetest {\n\n    public static void main(string[] args) {\n\n        list<string> list = arrays.aslist("hello","world","hello world");\n\n        // lambda方式\n        list.foreach(item-> system.out.println(item));\n\n        // 方法引用\n        list.foreach(system.out::println);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 4.3 方法引用的分类\n\n# 1. 类名::静态方法名 ==[静态方法在实体类里面]==\n\n * 实体类stu\n\npackage com.chggx.jdk8.lambda.methodreference;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 18:45\n * @description: <h1> </h1>\n */\npublic class stu {\n    private string name;\n    private int score;\n\n    public stu() {\n    }\n\n    public stu(string name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getscore() {\n        return score;\n    }\n\n    public void setscore(int score) {\n        this.score = score;\n    }\n\n    /**\n     * 静态方法比较(分数)\n     */\n    public static int comparestubyscore(stu stu1, stu stu2) {\n        return stu1.getscore() - stu2.getscore();\n    }\n\n    /**\n     * 静态方法比较(名字)\n     */\n    public static int comparestubyname(stu stu1, stu stu2) {\n        return stu1.getname().comparetoignorecase(stu2.getname());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * 测试\n\npackage com.chggx.jdk8.lambda.methodreference;\n\nimport java.util.arrays;\nimport java.util.list;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 18:44\n * @description: <h1> </h1>\n * 方法引用的第一类:  1). 类名::静态方法名 [静态方法在实体类里面]\n */\npublic class methodreferencetest2 {\n\n    public static void main(string[] args) {\n        stu stu1 = new stu("zhangsan", 10);\n        stu stu2 = new stu("lisi", 90);\n        stu stu3 = new stu("wangwu", 50);\n        stu stu4 = new stu("zhaoliu", 40);\n\n        list<stu> stulist = arrays.aslist(stu1, stu2, stu3, stu4);\n\n        // 1. 根据分数排序\n        // 1.1 lambda\n        // 排序(在原有集合上排序,不创建新集合) sort\n        // 传递两个参数 (compare)\n        stulist.sort((stuparam1, stuparam2) ->\n                stu.comparestubyscore(stuparam1, stuparam2));\n        stulist.foreach(stu -> system.out.println(stu.getscore()));\n\n        // 1.2 方法引用(stu里的静态方法) [类名::静态方法名]\n        // :: comparator\n        stulist.sort(stu::comparestubyscore);\n        stulist.foreach(stu -> system.out.println(stu.getscore()));\n\n        // 2. 根据名字排序\n        // 2.1 lambda\n        // 排序(在原有集合上排序,不创建新集合) sort\n        // 传递两个参数 (compare)\n        stulist.sort((stuparam1, stuparam2) ->\n                stu.comparestubyname(stuparam1, stuparam2));\n        stulist.foreach(stu -> system.out.println(stu.getname()));\n\n        // 2.2 方法引用(stu里的静态方法) [类名::静态方法名]\n        // :: comparator\n        stulist.sort(stu::comparestubyname);\n        stulist.foreach(stu -> system.out.println(stu.getname()));\n\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n# 2. 引用名(对象名)::实例方法名\n\n * 引用的类\n\npackage com.chggx.jdk8.lambda.methodreference;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 20:40\n * @description: <h1> </h1>\n */\npublic class stucomparator {\n\n    /**\n     * 比较分数\n     */\n    public int comparatorstubyscore(stu stu1, stu stu2) {\n        return stu1.getscore() - stu2.getscore();\n    }\n\n    /**\n     * 比较分数\n     */\n    public int comparatorstubyname(stu stu1, stu stu2) {\n        return stu1.getname().comparetoignorecase(stu2.getname());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 测试\n\npackage com.chggx.jdk8.lambda.methodreference;\n\nimport java.util.arrays;\nimport java.util.list;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 18:44\n * @description: <h1> </h1>\n * 方法引用的第二类:  1). 引用名(对象名)::实例方法名\n */\npublic class methodreferencetest3 {\n    public static void main(string[] args) {\n        stu stu1 = new stu("zhangsan", 10);\n        stu stu2 = new stu("lisi", 90);\n        stu stu3 = new stu("wangwu", 50);\n        stu stu4 = new stu("zhaoliu", 40);\n\n        list<stu> stulist = arrays.aslist(stu1, stu2, stu3, stu4);\n\n        // 创建stu比较对象\n        stucomparator stucomparator = new stucomparator();\n\n        // 1. 排序 比较分数\n        // 1.1 lambda\n        stulist.sort((stuparam1, stuparam2) ->\n                stucomparator.comparatorstubyscore(stuparam1, stuparam2));\n        stulist.foreach(stu -> system.out.println(stu.getscore()));\n        // 1.2 方法引用 stucomparator的方法 [引用名(对象名)::实例方法名]\n        // :: comparator\n        stulist.sort(stucomparator::comparatorstubyscore);\n        stulist.foreach(stu -> system.out.println(stu.getscore()));\n\n        // 2. 排序 比较名字\n        // 2.1 lambda\n        stulist.sort((stuparam1, stuparam2) ->\n                stucomparator.comparatorstubyname(stuparam1, stuparam2));\n        stulist.foreach(stu -> system.out.println(stu.getname()));\n        // 2.2 方法引用 stucomparator的方法 [引用名(对象名)::实例方法名]\n        // :: comparator\n        stulist.sort(stucomparator::comparatorstubyname);\n        stulist.foreach(stu -> system.out.println(stu.getname()));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n# 3. 类名::实例方法名\n\n * 实体类\n\npackage com.chggx.jdk8.lambda.methodreference;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 18:45\n * @description: <h1> </h1>\n */\npublic class stu {\n    private string name;\n    private int score;\n\n    public stu() {\n    }\n\n    public stu(string name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public int getscore() {\n        return score;\n    }\n\n    public void setscore(int score) {\n        this.score = score;\n    }\n\n    /**\n     * 静态方法比较(分数)\n     */\n    public static int comparatorstubyscore(stu stu1, stu stu2) {\n        return stu1.getscore() - stu2.getscore();\n    }\n\n    /**\n     * 静态方法比较(名字)\n     */\n    public static int comparatorstubyname(stu stu1, stu stu2) {\n        return stu1.getname().comparetoignorecase(stu2.getname());\n    }\n\n    //================================================================================================/\n\n    /**\n     * 改造上面的方法\n     */\n    public int comparatorbyscore(stu stu1) {\n        return this.getscore() - stu1.getscore();\n    }\n\n    public int comparatorbyname(stu stu1) {\n        return this.getname().comparetoignorecase(stu1.getname());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n * 测试\n\npackage com.chggx.jdk8.lambda.methodreference;\n\nimport java.util.arrays;\nimport java.util.collections;\nimport java.util.list;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 18:44\n * @description: <h1> </h1>\n * 方法引用的第三类:  3). 类名::实例方法名\n */\npublic class methodreferencetest4 {\n    public static void main(string[] args) {\n\n        stu stu1 = new stu("zhangsan", 10);\n        stu stu2 = new stu("lisi", 90);\n        stu stu3 = new stu("wangwu", 50);\n        stu stu4 = new stu("zhaoliu", 40);\n\n        list<stu> stulist = arrays.aslist(stu1, stu2, stu3, stu4);\n\n        // 1. 方法引用  类名::实例方法名\n        //  排序 比较分数\n        // 类名::实例方法名 stu::comparatorbyscore [实例为类的非静态方法]\n        stulist.sort(stu::comparatorbyscore);\n        stulist.foreach(stu -> system.out.println(stu.getscore()));\n\n        // 排序 比较分数\n        // 类名::实例方法名 stu::comparatorbyscore [实例为类的非静态方法]\n        stulist.sort(stu::comparatorbyname);\n        stulist.foreach(stu -> system.out.println(stu.getname()));\n\n        // 2. jdk自带排序\n        list<string> cities = arrays.aslist("beijing", "shanghai", "tianjin", "chongqing");\n\n        // 2.1 collections.sort\n        collections.sort(cities, (cities1, cities2) -> cities1.comparetoignorecase(cities2));\n        cities.foreach(city -> system.out.println(city));\n\n        // 2.2 方法引用改进\n        //  public int comparetoignorecase(string str)\n        cities.sort(string::comparetoignorecase);\n        cities.foreach(system.out::println);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n# 4. 构造方法引用: ==类名::new==\n\npackage com.chggx.jdk8.lambda.methodreference;\n\nimport java.util.function.function;\nimport java.util.function.supplier;\n\n/**\n * @author: chggx\n * @date: 2020/04/19 18:44\n * @description: <h1> </h1>\n * 方法引用的第四类:  4). 构造方法: 类名::new\n */\npublic class methodreferencetest5 {\n\n    public static void main(string[] args) {\n\n        methodreferencetest5 test5 = new methodreferencetest5();\n        // 1.\n        // string::new : new string() 类名::new\n        system.out.println(test5.getstring(string::new));\n\n        // 2. \n        system.out.println(test5.getstring2("hello", string::new));\n\n\n    }\n\n    /**\n     * supplier<t>: 不接收参数,返回值\n     */\n    public string getstring(supplier<string> supplier) {\n        return supplier.get() + "test";\n    }\n\n    /**\n     * function<t,r>:\n     */\n    public string getstring2(string str, function<string, string> function) {\n        return function.apply(str);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 4. 案例\n\n持续更新..........\n\n\n# 5. stream api\n\n\n# 5.1 stream简介\n\n# 1. 什么是流\n\n流是java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。\n\n众所周知，集合操作非常麻烦，若要对集合进行筛选、投影，需要写大量的代码，而流是以声明的形式操作集合，它就像sql语句，我们只需告诉流需要对集合进行什么操作，它就会自动进行操作，并将执行结果交给你，无需我们自己手写代码。\n\n因此，流的集合操作对我们来说是透明的，我们只需向流下达命令，它就会自动把我们想要的结果给我们。由于操作过程完全由java处理，因此它可以根据当前硬件环境选择最优的方法处理，我们也无需编写复杂又容易出错的多线程代码了。\n\n> 总结\n\n流使用于操作数据源(集合.数组等)所生成的元素序列. 集合将的是数据,流讲的是计算.\n\n> 注意\n\n① stream 自己不会存储元素 (不是数据结构，不会保存数据)\n\n② stream 不会改变源对象. 相反,他们会返回一个持有结果的新stream.\n\n③ stream 操作是 延迟执行 的. 这意味着他们会等到需要结果的时候才执行.\n\n# 2. 流的操作种类\n\n> 创建 stream\n\n一个数据源 (集合,数组等) , 获取一个流.\n\n> 中间操作\n\n当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为 “中间操作”。 中间操作仍然会返回一个流对象，因此多个中间操作可以串连起来形成一个流水线。除非流水线上触发终止操作,否则中间操作不会执行任何的处理! 而在终止操作是一次性全部处理,成为 "惰性求值"\n\n> 终端操作(终止操作)\n\n当所有的中间操作完成后，若要将数据从流水线上拿下来，则需要执行终端操作。 终端操作将返回一个执行结果，这就是你想要的数据。\n\n\n\n\n# 5.2 stream 创建流\n\n> 集合流\n\n// 通过 collection 系列集合提供的 stream() 或 parallelstream()\nlist<string> list = new arraylist<>();\n//获取一个顺序流\nstream<string> stream1 = list.stream();\n//获取一个并行流\nstream<string> parallelstream = list.parallelstream(); \n\n\n1\n2\n3\n4\n5\n6\n\n\n> 数组流: arrays.stream()\n\n// 通过 arrays 中的静态方法stream()获取\nstring[] strings = new string[10];\nstream<string> stream2 = arrays.stream(strings);\n\n\n1\n2\n3\n\n\n> stream 类中的静态方法 of()、iterate()、generate()\n\n// 通过 stream 类中的静态方法 of\nstream<java.lang.string> stream3 = stream.of("aa", "bb", "cc");\n// 无限流\nstream<integer> stream2 = stream.iterate(0, (x) -> x + 2).limit(6); // 迭代\nstream2.foreach(system.out::println); \nstream<double> stream3 = stream.generate(math::random).limit(2); // 生成\nstream3.foreach(system.out::println);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 无限流\n\n 1. 迭代 iterate()\n\nstream<integer> stream4 = stream.iterate(0, (x) -> x + 2);\n\n\n1\n\n 2. 生成 generate()\n\nstream.generate(math::random).foreach(system.out::println);\n\n\n1\n\n\n> 文件生成流 bufferedreader.lines()\n\nbufferedreader reader = new bufferedreader(new filereader("f:\\\\test_stream.txt"));\nstream<java.lang.string> linestream = reader.lines();\nlinestream.foreach(system.out::println);\n\n\n1\n2\n3\n\n\n> 字符串分隔成流: pattern.splitasstream()\n\npattern pattern = pattern.compile(",");\nstream<java.lang.string> stringstream = pattern.splitasstream("a,b,c,d");\nstringstream.foreach(system.out::println);\n\n\n1\n2\n3\n\n\n> 生成空流\n\nstream<object> empty = stream.empty();\n\n\n1\n\n\n> 数值范围生成流\n\n// 生成0到10的int流\nintstream intstream = intstream.rangeclosed(0, 10);\n// 生成0到9的int流\nintstream intstream1 = intstream.range(0, 10);\n\n\n1\n2\n3\n4\n\n\n> 手动生成流\n\n// 生成有字符串a和数字1的异构的流\nstream.builder().add("a").add(1).build().foreach(system.out::print);\n\n\n1\n2\n\n\n\n# 5.3 stream 中间操作\n\n# 1. 筛选与切片\n\n方法                    描述\nfilter(predicate p)   接收 lambda ， 从流中排除某些元素。\ndistinct()            筛选，通过流所生成元素的 hashcode() 和 equals() 去除重复元素\nlimit(long maxsize)   截断流，使其元素不超过给定数量。\nskip(long n)          跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素\n\n> filter——接收 lambda ， 从流中排除某些元素。\n\n 1. 内部迭代\n\n@test\npublic void screeningandslicing1() {\n    // 中间操作\n    stream<employee> stream = employeelist.stream()\n            // 年龄大于35\n            .filter(e -> e.getage() > 35);\n    // 只有当做终止操作时，所有的中间操作会一次性的全部执行，称为“惰性求值”\n    stream.foreach(system.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 内部迭代\n\n// 外部迭代\n@test\npublic void screeningandslicing2() {\n    iterator<employee> it = employeelist.iterator();\n    while (it.hasnext()) {\n        system.out.println(it.next());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> limit——截断流，使其元素不超过给定数量。\n\n@test\npublic void screeningandslicing3() {\n    employeelist.stream()\n            .filter(e -> {\n                system.out.println("短路！"); // &&  ||\n                return e.getsalary() > 5000;\n            })\n            .limit(2)\n            .foreach(system.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补\n\n@test\npublic void screeningandslicing4() {\n    employeelist.stream()\n            .filter(e -> e.getsalary() > 5000)\n            .skip(2)\n            .foreach(system.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> distinct——筛选，通过流所生成元素的 hashcode() 和 equals() 去除重复元素\n\n@test\npublic void screeningandslicing5() {\n    // distinct——筛选，通过流所生成元素的 hashcode() 和 equals() 去除重复元素\n    employeelist.stream()\n            .filter(e -> e.getsalary() > 5000)\n            .skip(2)\n            .distinct()\n            .foreach(system.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 2. 映射\n\n方法                                描述\nmap(function f)                   接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\nmaptodouble(todoublefunction f)   接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 doublestream。\nmaptoint(tointfunction f)         接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 intstream。\nmaptolong(tolongfunction f)       接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 longstream。\nflatmap(function f)               接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流\n\n> map——接收 lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n\nlist<string> list = arrays.aslist("aaa", "bbb", "ccc", "ddd", "eee");\nlist.stream()\n        // str -> str.touppercase() 转换为大写\n        .map(string::touppercase)\n        .foreach(system.out::println);\n\nsystem.out.println("------------");\n\nemployeelist.stream()\n        .map(employee::getname)\n        .foreach(system.out::println); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> flatmap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流\n\n// map\nstream<stream<character>> stream1 = list.stream()\n        // 类名::静态方法\n        .map(streamapitest02::filtercharacter);\nstream1.foreach(sm -> {\n    sm.foreach(system.out::print);\n});\nsystem.out.println();\nsystem.out.println("------------");\n\n// 优化上面\n// flatmap\nstream<character> stream2 = list.stream()\n        // 类名::静态方法\n        .flatmap(streamapitest02::filtercharacter);\nstream2.foreach(system.out::print);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n静态方法\n\npublic static stream<character> filtercharacter(string str) {\n    list<character> list = new arraylist<>();\n    for (character ch : str.tochararray()) {\n        list.add(ch);\n    }\n    return list.stream();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 3. 排序\n\n方法                        描述\nsorted()                  产生一个新流，其中按自然顺序排序\nsorted(comparator comp)   产生一个新流，其中按比较器顺序排序\n\n> sorted()——自然排序(comparable)\n\nlist<string> list = arrays.aslist("aaa", "bbb", "ccc", "ddd", "eee");\n// 自然排序\nlist.stream()\n        .sorted()\n        .foreach(system.out::println);\n\n\n1\n2\n3\n4\n5\n\n\n> sorted(comparator com)——定制排序(comparator)\n\nemployeelist.stream()\n        .sorted((e1, e2) -> {\n            if (e1.getage() == e2.getage()) {\n                return e1.getname().compareto(e2.getname());\n            } else {\n                return integer.compare(e1.getage(), e2.getage());\n            }\n        }).foreach(system.out::println);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5.4 stream 终止操作\n\n# 1 查找与匹配\n\n方法                       描述\nallmatch(predicate p)    检查是否匹配所有元素\nanymatch(predicate p)    检查是否至少匹配一个元素\nnonematch(predicate p)   检查是否没有匹配所有元素\nfindfirst()              返回第一个元素\nfindany()                返回当前流中的任意元素\ncount                    返回流中元素总数\nmax(comparator c)        返回流中大值\nmin(comparator c)        返回流中最小值\nforeach(consumer c)      内部迭代(使用 collection 接口需要用户去做迭代，称为 外部迭代。相反，stream api 使用内部\n                         迭代——它帮你把迭代做了)\n\n> allmatch——检查是否匹配所有元素\n\nboolean b1 = employeelist.stream()\n        .allmatch(e -> e.getstatus().equals(employee.status.busy));\nsystem.out.println(b1);\n\n\n1\n2\n3\n\n\n> anymatch——检查是否至少匹配一个元素\n\nboolean b2 = employeelist.stream()\n        .anymatch(e -> e.getstatus().equals(employee.status.busy));\nsystem.out.println(b2);\n\n\n1\n2\n3\n\n\n> nonematch——检查是否没有匹配的元素\n\nboolean b3 = employeelist.stream()\n        .nonematch(e -> e.getstatus().equals(employee.status.busy));\nsystem.out.println(b3);\n\n\n1\n2\n3\n\n\n> findfirst——返回第一个元素\n\n工资排序\n\noptional<employee> opa = employeelist.stream()\n        // 工资排序 正序\n        .sorted((e1, e2) -> double.compare(e1.getsalary(), e2.getsalary()))\n        .findfirst();\nif (opa.ispresent()) {\n    system.out.println(opa.get());\n}\noptional<employee> opd = employeelist.stream()\n        // 工资排序  倒序\n        .sorted((e1, e2) -> -double.compare(e1.getsalary(), e2.getsalary()))\n        .findfirst();\nif (opd.ispresent()) {\n    system.out.println(opd.get());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用 max(),min() 优化\n\noptional<employee> op1 = employeelist.stream().min(comparator.comparingdouble(employee::getsalary));\nop1.ifpresent(system.out::println);\noptional<employee> op2 = employeelist.stream().max(comparator.comparingdouble(employee::getsalary));\nop2.ifpresent(system.out::println);\n\n\n1\n2\n3\n4\n\n\n> findany——返回当前流中的任意元素\n\noptional<employee> any = employeelist.stream()\n        .filter(e -> e.getstatus().equals(employee.status.free))\n        .findany();\nany.ifpresent(system.out::println);\n\n\n1\n2\n3\n4\n\n\n> count——返回流中元素的总个数\n\nlong count = employeelist.stream()\n        .count();\nsystem.out.println(count);\n\n\n1\n2\n3\n\n\n> max——返回流中最大值\n\n获取最大工资员工\n\noptional<employee> max = employeelist.stream()\n        .max((e1, e2) -> double.compare(e1.getsalary(), e2.getsalary()));\nif (max.ispresent()){\n    system.out.println(max.get());\n}\n\n\n1\n2\n3\n4\n5\n\n\n优化:\n\n 1. 方式一\n\noptional<employee> max1 = employeelist.stream()\n        .max(comparator.comparingdouble(employee::getsalary));\nmax1.ifpresent(system.out::println);\n\n\n1\n2\n3\n\n 2. 方式二 最大工资\n\noptional<double> max2 = employeelist.stream()\n        .map(employee::getsalary)\n        .max(double::compare);\nmax2.ifpresent(system.out::println);\n\n\n1\n2\n3\n4\n\n\n> min——返回流中最小值\n\noptional<employee> min = employeelist.stream()\n        .min((e1, e2) -> double.compare(e1.getsalary(), e2.getsalary()));\nif (max.ispresent()){\n    system.out.println(min.get());\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 2. 规约\n\n方法                                 描述\nreduce(t iden, binaryoperator b)   可以将流中元素反复结合起来，得到一个值。返回 t\nreduce(binaryoperator b)           可以将流中元素反复结合起来，得到一个值。返回 optional<t>\n\n> reduce(t identity, binaryoperator)——可以将流中元素反复结合起来，得到一个值。\n\nlist<integer> list = arrays.aslist(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\ninteger sum = list.stream()\n        // 参数一: 起始值\n        // (x,y)-> x+y[求和] 转换为 integer::sum\n        .reduce(0, integer::sum);\nsystem.out.println(sum);\n\n\n1\n2\n3\n4\n5\n6\n\n\n> reduce(binaryoperator) ——可以将流中元素反复结合起来，得到一个值,返回 optional<t>。\n\noptional<double> reduce = employeelist.stream()\n        .map(employee::getsalary)\n        .reduce(double::sum);\nreduce.ifpresent(system.out::println);\n\n\n1\n2\n3\n4\n\n\n# 3. 收集\n\n方法                     描述\ncollect(collector c)   将流转换为其他形式。接收一个 collector接口的实现，用于给stream中元素做汇总的方法\n\ncollector 接口中方法的实现决定了如何对流执行收集操作(如收集到 list、set、map)。但是 collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：\n\n方法                  返回类型                      作用\ntolist              list(t)                   把流中元素收集到list\ntoset               set(t)                    把流中元素收集到set\ntocollection        collection(t)             把流中元素收集到创建的集合\ncounting            long                      计算流中元素的个数\naveragingdouble     double                    平均值\naveragingint        integer                   \naveraginglong       long                      \nsummingint          integer                   对流中元素的整数属性求和\nsummingdouble       double                    \nsumminglong         long                      \nsummarizingdouble   doublesummarystatistics   用于int、long、double类型数据一个求总操作\nsummarizingint                                \nsummarizinglong                               \njoining             string                    连接流中每个字符串\nmaxby               optional(t)               根据比较器选择最大值\nminby               optional(t)               根据比较器选择最小值\nreducing            归约产生的类型                   从一个作为累加器的初始值开始，利用binaryoperator与流中元素逐个结合，从而归约成单个值\ncollectingandthen   转换函数返回的类型                 包裹另一个收集器，对其结果转换函数\ngroupingby          map(k, list(t))           根据某属性值对流分组，属性为k，结果为v\npartitioningby      map(boolean, list(t))     根据true或false进行分区\n\n注意：为避免markdown在文档页面格式冲突，上面返回类型中所有的()都是代表<> . 比如 list(t) 指的是 list<t>. \n\n\n1\n\n\n> tolist\n\nlist<string> list = employeelist.stream()\n        .map((employee::getname))\n        .collect(collectors.tolist());\nlist.foreach(system.out::println);\n\n\n1\n2\n3\n4\n\n\n> toset\n\nset<string> set = employeelist.stream()\n                .map((employee::getname))\n                .collect(collectors.toset());\n        set.foreach(system.out::println);\n\n\n1\n2\n3\n4\n\n\n> tocollection\n\nhashset<string> collect = employeelist.stream()\n        .map((employee::getname))\n        .collect(collectors.tocollection(hashset::new));\ncollect.foreach(system.out::println);\n\n\n1\n2\n3\n4\n\n\n> counting\n\nlong count = employeelist.stream()\n        .collect(collectors.counting());\nsystem.out.println(count);\n\n\n1\n2\n3\n\n\n> averagingdouble 平均值\n\ndouble avg = employeelist.stream()\n        .collect(collectors.averagingdouble(employee::getsalary));\nsystem.out.println(avg);\n\n\n1\n2\n3\n\n\n> summingdouble 总和\n\ndouble summ = employeelist.stream()\n        .collect(collectors.summingdouble(employee::getsalary));\nsystem.out.println(summ);\n\n\n1\n2\n3\n\n\n> maxby 最大值\n\noptional<employee> max = employeelist.stream()\n        .collect(collectors.maxby((e1, e2) -> double.compare(e1.getsalary(), e2.getsalary())));\nmax.ifpresent(system.out::println);\n\n\n1\n2\n3\n\n\n> minby 最小值\n\noptional<employee> min = employeelist.stream()\n        .collect(collectors.minby((e1, e2) -> double.compare(e1.getsalary(), e2.getsalary())));\nmin.ifpresent(system.out::println);\n\n\n1\n2\n3\n\n\n> groupingby 分组\n\n 1. 分组\n\nmap<employee.status, list<employee>> groupby = employeelist.stream()\n        .collect(collectors.groupingby(employee::getstatus));\nsystem.out.println(groupby);\n\n\n1\n2\n3\n\n 2. 多级分组\n\nmap<employee.status, map<string, list<employee>>> map = employeelist.stream()\n        .collect(collectors.groupingby(employee::getstatus, collectors.groupingby(e -> {\n            if (e.getage() <= 35) {\n                return "青年";\n            } else if (e.getage() <= 50) {\n                return "中年";\n            } else {\n                return "老年";\n            }\n        })));\nsystem.out.println(map);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> partitioningby 分区\n\nmap<boolean, list<employee>> partitioningby = employeelist.stream()\n        .collect(collectors.partitioningby(e -> e.getsalary() > 8000));\nsystem.out.println(partitioningby);\n\n\n1\n2\n3\n\n\n> summarizingdouble\n\ndoublesummarystatistics dss = employeelist.stream()\n        .collect(collectors.summarizingdouble(employee::getsalary));\nsystem.out.println("总和 : " + dss.getsum());\nsystem.out.println("数量 : " + dss.getcount());\nsystem.out.println("平均值 : " + dss.getaverage());\nsystem.out.println("最大值 : " + dss.getmax());\nsystem.out.println("最小值 : " + dss.getmin());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> joining 连接\n\nstring str = employeelist.stream()\n        .map(employee::getname)\n        .collect(collectors.joining(",","===","==="));\nsystem.out.println(str);\n\n\n1\n2\n3\n4\n\n\n\n# 6. 日期api\n\n> 参考：calendar、date\n\n\n# 6.1 新旧版本api差别\n\n# 1. 新版本计算准确(毫秒),旧版本有误差\n\npublic class dateapitest01 {\n\n    /**\n     * 程序员小李出生于1995年12月26日,计算当前这个时间他已经出生多久了?\n     */\n    @test\n    public void oldapi() {\n        date d = new date();\n        // 获取时间\n        long s1 = d.gettime();\n\n        //\n        calendar c = calendar.getinstance();\n        // 月份从 0-11 12月为: 11\n        c.set(1995, 11, 16);\n        date d2 = c.gettime();\n        long s2 = d2.gettime();\n\n        long intervalday = (s1 - s2) / 1000 / 60 / 60 / 24;\n\n        system.out.println("1995年12月距离现在已经过时了" + intervalday + "天");\n        // 9013\n    }\n\n    /**\n     * 程序员小李出生于1995年12月26日,计算当前这个时间他已经出生多久了?\n     *  java8新日期api计算准确\n     */\n    @test\n    public void newapi() {\n\n        // 使用jav8新版本的api获取\n        long intervalday = chronounit.days.between(localdate.of(1995, 12, 16), localdate.now());\n\n        system.out.println("1995年12月距离现在已经过时了" + intervalday + "天");\n        // 9014\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 2. 老版本存在 线程不安全问题\n\nsimpledateformat 类是线程不安全的,咋多线程的情况下,全局贡献一个 simpledateformat 类中的 calendar 对象有可能出现异常.\n\nfinal static simpledateformat simple_date_format = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n\n/**\n * 创建10个线程,将字符串"2020-08-08 12:12:12"转换为date对象后,打印到控制台上\n */\n@test\npublic void oldapi() {\n    for (int i = 0; i < 10; i++) {\n        // 创建线程(匿名内部类方式)\n        new thread(new runnable() {\n            @override\n            public void run() {\n                try {\n                    date date = simple_date_format.parse("2020-08-08 12:12:12");\n                    system.out.println(date);\n                } catch (parseexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }).start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n控制台错误:\n\n java.lang.numberformatexception: for input string: ""\n\n\n1\n\n\n问题原因: 线程问题\n\n\n\n> 解决: 锁\n\n@test\npublic void oldapi() {\n    for (int i = 0; i < 10; i++) {\n        // 创建线程(匿名内部类方式)\n        new thread(new runnable() {\n            @override\n            public void run() {\n                try {\n                    // 通过加锁解决线程安全问题\n                    synchronized (simple_date_format) {\n                        date date = simple_date_format.parse("2020-08-08 12:12:12");\n                        system.out.println(date);\n                    }\n                } catch (parseexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }).start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 3. 开发规范\n\n不允许使用没有定义的魔法数字\n\npublic class dateapitest03 {\n\n    /**\n     * 初始化calendar对象,封装日期为2008年8月8日\n     */\n    @test\n    public void oldapi() {\n        // 初始化calendar对象\n        calendar calendar = calendar.getinstance();\n        // 设置年月日\n        // 不允许使用没有定义的魔法数字\n//        calendar.set(2008,7,8);\n        /**\n         * public final static int august = 7;\n         */\n        calendar.set(2008,calendar.august,0); // 正确格式 august: 8月\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6.2 date-time api基本类\n\n# 1. 常用类\n\n常用类             功能概述\ninstant         instant类对时间轴上的单一瞬时点建模,可以用于记录应用程序中的事件时间戳,在之后的类型转换中,均可以使用instant类作为中间类完成转换.\nduration        duration类表示秒或纳秒时间间隔,适合处理较短的时间,需要更高的精确度.\nperiod          period类表示一段时间的年,月,日.\nlocaldate       localdate是一个不可变的日期时间对象,表示日期,通常视为年月日.\nlocaltime       localtime是一个不可变的日期时间对象,代表一个时间,通常看做是小时-秒,时间表示为纳秒精度.\nlocaldatetime   localdatetime是一个不可变得日期时间对象,代表日期时间,通常视为年-月-日-时-分-秒.\nzoneddatetime   zoneddatetime是具有时区的日期的不可变表时,此类存储所有时间和时间字段,精确度为纳秒,时区为区域偏移量,用于处理模糊的本地日期时间.\n\n# 2. now 方法在日期/时间类中的使用\n\ndate-time api 中的所有类均生成不可变的示例,它们是线程安全的,并且这些类不提供公共构造函数,也就是说没办法通过new的方式直接创建,需要曹勇工厂方法加以实例化.\n\n 1. now方法可以根据当前日期或时间创建实例对象\n\npublic class timeclassmethodtest01 {\n\n    /**\n     * now方法可以根据当前日期或时间创建实例对象\n     * instant,localdate,localtime,localdatetime,zoneddatetime\n     */\n    @test\n    public void test1() {\n        // 使用now方法创建instant的实例方法对象\n        instant instant = instant.now();\n        // 使用now方法创建localdate的实例对象\n        localdate localdatenow = localdate.now();\n        // 使用now方法创建localtime的实例对象\n        localtime localtimenow = localtime.now();\n        // 使用now方法创建localdatetime的实例对象\n        localdatetime localdatetimenow = localdatetime.now();\n        // 使用now方法创建zoneddatetime的实例对象\n        zoneddatetime zoneddatetimenow = zoneddatetime.now();\n\n        // 将实例对象在到控制台输出\n        system.out.println("instant: " + instant); // instant: 2020-08-20t05:05:47.339z 标准时间(国际)\n        system.out.println("localdatenow: " + localdatenow); // localdatenow: 2020-08-20\n        system.out.println("localtimenow: " + localtimenow); // localtimenow: 13:05:47.440 (440: 表示纳秒)\n        system.out.println("localdatetimenow: " + localdatetimenow); // localdatetimenow: 2020-08-20t13:05:47.440\n        system.out.println("zoneddatetimenow: " + zoneddatetimenow); // zoneddatetimenow: 2020-08-20t13:05:47.440+08:00[asia/shanghai] 东八区\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 2. java8的time包下其他使用now方法的类.\n\n/**\n * 其他使用now方法的类\n * year,yearmonth,monthday\n */\n@test\npublic void test2() {\n    // 使用now方法创建year的实例方法对象\n    year yearnow = year.now();\n    // 使用now方法创建month的实例方法对象\n    yearmonth yearmonthnow = yearmonth.now();\n    // 使用now方法创建day的实例方法对象\n    monthday monthdaynow = monthday.now();\n\n    // 将实例对象在到控制台输出\n    system.out.println("yearnow: " + yearnow); // yearnow: 2020\n    system.out.println("yearmonthnow: " + yearmonthnow); // yearmonthnow: 2020-08\n    system.out.println("monthdaynow: " + monthdaynow); // monthdaynow: --08-20\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> now(): 获取当前时间日期.\n\n# 3. of方法在日期/时间类中的应用\n\nof方法可以根据给定的参数生成对相应的日期/时间,基本上每个基本类都有of方法用于生成的对应的对象,而且重载形式多变,可以根据不同的参数生成对应的数据.\n\n 1. localdate.of 简单使用\n\n/**\n * 初始化2020年8月8日\n */\n@test\npublic void test1() {\n    localdate localdate = localdate.of(2020, 8, 8);\n    system.out.println("localdate: "+ localdate); // localdate: 2020-08-08\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n 2. localtime.of 的使用\n    \n    localtime.of(int hour, int minute): 根据小时/分钟生成对象\n    \n    localtime.of(int hour, int minute,int second): 根据小时/分钟/秒生成对象\n    \n    localtime.of(int hour, int minute,int second, int nanoofsecond): 根据小时/分钟/秒/纳秒生成对象.\n\n/**\n * 初始化晚上8点0分0秒的" localtime " 对象  -> 如果是晚上的时间,需要将12.\n */\n@test\npublic void test2() {\n    // 方式一\n    localtime localtime1 = localtime.of(20, 0);\n    // 方式二\n    localtime localtime2 = localtime.of(20, 0,58);\n    // 方式三\n    localtime localtime3 = localtime.of(20, 0,34,1);\n    system.out.println("localtime1: " + localtime1); // localtime1: 20:00\n    system.out.println("localtime2: " + localtime2); // localtime2: 20:00:58\n    system.out.println("localtime3: " + localtime3); // localtime3: 20:00:34.000000001\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n 3. localdatetime.of的使用\n    \n    localdatetime.of(int year, int month, int dayofmonth, int hour, int minute ,int second, int nanoofsecond): 根据年/月/日/时/分/秒/纳秒生成对象\n    \n    localdatetime.of(int year, int month, int dayofmonth, int hour, int minute): 根据年/月/日/时/分生成对象\n\n/**\n * 初始化2020年8月8日下午8点0分的 " localdatetime " 对象\n */\n@test\npublic void test3(){\n    localdatetime localdatetime1 = localdatetime.of(2020, 8, 8, 20, 0);\n    system.out.println("localdatetime1: " + localdatetime1); // localdatetime1: 2020-08-08t20:00\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 特殊情况: localdatetime.of(localdate date, localtime time)\n\n/**\n * localdatetime: 特殊使用\n */\n@test\npublic void test4() {\n    // localdate\n    localdate localdate = localdate.of(2020, 8, 8);\n    // localtime\n    localtime localtime = localtime.of(20, 0);\n\n    localdatetime localdatetime = localdatetime.of(localdate, localtime);\n    system.out.println("localdatetime: " + localdatetime); // localdatetime: 2020-08-08t20:00\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 4. localdatetime 时区信息\n\nzoneddatetime: 不仅封装有日期时间,并且还有偏移量 时区 (中国东八区)\n\n 1. 时区的获取\n    \n    通过 zoneid 类 提供的 getavailablezoneids() 可以获取一个set集合,集合中封装了600个时区.\n\npublic class timeclassmethodtest03 {\n\n    @test\n    public void test1(){\n        // 获取所有时区信息\n        set<string> availablezoneids = zoneid.getavailablezoneids();\n        for (string availablezoneid : availablezoneids) {\n//            system.out.println(availablezoneid);\n        }\n        // 获取当前系统默认的时区信息 -> 中国\n        zoneid zoneid = zoneid.systemdefault();\n        system.out.println(zoneid); // asia/shanghai\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 2. 添加时区信息 / 获取其他时区信息\n\n@test\npublic void test2(){\n    // 1. 封装localdatetime对象,参数自定义->2020年11月11日 8点54分38秒\n    localdatetime time = localdatetime.of(2020, 11, 11, 8, 54, 38);\n    // 2. 封装完成后的time对象知识一个封装的时间对象,并没有时区相关的数据,所以添加时区到对象中,使用atzone()方法\n    zoneddatetime zoneddatetime = time.atzone(zoneid.of("asia/shanghai"));\n    system.out.println("zoneddatetime: " + zoneddatetime); // zoneddatetime: 2020-11-11t08:54:38+08:00[asia/shanghai]\n    // 3. 更改时区查看其它时区的当前时间 通过 withzonesameinstant() 即可更改\n    zoneddatetime americazoneddatetime = zoneddatetime.withzonesameinstant(zoneid.of("asia/tokyo"));\n    system.out.println("同一时间的日本时间: " + americazoneddatetime);\n    // 同一时间的日本时间: 2020-11-11t09:54:38+09:00[asia/tokyo]\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 5. month枚举类的使用\n\njava.time包中引入了month的枚举,month中包含标准日历中的12个月份的常量(1-12)月,也提供了一些方便的方法共我们使用.\n\n推荐在初始化 localdate 和 localdatetime 对象的时候,月份使用枚举的方式传入,这样更简单易懂而且不易出错.(旧的api calendar从0-11)\n\n/**\n * month月份枚举使用\n */\n@test\npublic void test(){\n    // 1. 初始化 localdate 和 localdatetime 对象的时候,月份使用枚举的方式传入 -> 2020年7月26日11时11分11面\n    localdatetime time = localdatetime.of(2020, month.july, 26, 11, 11, 11);\n    system.out.println(time); // 2020-07-26t11:11:11\n\n    // 2. month枚举类 -> of可以根据传入的数字返回对应月份的枚举\n    month month = month.of(12);\n    system.out.println(month); // december\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 6. 测试\n\npublic class timeclassmethodtest05 {\n\n    /**\n     * 创建当前时间(不带时区)\n     */\n    @test\n    public void test1(){\n        localdatetime now = localdatetime.now();\n        system.out.println(now); // 2020-08-20t22:06:05.361\n    }\n\n    /**\n     * 创建当前时间(只包含年月日)\n     */\n    @test\n    public void test2(){\n        localdate now = localdate.now();\n        system.out.println(now); // 2020-08-20\n    }\n\n    /**\n     * 创建当前时间(包含年月日时分秒并且带有时区)\n     */\n    @test\n    public void test3(){\n        zoneddatetime now = zoneddatetime.now();\n        system.out.println(now); // 2020-08-20t22:09:06.124+08:00[asia/shanghai]\n    }\n\n    /**\n     * 创建2020年12日31日7时38分46秒的日期对象(月份使用枚举)\n     */\n    @test\n    public void test4(){\n        localdatetime now = localdatetime.of(2020, month.december,31,7,38,46);\n        system.out.println(now); // 2020-12-31t07:38:46\n    }\n\n    /**\n     * 创建2020年12日31日的日期对象(月份使用枚举)\n     */\n    @test\n    public void test5(){\n        localdate now = localdate.of(2020,month.december,31);\n        system.out.println(now); // 2020-12-31\n    }\n\n    /**\n     * 创建7时38分46秒的时间对象\n     */\n    @test\n    public void test6(){\n        localtime now = localtime.of(7,38,46);\n        system.out.println(now); // 07:38:46\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 6.3 根据现有实例创建日期与时间对象\n\njava8中的日期时间相关的api的所有实例都是不可变的,一旦创建 localdate,localtime,localdatetime 就无法修改(类似于spring), 这对于线程安全非常有利\n\n# 1. plus在 localdate,localtime 中的使用\n\n想要修改某个日期/时间的现有实力是,我们可以使用plus/minus方法来完成操作.\n\n 1. localdate中对日期进行递增/减操作的方法\n\n方法                                  作用\nlocaldate plusdays(long days)       增减天数\nlocaldate plusweeks(long weeks)     增减周数\nlocaldate plusmonths(long months)   增减月数\nlocaldate plusyears(long years)     增减年数\n\n/**\n * plus方法在localdate中的使用\n * localdate plusdays(long days)增减天数\n * localdate plusweeks(long weeks)增减周数\n * localdate plusmonths(long months)增减月数\n * localdate plusyears(long years)增减年数\n */\n@test\npublic void test1(){\n    // 封装localdate对象,参数为2020年2月13日\n    localdate localdate = localdate.of(2020, month.february, 13);\n    system.out.println("当前时间: " + localdate); // 当前时间: 2020-02-13\n\n    // 计算当前时间的4天后的时间,并打印\n    localdate date1 = localdate.plusdays(4);\n    system.out.println("当前时间的4天后时间: " + date1); // 当前时间的4天后时间: 2020-02-17\n\n    // 计算当前时间的3周后的时间,并打印\n    localdate date2 = localdate.plusweeks(3);\n    system.out.println("当前时间的4周后时间: " + date2); // 当前时间的4周后时间: 2020-03-05\n\n    // 计算当前时间的5个月后的时间,并打印\n    localdate date3 = localdate.plusmonths(5);\n    system.out.println("当前时间的5个月后时间: " + date3); // 当前时间的5个月后时间: 2020-07-13\n\n    // 计算当前时间的2年后的时间,并打印\n    localdate date = localdate.plusyears(3);\n    system.out.println("当前时间的2年后时间: " + date); // 当前时间的2年后时间: 2023-02-13\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n 2. localtime中对时间进行递增/减操作的方法\n\n方法                                    作用\nlocaltime plusnanos(long nanos)       增加纳秒\nlocaltime plusseconds(long seconds)   增加秒\nlocaltime plusmenutes(long menutes)   增加分钟\nlocaltime plushours(long hours)       增加小时\n\n/**\n * plus方法在localtime中的使用\n * localtime plusnanos(long nanos)增加纳秒\n * localtime plusseconds(long seconds)增加秒\n * localtime plusmenutes(long menutes)增加分钟\n * localtime plushours(long hours)增加小时\n */\n@test\npublic void test2() {\n    // 封装localtime对象参数为8点13分39秒218毫秒\n    localtime localtime = localtime.of(8, 13, 39, 218);\n    system.out.println("当前时间: " + localtime); // 当前时间: 08:13:39.000000218\n\n    // 计算当前时间500纳秒后的时间,并打印\n    localtime date1 = localtime.plusnanos(500);\n    system.out.println("当前时间500纳秒后的时间: " + date1); // 当前时间500纳秒后的时间: 08:13:39.000000718\n\n    // 计算当前时间45秒后的时间,并打印\n    localtime date2 = localtime.plusseconds(45);\n    system.out.println("当前时间45秒后的时间: " + date2); // 当前时间45秒后的时间: 08:14:24.000000218\n\n\n    // 计算当前时间19分钟后的时间,并打印\n    localtime date3 = localtime.plusminutes(19);\n    system.out.println("当前时间19分钟后的时间: " + date3); // 当前时间19分钟后的时间: 08:32:39.000000218\n\n    // 计算当前时间3小时后的时间,并打印\n    localtime date4 = localtime.plushours(3);\n    system.out.println("当前时间3小时后的时间: " + date4); // 当前时间3小时后的时间: 11:13:39.000000218\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 2. minus方法在 localdate,localtime中的使用\n\n 1. localdate中对日期进行递增/减操作的方法\n\n方法                                             作用\nlocaldate minusdays(long daystosubtract)       增减天数\nlocaldate minusweeks(long weekstosubtract)     增减周数\nlocaldate minusmonths(long monthstosubtract)   增减月数\nlocaldate minusyears(long yearstosubtract)     增减年数\n\n/**\n * minus方法在localdate中的使用\n * localdate minusdays(long daystosubtract)增减天数\n * localdate minusweeks(long weekstosubtract)增减周数\n * localdate minusmonths(long monthstosubtract)增减月数\n * localdate minusyears(long yearstosubtract)增减年数\n */\n@test\npublic void test1() {\n    // 封装localdate对象,参数为2020年2月13日\n    localdate localdate = localdate.of(2020, month.february, 13);\n    system.out.println("当前时间: " + localdate); // 当前时间: 2020-02-13\n\n    // 计算当前时间的4天后的时间,并打印\n    localdate date1 = localdate.minusdays(4);\n    system.out.println("当前时间的4天前时间: " + date1); // 当前时间的4天前时间: 2020-02-09\n\n    // 计算当前时间的3周后的时间,并打印\n    localdate date2 = localdate.minusweeks(3);\n    system.out.println("当前时间的4周前时间: " + date2); // 当前时间的4周前时间: 2020-01-09\n\n    // 计算当前时间的5个月后的时间,并打印\n    localdate date3 = localdate.minusmonths(5);\n    system.out.println("当前时间的5个月前时间: " + date3); // 当前时间的5个月前时间: 2019-09-13\n\n    // 计算当前时间的2年后的时间,并打印\n    localdate date = localdate.minusyears(2);\n    system.out.println("当前时间的2年前时间: " + date); // 当前时间的2年前时间: 2018-02-13\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n 2. localtime中对时间进行递增/减操作的方法\n\n方法                                               作用\nlocaltime minusnanos(long nanostosubtract)       增加纳秒\nlocaltime minusseconds(long secondstosubtract)   增加秒\nlocaltime minusminutes(long menutes)             增加分钟\nlocaltime minushours(long hourstosubtract)       增加小时\n\n/**\n * minus方法在localtime中的使用\n * localtime minusnanos(long nanostosubtract)增加纳秒\n * localtime minusseconds(long secondstosubtract)增加秒\n * localtime minusminutes(long menutes)增加分钟\n * localtime minushours(long hourstosubtract)增加小时\n */\n@test\npublic void test2() {\n    // 封装localtime对象参数为8点13分39秒218毫秒\n    localtime localtime = localtime.of(8, 13, 39, 218);\n    system.out.println("当前时间: " + localtime); // 当前时间: 08:13:39.000000218\n\n    // 计算当前时间500纳秒后的时间,并打印\n    localtime date1 = localtime.minusnanos(500);\n    system.out.println("当前时间500纳秒后的时间: " + date1); // 当前时间500纳秒后的时间: 08:13:39.000000718\n\n    // 计算当前时间45秒后的时间,并打印\n    localtime date2 = localtime.minusseconds(45);\n    system.out.println("当前时间45秒后的时间: " + date2); // 当前时间45秒后的时间: 08:14:24.000000218\n\n\n    // 计算当前时间19分钟后的时间,并打印\n    localtime date3 = localtime.minusminutes(19);\n    system.out.println("当前时间19分钟后的时间: " + date3); // 当前时间19分钟后的时间: 08:32:39.000000218\n\n    // 计算当前时间3小时后的时间,并打印\n    localtime date4 = localtime.minushours(3);\n    system.out.println("当前时间3小时后的时间: " + date4); // 当前时间3小时后的时间: 11:13:39.000000218\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 3. plus/minus单独使用\n\n 1. plus方法\n\n方法                                                         作用\nlocaldate/localtime/localdatetime plus(temporalamount      \namounttoadd)\nlocaldate/localtime/localdatetime plus(long amounttoadd,   \ntemporalunit unit)\n\n * temporalamount 是一个接口,当借口作为方法的参数的时候,实际上传入的是接口的实现类对象,根据查看这个接口的体系,可以看到这个接口有一个实现类,名字叫做 period (表示一段时间)\n   \n   \n\n> period of(int years, int months, int days): period.of(1,2,3) 返回对象表示即为1年2月3天\n\n/**\n * 今天程序员小张查看自己的车辆的保险记录的时候看到还有2年3月8天就到期了,计算到期的时间是什么时候.\n * localdate plus(temporalamount amounttoadd)\n * period.of(int years, int months, int days)\n */\n@test\npublic void test3(){\n\n    // 1. 封装当前时间 -> now方法\n    localdatetime now = localdatetime.now();\n    system.out.println("当前时间: " + now); // 当前时间: 2020-08-21t06:34:36.627\n\n    // 2. 在当前时间的基础上,进行+年月日操作,获取一个截止日期对象,这个对象就是保险的到期时间\n    localdatetime endtime1 = now.plusyears(2).plusmonths(3).plusdays(8);\n    system.out.println("保险到期时间: " + endtime1); // 保险到期时间: 2022-11-29t06:34:36.627\n\n    // 3. 使用 plus 方法改进 temporalamount ---\x3e period(实现类)\n    // period.of(int years, int months, int days)\n    period period = period.of(2, 3, 8);\n    localdatetime endtime2 = now.plus(period); // 在当前时间的基础上增加\n    system.out.println("保险到期时间: " + endtime2); // 保险到期时间: 2022-11-29t06:34:36.627\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n * 在实际开发过程中可能还会更准确的操作日期或者说增加一些特殊的时间,比如说1个世纪,一个半天,一年...,java8已经提供了这些日期的表示方法而不需要去单独进行计算了.\n   \n   temporalunit 是一个接口,通过查看体系接口发现,可以使用子类 chronounit 来表示.\n   \n   \n\n * chronounit\n   \n   一组标准的日期时间单位。\n   \n   \n   \n   > 图片来源: jdk文档\n\n/**\n * 结婚10年称为锡婚,2020年2月2日11点11分11秒称为对称日,很多情侣准备在那天结婚,如果在那天结婚了,那么锡婚会发生在什么时候?\n * localdate/localtime/localdatetime plus(long amounttoadd, temporalunit unit)\n */\n@test\npublic void test4() {\n    // 封装日期 -> 表示结婚的时间点\n    localdatetime marrytime = localdatetime.of(2020, month.february, 2, 11, 11, 11);\n\n    // 1. 使用 plus() 进行计算,加上一个十年  chronounit.decades : 代表十年\n    localdatetime time = marrytime.plus(1, chronounit.decades);\n    system.out.println("如果在: " + marrytime + " 结婚, 那么锡婚的时间是: " + time); // 如果在: 2020-02-02t11:11:11 结婚, 那么锡婚的时间是: 2030-02-02t11:11:11\n\n    // 2. 如果锡婚后的半天,需要请所有的亲朋好友吃饭,计算吃饭的时间. chronounit.half_days : 代表半天\n    localdatetime ctime = time.plus(1, chronounit.half_days);\n    system.out.println("半天后, 请客吃放的时间为: " + ctime); // 半天后,请客吃放的时间为: 2030-02-02t23:11:11\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 2. minus方法\n\n方法                                                       作用\nlocaldate/localtime/localdatetime minus(long             \namounttosubtract, temporalunit unit)\nlocaldate/localtime/localdatetime minus(temporalamount   \namounttosubtract)\n\n> 使用方法同 plus\n\n# 4. with方法\n\n如果不需要对日期进行加减而是直接修改日期的话,那么可以使用with方法,with方法提供了许多种修改时间的方法.\n\n 1. 在localdatetime中的使用\n\n方法                                             作用\nlocaldatetime withnano(int nanoofsecond)       修改纳秒\nlocaldatetime withsecond(int second)           修改秒\nlocaldatetime withminute(int minute)           修改分钟\nlocaldatetime withhour(int hour)               修改小时\nlocaldatetime withdayofmonth(int dayofmonth)   修改日\nlocaldatetime withdayofyear(int dayofyear)     \nlocaldatetime withmonth(int month)             修改月\nlocaldatetime withyear(int year)               修改年\n\npublic static localdatetime gettime(){\n    // 2020.12.12 12:12:0\n    return localdatetime.of(1999, month.december,12,12,12,0);\n}\n\n/**\n *\n */\n@test\npublic void test1(){\n    localdatetime time = gettime();\n    // 使用 with 方法修改\n    // 1. 经过使用发现 time 存在问题, 时间应为 1 号\n    localdatetime resulttime1 = time.withdayofmonth(1);\n    system.out.println("修改前的错误时间: "+ time); // 修改前的错误时间: 1999-12-12t12:12\n    system.out.println("修改后的正确时间1: "+ resulttime1); //  修改后的正确时间: 1999-12-01t12:12\n\n    // 2. 修改为 2020.8.8 11:11:11:1\n    localdatetime resulttime2 = time.withyear(2020).withmonth(8).withdayofmonth(8).withhour(11).withminute(11).withsecond(11).withnano(1);\n    system.out.println("修改前的错误时间: "+ time); // 修改前的错误时间: 1999-12-12t12:12\n    system.out.println("修改后的正确时间2: "+ resulttime2); // 修改后的正确时间2: 2020-08-08t11:11:11.000000001\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n 2. with单独使用\n\n方法                                         作用\nwith(temporalfield field, long newvalue)   \nwith(temporaladjuster adjuster)            \n\n * temporalfield是一个接口,通过查看体系结构,可以使用它的子类chronofield\n   \n   \n\n * chronofield中封装了一些日期时间中的组成部分,可以直接选择之后传入第二个参数进行修改.(参考)\n   \n   例; with(chronofield.day_of_month,1): 将日期中的月份中的天数修改为1\n\n/**\n * with(temporalfield field, long newvalue)\n */\n@test\npublic void test2(){\n    localdatetime time = gettime();\n    // 使用 with 方法修改\n    // 1. 经过使用发现 time 存在问题, 时间应为 1 号\n    localdatetime resulttime1 = time.with(chronofield.day_of_month, 1);\n    system.out.println("修改前的错误时间: "+ time); // 修改前的错误时间: 1999-12-12t12:12\n    system.out.println("修改后的正确时间1: "+ resulttime1); //  修改后的正确时间: 1999-12-01t12:12\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 5. 测试\n\n/**\n * @description: <h1> 测试plus/with </h1>\n * 使用三种方式计算2019年7月19日14是38分34秒后的3年7个月18天后是什么时候\n */\npublic class timeclassmethodpluswithtest {\n\n    /**\n     * plus() period\n     */\n    @test\n    public void test1(){\n        // 封装当前时间 -> of()\n        localdatetime time = localdatetime.of(2019, month.july, 19, 14, 38, 34);\n        // 通过period封装一个时间段表示: 3年7个月18天后\n        period period = period.of(3, 7, 18);\n        // 通过plus()增加 period 是 temporalamount 的一个实现类\n        localdatetime endtime = time.plus(period);\n        system.out.println("当前时间是: " + time + ", 3年7个月18天后: " + endtime);\n        // 当前时间是: 2019-07-19t14:38:34 3年7个月18天后: 2023-03-09t14:38:34\n    }\n\n    /**\n     * plus()\n     */\n    @test\n    public void test2(){\n        // 封装当前时间 -> of()\n        localdatetime time = localdatetime.of(2019, month.july, 19, 14, 38, 34);\n        // 通过plus()增加 3年7个月18天后\n        localdatetime endtime = time\n                .plusyears(3)\n                .withmonth(7)\n                .withdayofmonth(18);\n        system.out.println("当前时间是: " + time + ", 3年7个月18天后: " + endtime);\n        // 当前时间是: 2019-07-19t14:38:34 3年7个月18天后: 2023-03-09t14:38:34\n    }\n\n    /**\n     * with()\n     */\n    @test\n    public void test3(){\n        // 封装当前时间 -> of()\n        localdatetime time = localdatetime.of(2019, month.july, 19, 14, 38, 34);\n        // 通过with 修改到 3年7个月18天后\n        localdatetime endtime = time\n                .withyear(2023)\n                .withmonth(3)\n                .withdayofmonth(9);\n        system.out.println("当前时间是: " + time + ", 3年7个月18天后: " + endtime);\n        // 当前时间是: 2019-07-19t14:38:34 3年7个月18天后: 2023-03-09t14:38:34\n    }\n\n    /**\n     * with()\n     */\n    @test\n    public void test4(){\n        // 封装当前时间 -> of()\n        localdatetime time = localdatetime.of(2019, month.july, 19, 14, 38, 34);\n        // 通过with 修改到 3年7个月18天后\n        localdatetime endtime = time\n                .with(chronofield.year,2023)\n                .with(chronofield.month_of_year,3)\n                .with(chronofield.day_of_month,9);\n        system.out.println("当前时间是: " + time + ", 3年7个月18天后: " + endtime);\n        // 当前时间是: 2019-07-19t14:38:34 3年7个月18天后: 2023-03-09t14:38:34\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 6.4 调节器temporaladjuster与查询temporalquery\n\n# 1. 调节器temporaladjuster\n\n在上一篇中介绍了,我们可以通过with方法修改日期时间对象中封装的数据,但是有一些时候可能会做一些复杂的操作,比如说将时间调整到下个周的周日,下一个工作日,又或者本月中的某一天,这个时候我们可以使用temporaladjuster来更方便的处理日期.\n\n方法                                作用\nwith(temporaladjuster adjuster)   \n\n> temporaladjuster: 是一个接口,with方法实际上传入的是这个接口的实现类对象, temporaladjusters并不是temporaladjuster的一个实现类,只不过temporaladjusters的静态方法石祥路temporaladjuster.并且将实现类对象返回了.\n\n方法                                                          作用\nstatic temporaladjuster firstdayofmonth()                   当月的第一天\nstatic temporaladjuster lastdayofmonth()                    当月的第一天\nstatic temporaladjuster firstdayofnextmonth()               下一个月的第一天\nstatic temporaladjuster firstdayofyear()                    当年的第一天\nstatic temporaladjuster lastdayofyear()                     当年的第一天\nstatic temporaladjuster firstdayofnextyear()                下一年的第一天\nstatic temporaladjuster firstinmonth(dayofweek dayofweek)   当月的第一个周x(通过参数确定)\nstatic temporaladjuster lastinmonth(dayofweek dayofweek)    当月的最后一个周x(通过参数确定)\n\nstatic temporaladjuster ofdateadjuster(unaryoperator<localdate> datebasedadjuster)\n\n\n1\n\n\n> temporaladjuster 是一个函数是接口,里面有一个抽象方法叫做 temporal adjustinto(temporal temporal) ;传入一个 temporal 对象通过实现逻辑返回一个 temporal 对象,temporal 是 localdate,localtime相关日期类的父接口,\n\n@test\npublic void test1() {\n    // 封装日期时间对象为当前对象\n    localdate now = localdate.now();\n\n    // 通过with()传入temporaladjuster类的实现类对象,就可以更改,实现类对象是由temporaladjuster s类的静态方法来提供.\n    // 1. 修改时间为当月的第一天\n    localdate firstdayofmonth = now.with(temporaladjusters.firstdayofmonth());\n    system.out.println("当月的第一天: " + firstdayofmonth); // 当月的第一天: 2020-08-01\n\n    // 2. 修改时间为当月的最后第一天\n    localdate lastdayofmonth = now.with(temporaladjusters.lastdayofmonth());\n    system.out.println("当月的最后第一天: " + lastdayofmonth); // 当月的最后第一天: 2020-08-31\n\n    // 3. 修改时间为下一个月的第一天\n    localdate firstdayofnextmonth = now.with(temporaladjusters.firstdayofnextmonth());\n    system.out.println("下一个月的第一天: " + firstdayofnextmonth); // 下一个月的第一天: 2020-09-01\n\n    // 4. 修改时间为当年的第一天\n    localdate firstdayofyear = now.with(temporaladjusters.firstdayofyear());\n    system.out.println("当年的第一天: " + firstdayofyear); // 当年的第一天: 2020-01-01\n\n    // 5. 修改时间为下一年的第一天\n    localdate firstdayofnextyear = now.with(temporaladjusters.firstdayofnextyear());\n    system.out.println("下一年的第一天: " + firstdayofnextyear); // 下一年的第一天: 2021-01-01\n\n    // 6. 修改时间为当年的最后第一天\n    localdate lastdayofyear = now.with(temporaladjusters.lastdayofyear());\n    system.out.println("当年的最后第一天: " + lastdayofyear); // 当年的最后第一天: 2020-12-31\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 2. dayofweek的使用\n\ndayofweek是一周中星期几的枚举类,其中封装了从周一到周日.\n\n/**\n * dayofweek\n * static temporaladjuster next(dayofweek dayofweek): 下一个周x\n * static temporaladjuster previous(dayofweek dayofweek): 上一个周x\n */\n@test\npublic void test2(){\n    // 封装日期时间对象为当前对象\n    localdate now = localdate.now();\n\n    // 1. 将当前时间修改为下一月的周日\n    localdate date1 = now.with(temporaladjusters.next(dayofweek.sunday));\n    system.out.println("当前日期: "+ now+ ", 下一月的周日; " + date1); // 当前日期: 2020-08-22, 下一月的周日; 2020-08-23\n\n    // 2. 将当前时间修改为上一个周三\n    localdate date2 = now.with(temporaladjusters.previous(dayofweek.wednesday));\n    system.out.println("当前日期: "+ now+ ", 上一月的周三; " + date2); // 当前日期: 2020-08-22, 上一月的周三; 2020-08-19\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3. 自定义temporaladjuster调节器\n\n通过java8本身提供的temporaladjusters中的方法可以完成一些常用的操作,如果需要自定义日期时间的更改逻辑,可以通过实现temporaladjuster类的接口中的方式来完成.\n\n * 创建类实现temporaladjuster接口\n * 实现temporaladjuster中的adjustinto方法,传入一个日期时间对象,完成逻辑之后日期时间对象\n * 通过with方法传入自定义调节器对象完成更改.\n\n /**\n     * 例如员工一个月中领取工资,发薪日是每个月的15号,如果发薪日是周末,则调整为周五\n     * <p>\n     * 之后会传入一个日期类时间对象,判断日期类时间对象是不是15号,如果不是15号则修改为15号,如果是周六或者周日,则改为周五(上一个)\n     */\n    class paydayadjuster implements temporaladjuster {\n\n        @override\n        public temporal adjustinto(temporal temporal) {\n            // 1. temporal: 日期时间类对象的父接口,实际上可以理解为传入的就是localdate或者localtime对象.需要将temporal转换为localdate对象\n            localdate payday = localdate.from(temporal);\n            // 2. 判断日期类时间对象是不是15号,如果不是15号则修改为15号\n            int day = 0;\n            if (payday.getdayofmonth() != 15) {\n                day = 15;\n            } else {\n                day = payday.getdayofmonth();\n            }\n            // with修改日期\n            localdate realpayday = payday.withdayofmonth(day);\n            // 3. 判断readpayday,如果是周六或者周日,则改为周五(上一个)\n            if (realpayday.getdayofweek() == dayofweek.saturday || realpayday.getdayofweek() == dayofweek.sunday) {\n                // 是周六/周日,修改为上一个周五\n                realpayday = realpayday.with(temporaladjusters.previous(dayofweek.friday));\n            }\n            return realpayday;\n        }\n    }\n\n    /**\n     * 测试上面类是否可用\n     */\n    @test\n    public void tes3() {\n        // 封装localdate对象为2018年12月1日\n        localdate payday = localdate.of(2018, month.december, 1);\n\n        // 计算payday的真实发薪日\n        temporal temporal = new paydayadjuster().adjustinto(payday);\n        // 转换\n        localdate localdate = localdate.from(temporal);\n        system.out.println("预计的发薪日: " + payday + ", 真是的发薪日: " + localdate);\n        // 预计的发薪日: 2018-12-01, 真是的发薪日: 2018-12-14\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n> temporal: 日期时间类对象的父接口,实际上可以理解为传入的就是localdate或者localtime对象.需要将temporal转换为localdate对象\n> \n> localdate.from():\n\n# 4. temporalquery的应用\n\n学习的是时态类对象(localdate,localtime)都有一个方法叫做query,可以针对日期进行查询.\n\nr query(temporalquery query)这个方法是一个泛型方法,返回的数据就是传入的泛型类的类型 temporalquery是一个泛型接口,包含一个抽象方法:\n\n方法\nr queryfrom(temporalaccessor temporal)\n\n> temporalaccessor: 是temporal的父接口,实际上也就是localdate,localdatetime相关类的顶级父接口,这个queryfrom的方法的实现逻辑就是传入一个日期/时间通过自定义逻辑返回数据.\n\n/**\n * @description: <h1> temporalquery查询使用 </h1>\n * 获取某一天距离下一个劳动节相隔天数的实现\n */\npublic class timeclasstemporalquerytest implements temporalquery<long> {\n\n    @override\n    public long queryfrom(temporalaccessor temporal) {\n        // 1. temporalaccessor时localdate和localdatetime的顶级父接口,相当于localdate就是这个接口的实现类.将这个参数转换为localdate使用\n        localdate now = localdate.from(temporal); // now > 2020.1.17\n        // 2. 封装当年劳动节的时间 年份: now 月份: 5 日: 1\n        localdate laborday = localdate.of(now.getyear(), month.may, 1);\n        // 3. 判断当前时间是否已过当年的劳动节,则laborday加一年 (判断月份是否为5月)\n//        if (laborday.getmonth()==month.may)\n        if (now.isafter(laborday)) { // isafter() 现在的日期是否在当年5月1日之后\n            laborday = laborday.plusyears(1); // plus() 年份+1\n        }\n        // 4. 通过chronounit的between()计算两个时间之间的差值\n        return chronounit.days.between(now, laborday);\n    }\n\n    /**\n     * 计算当前时间距离下个劳动节多少天\n     *\n     * @param args\n     */\n    public static void main(string[] args) {\n        // 封装当前时间\n        localdate now = localdate.now();\n        // 调用now的query方法,然后将我们自己的实现类timeclasstemporalquerytest作为参数传入\n        long day = now.query(new timeclasstemporalquerytest());\n        system.out.println("当前的时间是: " + now + ", 计算当前时间距离下个劳动节多少天: " + day);\n        // 当前的时间是: 2020-08-22计算当前时间距离下个劳动节多少天: 252\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n# 5. 测试\n\n/**\n * @description: <h1> 测试 </h1>\n * 计算任意时间与下一个圣诞季/儿童节/劳动节相差多少天?\n */\npublic class temporaladjusterandtemporalquerytest implements temporalquery<long[]> {\n\n    /**\n     * @return 表示距离 圣诞季/儿童节/劳动节 三个节日的天数差额,0索引表示距离圣诞节,1索引表示距离儿童及,2索引表示劳动节\n     */\n    @override\n    public long[] queryfrom(temporalaccessor temporal) {\n        // 1. 将temporal转换为localdate\n        localdate now = localdate.from(temporal);\n\n        // 2. 封装当年的 圣诞季/儿童节/劳动节 的日期对象 年: now的year 月+日: 各自对应日期\n        localdate date1 = localdate.of(now.getyear(), month.december, 25);\n        localdate date2 = localdate.of(now.getyear(), month.june, 1);\n        localdate date3 = localdate.of(now.getyear(), month.may, 1);\n\n        // 3. 判断now是否超过了当 date1,date2,date3三个节日,如果超过则计算下一年的日期\n        if (now.isafter(date1)) {\n            date1 = date1.plusyears(1); // +1\n        }\n        if (now.isafter(date2)) {\n            date2 = date2.plusyears(1); // +1\n        }\n        if (now.isafter(date3)) {\n            date3 = date3.plusyears(1); // +1\n        }\n\n        // 4. 通过chronounit的between()计算两个时间之间的差值\n        long[] longs = {chronounit.days.between(now, date1), chronounit.days.between(now, date2), chronounit.days.between(now, date3)};\n        return longs;\n    }\n\n    /**\n     * 计算任意时间与下一个圣诞季/儿童节/劳动节相差多少天?\n     *\n     * @param args\n     */\n    public static void main(string[] args) {\n        // 1. 封装任意日期\n        localdate now = localdate.of(2020, month.may, 30);\n\n        // 2. 调用now的query的方法查询三个节日的差值\n        long[] longs = now.query(new temporaladjusterandtemporalquerytest());\n\n        // 3. 打印结果\n        system.out.println("当前时期: " + now + ", 距离下一个圣诞节: " + longs[0] + "天");\n        system.out.println("当前时期: " + now + ", 距离下一个儿童节: " + longs[1] + "天");\n        system.out.println("当前时期: " + now + ", 距离下一个劳动节: " + longs[2] + "天");\n        // 当前时期: 2020-05-30, 距离下一个圣诞节: 209天\n        // 当前时期: 2020-05-30, 距离下一个儿童节: 2天\n        // 当前时期: 2020-05-30, 距离下一个劳动节: 336天 \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 6.5 date和localdate转换\n\njava8中的java.time包中并没有提供太多的内置方式类转换java.util包中用预处理标准日期和时间的类,我们可以使用instant类作为中介,也可以使用java.sql.date和java.sql.timestamp类提供的方法进行转换.\n\n# 1. java.util.date类的转换\n\n 1. 使用instant将java.util.date转换为java.time.localdate\n\njava.time包中没有提供很多方式来进行直接转换,但是给之前的date类,calendar类在java8都提供了一个新的方法: toinstant,可以将当前的对象,通过给instant添加时区信息之后就可转换为localdate对象.\n\n /**\n     * java.util.date ---\x3e localdate 对象之间的转换\n     */\n    @test\n    public void test1() {\n        // 初始化date对象\n        java.util.date date = new java.util.date();\n        // 1. 将date对象转换为instant对象 toinstant\n        instant instant = date.toinstant();\n        // 2. date类中国包含日期和时间信息,但是并不提供时区信息,和instant类一样,通过instant类的atzone()添加时区信息进行转换\n        zoneddatetime zoneddatetime = instant.atzone(zoneid.systemdefault());\n        // 3. 将zoneddatetime通过tolocaldate()转换为localdate对象\n        localdate localdate = zoneddatetime.tolocaldate();\n        system.out.println("之前的date对象: " + date + ", 转换之后localdate对象: " + localdate);\n        // 之前的date对象: sat aug 22 16:14:27 cst 2020, 转换之后localdate对象: 2020-08-22\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> date类中包含日期和时间信息,但是并不提供时区信息,和instant类一样,通过instant类的atzone()添加时区信息进行转换\n\n 2. 第二种方式\n\n将java.util.date -> java.sql.date -> java.util.date方法通过构造方法传入毫秒值 --\x3e tolocaldate().(毫秒是可以通过java.util.date的gettime方法类获取)\n\n/**\n * java.util.date ---\x3e localdate 对象之间的转换 2\n */\n@test\npublic void test2() {\n    // 初始化date对象\n    java.util.date ud = new java.util.date();\n    // 1. 将 java.util.date -> java.sql.date  -> java.util.date方法通过构造方法传入毫秒值 --\x3e tolocaldate()\n    java.sql.date sd = new java.sql.date(ud.gettime());\n    localdate localdate = sd.tolocaldate();\n    system.out.println("之前的java.util.date对象: "+ ud);\n    system.out.println("之前的java.sql.date对象: "+ sd);\n    system.out.println("之后的localdate对象: "+ localdate);\n    // 之前的java.util.date对象: sat aug 22 16:42:08 cst 2020\n    // 之前的java.sql.date对象: 2020-08-22\n    // 之后的localdate对象: 2020-08-22\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 2. java.sql.date类的转换\n\njava.sql.date类中,通过传入的一个毫秒值对象进行初始化,提供直接转换为localdate的方法: tolocaldate\n\n/**\n * java.sql.date ---\x3e localdate\n */\n@test\npublic void test2(){\n    // 初始化一个java.sql.date对象\n    java.sql.date date = new java.sql.date(system.currenttimemillis());\n    // java.sql.date类中自带转换为localdate的方法,tolocaldate();\n    localdate localdate = date.tolocaldate();\n    system.out.println("之前的date对象: " + date + ", 转换之后localdate对象: " + localdate);\n    // 之前的date对象: 2020-08-22, 转换之后localdate对象: 2020-08-22\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 3. java.sql.timestamp类的转换\n\ntimestamp是时间戳对象,通过传入的一个毫秒值对象进行初始化.提供直接转换为localdatetime的方法: tolocaldatetime\n\n/**\n * java.sql.timestamp ---\x3e localdate\n */\n@test\npublic void test3(){\n    // 初始化一个java.sql.timestamp对象\n    timestamp timestamp = new timestamp(system.currenttimemillis());\n    // java.sql.timestamp类中自带转换为localdate的方法,tolocaldatetime();\n    localdatetime localdatetime = timestamp.tolocaldatetime();\n    system.out.println("之前的timestamp对象: " + timestamp + ", 转换之后localdate对象: " + localdatetime);\n    // 之前的timestamp对象: 2020-08-22 16:31:17.165, 转换之后localdate对象: 2020-08-22t16:31:17.165\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 4. java.util.calendar类的转换\n\n 1. calendar转换为zoneddatetime\n\ncalendar对象字java1.1开始提供了一个方法获取时区对象的方法,gettimezone,要将calendar对象转换为zoneddatetime需要现获取到时区对象,自java8开始timezone类提供了一个方法可以获取到zoneid,获取到zoneid之后就可以初始化zoneddatetime对象了,zoneddatetime类有一个ofinstant方法,可以将instant对象和zonedid对象作为参数传入构造一个zoneddatetime对象.\n\n方法                                                      作用\ncalendar.getinstance()                                  初始化calendar对象\ntimezone gettimezone()                                  获取时区\nzoneid tozoneid()                                       根据时区获取 zoneid\nzoneddatetime ofinstant(instant instant, zoneid zone)   将一个instant对象和zoneid队形封装为zoneddatetime\n\n/**\n * calendar ---\x3e zoneddatetime\n */\n@test\npublic void test1(){\n    // 1. 初始化calendar对象 (date和calendar提供 转换为instant的方法: toinstant)\n    calendar calendar = calendar.getinstance();\n    // 2. calendar对象自java1.1提供了一个方法用于获取时区对象gettimezone(),要将calendar对象转换为zoneddatetime对象要现获取到市区对象\n    timezone timezone = calendar.gettimezone();\n    // 3. timezone从1.8开始提供一个方法(tozoneid)获取到zoneid -> 根据zoneid构建zoneddatetime对象\n    zoneid zoneid = timezone.tozoneid();\n    // 4. zoneddatetime类有一个ofinstant方法,可以将一个instant对象和zoneid队形封装为zoneddatetime\n    zoneddatetime zoneddatetime = zoneddatetime.ofinstant(calendar.toinstant(), zoneid);\n    system.out.println("之前的calendar对象: " + calendar);\n    system.out.println("之后的zoneddatetime对象: " + zoneddatetime);\n    // 之前的calendar对象: java.util.gregoriancalendar[time=1598087373926,arefieldsset=true,areallfieldsset=true,lenient=true,zone=sun.util.calendar.zoneinfo[id="asia/shanghai",offset=28800000,dstsavings=0,usedaylight=false,transitions=19,lastrule=null],firstdayofweek=1,minimaldaysinfirstweek=1,era=1,year=2020,month=7,week_of_year=34,week_of_month=4,day_of_month=22,day_of_year=235,day_of_week=7,day_of_week_in_month=4,am_pm=1,hour=5,hour_of_day=17,minute=9,second=33,millisecond=926,zone_offset=28800000,dst_offset=0]\n    // 之后的zoneddatetime对象: 2020-08-22t17:09:33.926+08:00[asia/shanghai]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. calendar转换为localdatetime\n\ncalendar对象可以获取到年月日时分秒的信息,这些信息可以作为localdatetime构造方法的参数\n\n/**\n * calendar ---\x3e localdatetime\n */\n@test\npublic void test2() {\n    // 1. 初始化calendar对象 (date和calendar提供 转换为instant的方法: toinstant)\n    calendar calendar = calendar.getinstance();\n    // 2. 通过get()获取calendar中封装的数\n    int year = calendar.get(calendar.year);\n    int month = calendar.get(calendar.month);\n    int day = calendar.get(calendar.day_of_month);\n    int hor = calendar.get(calendar.hour_of_day);\n    int minute = calendar.get(calendar.minute);\n    int second = calendar.get(calendar.second);\n    // 3. 将上述结果作为localdatetime的of()的参数 注意: calendar的月份 需要+1\n    localdatetime localdatetime = localdatetime.of(year, month + 1, day, hor, minute, second);\n    system.out.println("之前的calendar对象: " + calendar);\n    system.out.println("之后的zoneddatetime对象: " + localdatetime);\n    // 之前的calendar对象: java.util.gregoriancalendar[time=1598088161179,arefieldsset=true,areallfieldsset=true,lenient=true,zone=sun.util.calendar.zoneinfo[id="asia/shanghai",offset=28800000,dstsavings=0,usedaylight=false,transitions=19,lastrule=null],firstdayofweek=1,minimaldaysinfirstweek=1,era=1,year=2020,month=7,week_of_year=34,week_of_month=4,day_of_month=22,day_of_year=235,day_of_week=7,day_of_week_in_month=4,am_pm=1,hour=5,hour_of_day=17,minute=22,second=41,millisecond=179,zone_offset=28800000,dst_offset=0]\n    // 之后的zoneddatetime对象: 2020-08-22t17:25:28\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 5. 日期的解析与格式化datetimeformatter\n\nsimpledateformat类是线程不安全的,java8提供了新的格式化类 datetimeformatter.\n\ndatetimeformatter: 提供了大量预定义格式化器,包括常量(如: iso_local_date),模式字母(如: yyyy-mm-dd)以及本地化样式.\n\n与simpledateformat不同的是,新版本的日期/时间api的格式化与解析不需要创建转换器对象在进行转换了,通过日期时间对象的parse/format方法可以直接尽心转化.\n\n 1. localdatetime的parse/format\n\n@override  // override for javadoc and performance\npublic string format(datetimeformatter formatter) {\n    objects.requirenonnull(formatter, "formatter");\n    return formatter.format(this);\n}\n\n\n1\n2\n3\n4\n5\n\n\n> format方法需要传入一个datetimeformatter对象.\n\n/**\n * 对localdatetime进行格式化和解析\n */\n@test\npublic void test1(){\n    // 初始化localdatetime对象\n    localdatetime now = localdatetime.now();\n\n    // now可以直接调用format进行格式化\n    string s1 = now.format(datetimeformatter.iso_date_time);\n    string s2 = now.format(datetimeformatter.iso_date);\n    system.out.println("iso_date_time格式化后: " + s1);\n    system.out.println("iso_date格式化后: " + s2);\n    // iso_date_time格式化后: 2020-08-22t17:39:37.916\n    // iso_date格式化后: 2020-08-22\n\n    // 解析parse\n    localdatetime localdatetime1 = localdatetime.parse(s1);\n    system.out.println(localdatetime1); // 2020-08-22t17:41:06.634\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 2. datetimeformatter的oflocalizeddate()\n\npublic static datetimeformatter oflocalizeddate(formatstyle datestyle) {\n    objects.requirenonnull(datestyle, "datestyle");\n    return new datetimeformatterbuilder().appendlocalized(datestyle, null)\n            .toformatter(resolverstyle.smart, isochronology.instance);\n}\n\n\n1\n2\n3\n4\n5\n\n\n此方法需要传入一个formstyle类对象,查看后发现formatstyle对象是一个枚举类:\n\n值        描述\nfull     全显示(年月日+星期)\nlong     全显示(年月日)\nmedium   缩略显示(没有年月日汉字)\nshort    精简显示(精简年+月日)\n\n/**\n * oflocalizeddate()使用\n */\n@test\npublic void test2(){\n    // 初始化localdatetime对象\n    localdatetime now = localdatetime.now();\n\n    // 通过datetimeformatter的oflocalizeddate指定解析格式\n    string s1 = now.format(datetimeformatter.oflocalizeddate(formatstyle.full));\n    string s2 = now.format(datetimeformatter.oflocalizeddate(formatstyle.long));\n    string s3 = now.format(datetimeformatter.oflocalizeddate(formatstyle.medium));\n    string s4 = now.format(datetimeformatter.oflocalizeddate(formatstyle.short));\n\n    system.out.println("full: " + s1);\n    system.out.println("long: " + s2);\n    system.out.println("medium: " + s3);\n    system.out.println("short: " + s4);\n    // full: 2020年8月22日 星期六\n    // long: 2020年8月22日\n    // medium: 2020-8-22\n    // short: 20-8-22\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> 注意: 此种方式在不同时区的显示方式不一样,在其他时区不会显示中文,会根据当先系统默认的时区类进行区别显示.\n\n 3. 自定义格式化日期\n\n除了系统自带的方式之外,也可以通过datetimeformatter类提供的orpattern方式创建自定义的格式化器,格式化的写法与之前使用到的simpledateformat相同\n\n\n\n/**\n * 自定义格式化器\n */\n@test\npublic void test3() {\n    // 初始化localdatetime对象\n    localdatetime now = localdatetime.now();\n\n    string s = now.format(datetimeformatter.ofpattern("yyyy/mm/dd hh:mm:ss:sss"));\n\n    system.out.println("localdatetime格式化后的内容:  " + s);\n    // localdatetime格式化后的内容:  2020/08/22 18:01:44:189\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 4. 测试\n\n/**\n * 将1998年3月18日17时19分28秒格式化为以下格式化和或或或或i:1998-03月-8---17:19分:28秒\n * <p>\n * 格式: yyyy-mm月-dd---hh:mm分:ss秒\n */\n@test\npublic void test4() {\n    // 初始化localdatetime对象\n    localdatetime now = localdatetime.of(1998,\n            month.march,\n            18,\n            17,\n            19,\n            28);\n    string s = now.format(datetimeformatter.ofpattern("yyyy-mm月-dd---hh:mm分:ss秒"));\n    system.out.println("之前: " + now);\n    system.out.println("之后: " + s);\n    // 之前: 1998-03-18t17:19:28\n    // 之后: 1998-03月-18---17:19分:28秒\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',charsets:{cjk:!0},lastUpdated:"2023/02/28, 18:23:46",lastUpdatedTimestamp:1677579826e3},{title:"JVM-StringTable",frontmatter:{title:"JVM-StringTable",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/6cfffc/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/13.JVM-StringTable.html",relativePath:"01.语言/01.JAVA语言/02.JVM/13.JVM-StringTable.md",key:"v-7e4c890f",path:"/pages/6cfffc/",headers:[{level:2,title:"1. String的基本特性",slug:"_1-string的基本特性",normalizedTitle:"1. string的基本特性",charIndex:22},{level:3,title:"1. 为什么JDK9改变了结构",slug:"_1-为什么jdk9改变了结构",normalizedTitle:"1. 为什么jdk9改变了结构",charIndex:309},{level:3,title:"2. String的不可变性",slug:"_2-string的不可变性",normalizedTitle:"2. string的不可变性",charIndex:801},{level:3,title:"3. String底层HashTable结构的说明",slug:"_3-string底层hashtable结构的说明",normalizedTitle:"3. string底层hashtable结构的说明",charIndex:2265},{level:4,title:"面试题",slug:"面试题",normalizedTitle:"面试题",charIndex:2294},{level:3,title:"4. 注意",slug:"_4-注意",normalizedTitle:"4. 注意",charIndex:2869},{level:2,title:"2. String的内存分配",slug:"_2-string的内存分配",normalizedTitle:"2. string的内存分配",charIndex:3251},{level:3,title:"为什么StringTable从永久代调整到堆中",slug:"为什么stringtable从永久代调整到堆中",normalizedTitle:"为什么stringtable从永久代调整到堆中",charIndex:3793},{level:2,title:"3. String的基本操作",slug:"_3-string的基本操作",normalizedTitle:"3. string的基本操作",charIndex:4596},{level:2,title:"4. 字符串的拼接操作",slug:"_4-字符串的拼接操作",normalizedTitle:"4. 字符串的拼接操作",charIndex:6029},{level:3,title:"1. 常量、变量、intern()比较",slug:"_1-常量、变量、intern-比较",normalizedTitle:"1. 常量、变量、intern()比较",charIndex:6189},{level:3,title:"2. 字符串拼接底层原理",slug:"_2-字符串拼接底层原理",normalizedTitle:"2. 字符串拼接底层原理",charIndex:7657},{level:3,title:"3. 体会执行效率",slug:"_3-体会执行效率",normalizedTitle:"3. 体会执行效率",charIndex:10130},{level:2,title:"5. intern()的使用",slug:"_5-intern-的使用",normalizedTitle:"5. intern()的使用",charIndex:11376},{level:3,title:"1. 面试题",slug:"_1-面试题",normalizedTitle:"1. 面试题",charIndex:12258},{level:4,title:'1. new String("ab")到底创建了几个对象？',slug:"_1-new-string-ab-到底创建了几个对象",normalizedTitle:"1. new string(&quot;ab&quot;)到底创建了几个对象？",charIndex:null},{level:4,title:'2. new String("a") + new String("b") 呢？',slug:"_2-new-string-a-new-string-b-呢",normalizedTitle:"2. new string(&quot;a&quot;) + new string(&quot;b&quot;) 呢？",charIndex:null},{level:4,title:"3. intern的使用：Jdk6 VS jdk7/8",slug:"_3-intern的使用-jdk6-vs-jdk7-8",normalizedTitle:"3. intern的使用：jdk6 vs jdk7/8",charIndex:13754},{level:4,title:"5. 扩展：",slug:"_5-扩展",normalizedTitle:"5. 扩展：",charIndex:14833},{level:3,title:"2. intern使用总结",slug:"_2-intern使用总结",normalizedTitle:"2. intern使用总结",charIndex:15276},{level:3,title:"3. 练习",slug:"_3-练习",normalizedTitle:"3. 练习",charIndex:15485},{level:4,title:"1. 练习1",slug:"_1-练习1",normalizedTitle:"1. 练习1",charIndex:15494},{level:3,title:"4. Intern()的空间效率测试：空间角度",slug:"_4-intern-的空间效率测试-空间角度",normalizedTitle:"4. intern()的空间效率测试：空间角度",charIndex:16387},{level:2,title:"6. StringTable的垃圾回收",slug:"_6-stringtable的垃圾回收",normalizedTitle:"6. stringtable的垃圾回收",charIndex:17452},{level:2,title:"7. G1中的String去重操作",slug:"_7-g1中的string去重操作",normalizedTitle:"7. g1中的string去重操作",charIndex:17773},{level:3,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:17839},{level:3,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:179},{level:3,title:"开启",slug:"开启",normalizedTitle:"开启",charIndex:18517}],headersStr:'1. String的基本特性 1. 为什么JDK9改变了结构 2. String的不可变性 3. String底层HashTable结构的说明 面试题 4. 注意 2. String的内存分配 为什么StringTable从永久代调整到堆中 3. String的基本操作 4. 字符串的拼接操作 1. 常量、变量、intern()比较 2. 字符串拼接底层原理 3. 体会执行效率 5. intern()的使用 1. 面试题 1. new String("ab")到底创建了几个对象？ 2. new String("a") + new String("b") 呢？ 3. intern的使用：Jdk6 VS jdk7/8 5. 扩展： 2. intern使用总结 3. 练习 1. 练习1 4. Intern()的空间效率测试：空间角度 6. StringTable的垃圾回收 7. G1中的String去重操作 描述 实现 开启',content:'# JVM-StringTable\n\n\n# 1. String的基本特性\n\n * String：字符串，使用一对 ”” 引起来表示\n   * String s1 = "mogublog" ; // 字面量的定义方式\n   * String s2 = new String("moxi");\n * String声明为final的，不可被继承\n * String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小\n * string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]\n\n\n# 1. 为什么JDK9改变了结构\n\nString类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。\n\n我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。\n\n结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间\n\n// 之前\nprivate final char value[];\n// 之后\nprivate final byte[] value\n\n\n1\n2\n3\n4\n\n\n同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改\n\n\n# 2. String的不可变性\n\nString：代表不可变的字符序列。简称：不可变性。\n\n> 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。\n\n代码\n\n/**\n * String的不可变性\n *\n * @author: CHGGX\n * @create: 2020-07-11-8:57\n */\npublic class StringTest1 {\n\n    public static void test1() {\n        // 字面量定义的方式，“abc”存储在字符串常量池中\n        String s1 = "abc";\n        String s2 = "abc";\n        System.out.println(s1 == s2);\n        s1 = "hello";\n        System.out.println(s1 == s2);\n        System.out.println(s1);\n        System.out.println(s2);\n        System.out.println("----------------");\n    }\n\n    public static void test2() {\n        String s1 = "abc";\n        String s2 = "abc";\n        // 只要进行了修改，就会重新创建一个对象，这就是不可变性\n        s2 += "def";\n        System.out.println(s1);\n        System.out.println(s2);\n        System.out.println("----------------");\n    }\n\n    public static void test3() {\n        String s1 = "abc";\n        String s2 = s1.replace(\'a\', \'m\');\n        System.out.println(s1);\n        System.out.println(s2);\n    }\n\n    public static void main(String[] args) {\n        test1();\n        test2();\n        test3();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n运行结果\n\ntrue\nfalse\nhello\nabc\n----------------\nabc\nabcdef\n----------------\nabc\nmbc\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3. String底层HashTable结构的说明\n\n# 面试题\n\n/**\n * 面试题\n *\n * @author: CHGGX\n * @create: 2020-07-11-9:05\n */\npublic class StringExer {\n    String str = new String("good");\n    char [] ch = {\'t\',\'e\',\'s\',\'t\'};\n\n    public void change(String str, char ch []) {\n        str = "test ok";\n        ch[0] = \'b\';\n    }\n\n    public static void main(String[] args) {\n        StringExer ex = new StringExer();\n        ex.change(ex.str, ex.ch);\n        System.out.println(ex.str); // good\n        System.out.println(ex.ch); // best\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n输出结果\n\ngood\nbest\n\n\n1\n2\n\n\n\n# 4. 注意\n\n字符串常量池是不会存储相同内容的字符串的\n\n 1. String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。\n\n 2. 使用-XX:StringTablesize可设置stringTab1e的长度。\n\n 3. 在jdk6中stringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。stringTablesize设置没有要求。\n\n 4. 在jdk7中，stringTable的长度默认值是60013。\n\n 5. 在JDK8中，StringTable可以设置的最小值为1009。\n\n\n# 2. String的内存分配\n\n在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。\n\n常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，string类型的常量池比较特殊。它的主要使用方法有两种。\n\n直接使用双引号声明出来的String对象会直接存储在常量池中。\n\n * 比如：string info="chggx.com"；\n\n如果不是用双引号声明的string对象，可以使用string提供的intern（）方法。\n\nJava 6及以前，字符串常量池存放在永久代\n\nJava 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内\n\n> 所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。\n> \n> 字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。\n\nJava8元空间，字符串常量在堆\n\n * JDK6\n   \n   \n\n * JDK7\n   \n   \n\n\n# 为什么StringTable从永久代调整到堆中\n\n * 永久代的默认比较小（permSize）\n * 永久代垃圾回收频率低\n\n在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。\n\n/**\n * jdk6中：永久代\n * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m\n *\n * jdk8中：元空间\n * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m\n */\npublic class StringTest3 {\n    public static void main(String[] args) {\n        //使用Set保持着常量池引用，避免full gc回收常量池行为\n        Set<String> set = new HashSet<String>();\n        //在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。\n        short i = 0;\n        while(true){\n            set.add(String.valueOf(i++).intern());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3. String的基本操作\n\nJava语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。\n\n示例一：\n\npublic class StringTest4 {\n    public static void main(String[] args) {\n        System.out.println();//2293\n        System.out.println("1");//2294\n        System.out.println("2");\n        System.out.println("3");\n        System.out.println("4");\n        System.out.println("5");\n        System.out.println("6");\n        System.out.println("7");\n        System.out.println("8");\n        System.out.println("9");\n        System.out.println("10");//2303\n        //如下的字符串"1" 到 "10"不会再次加载\n        System.out.println("1");//2304\n        System.out.println("2");//2304\n        System.out.println("3");\n        System.out.println("4");\n        System.out.println("5");\n        System.out.println("6");\n        System.out.println("7");\n        System.out.println("8");\n        System.out.println("9");\n        System.out.println("10");//2304\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n示例二：\n\n\n\npublic class Memory {\n    public static void main(String[] args) {//line 1\n        int i = 1;//line 2\n        Object obj = new Object();//line 3\n        Memory mem = new Memory();//line 4\n        mem.foo(obj);//line 5\n    }//line 9\n\n    private void foo(Object param) {//line 6\n        String str = param.toString();//line 7\n        System.out.println(str);\n    }//line 8\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 4. 字符串的拼接操作\n\n * 常量与常量的拼接结果在常量池，原理是编译期优化\n * 常量池中不会存在相同内容的变量\n * 只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder\n * 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址\n\n\n# 1. 常量、变量、intern()比较\n\npublic class StringTest5 {\n  \n    /**\n     * 常量\n     */\n    @Test\n    public void test1(){\n        String s1 = "a" + "b" + "c";//常量 编译期优化：等同于"abc"\n        String s2 = "abc"; //"abc"一定是放在字符串常量池中，将此地址赋给s2\n        /*\n         * 最终.java编译成.class,再执行.class\n         * String s1 = "abc";\n         * String s2 = "abc"\n         */\n        System.out.println(s1 == s2); //true\n        System.out.println(s1.equals(s2)); //true\n    }\n\n    @Test\n    public void test2(){\n        String s1 = "javaEE";\n        String s2 = "hadoop";\n\n        String s3 = "javaEEhadoop";\n        String s4 = "javaEE" + "hadoop";//编译期优化\n        //如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop\n        String s5 = s1 + "hadoop";\n        String s6 = "javaEE" + s2;\n        String s7 = s1 + s2;\n\n        System.out.println(s3 == s4);//true\n        System.out.println(s3 == s5);//false\n        System.out.println(s3 == s6);//false\n        System.out.println(s3 == s7);//false\n        System.out.println(s5 == s6);//false\n        System.out.println(s5 == s7);//false\n        System.out.println(s6 == s7);//false\n        //intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；\n        //如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。\n        String s8 = s6.intern();\n        System.out.println(s3 == s8);//true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 2. 字符串拼接底层原理\n\n 1. 在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer\n\nSTRING                                                              STRINGBUFFER                                                                                                                 STRINGBUILDER\nString的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间   StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量   可变类，速度更快\n不可变                                                                 可变                                                                                                                           可变\n                                                                    线程安全                                                                                                                         线程不安全\n                                                                    多线程操作字符串                                                                                                                     单线程操作字符串\n\n注意，我们左右两边如果是变量的话，就是需要new StringBuilder进行拼接，但是如果使用的是final修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。也就是说被final修饰的变量，将会变成常量，类和方法将不能被继承、\n\npublic class StringTest5 {\n\n    @Test\n    public void test3(){\n        String s1 = "a";\n        String s2 = "b";\n        String s3 = "ab";\n        /*\n        如下的s1 + s2 的执行细节：(变量s是我临时定义的）\n        ① StringBuilder s = new StringBuilder();\n        ② s.append("a")\n        ③ s.append("b")\n        ④ s.toString()  --\x3e 约等于 new String("ab")\n\n        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer\n         */\n        String s4 = s1 + s2;//\n        System.out.println(s3 == s4);//false\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 2. 字符串拼接操作不一定使用的是StringBuilder! 如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。\n 3. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。\n\n/*\n\n */\n@Test\npublic void test4(){\n    final String s1 = "a"; // 加 final 变为常量\n    final String s2 = "b";\n    String s3 = "ab";\n    String s4 = s1 + s2;\n    System.out.println(s3 == s4);//true\n}\n//练习：\n@Test\npublic void test5(){\n    String s1 = "javaEEhadoop";\n    String s2 = "javaEE";\n    String s3 = s2 + "hadoop";\n    System.out.println(s1 == s3);//false\n\n    final String s4 = "javaEE";//s4:常量  // 加 final 变为常量\n    String s5 = s4 + "hadoop";\n    System.out.println(s1 == s5);//true\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 3. 体会执行效率\n\n通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！ 详情：\n\n① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象 使用String的字符串拼接方式：创建过多个StringBuilder和String的对象 ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。\n\n改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化： StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]\n\n    @Test\n    public void test6(){\n\n        long start = System.currentTimeMillis();\n\n//        method1(100000);//4014\n        method2(100000);//7\n\n        long end = System.currentTimeMillis();\n\n        System.out.println("花费的时间为：" + (end - start));\n    }\n\n    public void method1(int highLevel){\n        String src = "";\n        for(int i = 0;i < highLevel;i++){\n            src = src + "a";//每次循环都会创建一个StringBuilder、String\n        }\n//        System.out.println(src);\n\n    }\n\n    public void method2(int highLevel){\n        //只需要创建一个StringBuilder\n        StringBuilder src = new StringBuilder();\n        for (int i = 0; i < highLevel; i++) {\n            src.append("a");\n        }\n//        System.out.println(src);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n>  1. 可通过.class文件查看\n>  2. 通过 jclasslib 查看\n\n\n# 5. intern()的使用\n\n> 参考博文：https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html\n\nintern是一个native方法，调用的是底层 C的方法\n\n\n\n> 返回字符串对象的规范表示。 最初为空的字符串池由String类私有维护。调用intern方法时，如果池已经包含等于equals（Object）方法确定的此String对象的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。\n> \n> 示例：s1 = "abc" 当 s1.equals(s2) 时，s2不会创建新的对象（引用s1创建的对象）\n> \n> 因此，对于任意两个字符串s和t，当且仅当s.equals（t）为true时，s.intern（）== t.intern（）为true。 所有文字字符串和字符串值常量表达式均已插入。字符串文字在Java™语言规范的第3.10.5节中定义。 返回： 与该字符串具有相同内容的字符串，但保证来自唯一字符串池。\n\n如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。\n\n比如：\n\nString myInfo = new string("I love atguigu").intern();\n\n\n1\n\n\n也就是说，如果在任意字符串上调用string.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true\n\n（"a"+"b"+"c"）.intern（）=="abc"\n\n\n1\n\n\n通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）\n\n\n# 1. 面试题\n\n# 1. new String("ab")到底创建了几个对象？\n\n/**\n * 题目：\n * new String("ab")会创建几个对象？看字节码，就知道是两个。\n *     一个对象是：new关键字在堆空间创建的\n *     另一个对象是：字符串常量池中的对象"ab"。 字节码指令：ldc\n */\npublic class StringNewTest {\n    public static void main(String[] args) {\n        String str = new String("ab");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n字节码：\n\n 0 new #2 <java/lang/String>\n 3 dup\n 4 ldc #3 <ab>\n 6 invokespecial #4 <java/lang/String.<init>>\n 9 astore_1\n10 return\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 2. new String("a") + new String("b") 呢？\n\n/**\n * new String("a") + new String("b")呢？\n *  对象1：new StringBuilder() 【拼接使用StringBuilder】\n *  对象2： new String("a")\n *  对象3： 常量池中的"a"\n *  对象4： new String("b")\n *  对象5： 常量池中的"b"\n *\n *  深入剖析： StringBuilder的toString():\n *      对象6 ：new String("ab")\n *       强调一下，toString()的调用，在字符串常量池中，没有生成"ab"\n */\npublic class StringNewTest {\n    public static void main(String[] args) {\n        String str = new String("a") + new String("b");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n字节码\n\n0 new #2 <java/lang/StringBuilder>\n 3 dup\n 4 invokespecial #3 <java/lang/StringBuilder.<init>>\n 7 new #4 <java/lang/String>\n10 dup\n11 ldc #5 <a>\n13 invokespecial #6 <java/lang/String.<init>>\n16 invokevirtual #7 <java/lang/StringBuilder.append>\n19 new #4 <java/lang/String>\n22 dup\n23 ldc #8 <b>\n25 invokespecial #6 <java/lang/String.<init>>\n28 invokevirtual #7 <java/lang/StringBuilder.append>\n31 invokevirtual #9 <java/lang/StringBuilder.toString>\n34 astore_1\n35 return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 3. intern的使用：Jdk6 VS jdk7/8\n\n/**\n * 如何保证变量s指向的是字符串常量池中的数据呢？\n * 有两种方式：\n * 方式一： String s = "shkstart";//字面量定义的方式\n * 方式二： 调用intern()\n *         String s = new String("shkstart").intern();\n *         String s = new StringBuilder("shkstart").toString().intern();\n */\npublic class StringIntern {\n    public static void main(String[] args) {\n\n        String s = new String("1");\n        s.intern();//调用此方法之前，字符串常量池中已经存在了"1"\n        String s2 = "1";\n        System.out.println(s == s2);//jdk6：false   jdk7/8：false\n\n\n        String s3 = new String("1") + new String("1");//s3变量记录的地址为：new String("11")\n        //执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！\n        s3.intern();//在字符串常量池中生成"11"。如何理解：jdk6:创建了一个新的对象"11",也就有新的地址。【常量对象在永久代】\n                                            //         jdk7:此时常量中并没有创建"11",而是创建一个指向堆空间中new String("11")的地址 【常量对象放在堆空间中】\n        String s4 = "11";//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的"11"的地址\n        System.out.println(s3 == s4);//jdk6：false  jdk7/8：true\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面图解\n\nJDK6\n\n\n\nJDK7/8\n\n\n\n# 5. 扩展：\n\npublic class StringIntern1 {\n    public static void main(String[] args) {\n        //StringIntern.java中练习的拓展：\n        String s3 = new String("1") + new String("1");//new String("11")\n        //执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！\n        String s4 = "11";//在字符串常量池中生成对象"11"\n        String s5 = s3.intern();\n        System.out.println(s3 == s4);//false\n        System.out.println(s5 == s4);//true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2. intern使用总结\n\nJDK1.6中，将这个字符串对象尝试放入串池。\n\n * 如果串池中有，则并不会放入。返回已有的串池中的对象的地址\n * 如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址\n\nJDK1.7起，将这个字符串对象尝试放入串池。\n\n * 如果串池中有，则并不会放入。返回已有的串池中的对象的地址\n * 如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址\n\n\n# 3. 练习\n\n# 1. 练习1\n\npublic class StringExer1 {\n    public static void main(String[] args) {\n        String x = "ab";\n        String s = new String("a") + new String("b");//new String("ab")\n        //在上一行代码执行完以后，字符串常量池中并没有"ab"\n\n        String s2 = s.intern();//jdk6中：在串池中创建一个字符串"ab"\n                               //jdk8中：串池中没有创建字符串"ab",而是创建一个引用，指向new String("ab")，将此引用返回\n\n        System.out.println(s2 == "ab");//jdk6:true  jdk8:true\n        System.out.println(s == "ab");//jdk6:false  jdk8:true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nJDK6:\n\n\n\nJDK8\n\n\n\n练习2\n\npublic class StringExer2 {\n    public static void main(String[] args) {\n        String s1 = new String("ab");//执行完以后，会在字符串常量池中会生成"ab"\n//        String s1 = new String("a") + new String("b");////执行完以后，不会在字符串常量池中会生成"ab"\n        s1.intern();\n        String s2 = "ab";\n        System.out.println(s1 == s2); // false\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4. Intern()的空间效率测试：空间角度\n\n/**【可以使用 JProfiler IDEA插件测试 / java自带工具】\n * 使用intern()测试执行效率：空间使用上\n *\n * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。\n */\npublic class StringIntern2 {\n    static final int MAX_COUNT = 1000 * 10000;\n    static final String[] arr = new String[MAX_COUNT];\n\n    public static void main(String[] args) {\n        Integer[] data = new Integer[]{1,2,3,4,5,6,7,8,9,10};\n\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < MAX_COUNT; i++) {\n//            arr[i] = new String(String.valueOf(data[i % data.length]));\n            arr[i] = new String(String.valueOf(data[i % data.length])).intern();\n\n        }\n        long end = System.currentTimeMillis();\n        System.out.println("花费的时间为：" + (end - start));\n\n        try {\n            Thread.sleep(1000000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n> 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。\n\n\n# 6. StringTable的垃圾回收\n\n/**\n * String的垃圾回收:\n * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails\n */\npublic class StringGCTest {\n    public static void main(String[] args) {\n        for (int j = 0; j < 100000; j++) {\n            String.valueOf(j).intern();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7. G1中的String去重操作\n\n注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复\n\n\n# 描述\n\n背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：\n\n * 堆存活数据集合里面string对象占了25%\n * 堆存活数据集合里面重复的string对象有13.5%\n * string对象的平均长度是45\n\n许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。\n\n\n# 实现\n\n * 当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的string对象。\n * 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。\n * 使用一个hashtab1e来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。\n * 如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。\n * 如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。\n\n\n# 开启\n\n命令行选项\n\n> UsestringDeduplication（bool）：开启string去重，默认是不开启的，需要手动开启。 Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息 stringpeduplicationAgeThreshold（uintx）：达到这个年龄的string对象被认为是去重的候选对象',normalizedContent:'# jvm-stringtable\n\n\n# 1. string的基本特性\n\n * string：字符串，使用一对 ”” 引起来表示\n   * string s1 = "mogublog" ; // 字面量的定义方式\n   * string s2 = new string("moxi");\n * string声明为final的，不可被继承\n * string实现了serializable接口：表示字符串是支持序列化的。实现了comparable接口：表示string可以比较大小\n * string在jdk8及以前内部定义了final char[] value用于存储字符串数据。jdk9时改为byte[]\n\n\n# 1. 为什么jdk9改变了结构\n\nstring类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。\n\n我们建议改变字符串的内部表示class从utf - 16字符数组到字节数组+一个encoding-flag字段。新的string类将根据字符串的内容存储编码为iso-8859-1/latin-1(每个字符一个字节)或utf-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。\n\n结论：string再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间\n\n// 之前\nprivate final char value[];\n// 之后\nprivate final byte[] value\n\n\n1\n2\n3\n4\n\n\n同时基于string的数据结构，例如stringbuffer和stringbuilder也同样做了修改\n\n\n# 2. string的不可变性\n\nstring：代表不可变的字符序列。简称：不可变性。\n\n> 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。\n\n代码\n\n/**\n * string的不可变性\n *\n * @author: chggx\n * @create: 2020-07-11-8:57\n */\npublic class stringtest1 {\n\n    public static void test1() {\n        // 字面量定义的方式，“abc”存储在字符串常量池中\n        string s1 = "abc";\n        string s2 = "abc";\n        system.out.println(s1 == s2);\n        s1 = "hello";\n        system.out.println(s1 == s2);\n        system.out.println(s1);\n        system.out.println(s2);\n        system.out.println("----------------");\n    }\n\n    public static void test2() {\n        string s1 = "abc";\n        string s2 = "abc";\n        // 只要进行了修改，就会重新创建一个对象，这就是不可变性\n        s2 += "def";\n        system.out.println(s1);\n        system.out.println(s2);\n        system.out.println("----------------");\n    }\n\n    public static void test3() {\n        string s1 = "abc";\n        string s2 = s1.replace(\'a\', \'m\');\n        system.out.println(s1);\n        system.out.println(s2);\n    }\n\n    public static void main(string[] args) {\n        test1();\n        test2();\n        test3();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n运行结果\n\ntrue\nfalse\nhello\nabc\n----------------\nabc\nabcdef\n----------------\nabc\nmbc\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3. string底层hashtable结构的说明\n\n# 面试题\n\n/**\n * 面试题\n *\n * @author: chggx\n * @create: 2020-07-11-9:05\n */\npublic class stringexer {\n    string str = new string("good");\n    char [] ch = {\'t\',\'e\',\'s\',\'t\'};\n\n    public void change(string str, char ch []) {\n        str = "test ok";\n        ch[0] = \'b\';\n    }\n\n    public static void main(string[] args) {\n        stringexer ex = new stringexer();\n        ex.change(ex.str, ex.ch);\n        system.out.println(ex.str); // good\n        system.out.println(ex.ch); // best\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n输出结果\n\ngood\nbest\n\n\n1\n2\n\n\n\n# 4. 注意\n\n字符串常量池是不会存储相同内容的字符串的\n\n 1. string的string pool是一个固定大小的hashtable，默认值大小长度是1009。如果放进string pool的string非常多，就会造成hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。\n\n 2. 使用-xx:stringtablesize可设置stringtab1e的长度。\n\n 3. 在jdk6中stringtable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。stringtablesize设置没有要求。\n\n 4. 在jdk7中，stringtable的长度默认值是60013。\n\n 5. 在jdk8中，stringtable可以设置的最小值为1009。\n\n\n# 2. string的内存分配\n\n在java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。\n\n常量池就类似一个java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，string类型的常量池比较特殊。它的主要使用方法有两种。\n\n直接使用双引号声明出来的string对象会直接存储在常量池中。\n\n * 比如：string info="chggx.com"；\n\n如果不是用双引号声明的string对象，可以使用string提供的intern（）方法。\n\njava 6及以前，字符串常量池存放在永久代\n\njava 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到java堆内\n\n> 所有的字符串都保存在堆（heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。\n> \n> 字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在java 7中使用string.intern（）。\n\njava8元空间，字符串常量在堆\n\n * jdk6\n   \n   \n\n * jdk7\n   \n   \n\n\n# 为什么stringtable从永久代调整到堆中\n\n * 永久代的默认比较小（permsize）\n * 永久代垃圾回收频率低\n\n在jdk 7中，interned字符串不再在java堆的永久生成中分配，而是在java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。\n\n/**\n * jdk6中：永久代\n * -xx:permsize=6m -xx:maxpermsize=6m -xms6m -xmx6m\n *\n * jdk8中：元空间\n * -xx:metaspacesize=6m -xx:maxmetaspacesize=6m -xms6m -xmx6m\n */\npublic class stringtest3 {\n    public static void main(string[] args) {\n        //使用set保持着常量池引用，避免full gc回收常量池行为\n        set<string> set = new hashset<string>();\n        //在short可以取值的范围内足以让6mb的permsize或heap产生oom了。\n        short i = 0;\n        while(true){\n            set.add(string.valueof(i++).intern());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3. string的基本操作\n\njava语言规范里要求完全相同的字符串字面量，应该包含同样的unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个string类实例。\n\n示例一：\n\npublic class stringtest4 {\n    public static void main(string[] args) {\n        system.out.println();//2293\n        system.out.println("1");//2294\n        system.out.println("2");\n        system.out.println("3");\n        system.out.println("4");\n        system.out.println("5");\n        system.out.println("6");\n        system.out.println("7");\n        system.out.println("8");\n        system.out.println("9");\n        system.out.println("10");//2303\n        //如下的字符串"1" 到 "10"不会再次加载\n        system.out.println("1");//2304\n        system.out.println("2");//2304\n        system.out.println("3");\n        system.out.println("4");\n        system.out.println("5");\n        system.out.println("6");\n        system.out.println("7");\n        system.out.println("8");\n        system.out.println("9");\n        system.out.println("10");//2304\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n示例二：\n\n\n\npublic class memory {\n    public static void main(string[] args) {//line 1\n        int i = 1;//line 2\n        object obj = new object();//line 3\n        memory mem = new memory();//line 4\n        mem.foo(obj);//line 5\n    }//line 9\n\n    private void foo(object param) {//line 6\n        string str = param.tostring();//line 7\n        system.out.println(str);\n    }//line 8\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 4. 字符串的拼接操作\n\n * 常量与常量的拼接结果在常量池，原理是编译期优化\n * 常量池中不会存在相同内容的变量\n * 只要其中有一个是变量，结果就在堆中。变量拼接的原理是stringbuilder\n * 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址\n\n\n# 1. 常量、变量、intern()比较\n\npublic class stringtest5 {\n  \n    /**\n     * 常量\n     */\n    @test\n    public void test1(){\n        string s1 = "a" + "b" + "c";//常量 编译期优化：等同于"abc"\n        string s2 = "abc"; //"abc"一定是放在字符串常量池中，将此地址赋给s2\n        /*\n         * 最终.java编译成.class,再执行.class\n         * string s1 = "abc";\n         * string s2 = "abc"\n         */\n        system.out.println(s1 == s2); //true\n        system.out.println(s1.equals(s2)); //true\n    }\n\n    @test\n    public void test2(){\n        string s1 = "javaee";\n        string s2 = "hadoop";\n\n        string s3 = "javaeehadoop";\n        string s4 = "javaee" + "hadoop";//编译期优化\n        //如果拼接符号的前后出现了变量，则相当于在堆空间中new string()，具体的内容为拼接的结果：javaeehadoop\n        string s5 = s1 + "hadoop";\n        string s6 = "javaee" + s2;\n        string s7 = s1 + s2;\n\n        system.out.println(s3 == s4);//true\n        system.out.println(s3 == s5);//false\n        system.out.println(s3 == s6);//false\n        system.out.println(s3 == s7);//false\n        system.out.println(s5 == s6);//false\n        system.out.println(s5 == s7);//false\n        system.out.println(s6 == s7);//false\n        //intern():判断字符串常量池中是否存在javaeehadoop值，如果存在，则返回常量池中javaeehadoop的地址；\n        //如果字符串常量池中不存在javaeehadoop，则在常量池中加载一份javaeehadoop，并返回次对象的地址。\n        string s8 = s6.intern();\n        system.out.println(s3 == s8);//true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 2. 字符串拼接底层原理\n\n 1. 在jdk5之后，使用的是stringbuilder，在jdk5之前使用的是stringbuffer\n\nstring                                                              stringbuffer                                                                                                                 stringbuilder\nstring的值是不可变的，这就导致每次对string的操作都会生成新的string对象，不仅效率低下，而且浪费大量优先的内存空间   stringbuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个stringbuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量   可变类，速度更快\n不可变                                                                 可变                                                                                                                           可变\n                                                                    线程安全                                                                                                                         线程不安全\n                                                                    多线程操作字符串                                                                                                                     单线程操作字符串\n\n注意，我们左右两边如果是变量的话，就是需要new stringbuilder进行拼接，但是如果使用的是final修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。也就是说被final修饰的变量，将会变成常量，类和方法将不能被继承、\n\npublic class stringtest5 {\n\n    @test\n    public void test3(){\n        string s1 = "a";\n        string s2 = "b";\n        string s3 = "ab";\n        /*\n        如下的s1 + s2 的执行细节：(变量s是我临时定义的）\n        ① stringbuilder s = new stringbuilder();\n        ② s.append("a")\n        ③ s.append("b")\n        ④ s.tostring()  --\x3e 约等于 new string("ab")\n\n        补充：在jdk5.0之后使用的是stringbuilder,在jdk5.0之前使用的是stringbuffer\n         */\n        string s4 = s1 + s2;//\n        system.out.println(s3 == s4);//false\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 2. 字符串拼接操作不一定使用的是stringbuilder! 如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非stringbuilder的方式。\n 3. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。\n\n/*\n\n */\n@test\npublic void test4(){\n    final string s1 = "a"; // 加 final 变为常量\n    final string s2 = "b";\n    string s3 = "ab";\n    string s4 = s1 + s2;\n    system.out.println(s3 == s4);//true\n}\n//练习：\n@test\npublic void test5(){\n    string s1 = "javaeehadoop";\n    string s2 = "javaee";\n    string s3 = s2 + "hadoop";\n    system.out.println(s1 == s3);//false\n\n    final string s4 = "javaee";//s4:常量  // 加 final 变为常量\n    string s5 = s4 + "hadoop";\n    system.out.println(s1 == s5);//true\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 3. 体会执行效率\n\n通过stringbuilder的append()的方式添加字符串的效率要远高于使用string的字符串拼接方式！ 详情：\n\n① stringbuilder的append()的方式：自始至终中只创建过一个stringbuilder的对象 使用string的字符串拼接方式：创建过多个stringbuilder和string的对象 ② 使用string的字符串拼接方式：内存中由于创建了较多的stringbuilder和string的对象，内存占用更大；如果进行gc，需要花费额外的时间。\n\n改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highlevel的情况下,建议使用构造器实例化： stringbuilder s = new stringbuilder(highlevel);//new char[highlevel]\n\n    @test\n    public void test6(){\n\n        long start = system.currenttimemillis();\n\n//        method1(100000);//4014\n        method2(100000);//7\n\n        long end = system.currenttimemillis();\n\n        system.out.println("花费的时间为：" + (end - start));\n    }\n\n    public void method1(int highlevel){\n        string src = "";\n        for(int i = 0;i < highlevel;i++){\n            src = src + "a";//每次循环都会创建一个stringbuilder、string\n        }\n//        system.out.println(src);\n\n    }\n\n    public void method2(int highlevel){\n        //只需要创建一个stringbuilder\n        stringbuilder src = new stringbuilder();\n        for (int i = 0; i < highlevel; i++) {\n            src.append("a");\n        }\n//        system.out.println(src);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n>  1. 可通过.class文件查看\n>  2. 通过 jclasslib 查看\n\n\n# 5. intern()的使用\n\n> 参考博文：https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html\n\nintern是一个native方法，调用的是底层 c的方法\n\n\n\n> 返回字符串对象的规范表示。 最初为空的字符串池由string类私有维护。调用intern方法时，如果池已经包含等于equals（object）方法确定的此string对象的字符串，则返回池中的字符串。否则，将此string对象添加到池中，并返回对此string对象的引用。\n> \n> 示例：s1 = "abc" 当 s1.equals(s2) 时，s2不会创建新的对象（引用s1创建的对象）\n> \n> 因此，对于任意两个字符串s和t，当且仅当s.equals（t）为true时，s.intern（）== t.intern（）为true。 所有文字字符串和字符串值常量表达式均已插入。字符串文字在java™语言规范的第3.10.5节中定义。 返回： 与该字符串具有相同内容的字符串，但保证来自唯一字符串池。\n\n如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。\n\n比如：\n\nstring myinfo = new string("i love atguigu").intern();\n\n\n1\n\n\n也就是说，如果在任意字符串上调用string.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true\n\n（"a"+"b"+"c"）.intern（）=="abc"\n\n\n1\n\n\n通俗点讲，interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（string intern pool）\n\n\n# 1. 面试题\n\n# 1. new string("ab")到底创建了几个对象？\n\n/**\n * 题目：\n * new string("ab")会创建几个对象？看字节码，就知道是两个。\n *     一个对象是：new关键字在堆空间创建的\n *     另一个对象是：字符串常量池中的对象"ab"。 字节码指令：ldc\n */\npublic class stringnewtest {\n    public static void main(string[] args) {\n        string str = new string("ab");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n字节码：\n\n 0 new #2 <java/lang/string>\n 3 dup\n 4 ldc #3 <ab>\n 6 invokespecial #4 <java/lang/string.<init>>\n 9 astore_1\n10 return\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 2. new string("a") + new string("b") 呢？\n\n/**\n * new string("a") + new string("b")呢？\n *  对象1：new stringbuilder() 【拼接使用stringbuilder】\n *  对象2： new string("a")\n *  对象3： 常量池中的"a"\n *  对象4： new string("b")\n *  对象5： 常量池中的"b"\n *\n *  深入剖析： stringbuilder的tostring():\n *      对象6 ：new string("ab")\n *       强调一下，tostring()的调用，在字符串常量池中，没有生成"ab"\n */\npublic class stringnewtest {\n    public static void main(string[] args) {\n        string str = new string("a") + new string("b");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n字节码\n\n0 new #2 <java/lang/stringbuilder>\n 3 dup\n 4 invokespecial #3 <java/lang/stringbuilder.<init>>\n 7 new #4 <java/lang/string>\n10 dup\n11 ldc #5 <a>\n13 invokespecial #6 <java/lang/string.<init>>\n16 invokevirtual #7 <java/lang/stringbuilder.append>\n19 new #4 <java/lang/string>\n22 dup\n23 ldc #8 <b>\n25 invokespecial #6 <java/lang/string.<init>>\n28 invokevirtual #7 <java/lang/stringbuilder.append>\n31 invokevirtual #9 <java/lang/stringbuilder.tostring>\n34 astore_1\n35 return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 3. intern的使用：jdk6 vs jdk7/8\n\n/**\n * 如何保证变量s指向的是字符串常量池中的数据呢？\n * 有两种方式：\n * 方式一： string s = "shkstart";//字面量定义的方式\n * 方式二： 调用intern()\n *         string s = new string("shkstart").intern();\n *         string s = new stringbuilder("shkstart").tostring().intern();\n */\npublic class stringintern {\n    public static void main(string[] args) {\n\n        string s = new string("1");\n        s.intern();//调用此方法之前，字符串常量池中已经存在了"1"\n        string s2 = "1";\n        system.out.println(s == s2);//jdk6：false   jdk7/8：false\n\n\n        string s3 = new string("1") + new string("1");//s3变量记录的地址为：new string("11")\n        //执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！\n        s3.intern();//在字符串常量池中生成"11"。如何理解：jdk6:创建了一个新的对象"11",也就有新的地址。【常量对象在永久代】\n                                            //         jdk7:此时常量中并没有创建"11",而是创建一个指向堆空间中new string("11")的地址 【常量对象放在堆空间中】\n        string s4 = "11";//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的"11"的地址\n        system.out.println(s3 == s4);//jdk6：false  jdk7/8：true\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面图解\n\njdk6\n\n\n\njdk7/8\n\n\n\n# 5. 扩展：\n\npublic class stringintern1 {\n    public static void main(string[] args) {\n        //stringintern.java中练习的拓展：\n        string s3 = new string("1") + new string("1");//new string("11")\n        //执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！\n        string s4 = "11";//在字符串常量池中生成对象"11"\n        string s5 = s3.intern();\n        system.out.println(s3 == s4);//false\n        system.out.println(s5 == s4);//true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2. intern使用总结\n\njdk1.6中，将这个字符串对象尝试放入串池。\n\n * 如果串池中有，则并不会放入。返回已有的串池中的对象的地址\n * 如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址\n\njdk1.7起，将这个字符串对象尝试放入串池。\n\n * 如果串池中有，则并不会放入。返回已有的串池中的对象的地址\n * 如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址\n\n\n# 3. 练习\n\n# 1. 练习1\n\npublic class stringexer1 {\n    public static void main(string[] args) {\n        string x = "ab";\n        string s = new string("a") + new string("b");//new string("ab")\n        //在上一行代码执行完以后，字符串常量池中并没有"ab"\n\n        string s2 = s.intern();//jdk6中：在串池中创建一个字符串"ab"\n                               //jdk8中：串池中没有创建字符串"ab",而是创建一个引用，指向new string("ab")，将此引用返回\n\n        system.out.println(s2 == "ab");//jdk6:true  jdk8:true\n        system.out.println(s == "ab");//jdk6:false  jdk8:true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\njdk6:\n\n\n\njdk8\n\n\n\n练习2\n\npublic class stringexer2 {\n    public static void main(string[] args) {\n        string s1 = new string("ab");//执行完以后，会在字符串常量池中会生成"ab"\n//        string s1 = new string("a") + new string("b");////执行完以后，不会在字符串常量池中会生成"ab"\n        s1.intern();\n        string s2 = "ab";\n        system.out.println(s1 == s2); // false\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4. intern()的空间效率测试：空间角度\n\n/**【可以使用 jprofiler idea插件测试 / java自带工具】\n * 使用intern()测试执行效率：空间使用上\n *\n * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。\n */\npublic class stringintern2 {\n    static final int max_count = 1000 * 10000;\n    static final string[] arr = new string[max_count];\n\n    public static void main(string[] args) {\n        integer[] data = new integer[]{1,2,3,4,5,6,7,8,9,10};\n\n        long start = system.currenttimemillis();\n        for (int i = 0; i < max_count; i++) {\n//            arr[i] = new string(string.valueof(data[i % data.length]));\n            arr[i] = new string(string.valueof(data[i % data.length])).intern();\n\n        }\n        long end = system.currenttimemillis();\n        system.out.println("花费的时间为：" + (end - start));\n\n        try {\n            thread.sleep(1000000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n> 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。\n\n\n# 6. stringtable的垃圾回收\n\n/**\n * string的垃圾回收:\n * -xms15m -xmx15m -xx:+printstringtablestatistics -xx:+printgcdetails\n */\npublic class stringgctest {\n    public static void main(string[] args) {\n        for (int j = 0; j < 100000; j++) {\n            string.valueof(j).intern();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7. g1中的string去重操作\n\n注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复\n\n\n# 描述\n\n背景：对许多java应用（有大的也有小的）做的测试得出以下结果：\n\n * 堆存活数据集合里面string对象占了25%\n * 堆存活数据集合里面重复的string对象有13.5%\n * string对象的平均长度是45\n\n许多大规模的java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在g1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。\n\n\n# 实现\n\n * 当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的string对象。\n * 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。\n * 使用一个hashtab1e来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。\n * 如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。\n * 如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。\n\n\n# 开启\n\n命令行选项\n\n> usestringdeduplication（bool）：开启string去重，默认是不开启的，需要手动开启。 printstringbeduplicationstatistics（bool）：打印详细的去重统计信息 stringpeduplicationagethreshold（uintx）：达到这个年龄的string对象被认为是去重的候选对象',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-垃圾回收概述",frontmatter:{title:"JVM-垃圾回收概述",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/a75cf5/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/14.JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0.html",relativePath:"01.语言/01.JAVA语言/02.JVM/14.JVM-垃圾回收概述.md",key:"v-4c1c2380",path:"/pages/a75cf5/",headers:[{level:2,title:"1. 什么是垃圾",slug:"_1-什么是垃圾",normalizedTitle:"1. 什么是垃圾",charIndex:19},{level:3,title:"大厂面试题",slug:"大厂面试题",normalizedTitle:"大厂面试题",charIndex:339},{level:4,title:"蚂蚁金服",slug:"蚂蚁金服",normalizedTitle:"蚂蚁金服",charIndex:348},{level:4,title:"百度",slug:"百度",normalizedTitle:"百度",charIndex:483},{level:4,title:"天猫",slug:"天猫",normalizedTitle:"天猫",charIndex:521},{level:4,title:"滴滴",slug:"滴滴",normalizedTitle:"滴滴",charIndex:588},{level:4,title:"京东",slug:"京东",normalizedTitle:"京东",charIndex:637},{level:4,title:"阿里",slug:"阿里",normalizedTitle:"阿里",charIndex:705},{level:4,title:"字节跳动",slug:"字节跳动",normalizedTitle:"字节跳动",charIndex:777},{level:3,title:"1. 什么是垃圾(Garbage)？",slug:"_1-什么是垃圾-garbage",normalizedTitle:"1. 什么是垃圾(garbage)？",charIndex:951},{level:3,title:"2. 磁盘碎片整理",slug:"_2-磁盘碎片整理",normalizedTitle:"2. 磁盘碎片整理",charIndex:1089},{level:2,title:"2. 为什么需要GC",slug:"_2-为什么需要gc",normalizedTitle:"2. 为什么需要gc",charIndex:1119},{level:2,title:"3. 早期垃圾回收",slug:"_3-早期垃圾回收",normalizedTitle:"3. 早期垃圾回收",charIndex:1377},{level:2,title:"4. Java垃圾回收机制",slug:"_4-java垃圾回收机制",normalizedTitle:"4. java垃圾回收机制",charIndex:1957},{level:3,title:"1. 优点",slug:"_1-优点",normalizedTitle:"1. 优点",charIndex:1975},{level:3,title:"2. 担忧",slug:"_2-担忧",normalizedTitle:"2. 担忧",charIndex:2157},{level:3,title:"3. GC主要关注的区域",slug:"_3-gc主要关注的区域",normalizedTitle:"3. gc主要关注的区域",charIndex:2439}],headersStr:"1. 什么是垃圾 大厂面试题 蚂蚁金服 百度 天猫 滴滴 京东 阿里 字节跳动 1. 什么是垃圾(Garbage)？ 2. 磁盘碎片整理 2. 为什么需要GC 3. 早期垃圾回收 4. Java垃圾回收机制 1. 优点 2. 担忧 3. GC主要关注的区域",content:"# JVM-垃圾回收概述\n\n\n\n\n# 1. 什么是垃圾\n\n\n\n从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。\n\n垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 关于垃圾收集有三个经典问题：\n\n * 哪些内存需要回收？\n * 什么时候回收？\n * 如何回收？\n\n垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。\n\n\n# 大厂面试题\n\n# 蚂蚁金服\n\n * 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1？\n * JVM GC算法有哪些，目前的JDK版本采用什么回收算法？\n * G1回收器讲下回收过程GC是什么？为什么要有GC？\n * GC的两种判定方法？CMS收集器与G1收集器的特点\n\n# 百度\n\n * 说一下GC算法，分代回收说下\n * 垃圾收集策略和算法\n\n# 天猫\n\n * JVM GC原理，JVM怎么回收内存\n * CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？\n\n# 滴滴\n\nJava的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的\n\n# 京东\n\n * 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，\n * 包括原理，流程，优缺点。垃圾回收算法的实现原理\n\n# 阿里\n\n * 讲一讲垃圾回收算法。\n * 什么情况下触发垃圾回收？\n * 如何选择合适的垃圾收集算法？\n * JVM有哪三种垃圾回收器？\n\n# 字节跳动\n\n * 常见的垃圾回收器算法有哪些，各有什么优劣？\n * System.gc（）和Runtime.gc（）会做什么事情？\n * Java GC机制？GC Roots有哪些？\n * Java对象的回收方式，回收算法。\n * CMS和G1了解么，CMS解决什么问题，说一下回收的过程。\n * CMS回收停顿了几次，为什么要停顿两次?\n\n\n# 1. 什么是垃圾(Garbage)？\n\n垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。\n\n如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。\n\n\n# 2. 磁盘碎片整理\n\n机械硬盘需要进行磁盘整理\n\n\n\n\n# 2. 为什么需要GC\n\n * 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。\n\n * 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。\n\n * 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。\n\n\n# 3. 早期垃圾回收\n\n * 在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：\n\nMibBridge *pBridge= new cmBaseGroupBridge（）；\n//如果注册失败，使用Delete释放该对象所占内存区域\nif（pBridge->Register（kDestroy）！=NO ERROR）\n\tdelete pBridge；\n\n\n1\n2\n3\n4\n\n\n * 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。\n\n * 有了垃圾回收机制后，上述代码极有可能变成这样\n\nMibBridge *pBridge=new cmBaseGroupBridge(); \npBridge->Register(kDestroy);\n\n\n1\n2\n\n\n现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。\n\n\n# 4. Java垃圾回收机制\n\n\n# 1. 优点\n\n 1. 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险\n    \n    * 没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。\n\n 2. 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发\n\n 3. oracle官网关于垃圾回收的介绍\n\n\n# 2. 担忧\n\n 1. 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。\n\n 2. 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。\n\n 3. 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。\n\n\n# 3. GC主要关注的区域\n\nGC主要关注于 方法区 和堆中的垃圾收集\n\n\n\n垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收\n\n * 其中，Java堆是垃圾收集器的工作重点\n\n从次数上讲：\n\n * 频繁收集Young区\n * 较少收集Old区\n * 基本不收集Perm区（元空间）",normalizedContent:"# jvm-垃圾回收概述\n\n\n\n\n# 1. 什么是垃圾\n\n\n\n从上图我们可以很明确的知道，java 和 c++语言的区别，就在于垃圾收集技术和内存动态分配上，c语言没有垃圾收集技术，需要我们手动的收集。\n\n垃圾收集，不是java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的lisp语言诞生。 关于垃圾收集有三个经典问题：\n\n * 哪些内存需要回收？\n * 什么时候回收？\n * 如何回收？\n\n垃圾收集机制是java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。\n\n\n# 大厂面试题\n\n# 蚂蚁金服\n\n * 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和g1？\n * jvm gc算法有哪些，目前的jdk版本采用什么回收算法？\n * g1回收器讲下回收过程gc是什么？为什么要有gc？\n * gc的两种判定方法？cms收集器与g1收集器的特点\n\n# 百度\n\n * 说一下gc算法，分代回收说下\n * 垃圾收集策略和算法\n\n# 天猫\n\n * jvm gc原理，jvm怎么回收内存\n * cms特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？\n\n# 滴滴\n\njava的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的\n\n# 京东\n\n * 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和g1，\n * 包括原理，流程，优缺点。垃圾回收算法的实现原理\n\n# 阿里\n\n * 讲一讲垃圾回收算法。\n * 什么情况下触发垃圾回收？\n * 如何选择合适的垃圾收集算法？\n * jvm有哪三种垃圾回收器？\n\n# 字节跳动\n\n * 常见的垃圾回收器算法有哪些，各有什么优劣？\n * system.gc（）和runtime.gc（）会做什么事情？\n * java gc机制？gc roots有哪些？\n * java对象的回收方式，回收算法。\n * cms和g1了解么，cms解决什么问题，说一下回收的过程。\n * cms回收停顿了几次，为什么要停顿两次?\n\n\n# 1. 什么是垃圾(garbage)？\n\n垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。\n\n如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。\n\n\n# 2. 磁盘碎片整理\n\n机械硬盘需要进行磁盘整理\n\n\n\n\n# 2. 为什么需要gc\n\n * 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。\n\n * 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便jvm将整理出的内存分配给新的对象。\n\n * 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有gc就不能保证应用程序的正常进行。而经常造成stw的gc又跟不上实际的需求，所以才会不断地尝试对gc进行优化。\n\n\n# 3. 早期垃圾回收\n\n * 在早期的c/c++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：\n\nmibbridge *pbridge= new cmbasegroupbridge（）；\n//如果注册失败，使用delete释放该对象所占内存区域\nif（pbridge->register（kdestroy）！=no error）\n\tdelete pbridge；\n\n\n1\n2\n3\n4\n\n\n * 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。\n\n * 有了垃圾回收机制后，上述代码极有可能变成这样\n\nmibbridge *pbridge=new cmbasegroupbridge(); \npbridge->register(kdestroy);\n\n\n1\n2\n\n\n现在，除了java以外，c#、python、ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。\n\n\n# 4. java垃圾回收机制\n\n\n# 1. 优点\n\n 1. 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险\n    \n    * 没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。\n\n 2. 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发\n\n 3. oracle官网关于垃圾回收的介绍\n\n\n# 2. 担忧\n\n 1. 对于java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化java开发人员在程序出现内存溢出时定位问题和解决问题的能力。\n\n 2. 此时，了解jvm的自动内存分配和内存回收原理就显得非常重要，只有在真正了解jvm是如何管理内存后，我们才能够在遇见outofmemoryerror时，快速地根据错误异常日志定位问题和解决问题。\n\n 3. 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。\n\n\n# 3. gc主要关注的区域\n\ngc主要关注于 方法区 和堆中的垃圾收集\n\n\n\n垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收\n\n * 其中，java堆是垃圾收集器的工作重点\n\n从次数上讲：\n\n * 频繁收集young区\n * 较少收集old区\n * 基本不收集perm区（元空间）",charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-垃圾回收相关算法",frontmatter:{title:"JVM-垃圾回收相关算法",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/c0a9b6/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/15.JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95.html",relativePath:"01.语言/01.JAVA语言/02.JVM/15.JVM-垃圾回收相关算法.md",key:"v-0ba597e9",path:"/pages/c0a9b6/",headers:[{level:2,title:"1. 标记阶段：引用计数算法",slug:"_1-标记阶段-引用计数算法",normalizedTitle:"1. 标记阶段：引用计数算法",charIndex:19},{level:3,title:"1. 垃圾标记阶段：对象存活判断",slug:"_1-垃圾标记阶段-对象存活判断",normalizedTitle:"1. 垃圾标记阶段：对象存活判断",charIndex:40},{level:3,title:"2. 引用计数算法",slug:"_2-引用计数算法",normalizedTitle:"2. 引用计数算法",charIndex:281},{level:3,title:"3. 示例",slug:"_3-示例",normalizedTitle:"3. 示例",charIndex:661},{level:4,title:"1. 不进行GC处理",slug:"_1-不进行gc处理",normalizedTitle:"1. 不进行gc处理",charIndex:670},{level:4,title:"2. 通过GC处理",slug:"_2-通过gc处理",normalizedTitle:"2. 通过gc处理",charIndex:1959},{level:4,title:"3. 总结",slug:"_3-总结",normalizedTitle:"3. 总结",charIndex:3647},{level:3,title:"4. 小结",slug:"_4-小结",normalizedTitle:"4. 小结",charIndex:3675},{level:2,title:"2. 标记阶段：可达性分析算法",slug:"_2-标记阶段-可达性分析算法",normalizedTitle:"2. 标记阶段：可达性分析算法",charIndex:3945},{level:3,title:"1. 可达性分析算法",slug:"_1-可达性分析算法",normalizedTitle:"1. 可达性分析算法",charIndex:3965},{level:3,title:"2. GC Roots",slug:"_2-gc-roots",normalizedTitle:"2. gc roots",charIndex:4473},{level:3,title:"3. 注意",slug:"_3-注意",normalizedTitle:"3. 注意",charIndex:5221},{level:2,title:"3. 对象的finalization机制",slug:"_3-对象的finalization机制",normalizedTitle:"3. 对象的finalization机制",charIndex:5390},{level:3,title:"1. 对象的finalization机制",slug:"_1-对象的finalization机制",normalizedTitle:"1. 对象的finalization机制",charIndex:5415},{level:3,title:"2. 生存还是死亡？",slug:"_2-生存还是死亡",normalizedTitle:"2. 生存还是死亡？",charIndex:5985},{level:3,title:"3. 具体过程",slug:"_3-具体过程",normalizedTitle:"3. 具体过程",charIndex:6375},{level:3,title:"4. 代码演示可复活的对象",slug:"_4-代码演示可复活的对象",normalizedTitle:"4. 代码演示可复活的对象",charIndex:6886},{level:2,title:"4. MAT与JProfiler的GC Roots溯源",slug:"_4-mat与jprofiler的gc-roots溯源",normalizedTitle:"4. mat与jprofiler的gc roots溯源",charIndex:9956},{level:3,title:"1. MAT",slug:"_1-mat",normalizedTitle:"1. mat",charIndex:10030},{level:4,title:"获取dump文件",slug:"获取dump文件",normalizedTitle:"获取dump文件",charIndex:10185},{level:3,title:"2. Eclipse GC Roots说明",slug:"_2-eclipse-gc-roots说明",normalizedTitle:"2. eclipse gc roots说明",charIndex:11443},{level:3,title:"3. 使用Jprofiler分析OOM",slug:"_3-使用jprofiler分析oom",normalizedTitle:"3. 使用jprofiler分析oom",charIndex:11574},{level:2,title:"5. 清除阶段：标记-清除算法（Mark-Sweep）",slug:"_5-清除阶段-标记-清除算法-mark-sweep",normalizedTitle:"5. 清除阶段：标记-清除算法（mark-sweep）",charIndex:12297},{level:3,title:"背景：",slug:"背景",normalizedTitle:"背景：",charIndex:12485},{level:3,title:"执行过程",slug:"执行过程",normalizedTitle:"执行过程",charIndex:12568},{level:3,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:493},{level:3,title:"注意：何为清除？",slug:"注意-何为清除",normalizedTitle:"注意：何为清除？",charIndex:12910},{level:2,title:"6. 清除阶段：复制算法（Copying）",slug:"_6-清除阶段-复制算法-copying",normalizedTitle:"6. 清除阶段：复制算法（copying）",charIndex:12999},{level:3,title:"背景",slug:"背景-2",normalizedTitle:"背景",charIndex:12485},{level:3,title:"核心思想：",slug:"核心思想",normalizedTitle:"核心思想：",charIndex:13245},{level:3,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:437},{level:3,title:"缺点",slug:"缺点-2",normalizedTitle:"缺点",charIndex:493},{level:3,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:5224},{level:3,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:13630},{level:2,title:"7. 清除阶段：标记-压缩算法（Mark-Compact）",slug:"_7-清除阶段-标记-压缩算法-mark-compact",normalizedTitle:"7. 清除阶段：标记-压缩算法（mark-compact）",charIndex:13716},{level:3,title:"背景",slug:"背景-3",normalizedTitle:"背景",charIndex:12485},{level:3,title:"执行过程",slug:"执行过程-2",normalizedTitle:"执行过程",charIndex:12568},{level:3,title:"标清和标整的区别",slug:"标清和标整的区别",normalizedTitle:"标清和标整的区别",charIndex:14172},{level:3,title:"标整的优缺点",slug:"标整的优缺点",normalizedTitle:"标整的优缺点",charIndex:14438},{level:4,title:"优点",slug:"优点-2",normalizedTitle:"优点",charIndex:437},{level:4,title:"缺点",slug:"缺点-3",normalizedTitle:"缺点",charIndex:493},{level:2,title:"8. 小结",slug:"_8-小结",normalizedTitle:"8. 小结",charIndex:14637},{level:3,title:"分代收集算法",slug:"分代收集算法",normalizedTitle:"分代收集算法",charIndex:15015},{level:4,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:15025},{level:4,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:10354},{level:2,title:"9. 增量收集算法、分区算法",slug:"_9-增量收集算法、分区算法",normalizedTitle:"9. 增量收集算法、分区算法",charIndex:16089},{level:3,title:"1. 增量收集算法（Incremental Collectiong）",slug:"_1-增量收集算法-incremental-collectiong",normalizedTitle:"1. 增量收集算法（incremental collectiong）",charIndex:16108},{level:4,title:"缺点",slug:"缺点-4",normalizedTitle:"缺点",charIndex:493},{level:3,title:"2. 分区算法",slug:"_2-分区算法",normalizedTitle:"2. 分区算法",charIndex:16648}],headersStr:"1. 标记阶段：引用计数算法 1. 垃圾标记阶段：对象存活判断 2. 引用计数算法 3. 示例 1. 不进行GC处理 2. 通过GC处理 3. 总结 4. 小结 2. 标记阶段：可达性分析算法 1. 可达性分析算法 2. GC Roots 3. 注意 3. 对象的finalization机制 1. 对象的finalization机制 2. 生存还是死亡？ 3. 具体过程 4. 代码演示可复活的对象 4. MAT与JProfiler的GC Roots溯源 1. MAT 获取dump文件 2. Eclipse GC Roots说明 3. 使用Jprofiler分析OOM 5. 清除阶段：标记-清除算法（Mark-Sweep） 背景： 执行过程 缺点 注意：何为清除？ 6. 清除阶段：复制算法（Copying） 背景 核心思想： 优点 缺点 注意 应用场景 7. 清除阶段：标记-压缩算法（Mark-Compact） 背景 执行过程 标清和标整的区别 标整的优缺点 优点 缺点 8. 小结 分代收集算法 概述 应用 9. 增量收集算法、分区算法 1. 增量收集算法（Incremental Collectiong） 缺点 2. 分区算法",content:'# JVM-垃圾回收相关算法\n\n\n# 1. 标记阶段：引用计数算法\n\n\n\n\n# 1. 垃圾标记阶段：对象存活判断\n\n * 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要分出内存中那些是存活对象，那些是已经死亡的对象。只有被标记已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以成为垃圾标记阶段。\n * 那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。\n * 判断对象存活一般有两种方式：引用技术算法和可达性分析算法\n\n\n# 2. 引用计数算法\n\n * 引用计数算法比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况.\n\n * 对于一个对象A,只要有任何一个对象引用类了A，咋A的引用计数器就加1；当引用失效是，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用时，可进行回收。\n\n * 优点：\n   \n   ① 实现简单，垃圾对象便于辨识；\n   \n   ② 判断效率高，回收没有延迟性。\n\n * 缺点：\n   \n   ① 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。\n   \n   ② 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。\n   \n   ③ 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。\n\n循环引用\n\n\n\n\n# 3. 示例\n\n# 1. 不进行GC处理\n\n\n\n/**\n * -XX:+PrintGCDetails\n * 证明：java使用的不是引用计数算法\n */\npublic class RefCountGC {\n    //这个成员属性唯一的作用就是占用一点内存\n    private byte[] bigSize = new byte[5 * 1024 * 1024];//5MB\n\n    Object reference = null;\n\n    public static void main(String[] args) {\n        RefCountGC obj1 = new RefCountGC();\n        RefCountGC obj2 = new RefCountGC();\n\n        obj1.reference = obj2;\n        obj2.reference = obj1;\n\n        obj1 = null;\n        obj2 = null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 通过参数 -XX:+PrintGCDetails\n\n\n\nHeap\n PSYoungGen      total 38400K, used 12910K [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)\n  eden space 33280K, 38% used [0x0000000795580000,0x000000079621bb50,0x0000000797600000)\n  from space 5120K, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000)\n  to   space 5120K, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000)\n ParOldGen       total 87552K, used 0K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)\n  object space 87552K, 0% used [0x0000000740000000,0x0000000740000000,0x0000000745580000)\n Metaspace       used 3044K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 325K, capacity 388K, committed 512K, reserved 1048576K\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 2. 通过GC处理\n\n/**\n * -XX:+PrintGCDetails\n * 证明：java使用的不是引用计数算法\n */\npublic class RefCountGC {\n    //这个成员属性唯一的作用就是占用一点内存\n    private byte[] bigSize = new byte[5 * 1024 * 1024];//5MB\n\n    Object reference = null;\n\n    public static void main(String[] args) {\n        RefCountGC obj1 = new RefCountGC();\n        RefCountGC obj2 = new RefCountGC();\n\n        obj1.reference = obj2;\n        obj2.reference = obj1;\n\n        obj1 = null;\n        obj2 = null;\n        //显式的执行垃圾回收行为\n        //这里发生GC，obj1和obj2能否被回收？\n        System.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n[GC (System.gc()) [PSYoungGen: 12244K->448K(38400K)] 12244K->456K(125952K), 0.0009901 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (System.gc()) [PSYoungGen: 448K->0K(38400K)] [ParOldGen: 8K->347K(87552K)] 456K->347K(125952K), [Metaspace: 3120K->3120K(1056768K)], 0.0022413 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] \nHeap\n PSYoungGen      total 38400K, used 333K [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)\n  eden space 33280K, 1% used [0x0000000795580000,0x00000007955d34a8,0x0000000797600000)\n  from space 5120K, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000)\n  to   space 5120K, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000)\n ParOldGen       total 87552K, used 347K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)\n  object space 87552K, 0% used [0x0000000740000000,0x0000000740056f60,0x0000000745580000)\n Metaspace       used 3127K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 339K, capacity 388K, committed 512K, reserved 1048576K\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 3. 总结\n\nJava使用的不是引用计数算法.\n\n\n# 4. 小结\n\n * 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python。它更是同时支持引用计数和垃圾回收机制。\n\n * 具体哪种最优势要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。\n\n * Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。\n\n * Python如何解决循环引用？\n   \n   ① 手动解除：在合适的时机，解除引用关系。\n   \n   ② 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。\n\n\n# 2. 标记阶段：可达性分析算法\n\n\n# 1. 可达性分析算法\n\n> 可达性分析算法又名：根搜索算法、追踪性垃圾收集\n\n 1. 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效的解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。\n\n 2. 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫做追踪性垃圾收集（Tracing GarBage Collection）。\n\n 3. 所谓“GC Roots”根集合就是一组必须活跃的引用。\n\n 4. 基本思路：\n    \n    * 可达性分析算法是以根对象（GC Roots）为起始点，按照从上至下的方式搜索被跟对象集合所连接的目标对象是否可达。\n    * 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）。\n    * 如果目标对象没有任何引用链相连，则是不可达，就意味着该对象已经过死亡，可以标记为垃圾对象。\n    * 在可达性分析算法中，只有能够被跟对象集合直接或者间接连接的对象才是存活对象。\n    \n    \n\n\n# 2. GC Roots\n\n在Java语言中，GC Roots包括以下几类元素：\n\n 1. 虚拟机栈中引用的对象\n    * 比如：各个线程被调用的方法中使用到的参数、局部变量等。\n 2. 本地方法栈内JNT（通常说的本地方法）引用的对象。\n 3. 方法区中类静态属性引用的对象。\n    * 比如：Java类的引用类型静态变量。\n 4. 方法区中常量引用的对象\n    * 比如：字符串常量吃（String Table）里的引用。\n 5. 所有被同步锁synchronized持有的对象。\n 6. Java虚拟机内部的引用。\n    * 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError）,系统类加载器。\n 7. 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。\n\n\n\n 8. 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”的加入，共同构成完整GC Roots集合，比如：分代收集和局部回收（Partial GC）。\n    \n    * 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是独立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。\n\n 9. 小技巧\n    \n    由于Root采用绽放时存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。\n\n\n# 3. 注意\n\n * 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。\n * 这点也是导致GC进行时必须“Stop The World”的一个重要原因。\n   * 即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。\n\n\n# 3. 对象的finalization机制\n\n\n# 1. 对象的finalization机制\n\n 1. Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。\n\n 2. 当垃圾回收器发现没有引用执行一个对象，即：垃圾回收此对象之前，总会想调用这个对象的finalize()方法。\n\n 3. finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。\n\n 4. 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：\n    \n    * 在fianlize()是可能会导致对象复活。\n    * finalize()方法的执行时间是没有保障的，它完全是由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。\n    * 一个糟糕的finalize()会严重影响GC的性能。\n\n 5. 从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，多一finalize()方法在本质上年不同于C++中的析构函数。\n\n 6. 忧郁finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。\n\n\n# 2. 生存还是死亡？\n\n 1. 如果从所有的根结点都无法访问到某个队形，说经队形已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：\n    \n    * 可触及的：从根节点开始，可以到达这个对象。\n    * 可复活的：对象的finalize()被调用，但是兑现有可能在finalize()复活。\n    * 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。\n\n 2. 以上3中状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。\n\n\n# 3. 具体过程\n\n判定一个对象objA是否可回收，至少要经历两次标记过程：\n\n 1. 如果对象objA到GC Roots没有引用链，则进行第一次标记。\n 2. 进行筛选，判断此对象是否有必要执行finalize（）方法\n\n * 如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。\n * 如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。\n * finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。\n\n\n\n\n# 4. 代码演示可复活的对象\n\n * 没有重写finalize()方法\n\n/**\n * 测试Object类中finalize()方法，即对象的finalization机制。\n *\n * @author shkstart\n * @create 2020 下午 2:57\n */\npublic class CanReliveObj {\n     /**\n     * 类变量，属于 GC Root\n     */\n    public static CanReliveObj obj;\n\n    public static void main(String[] args) {\n        try {\n            obj = new CanReliveObj();\n            // 对象第一次成功拯救自己\n            obj = null;\n            System.gc();//调用垃圾回收器\n            System.out.println("第1次 gc");\n            // 因为Finalizer线程优先级很低，暂停2秒，以等待它\n            Thread.sleep(2000);\n            if (obj == null) {\n                System.out.println("obj is dead");\n            } else {\n                System.out.println("obj is still alive");\n            }\n            System.out.println("第2次 gc");\n            // 下面这段代码与上面的完全相同，但是这次自救却失败了\n            obj = null;\n            System.gc();\n            // 因为Finalizer线程优先级很低，暂停2秒，以等待它\n            Thread.sleep(2000);\n            if (obj == null) {\n                System.out.println("obj is dead");\n            } else {\n                System.out.println("obj is still alive");\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n结果：\n\n第1次 gc\nobj is dead\n第2次 gc\nobj is dead\n\n\n1\n2\n3\n4\n\n * 重写finalize()方法\n\n/**\n * 测试Object类中finalize()方法，即对象的finalization机制。\n *\n * @author shkstart\n * @create 2020 下午 2:57\n */\npublic class CanReliveObj {\n    /**\n     * 类变量，属于 GC Root\n     */\n    public static CanReliveObj obj;\n\n\n    /**\n     * 此方法只能被调用一次\n     * @throws Throwable\n     */\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println("调用当前类重写的finalize()方法");\n        //当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系\n        obj = this;\n    }\n\n    public static void main(String[] args) {\n        try {\n            obj = new CanReliveObj();\n            // 对象第一次成功拯救自己\n            obj = null;\n            System.gc();//调用垃圾回收器\n            System.out.println("第1次 gc");\n            // 因为Finalizer线程优先级很低，暂停2秒，以等待它\n            Thread.sleep(2000);\n            if (obj == null) {\n                System.out.println("obj is dead");\n            } else {\n                System.out.println("obj is still alive");\n            }\n            System.out.println("第2次 gc");\n            // 下面这段代码与上面的完全相同，但是这次自救却失败了\n            obj = null;\n            System.gc();\n            // 因为Finalizer线程优先级很低，暂停2秒，以等待它\n            Thread.sleep(2000);\n            if (obj == null) {\n                System.out.println("obj is dead");\n            } else {\n                System.out.println("obj is still alive");\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n结果：\n\n第1次 gc\n调用当前类重写的finalize()方法\nobj is still alive\n第2次 gc\nobj is dead\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4. MAT与JProfiler的GC Roots溯源\n\nJVM调试工具：jvisualvm、jconsole、MAT、Jprofiler\n\n\n# 1. MAT\n\n * MAT是MemoryAnalyzer的简称，它是一款功能强大的Java内存分析器。用于查找内存泄露以及查看内存消耗情况。\n\n * MAT是基于Eclipse开发的，是一款免费的性能分析工具。\n\n * MAT下载地址 : http://www.eclipse.org/mat/。\n\n\n\n# 获取dump文件\n\n 1. 命令行使用jmap\n\n\n\n 2. 使用JVisualVM导出\n    \n    ① 捕获的heap dump文件是一个临时文件，关闭JVisualVM后会自动删除，若要保留需要将其另存为文件。\n    \n    ② 可以通过以下方法捕获heap dump：\n    \n    在左侧“Application”(应用程序)子窗口中右击相应的应用程序，选择heap dump（堆Dump）\n    \n    在Monitor(监视)子标签页中点击Heap Dump（堆Dump）按钮。\n    \n    ③ 本地应用程序的Heap Dumps作为应用程序的一个子标签页打开。同时，Heap Dump在左侧的Application(应用程序)栏中对应一个含有时间戳的节点。右击这个节点选择save as（另存为）即可将Heap Dump保存到本地。\n\n示例代码\n\n// 局部变量表就是天然作为GCRoot\npublic class GCRootsTest {\n    public static void main(String[] args) {\n        List<Object> numList = new ArrayList<>();\n        Date birth = new Date();\n\n        for (int i = 0; i < 100; i++) {\n            numList.add(String.valueOf(i));\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        System.out.println("数据添加完毕，请操作：");\n        new Scanner(System.in).next();\n        numList = null;\n        birth = null;\n\n        System.out.println("numList、birth已置空，请操作：");\n        new Scanner(System.in).next();\n\n        System.out.println("结束");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n使用JVisualVM生成临时文件（快照）：步骤：\n\n\n\n\n\n保存临时文件：\n\n\n\n\n\n使用MAT解析上面生成快照步骤：\n\n选择file\n\n\n\n\n\n打开JVisualVM生成临时文件（快照）\n\n\n\n\n\n\n\n\n# 2. Eclipse GC Roots说明\n\nhttps://help.eclipse.org/2020-03/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html\n\n\n\n\n# 3. 使用Jprofiler分析OOM\n\n/**\n * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError\n *\n */\npublic class HeapOOM {\n    byte[] buffer = new byte[1 * 1024 * 1024];//1MB\n\n    public static void main(String[] args) {\n        ArrayList<HeapOOM> list = new ArrayList<>();\n\n        int count = 0;\n        try{\n            while(true){\n                list.add(new HeapOOM());\n                count++;\n            }\n        }catch (Throwable e){\n            System.out.println("count = " + count);\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n使用IDEA填写参数运行：\n\n-Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError\n\n\n1\n\n\n\n\n结果：\n\n\n\n\n\n打开生成的文件\n\n\n\n选择Biggest Objects\n\n\n\n> 发现超大对象ArrayList\n\n\n# 5. 清除阶段：标记-清除算法（Mark-Sweep）\n\n当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。\n\n目前在JVM中比较常见的三种垃圾收集算法是：标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）。\n\n\n# 背景：\n\n标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾回收算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。\n\n\n# 执行过程\n\n当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。\n\n * 标记：Collector从引用根结点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。\n * 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达性对象，则将其回收。\n\n\n\n\n# 缺点\n\n * 效率不算高。（通过上图分析经历过两次全遍历）\n * 在进行GC的时候，需要停止整个应用程序，导致用户体验差。\n * 这种方式清理出来的空闲内存时不连续的，产生内存碎片。需要维护一个空闲列表。（上图分析）\n\n\n# 注意：何为清除？\n\n> 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。\n\n\n# 6. 清除阶段：复制算法（Copying）\n\n\n# 背景\n\n为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky与1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CALISP Garbage Collector Algorithm Using Serial Secondary Storage”。M.L.Minsky在该论文中描述的算法被人们称为赋值算法（Copying）算法，它也被M.L.Minsky本人成功的引入到Lisp语言的一个实现版本。\n\n\n# 核心思想：\n\n将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复值到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。\n\n\n\n> 新生代对象分配与回收使用复制算法。\n\n\n\n\n# 优点\n\n * 没有标记和清除过程，实现简单，运行高效\n * 复制过去以后保证空间的连续性，不会出现“碎片”问题。\n\n\n# 缺点\n\n * 此算法的缺点也是很明显的，就是需要两倍的内存空间。\n * 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小\n\n\n# 注意\n\n如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）\n\n\n# 应用场景\n\n在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。\n\n\n\n\n# 7. 清除阶段：标记-压缩算法（Mark-Compact）\n\n\n# 背景\n\n * 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。\n\n * 标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。\n\n * 1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。\n\n\n# 执行过程\n\n * 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象\n\n * 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。\n\n\n\n\n# 标清和标整的区别\n\n标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。\n\n二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。\n\n\n# 标整的优缺点\n\n# 优点\n\n * 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。\n * 消除了复制算法当中，内存减半的高额代价。\n\n# 缺点\n\n * 从效率上来说，标记-整理算法要低于复制算法。\n * 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址\n * 移动过程中，需要全程暂停用户应用程序。即：STW\n\n\n# 8. 小结\n\n效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。\n\n而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。\n\n       标记清除（MARK-SWEEP）   标记整理（MARK-COMPACT）   复制（COPYING）\n速率     中等                 最慢                   最快\n空间开销   少（但会堆积碎片）          少（不堆积碎片）             通常需要活对象的2倍空间（不堆积碎片）\n移动对象   否                  是                    是\n\n> 综合我们可以找到，没有最好的算法，只有最合适的算法\n\n\n# 分代收集算法\n\n# 概述\n\n前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。\n\n分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。\n\n在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。\n\n目前几乎所有的GC都采用分代算法执行垃圾回收的\n\n# 应用\n\n在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。\n\n * 年轻代（Young Gen）\n\n年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。\n\n这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。\n\n> 年轻代使用复制算法\n\n * 老年代（Tenured Gen）\n\n老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。\n\n这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。\n\n * Mark阶段的开销与存活对象的数量成正比。\n * Sweep阶段的开销与所管理区域的大小成正相关。\n * compact阶段的开销与存活对象的数据成正比。\n\n> 老年代由标记-清除或者是标记-清除与标记-整理的混合实现\n\n以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。\n\n分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代\n\n\n# 9. 增量收集算法、分区算法\n\n\n# 1. 增量收集算法（Incremental Collectiong）\n\n上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾回收算法的研究直接导致了增量收集算法（Incremental Collectiong）的诞生。\n\n> 基本思想\n\n如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。一侧反复，知道垃圾收集完成。 (洗衣服)\n\n总的来说，增量收集算法的基础人事传统的标记-清除算法和赋值算法，增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或赋值工作。\n\n# 缺点\n\n使用这种方式，由于在垃圾收集过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间，但是，因为线程切换和上下文交换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。\n\n\n# 2. 分区算法\n\n一般来说，在相同条件下，堆空间越大，一次GC时所需的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。\n\n分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。\n\n每个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。\n\n\n\n> 注意：这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。',normalizedContent:'# jvm-垃圾回收相关算法\n\n\n# 1. 标记阶段：引用计数算法\n\n\n\n\n# 1. 垃圾标记阶段：对象存活判断\n\n * 在堆里存放着几乎所有的java对象实例，在gc执行垃圾回收之前，首先需要分出内存中那些是存活对象，那些是已经死亡的对象。只有被标记已经死亡的对象，gc才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以成为垃圾标记阶段。\n * 那么在jvm中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。\n * 判断对象存活一般有两种方式：引用技术算法和可达性分析算法\n\n\n# 2. 引用计数算法\n\n * 引用计数算法比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况.\n\n * 对于一个对象a,只要有任何一个对象引用类了a，咋a的引用计数器就加1；当引用失效是，引用计数器就减1。只要对象a的引用计数器的值为0，即表示对象a不可能再被使用时，可进行回收。\n\n * 优点：\n   \n   ① 实现简单，垃圾对象便于辨识；\n   \n   ② 判断效率高，回收没有延迟性。\n\n * 缺点：\n   \n   ① 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。\n   \n   ② 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。\n   \n   ③ 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在java的垃圾回收器中没有使用这类算法。\n\n循环引用\n\n\n\n\n# 3. 示例\n\n# 1. 不进行gc处理\n\n\n\n/**\n * -xx:+printgcdetails\n * 证明：java使用的不是引用计数算法\n */\npublic class refcountgc {\n    //这个成员属性唯一的作用就是占用一点内存\n    private byte[] bigsize = new byte[5 * 1024 * 1024];//5mb\n\n    object reference = null;\n\n    public static void main(string[] args) {\n        refcountgc obj1 = new refcountgc();\n        refcountgc obj2 = new refcountgc();\n\n        obj1.reference = obj2;\n        obj2.reference = obj1;\n\n        obj1 = null;\n        obj2 = null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 通过参数 -xx:+printgcdetails\n\n\n\nheap\n psyounggen      total 38400k, used 12910k [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)\n  eden space 33280k, 38% used [0x0000000795580000,0x000000079621bb50,0x0000000797600000)\n  from space 5120k, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000)\n  to   space 5120k, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000)\n paroldgen       total 87552k, used 0k [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)\n  object space 87552k, 0% used [0x0000000740000000,0x0000000740000000,0x0000000745580000)\n metaspace       used 3044k, capacity 4496k, committed 4864k, reserved 1056768k\n  class space    used 325k, capacity 388k, committed 512k, reserved 1048576k\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 2. 通过gc处理\n\n/**\n * -xx:+printgcdetails\n * 证明：java使用的不是引用计数算法\n */\npublic class refcountgc {\n    //这个成员属性唯一的作用就是占用一点内存\n    private byte[] bigsize = new byte[5 * 1024 * 1024];//5mb\n\n    object reference = null;\n\n    public static void main(string[] args) {\n        refcountgc obj1 = new refcountgc();\n        refcountgc obj2 = new refcountgc();\n\n        obj1.reference = obj2;\n        obj2.reference = obj1;\n\n        obj1 = null;\n        obj2 = null;\n        //显式的执行垃圾回收行为\n        //这里发生gc，obj1和obj2能否被回收？\n        system.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n[gc (system.gc()) [psyounggen: 12244k->448k(38400k)] 12244k->456k(125952k), 0.0009901 secs] [times: user=0.00 sys=0.00, real=0.00 secs] \n[full gc (system.gc()) [psyounggen: 448k->0k(38400k)] [paroldgen: 8k->347k(87552k)] 456k->347k(125952k), [metaspace: 3120k->3120k(1056768k)], 0.0022413 secs] [times: user=0.01 sys=0.00, real=0.00 secs] \nheap\n psyounggen      total 38400k, used 333k [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)\n  eden space 33280k, 1% used [0x0000000795580000,0x00000007955d34a8,0x0000000797600000)\n  from space 5120k, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000)\n  to   space 5120k, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000)\n paroldgen       total 87552k, used 347k [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)\n  object space 87552k, 0% used [0x0000000740000000,0x0000000740056f60,0x0000000745580000)\n metaspace       used 3127k, capacity 4496k, committed 4864k, reserved 1056768k\n  class space    used 339k, capacity 388k, committed 512k, reserved 1048576k\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 3. 总结\n\njava使用的不是引用计数算法.\n\n\n# 4. 小结\n\n * 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的python。它更是同时支持引用计数和垃圾回收机制。\n\n * 具体哪种最优势要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。\n\n * java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。\n\n * python如何解决循环引用？\n   \n   ① 手动解除：在合适的时机，解除引用关系。\n   \n   ② 使用弱引用weakref，weakref是python提供的标准库，旨在解决循环引用。\n\n\n# 2. 标记阶段：可达性分析算法\n\n\n# 1. 可达性分析算法\n\n> 可达性分析算法又名：根搜索算法、追踪性垃圾收集\n\n 1. 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效的解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。\n\n 2. 相较于引用计数算法，这里的可达性分析就是java、c#选择的。这种类型的垃圾收集通常也叫做追踪性垃圾收集（tracing garbage collection）。\n\n 3. 所谓“gc roots”根集合就是一组必须活跃的引用。\n\n 4. 基本思路：\n    \n    * 可达性分析算法是以根对象（gc roots）为起始点，按照从上至下的方式搜索被跟对象集合所连接的目标对象是否可达。\n    * 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（reference chain）。\n    * 如果目标对象没有任何引用链相连，则是不可达，就意味着该对象已经过死亡，可以标记为垃圾对象。\n    * 在可达性分析算法中，只有能够被跟对象集合直接或者间接连接的对象才是存活对象。\n    \n    \n\n\n# 2. gc roots\n\n在java语言中，gc roots包括以下几类元素：\n\n 1. 虚拟机栈中引用的对象\n    * 比如：各个线程被调用的方法中使用到的参数、局部变量等。\n 2. 本地方法栈内jnt（通常说的本地方法）引用的对象。\n 3. 方法区中类静态属性引用的对象。\n    * 比如：java类的引用类型静态变量。\n 4. 方法区中常量引用的对象\n    * 比如：字符串常量吃（string table）里的引用。\n 5. 所有被同步锁synchronized持有的对象。\n 6. java虚拟机内部的引用。\n    * 基本数据类型对应的class对象，一些常驻的异常对象（如：nullpointerexception、outofmemoryerror）,系统类加载器。\n 7. 反应java虚拟机内部情况的jmxbean、jvmti中注册的回调、本地代码缓存等。\n\n\n\n 8. 除了这些固定的gc roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”的加入，共同构成完整gc roots集合，比如：分代收集和局部回收（partial gc）。\n    \n    * 如果只针对java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是独立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入gc roots集合中去考虑，才能保证可达性分析的准确性。\n\n 9. 小技巧\n    \n    由于root采用绽放时存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个root。\n\n\n# 3. 注意\n\n * 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。\n * 这点也是导致gc进行时必须“stop the world”的一个重要原因。\n   * 即使是号称（几乎）不会发生停顿的cms收集器中，枚举根节点时也是必须要停顿的。\n\n\n# 3. 对象的finalization机制\n\n\n# 1. 对象的finalization机制\n\n 1. java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。\n\n 2. 当垃圾回收器发现没有引用执行一个对象，即：垃圾回收此对象之前，总会想调用这个对象的finalize()方法。\n\n 3. finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。\n\n 4. 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：\n    \n    * 在fianlize()是可能会导致对象复活。\n    * finalize()方法的执行时间是没有保障的，它完全是由gc线程决定，极端情况下，若不发生gc，则finalize()方法将没有执行机会。\n    * 一个糟糕的finalize()会严重影响gc的性能。\n\n 5. 从功能上来说，finalize()方法与c++中的析构函数比较相似，但是java采用的是基于垃圾回收器的自动内存管理机制，多一finalize()方法在本质上年不同于c++中的析构函数。\n\n 6. 忧郁finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。\n\n\n# 2. 生存还是死亡？\n\n 1. 如果从所有的根结点都无法访问到某个队形，说经队形已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：\n    \n    * 可触及的：从根节点开始，可以到达这个对象。\n    * 可复活的：对象的finalize()被调用，但是兑现有可能在finalize()复活。\n    * 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。\n\n 2. 以上3中状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。\n\n\n# 3. 具体过程\n\n判定一个对象obja是否可回收，至少要经历两次标记过程：\n\n 1. 如果对象obja到gc roots没有引用链，则进行第一次标记。\n 2. 进行筛选，判断此对象是否有必要执行finalize（）方法\n\n * 如果对象obja没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，obja被判定为不可触及的。\n * 如果对象obja重写了finalize（）方法，且还未执行过，那么obja会被插入到f-queue队列中，由一个虚拟机自动创建的、低优先级的finalizer线程触发其finalize（）方法执行。\n * finalize（）方法是对象逃脱死亡的最后机会，稍后gc会对f-queue队列中的对象进行第二次标记。如果obja在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，obja会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。\n\n\n\n\n# 4. 代码演示可复活的对象\n\n * 没有重写finalize()方法\n\n/**\n * 测试object类中finalize()方法，即对象的finalization机制。\n *\n * @author shkstart\n * @create 2020 下午 2:57\n */\npublic class canreliveobj {\n     /**\n     * 类变量，属于 gc root\n     */\n    public static canreliveobj obj;\n\n    public static void main(string[] args) {\n        try {\n            obj = new canreliveobj();\n            // 对象第一次成功拯救自己\n            obj = null;\n            system.gc();//调用垃圾回收器\n            system.out.println("第1次 gc");\n            // 因为finalizer线程优先级很低，暂停2秒，以等待它\n            thread.sleep(2000);\n            if (obj == null) {\n                system.out.println("obj is dead");\n            } else {\n                system.out.println("obj is still alive");\n            }\n            system.out.println("第2次 gc");\n            // 下面这段代码与上面的完全相同，但是这次自救却失败了\n            obj = null;\n            system.gc();\n            // 因为finalizer线程优先级很低，暂停2秒，以等待它\n            thread.sleep(2000);\n            if (obj == null) {\n                system.out.println("obj is dead");\n            } else {\n                system.out.println("obj is still alive");\n            }\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n结果：\n\n第1次 gc\nobj is dead\n第2次 gc\nobj is dead\n\n\n1\n2\n3\n4\n\n * 重写finalize()方法\n\n/**\n * 测试object类中finalize()方法，即对象的finalization机制。\n *\n * @author shkstart\n * @create 2020 下午 2:57\n */\npublic class canreliveobj {\n    /**\n     * 类变量，属于 gc root\n     */\n    public static canreliveobj obj;\n\n\n    /**\n     * 此方法只能被调用一次\n     * @throws throwable\n     */\n    @override\n    protected void finalize() throws throwable {\n        super.finalize();\n        system.out.println("调用当前类重写的finalize()方法");\n        //当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系\n        obj = this;\n    }\n\n    public static void main(string[] args) {\n        try {\n            obj = new canreliveobj();\n            // 对象第一次成功拯救自己\n            obj = null;\n            system.gc();//调用垃圾回收器\n            system.out.println("第1次 gc");\n            // 因为finalizer线程优先级很低，暂停2秒，以等待它\n            thread.sleep(2000);\n            if (obj == null) {\n                system.out.println("obj is dead");\n            } else {\n                system.out.println("obj is still alive");\n            }\n            system.out.println("第2次 gc");\n            // 下面这段代码与上面的完全相同，但是这次自救却失败了\n            obj = null;\n            system.gc();\n            // 因为finalizer线程优先级很低，暂停2秒，以等待它\n            thread.sleep(2000);\n            if (obj == null) {\n                system.out.println("obj is dead");\n            } else {\n                system.out.println("obj is still alive");\n            }\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n结果：\n\n第1次 gc\n调用当前类重写的finalize()方法\nobj is still alive\n第2次 gc\nobj is dead\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4. mat与jprofiler的gc roots溯源\n\njvm调试工具：jvisualvm、jconsole、mat、jprofiler\n\n\n# 1. mat\n\n * mat是memoryanalyzer的简称，它是一款功能强大的java内存分析器。用于查找内存泄露以及查看内存消耗情况。\n\n * mat是基于eclipse开发的，是一款免费的性能分析工具。\n\n * mat下载地址 : http://www.eclipse.org/mat/。\n\n\n\n# 获取dump文件\n\n 1. 命令行使用jmap\n\n\n\n 2. 使用jvisualvm导出\n    \n    ① 捕获的heap dump文件是一个临时文件，关闭jvisualvm后会自动删除，若要保留需要将其另存为文件。\n    \n    ② 可以通过以下方法捕获heap dump：\n    \n    在左侧“application”(应用程序)子窗口中右击相应的应用程序，选择heap dump（堆dump）\n    \n    在monitor(监视)子标签页中点击heap dump（堆dump）按钮。\n    \n    ③ 本地应用程序的heap dumps作为应用程序的一个子标签页打开。同时，heap dump在左侧的application(应用程序)栏中对应一个含有时间戳的节点。右击这个节点选择save as（另存为）即可将heap dump保存到本地。\n\n示例代码\n\n// 局部变量表就是天然作为gcroot\npublic class gcrootstest {\n    public static void main(string[] args) {\n        list<object> numlist = new arraylist<>();\n        date birth = new date();\n\n        for (int i = 0; i < 100; i++) {\n            numlist.add(string.valueof(i));\n            try {\n                thread.sleep(10);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n\n        system.out.println("数据添加完毕，请操作：");\n        new scanner(system.in).next();\n        numlist = null;\n        birth = null;\n\n        system.out.println("numlist、birth已置空，请操作：");\n        new scanner(system.in).next();\n\n        system.out.println("结束");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n使用jvisualvm生成临时文件（快照）：步骤：\n\n\n\n\n\n保存临时文件：\n\n\n\n\n\n使用mat解析上面生成快照步骤：\n\n选择file\n\n\n\n\n\n打开jvisualvm生成临时文件（快照）\n\n\n\n\n\n\n\n\n# 2. eclipse gc roots说明\n\nhttps://help.eclipse.org/2020-03/index.jsp?topic=%2forg.eclipse.mat.ui.help%2fconcepts%2fgcroots.html\n\n\n\n\n# 3. 使用jprofiler分析oom\n\n/**\n * -xms8m -xmx8m -xx:+heapdumponoutofmemoryerror\n *\n */\npublic class heapoom {\n    byte[] buffer = new byte[1 * 1024 * 1024];//1mb\n\n    public static void main(string[] args) {\n        arraylist<heapoom> list = new arraylist<>();\n\n        int count = 0;\n        try{\n            while(true){\n                list.add(new heapoom());\n                count++;\n            }\n        }catch (throwable e){\n            system.out.println("count = " + count);\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n使用idea填写参数运行：\n\n-xms8m -xmx8m -xx:+heapdumponoutofmemoryerror\n\n\n1\n\n\n\n\n结果：\n\n\n\n\n\n打开生成的文件\n\n\n\n选择biggest objects\n\n\n\n> 发现超大对象arraylist\n\n\n# 5. 清除阶段：标记-清除算法（mark-sweep）\n\n当成功区分出内存中存活对象和死亡对象后，gc接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。\n\n目前在jvm中比较常见的三种垃圾收集算法是：标记-清除算法（mark-sweep）、复制算法（copying）、标记-压缩算法（mark-compact）。\n\n\n# 背景：\n\n标记-清除算法（mark-sweep）是一种非常基础和常见的垃圾回收算法，该算法被j.mccarthy等人在1960年提出并并应用于lisp语言。\n\n\n# 执行过程\n\n当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。\n\n * 标记：collector从引用根结点开始遍历，标记所有被引用的对象。一般是在对象的header中记录为可达对象。\n * 清除：collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其header中没有标记为可达性对象，则将其回收。\n\n\n\n\n# 缺点\n\n * 效率不算高。（通过上图分析经历过两次全遍历）\n * 在进行gc的时候，需要停止整个应用程序，导致用户体验差。\n * 这种方式清理出来的空闲内存时不连续的，产生内存碎片。需要维护一个空闲列表。（上图分析）\n\n\n# 注意：何为清除？\n\n> 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。\n\n\n# 6. 清除阶段：复制算法（copying）\n\n\n# 背景\n\n为了解决标记-清除算法在垃圾收集效率方面的缺陷，m.l.minsky与1963年发表了著名的论文，“使用双存储区的lisp语言垃圾收集器calisp garbage collector algorithm using serial secondary storage”。m.l.minsky在该论文中描述的算法被人们称为赋值算法（copying）算法，它也被m.l.minsky本人成功的引入到lisp语言的一个实现版本。\n\n\n# 核心思想：\n\n将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复值到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。\n\n\n\n> 新生代对象分配与回收使用复制算法。\n\n\n\n\n# 优点\n\n * 没有标记和清除过程，实现简单，运行高效\n * 复制过去以后保证空间的连续性，不会出现“碎片”问题。\n\n\n# 缺点\n\n * 此算法的缺点也是很明显的，就是需要两倍的内存空间。\n * 对于g1这种分拆成为大量region的gc，复制而不是移动，意味着gc需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小\n\n\n# 注意\n\n如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）\n\n\n# 应用场景\n\n在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。\n\n\n\n\n# 7. 清除阶段：标记-压缩算法（mark-compact）\n\n\n# 背景\n\n * 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。\n\n * 标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以jvm的设计者需要在此基础之上进行改进。标记-压缩（mark-compact）算法由此诞生。\n\n * 1970年前后，g.l.steele、c.j.chene和d.s.wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。\n\n\n# 执行过程\n\n * 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象\n\n * 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。\n\n\n\n\n# 标清和标整的区别\n\n标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（mark-sweep-compact）算法。\n\n二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，jvm只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。\n\n\n# 标整的优缺点\n\n# 优点\n\n * 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，jvm只需要持有一个内存的起始地址即可。\n * 消除了复制算法当中，内存减半的高额代价。\n\n# 缺点\n\n * 从效率上来说，标记-整理算法要低于复制算法。\n * 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址\n * 移动过程中，需要全程暂停用户应用程序。即：stw\n\n\n# 8. 小结\n\n效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。\n\n而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。\n\n       标记清除（mark-sweep）   标记整理（mark-compact）   复制（copying）\n速率     中等                 最慢                   最快\n空间开销   少（但会堆积碎片）          少（不堆积碎片）             通常需要活对象的2倍空间（不堆积碎片）\n移动对象   否                  是                    是\n\n> 综合我们可以找到，没有最好的算法，只有最合适的算法\n\n\n# 分代收集算法\n\n# 概述\n\n前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。\n\n分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。\n\n在java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如http请求中的session对象、线程、socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。\n\n目前几乎所有的gc都采用分代算法执行垃圾回收的\n\n# 应用\n\n在hotspot中，基于分代的概念，gc所使用的内存回收算法必须结合年轻代和老年代各自的特点。\n\n * 年轻代（young gen）\n\n年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。\n\n这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。\n\n> 年轻代使用复制算法\n\n * 老年代（tenured gen）\n\n老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。\n\n这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。\n\n * mark阶段的开销与存活对象的数量成正比。\n * sweep阶段的开销与所管理区域的大小成正相关。\n * compact阶段的开销与存活对象的数据成正比。\n\n> 老年代由标记-清除或者是标记-清除与标记-整理的混合实现\n\n以hotspot中的cms回收器为例，cms是基于mark-sweep实现的，对于对象的回收效率很高。而对于碎片问题，cms采用基于mark-compact算法的serial old回收器作为补偿措施：当内存回收不佳（碎片导致的concurrent mode failure时），将采用serial old执行fullgc以达到对老年代内存的整理。\n\n分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代\n\n\n# 9. 增量收集算法、分区算法\n\n\n# 1. 增量收集算法（incremental collectiong）\n\n上述现有的算法，在垃圾回收过程中，应用软件将处于一种 stop the world的状态。在stop the world状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾回收算法的研究直接导致了增量收集算法（incremental collectiong）的诞生。\n\n> 基本思想\n\n如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。一侧反复，知道垃圾收集完成。 (洗衣服)\n\n总的来说，增量收集算法的基础人事传统的标记-清除算法和赋值算法，增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或赋值工作。\n\n# 缺点\n\n使用这种方式，由于在垃圾收集过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间，但是，因为线程切换和上下文交换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。\n\n\n# 2. 分区算法\n\n一般来说，在相同条件下，堆空间越大，一次gc时所需的时间就越长，有关gc产生的停顿也越长。为了更好地控制gc产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次gc所产生的停顿。\n\n分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。\n\n每个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。\n\n\n\n> 注意：这些只是基本的算法思路，实际gc实现过程要复杂的多，目前还在发展中的前沿gc都是复合算法，并且并行和并发兼备。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-垃圾回收相关概念",frontmatter:{title:"JVM-垃圾回收相关概念",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/e20df8/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/16.JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.html",relativePath:"01.语言/01.JAVA语言/02.JVM/16.JVM-垃圾回收相关概念.md",key:"v-4fb73d7d",path:"/pages/e20df8/",headers:[{level:2,title:"1. System.gc()的理解",slug:"_1-system-gc-的理解",normalizedTitle:"1. system.gc()的理解",charIndex:19},{level:3,title:"示例1",slug:"示例1",normalizedTitle:"示例1",charIndex:295},{level:3,title:"示例2",slug:"示例2",normalizedTitle:"示例2",charIndex:773},{level:3,title:"示例3：手动gc理解不可达对象的回收行为",slug:"示例3-手动gc理解不可达对象的回收行为",normalizedTitle:"示例3：手动gc理解不可达对象的回收行为",charIndex:1295},{level:4,title:"1. 示例一",slug:"_1-示例一",normalizedTitle:"1. 示例一",charIndex:1340},{level:4,title:"2. 示例二",slug:"_2-示例二",normalizedTitle:"2. 示例二",charIndex:1663},{level:4,title:"3. 示例三",slug:"_3-示例三",normalizedTitle:"3. 示例三",charIndex:2005},{level:4,title:"4. 示例四",slug:"_4-示例四",normalizedTitle:"4. 示例四",charIndex:2352},{level:4,title:"5. 示例五",slug:"_5-示例五",normalizedTitle:"5. 示例五",charIndex:2727},{level:2,title:"2. 内存溢出与内存泄露",slug:"_2-内存溢出与内存泄露",normalizedTitle:"2. 内存溢出与内存泄露",charIndex:3013},{level:3,title:"1. 内存溢出（OOM）",slug:"_1-内存溢出-oom",normalizedTitle:"1. 内存溢出（oom）",charIndex:3030},{level:3,title:"2. 内存泄漏（Memoy Leak）",slug:"_2-内存泄漏-memoy-leak",normalizedTitle:"2. 内存泄漏（memoy leak）",charIndex:4174},{level:4,title:"内存泄漏举例",slug:"内存泄漏举例",normalizedTitle:"内存泄漏举例",charIndex:4480},{level:5,title:"1. 单例模式",slug:"_1-单例模式",normalizedTitle:"1. 单例模式",charIndex:4490},{level:5,title:"2. 一些提供close的资源未关闭导致内存泄露",slug:"_2-一些提供close的资源未关闭导致内存泄露",normalizedTitle:"2. 一些提供close的资源未关闭导致内存泄露",charIndex:4579},{level:2,title:"3. Stop The World",slug:"_3-stop-the-world",normalizedTitle:"3. stop the world",charIndex:4681},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:295},{level:2,title:"4. 垃圾回收的并行与并发",slug:"_4-垃圾回收的并行与并发",normalizedTitle:"4. 垃圾回收的并行与并发",charIndex:6730},{level:3,title:"1. 并发（Concurrent）",slug:"_1-并发-concurrent",normalizedTitle:"1. 并发（concurrent）",charIndex:6748},{level:3,title:"2. 并行（Parallel）",slug:"_2-并行-parallel",normalizedTitle:"2. 并行（parallel）",charIndex:6936},{level:3,title:"3. 并发 VS 并行",slug:"_3-并发-vs-并行",normalizedTitle:"3. 并发 vs 并行",charIndex:7097},{level:4,title:"二者对比",slug:"二者对比",normalizedTitle:"二者对比",charIndex:7112},{level:3,title:"4. 垃圾回收的并行与并发",slug:"_4-垃圾回收的并行与并发-2",normalizedTitle:"4. 垃圾回收的并行与并发",charIndex:6730},{level:2,title:"5. 安全点与安全区域",slug:"_5-安全点与安全区域",normalizedTitle:"5. 安全点与安全区域",charIndex:7616},{level:3,title:"1. 安全点（Safepoint）",slug:"_1-安全点-safepoint",normalizedTitle:"1. 安全点（safepoint）",charIndex:7632},{level:4,title:"如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来能？",slug:"如何在gc发生时-检查所有线程都跑到最近的安全点停顿下来能",normalizedTitle:"如何在gc发生时，检查所有线程都跑到最近的安全点停顿下来能？",charIndex:7862},{level:3,title:"2. 安全区域",slug:"_2-安全区域",normalizedTitle:"2. 安全区域",charIndex:8041},{level:4,title:"实际执行时：",slug:"实际执行时",normalizedTitle:"实际执行时：",charIndex:8305},{level:2,title:"6. 再谈引用",slug:"_6-再谈引用",normalizedTitle:"6. 再谈引用",charIndex:8489},{level:3,title:"0. 再谈引用",slug:"_0-再谈引用",normalizedTitle:"0. 再谈引用",charIndex:8501},{level:4,title:"【即偏门有非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？",slug:"【即偏门有非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别-具体使用场景是什么",normalizedTitle:"【即偏门有非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？",charIndex:8578},{level:3,title:"1. 强引用 Strong Reference--不回收",slug:"_1-强引用-strong-reference-不回收",normalizedTitle:"1. 强引用 strong reference--不回收",charIndex:9357},{level:3,title:"2. 软引用 Soft Reference",slug:"_2-软引用-soft-reference",normalizedTitle:"2. 软引用 soft reference",charIndex:9063},{level:3,title:"3. 弱引用 Weak Reference",slug:"_3-弱引用-weak-reference",normalizedTitle:"3. 弱引用 weak reference",charIndex:9154},{level:3,title:"4. 虚引用 Phantom Reference",slug:"_4-虚引用-phantom-reference",normalizedTitle:"4. 虚引用 phantom reference",charIndex:9240},{level:3,title:"5. 终结器引用 Final Reference",slug:"_5-终结器引用-final-reference",normalizedTitle:"5. 终结器引用 final reference",charIndex:9797}],headersStr:"1. System.gc()的理解 示例1 示例2 示例3：手动gc理解不可达对象的回收行为 1. 示例一 2. 示例二 3. 示例三 4. 示例四 5. 示例五 2. 内存溢出与内存泄露 1. 内存溢出（OOM） 2. 内存泄漏（Memoy Leak） 内存泄漏举例 1. 单例模式 2. 一些提供close的资源未关闭导致内存泄露 3. Stop The World 示例 4. 垃圾回收的并行与并发 1. 并发（Concurrent） 2. 并行（Parallel） 3. 并发 VS 并行 二者对比 4. 垃圾回收的并行与并发 5. 安全点与安全区域 1. 安全点（Safepoint） 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来能？ 2. 安全区域 实际执行时： 6. 再谈引用 0. 再谈引用 【即偏门有非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？ 1. 强引用 Strong Reference--不回收 2. 软引用 Soft Reference 3. 弱引用 Weak Reference 4. 虚引用 Phantom Reference 5. 终结器引用 Final Reference",content:'# JVM-垃圾回收相关概念\n\n\n# 1. System.gc()的理解\n\n在默认情况下，通过System.()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。\n\n然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。\n\nJVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无序手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行质检调用System.gc()。\n\n\n# 示例1\n\npublic class SystemGCTest {\n    public static void main(String[] args) {\n        new SystemGCTest();\n        System.gc();//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc\n        //与Runtime.getRuntime().gc();的作用一样。\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println("SystemGCTest 重写了finalize()");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n结果：多次执行没有调用 finalize() ，偶尔会执行 finalize() .\n\n> 提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc\n\n\n# 示例2\n\npublic class SystemGCTest {\n    public static void main(String[] args) {\n        new SystemGCTest();\n        System.gc();//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc\n        //与Runtime.getRuntime().gc();的作用一样。\n\n        System.runFinalization();//强制调用使用引用的对象的finalize()方法\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println("SystemGCTest 重写了finalize()");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> System.runFinalization(): 强制调用使用引用的对象的finalize()方法\n\n\n# 示例3：手动gc理解不可达对象的回收行为\n\n-XX:+PrintGCDetails\n\n# 1. 示例一\n\npublic class LocalVarGC {\n    public void localvarGC1() {\n        byte[] buffer = new byte[10 * 1024 * 1024];//10MB\n        System.gc();\n    }\n\n    public static void main(String[] args) {\n        LocalVarGC local = new LocalVarGC();\n        local.localvarGC1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n结果：未进行垃圾回收\n\n# 2. 示例二\n\npublic class LocalVarGC {\n    public void localvarGC2() {\n        byte[] buffer = new byte[10 * 1024 * 1024];\n        buffer = null;\n        System.gc();\n    }\n\n    public static void main(String[] args) {\n        LocalVarGC local = new LocalVarGC();\n        local.localvarGC2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n结果：进行垃圾回收\n\n# 3. 示例三\n\npublic class LocalVarGC {\n    public void localvarGC3() {\n        {\n            byte[] buffer = new byte[10 * 1024 * 1024];\n        }\n        System.gc();\n    }\n\n    public static void main(String[] args) {\n        LocalVarGC local = new LocalVarGC();\n        local.localvarGC3();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n结果：未进行垃圾回收\n\n# 4. 示例四\n\npublic class LocalVarGC {\n    public void localvarGC4() {\n        {\n            byte[] buffer = new byte[10 * 1024 * 1024];\n        }\n        int value = 10;\n        System.gc();\n    }\n  \n    public static void main(String[] args) {\n        LocalVarGC local = new LocalVarGC();\n        local.localvarGC4();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\n结果：进行垃圾回收\n\n# 5. 示例五\n\npublic class LocalVarGC {\n  public void localvarGC5() {\n        localvarGC1();\n        System.gc();\n    }\n\n    public static void main(String[] args) {\n        LocalVarGC local = new LocalVarGC();\n        local.localvarGC5();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n结论：进行垃圾回收\n\n\n# 2. 内存溢出与内存泄露\n\n\n# 1. 内存溢出（OOM）\n\n 1. 内存溢出相对于内存泄露来说，尽管更容易被理解，单是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。\n\n 2. 由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。\n\n 3. 大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。\n\n 4. javadoc中对OutOfMenoryError的解释是：没有空闲内存，并且垃圾收集器也无法提供更多内存。\n\n 5. 首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。\n    \n    * Java虚拟机的堆内存设置不够\n    \n    比如：可能存在内存泄露问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms、-Xmx来调整。\n    \n    * 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）\n    \n    对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如：常量池回收、卸载不在需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMenoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；李四intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标寄出来和永久代相关：“Java.lang.OurOfMemoryError: PermGen space".\n    \n    随着元数据区的引入，方法区内存已经不再那么窘迫，所以响应的OOM有所改观，出现OOM，异常信息则变成了：ava.lang.OurOfMemoryError: PermGen space".直接内存不足，也会导致OOM。\n\n 6. 这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，近期所能去清理空间\n    \n    * 例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。\n    * 在java.nio.BIts.reserveMemory()方法中，我们能够清楚的看到，System.gc()会被调用，已清理空间。\n\n 7. 当然，也不是在任何情况下垃圾收集器都会被触发的\n    \n    比如，我们去分配一个超大对象，类似一个超大数组超过谁的最大值，JVM可以判定出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。\n\n\n# 2. 内存泄漏（Memoy Leak）\n\n> Java使用可达性分析算法\n\n 1. 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收它们的情况，才叫内存泄露。\n\n 2. 但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变的很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄露”。\n\n 3. 尽管内存泄露并不会立刻引起程序崩溃，但是一旦发生泄漏，程序中的可用内存就会逐步蚕食，直至耗尽所有内存，最庸出现OutOfMemory异常，导致程序崩溃。\n\n 4. 注意：这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。\n\n\n\n# 内存泄漏举例\n\n# 1. 单例模式\n\n单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄露的产生。Runtime\n\n# 2. 一些提供close的资源未关闭导致内存泄露\n\n数据库连接（dateSource.getConnection()）,玩过连接（socket）和io连接必须手动close，否则是不能被回收的。\n\n\n# 3. Stop The World\n\nStop-the-world简称“STW”，值的是GC事件发生过程中，会产生应用程序的停顿。停顿产生是整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。\n\n可达性分析算法中枚举根结点（GC Roots）会导致所有Java执行线程停顿。\n\n * 分析工作必须在一个能确保一致性的快照中进行\n * 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上\n * 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。\n\n被STW中断的应用程序会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。\n\nSTW事件和采用那款GC无关，所有的GC都有这个事件。\n\n哪怕是G1也不能完全避免STW情况发生，只能说垃圾收集器越来越优秀没回收效率越来越高，尽可能的缩短了暂停时间。\n\nSTW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。\n\n开发中不要用System.gc()；会导致STM的发生。\n\n\n# 示例\n\npublic class StopTheWorldDemo {\n    public static class WorkThread extends Thread {\n        List<byte[]> list = new ArrayList<byte[]>();\n\n        public void run() {\n            try {\n                while (true) {\n                    for(int i = 0;i < 1000;i++){\n                        byte[] buffer = new byte[1024];\n                        list.add(buffer);\n                    }\n\n                    if(list.size() > 10000){\n                        list.clear();\n                        System.gc();//会触发full gc，进而会出现STW事件\n                    }\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    public static class PrintThread extends Thread {\n        public final long startTime = System.currentTimeMillis();\n\n        public void run() {\n            try {\n                while (true) {\n                    // 每秒打印时间信息\n                    long t = System.currentTimeMillis() - startTime;\n                    System.out.println(t / 1000 + "." + t % 1000);\n                    Thread.sleep(1000);\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        WorkThread w = new WorkThread();\n        PrintThread p = new PrintThread();\n        w.start();\n        p.start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n不添加system.gc() 有规律1s一次\n\n\n\n添加system.gc()\n\n\n\n\n# 4. 垃圾回收的并行与并发\n\n\n# 1. 并发（Concurrent）\n\n在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。\n\n并发不是真正意义上的“同时进行”只是CPU把同一个时间段划分成几个实际那片段（时间区间），然后在这几个时间区间来回切换，忧郁CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在运行。\n\n\n\n\n# 2. 并行（Parallel）\n\n当两个系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个程序，两个进程互不抢占资源，可以同时进行，我们称之为并行。\n\n其实决定并行的因素不是CPU数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。\n\n适合科学计算，后台处理等弱交互场景。\n\n\n\n\n# 3. 并发 VS 并行\n\n# 二者对比\n\n并发：指的是多个事情，在同一个时间段内同时发生了。\n\n并行：指的是多个事情，在同一个时间点上同时发生了。\n\n并发的多个任务之间是互相抢占资源的。\n\n并行的多个任务之间是不互相抢占资源的。\n\n只要在多CPU或者一个CPU多核的情况下，才会发生并行。\n\n否则，看似同时发生的事情，其实都是并发执行的。\n\n\n# 4. 垃圾回收的并行与并发\n\n并行和并发，在谈论垃圾收集器的上下文语境中，它们可以解释如下：\n\n * 并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。\n   \n   如：ParNew、Parallel、Scavenge、Parallel Old；\n\n * 串行（Serial）\n   \n   * 相较于并行的概念，单线程执行。\n   * 如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收，回收万，再启动程序的线程。\n\n\n\n * 并发：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。\n   * 用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；\n   * 如: CMS、G1\n\n\n\n\n# 5. 安全点与安全区域\n\n\n# 1. 安全点（Safepoint）\n\n程序执行时并非所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）"。\n\nSafe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据”是否具有让程序长时间执行的特性“为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用，循环跳转和异常跳转等。\n\n# 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来能？\n\n * 抢占式中断：（目前没有虚拟机采用了）\n   \n   收线中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。\n\n * 主动式中断：\n   \n   设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。\n\n\n# 2. 安全区域\n\nSafepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序”不执行“的时候能？例如线程处于Sleep状态或者Blocked状态，这个时候线程无法响应JVM的中断请求，”走“到安全点去中段挂起，JVM也不太可能等待贤臣被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。 安全区域是指在一段代码片段中，对象的引用关系不会变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。\n\n# 实际执行时：\n\n 1. 当线程云心到Safe Region的代码时，首先表示已经进入Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程；\n 2. 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直接收到可以安全离开Safe Region的信号为止。\n\n\n# 6. 再谈引用\n\n\n# 0. 再谈引用\n\n我们希望能够描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。\n\n# 【即偏门有非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？\n\n在JDK1.2版之后，Java对应用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这四种引用强度依次逐渐减弱。\n\n除强引用外，其他2种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示着3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。\n\n\n\n> Reference子类中只有终结器引用（Final Reference）是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用\n\n 1. 强引用 Strong Reference\n\n> 强引用开发中占99%以上。\n\n最传统的"引用"的定义：在程序代码之中普遍存在的引用赋值，即类“Object obj = new objct()"这种引用关系。无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉引用的对象。\n\n 2. 软引用 Soft Reference\n\n在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中及逆行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。\n\n 3. 弱引用 Weak Reference\n\n被弱引用关联的对象只能生存到下一个垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。\n\n 4. 虚引用 Phantom Reference\n\n一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置引用关联的唯一目的就是内在这个对象被收集器回收时收到一个通知。\n\n\n# 1. 强引用 Strong Reference--不回收\n\n在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普遍对象引用，也是默认的引用类型。\n\n当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。\n\n强引用的对象是可触及的，垃圾收集器就永远不会回收掉引用的对象。\n\n对于一个普通的对象，如果没有其他的引用关系，只要超过了作用的作用域或者显示地将相应（强）引用赋值为null，就是可以当做垃圾被手机了，当然具体回收时机还是要看垃圾收集策略。\n\n相对的，软引用如引用和虚引用的对象是软可触及、若可触及、和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄露的主要原因之一。\n\n\n# 2. 软引用 Soft Reference\n\n\n# 3. 弱引用 Weak Reference\n\n\n# 4. 虚引用 Phantom Reference\n\n\n# 5. 终结器引用 Final Reference',normalizedContent:'# jvm-垃圾回收相关概念\n\n\n# 1. system.gc()的理解\n\n在默认情况下，通过system.()或者runtime.getruntime().gc()的调用，会显式触发full gc，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。\n\n然而system.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。\n\njvm实现者可以通过system.gc()调用来决定jvm的gc行为。而一般情况下，垃圾回收应该是自动进行的，无序手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行质检调用system.gc()。\n\n\n# 示例1\n\npublic class systemgctest {\n    public static void main(string[] args) {\n        new systemgctest();\n        system.gc();//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc\n        //与runtime.getruntime().gc();的作用一样。\n    }\n\n    @override\n    protected void finalize() throws throwable {\n        super.finalize();\n        system.out.println("systemgctest 重写了finalize()");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n结果：多次执行没有调用 finalize() ，偶尔会执行 finalize() .\n\n> 提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc\n\n\n# 示例2\n\npublic class systemgctest {\n    public static void main(string[] args) {\n        new systemgctest();\n        system.gc();//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc\n        //与runtime.getruntime().gc();的作用一样。\n\n        system.runfinalization();//强制调用使用引用的对象的finalize()方法\n    }\n\n    @override\n    protected void finalize() throws throwable {\n        super.finalize();\n        system.out.println("systemgctest 重写了finalize()");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> system.runfinalization(): 强制调用使用引用的对象的finalize()方法\n\n\n# 示例3：手动gc理解不可达对象的回收行为\n\n-xx:+printgcdetails\n\n# 1. 示例一\n\npublic class localvargc {\n    public void localvargc1() {\n        byte[] buffer = new byte[10 * 1024 * 1024];//10mb\n        system.gc();\n    }\n\n    public static void main(string[] args) {\n        localvargc local = new localvargc();\n        local.localvargc1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n结果：未进行垃圾回收\n\n# 2. 示例二\n\npublic class localvargc {\n    public void localvargc2() {\n        byte[] buffer = new byte[10 * 1024 * 1024];\n        buffer = null;\n        system.gc();\n    }\n\n    public static void main(string[] args) {\n        localvargc local = new localvargc();\n        local.localvargc2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n结果：进行垃圾回收\n\n# 3. 示例三\n\npublic class localvargc {\n    public void localvargc3() {\n        {\n            byte[] buffer = new byte[10 * 1024 * 1024];\n        }\n        system.gc();\n    }\n\n    public static void main(string[] args) {\n        localvargc local = new localvargc();\n        local.localvargc3();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n结果：未进行垃圾回收\n\n# 4. 示例四\n\npublic class localvargc {\n    public void localvargc4() {\n        {\n            byte[] buffer = new byte[10 * 1024 * 1024];\n        }\n        int value = 10;\n        system.gc();\n    }\n  \n    public static void main(string[] args) {\n        localvargc local = new localvargc();\n        local.localvargc4();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\n结果：进行垃圾回收\n\n# 5. 示例五\n\npublic class localvargc {\n  public void localvargc5() {\n        localvargc1();\n        system.gc();\n    }\n\n    public static void main(string[] args) {\n        localvargc local = new localvargc();\n        local.localvargc5();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n结论：进行垃圾回收\n\n\n# 2. 内存溢出与内存泄露\n\n\n# 1. 内存溢出（oom）\n\n 1. 内存溢出相对于内存泄露来说，尽管更容易被理解，单是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。\n\n 2. 由于gc一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现oom的情况。\n\n 3. 大多数情况下，gc会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的full gc操作，这时候会回收大量的内存，供应用程序继续使用。\n\n 4. javadoc中对outofmenoryerror的解释是：没有空闲内存，并且垃圾收集器也无法提供更多内存。\n\n 5. 首先说没有空闲内存的情况：说明java虚拟机的堆内存不够。\n    \n    * java虚拟机的堆内存设置不够\n    \n    比如：可能存在内存泄露问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定jvm堆大小或者指定数值偏小。我们可以通过参数-xms、-xmx来调整。\n    \n    * 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）\n    \n    对于老版本的oracle jdk，因为永久代的大小是有限的，并且jvm对永久代垃圾回收（如：常量池回收、卸载不在需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现outofmenoryerror也非常多见，尤其是在运行时存在大量动态类型生成的场合；李四intern字符串缓存占用太多空间，也会导致oom问题。对应的异常信息，会标寄出来和永久代相关：“java.lang.ourofmemoryerror: permgen space".\n    \n    随着元数据区的引入，方法区内存已经不再那么窘迫，所以响应的oom有所改观，出现oom，异常信息则变成了：ava.lang.ourofmemoryerror: permgen space".直接内存不足，也会导致oom。\n\n 6. 这里面隐含着一层意思是，在抛出outofmemoryerror之前，通常垃圾收集器会被触发，近期所能去清理空间\n    \n    * 例如：在引用机制分析中，涉及到jvm会去尝试回收软引用指向的对象等。\n    * 在java.nio.bits.reservememory()方法中，我们能够清楚的看到，system.gc()会被调用，已清理空间。\n\n 7. 当然，也不是在任何情况下垃圾收集器都会被触发的\n    \n    比如，我们去分配一个超大对象，类似一个超大数组超过谁的最大值，jvm可以判定出垃圾收集并不能解决这个问题，所以直接抛出outofmemoryerror。\n\n\n# 2. 内存泄漏（memoy leak）\n\n> java使用可达性分析算法\n\n 1. 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是gc又不能回收它们的情况，才叫内存泄露。\n\n 2. 但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变的很长甚至导致oom，也可以叫做宽泛意义上的“内存泄露”。\n\n 3. 尽管内存泄露并不会立刻引起程序崩溃，但是一旦发生泄漏，程序中的可用内存就会逐步蚕食，直至耗尽所有内存，最庸出现outofmemory异常，导致程序崩溃。\n\n 4. 注意：这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。\n\n\n\n# 内存泄漏举例\n\n# 1. 单例模式\n\n单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄露的产生。runtime\n\n# 2. 一些提供close的资源未关闭导致内存泄露\n\n数据库连接（datesource.getconnection()）,玩过连接（socket）和io连接必须手动close，否则是不能被回收的。\n\n\n# 3. stop the world\n\nstop-the-world简称“stw”，值的是gc事件发生过程中，会产生应用程序的停顿。停顿产生是整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为stw。\n\n可达性分析算法中枚举根结点（gc roots）会导致所有java执行线程停顿。\n\n * 分析工作必须在一个能确保一致性的快照中进行\n * 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上\n * 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。\n\n被stw中断的应用程序会在完成gc之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少stw的发生。\n\nstw事件和采用那款gc无关，所有的gc都有这个事件。\n\n哪怕是g1也不能完全避免stw情况发生，只能说垃圾收集器越来越优秀没回收效率越来越高，尽可能的缩短了暂停时间。\n\nstw是jvm在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。\n\n开发中不要用system.gc()；会导致stm的发生。\n\n\n# 示例\n\npublic class stoptheworlddemo {\n    public static class workthread extends thread {\n        list<byte[]> list = new arraylist<byte[]>();\n\n        public void run() {\n            try {\n                while (true) {\n                    for(int i = 0;i < 1000;i++){\n                        byte[] buffer = new byte[1024];\n                        list.add(buffer);\n                    }\n\n                    if(list.size() > 10000){\n                        list.clear();\n                        system.gc();//会触发full gc，进而会出现stw事件\n                    }\n                }\n            } catch (exception ex) {\n                ex.printstacktrace();\n            }\n        }\n    }\n\n    public static class printthread extends thread {\n        public final long starttime = system.currenttimemillis();\n\n        public void run() {\n            try {\n                while (true) {\n                    // 每秒打印时间信息\n                    long t = system.currenttimemillis() - starttime;\n                    system.out.println(t / 1000 + "." + t % 1000);\n                    thread.sleep(1000);\n                }\n            } catch (exception ex) {\n                ex.printstacktrace();\n            }\n        }\n    }\n\n    public static void main(string[] args) {\n        workthread w = new workthread();\n        printthread p = new printthread();\n        w.start();\n        p.start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n不添加system.gc() 有规律1s一次\n\n\n\n添加system.gc()\n\n\n\n\n# 4. 垃圾回收的并行与并发\n\n\n# 1. 并发（concurrent）\n\n在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。\n\n并发不是真正意义上的“同时进行”只是cpu把同一个时间段划分成几个实际那片段（时间区间），然后在这几个时间区间来回切换，忧郁cpu处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在运行。\n\n\n\n\n# 2. 并行（parallel）\n\n当两个系统有一个以上cpu时，当一个cpu执行一个进程时，另一个cpu可以执行另一个程序，两个进程互不抢占资源，可以同时进行，我们称之为并行。\n\n其实决定并行的因素不是cpu数量，而是cpu的核心数量，比如一个cpu多个核也可以并行。\n\n适合科学计算，后台处理等弱交互场景。\n\n\n\n\n# 3. 并发 vs 并行\n\n# 二者对比\n\n并发：指的是多个事情，在同一个时间段内同时发生了。\n\n并行：指的是多个事情，在同一个时间点上同时发生了。\n\n并发的多个任务之间是互相抢占资源的。\n\n并行的多个任务之间是不互相抢占资源的。\n\n只要在多cpu或者一个cpu多核的情况下，才会发生并行。\n\n否则，看似同时发生的事情，其实都是并发执行的。\n\n\n# 4. 垃圾回收的并行与并发\n\n并行和并发，在谈论垃圾收集器的上下文语境中，它们可以解释如下：\n\n * 并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。\n   \n   如：parnew、parallel、scavenge、parallel old；\n\n * 串行（serial）\n   \n   * 相较于并行的概念，单线程执行。\n   * 如果内存不够，则程序暂停，启动jvm垃圾回收器进行垃圾回收，回收万，再启动程序的线程。\n\n\n\n * 并发：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。\n   * 用户程序在继续运行，而垃圾收集程序线程运行于另一个cpu上；\n   * 如: cms、g1\n\n\n\n\n# 5. 安全点与安全区域\n\n\n# 1. 安全点（safepoint）\n\n程序执行时并非所有地方都能停顿下来开始gc，只有在特定的位置才能停顿下来开始gc，这些位置称为“安全点（safepoint）"。\n\nsafe point的选择很重要，如果太少可能导致gc等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据”是否具有让程序长时间执行的特性“为标准。比如：选择一些执行时间较长的指令作为safe point，如方法调用，循环跳转和异常跳转等。\n\n# 如何在gc发生时，检查所有线程都跑到最近的安全点停顿下来能？\n\n * 抢占式中断：（目前没有虚拟机采用了）\n   \n   收线中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。\n\n * 主动式中断：\n   \n   设置一个中断标志，各个线程运行到safe point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。\n\n\n# 2. 安全区域\n\nsafepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入gc的safepoint。但是，程序”不执行“的时候能？例如线程处于sleep状态或者blocked状态，这个时候线程无法响应jvm的中断请求，”走“到安全点去中段挂起，jvm也不太可能等待贤臣被唤醒。对于这种情况，就需要安全区域（safe region）来解决。 安全区域是指在一段代码片段中，对象的引用关系不会变化，在这个区域中的任何位置开始gc都是安全的。我们也可以把safe region看做是被扩展了的safepoint。\n\n# 实际执行时：\n\n 1. 当线程云心到safe region的代码时，首先表示已经进入safe region，如果这段时间内发生gc，jvm会忽略标识为safe region状态的线程；\n 2. 当线程即将离开safe region时，会检查jvm是否已经完成gc，如果完成了，则继续运行，否则线程必须等待直接收到可以安全离开safe region的信号为止。\n\n\n# 6. 再谈引用\n\n\n# 0. 再谈引用\n\n我们希望能够描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。\n\n# 【即偏门有非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？\n\n在jdk1.2版之后，java对应用的概念进行了扩充，将引用分为强引用（strong reference）、软引用（soft reference）、弱引用（weak reference）和虚引用（phantom reference）4种，这四种引用强度依次逐渐减弱。\n\n除强引用外，其他2种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示着3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。\n\n\n\n> reference子类中只有终结器引用（final reference）是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用\n\n 1. 强引用 strong reference\n\n> 强引用开发中占99%以上。\n\n最传统的"引用"的定义：在程序代码之中普遍存在的引用赋值，即类“object obj = new objct()"这种引用关系。无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉引用的对象。\n\n 2. 软引用 soft reference\n\n在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中及逆行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。\n\n 3. 弱引用 weak reference\n\n被弱引用关联的对象只能生存到下一个垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。\n\n 4. 虚引用 phantom reference\n\n一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置引用关联的唯一目的就是内在这个对象被收集器回收时收到一个通知。\n\n\n# 1. 强引用 strong reference--不回收\n\n在java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普遍对象引用，也是默认的引用类型。\n\n当在java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。\n\n强引用的对象是可触及的，垃圾收集器就永远不会回收掉引用的对象。\n\n对于一个普通的对象，如果没有其他的引用关系，只要超过了作用的作用域或者显示地将相应（强）引用赋值为null，就是可以当做垃圾被手机了，当然具体回收时机还是要看垃圾收集策略。\n\n相对的，软引用如引用和虚引用的对象是软可触及、若可触及、和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成java内存泄露的主要原因之一。\n\n\n# 2. 软引用 soft reference\n\n\n# 3. 弱引用 weak reference\n\n\n# 4. 虚引用 phantom reference\n\n\n# 5. 终结器引用 final reference',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-运行时数据区概述及线程",frontmatter:{title:"JVM-运行时数据区概述及线程",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/c15e11/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/3.JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B.html",relativePath:"01.语言/01.JAVA语言/02.JVM/3.JVM-运行时数据区概述及线程.md",key:"v-659791a7",path:"/pages/c15e11/",headersStr:null,content:"# JVM-运行时数据区概述及线程\n\n本片主要介绍运行时数据区\n\n\n\n当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区\n\n\n\n也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品\n\n\n\n内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。\n\n> 我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁\n\n\n\nJava虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。\n\n灰色的为单独线程私有的，红色的为多个线程共享的。即：\n\n * 每个线程：独立包括程序计数器、栈、本地栈。\n * 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）",normalizedContent:"# jvm-运行时数据区概述及线程\n\n本片主要介绍运行时数据区\n\n\n\n当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区\n\n\n\n也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品\n\n\n\n内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行jvm内存布局规定了java在运行过程中内存申请、分配、管理的策略，保证了jvm的高效稳定运行。不同的jvm对于内存的划分方式和管理机制存在着部分差异。结合jvm虚拟机规范，来探讨一下经典的jvm内存布局。\n\n> 我们通过磁盘或者网络io得到的数据，都需要先加载到内存中，然后cpu从内存中获取数据进行读取，也就是说内存充当了cpu和磁盘之间的桥梁\n\n\n\njava虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。\n\n灰色的为单独线程私有的，红色的为多个线程共享的。即：\n\n * 每个线程：独立包括程序计数器、栈、本地栈。\n * 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）",charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-类加载子系统",frontmatter:{title:"JVM-类加载子系统",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/bac2fa/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/2.JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F.html",relativePath:"01.语言/01.JAVA语言/02.JVM/2.JVM-类加载子系统.md",key:"v-74277329",path:"/pages/bac2fa/",headers:[{level:2,title:"1. 回顾JVM流程图",slug:"_1-回顾jvm流程图",normalizedTitle:"1. 回顾jvm流程图",charIndex:17},{level:2,title:"2. 类加载器子系统的概述",slug:"_2-类加载器子系统的概述",normalizedTitle:"2. 类加载器子系统的概述",charIndex:134},{level:3,title:"1. 类加载器的作用",slug:"_1-类加载器的作用",normalizedTitle:"1. 类加载器的作用",charIndex:152},{level:3,title:"2. 类加载器ClassLoader角色",slug:"_2-类加载器classloader角色",normalizedTitle:"2. 类加载器classloader角色",charIndex:391},{level:2,title:"3. 类的加载过程",slug:"_3-类的加载过程",normalizedTitle:"3. 类的加载过程",charIndex:615},{level:3,title:"1.  加载",slug:"_1-加载",normalizedTitle:"1.  加载",charIndex:null},{level:3,title:"2.  验证",slug:"_2-验证",normalizedTitle:"2.  验证",charIndex:null},{level:3,title:"3. 准备",slug:"_3-准备",normalizedTitle:"3. 准备",charIndex:1988},{level:3,title:"4.  解析",slug:"_4-解析",normalizedTitle:"4.  解析",charIndex:null},{level:3,title:"5. 初始化",slug:"_5-初始化",normalizedTitle:"5. 初始化",charIndex:2896},{level:4,title:"1. 测试初始化执行类构造方法<clinit>()的过程",slug:"_1-测试初始化执行类构造方法-clinit-的过程",normalizedTitle:"1. 测试初始化执行类构造方法<clinit>()的过程",charIndex:3171},{level:4,title:"2. 重新赋值后",slug:"_2-重新赋值后",normalizedTitle:"2. 重新赋值后",charIndex:3810},{level:4,title:"3.  <clinit>()不同于类的构造器",slug:"_3-clinit-不同于类的构造器",normalizedTitle:"3.  <clinit>()不同于类的构造器",charIndex:null},{level:4,title:"4. 该类具有父类",slug:"_4-该类具有父类",normalizedTitle:"4. 该类具有父类",charIndex:6841},{level:4,title:"5. 虚拟机必须保证一个类的<clinit>()方法在多线程下会被同步加锁",slug:"_5-虚拟机必须保证一个类的-clinit-方法在多线程下会被同步加锁",normalizedTitle:"5. 虚拟机必须保证一个类的<clinit>()方法在多线程下会被同步加锁",charIndex:7841},{level:2,title:"4. 类加载器的分类",slug:"_4-类加载器的分类",normalizedTitle:"4. 类加载器的分类",charIndex:8682},{level:2,title:"5. 虚拟机自带的加载器",slug:"_5-虚拟机自带的加载器",normalizedTitle:"5. 虚拟机自带的加载器",charIndex:10345},{level:3,title:"1. 启动类加载器(引导类加载器 Bootstrap ClassLoader)",slug:"_1-启动类加载器-引导类加载器-bootstrap-classloader",normalizedTitle:"1. 启动类加载器(引导类加载器 bootstrap classloader)",charIndex:10362},{level:3,title:"2. 扩展类加载器 (Extension ClassLoader)",slug:"_2-扩展类加载器-extension-classloader",normalizedTitle:"2. 扩展类加载器 (extension classloader)",charIndex:11788},{level:3,title:"3. 应用程序类加载器（系统类加载器，AppClassLoader）",slug:"_3-应用程序类加载器-系统类加载器-appclassloader",normalizedTitle:"3. 应用程序类加载器（系统类加载器，appclassloader）",charIndex:12693},{level:3,title:"4. 用户自定义类加载器",slug:"_4-用户自定义类加载器",normalizedTitle:"4. 用户自定义类加载器",charIndex:12960},{level:2,title:"6. 关于CLassLoader",slug:"_6-关于classloader",normalizedTitle:"6. 关于classloader",charIndex:13419},{level:2,title:"7. 双亲委派机制",slug:"_7-双亲委派机制",normalizedTitle:"7. 双亲委派机制",charIndex:16116},{level:3,title:"工作原理",slug:"工作原理",normalizedTitle:"工作原理",charIndex:16255},{level:3,title:"双亲委派机制",slug:"双亲委派机制",normalizedTitle:"双亲委派机制",charIndex:16119},{level:3,title:"沙箱安全机制",slug:"沙箱安全机制",normalizedTitle:"沙箱安全机制",charIndex:16600},{level:3,title:"优势",slug:"优势",normalizedTitle:"优势",charIndex:16784},{level:2,title:"8.  其它",slug:"_8-其它",normalizedTitle:"8.  其它",charIndex:null},{level:3,title:"如何判断两个class对象是否相同",slug:"如何判断两个class对象是否相同",normalizedTitle:"如何判断两个class对象是否相同",charIndex:16872},{level:3,title:"类的主动使用和被动使用",slug:"类的主动使用和被动使用",normalizedTitle:"类的主动使用和被动使用",charIndex:17220}],headersStr:"1. 回顾JVM流程图 2. 类加载器子系统的概述 1. 类加载器的作用 2. 类加载器ClassLoader角色 3. 类的加载过程 1.  加载 2.  验证 3. 准备 4.  解析 5. 初始化 1. 测试初始化执行类构造方法<clinit>()的过程 2. 重新赋值后 3.  <clinit>()不同于类的构造器 4. 该类具有父类 5. 虚拟机必须保证一个类的<clinit>()方法在多线程下会被同步加锁 4. 类加载器的分类 5. 虚拟机自带的加载器 1. 启动类加载器(引导类加载器 Bootstrap ClassLoader) 2. 扩展类加载器 (Extension ClassLoader) 3. 应用程序类加载器（系统类加载器，AppClassLoader） 4. 用户自定义类加载器 6. 关于CLassLoader 7. 双亲委派机制 工作原理 双亲委派机制 沙箱安全机制 优势 8.  其它 如何判断两个class对象是否相同 类的主动使用和被动使用",content:'# JVM-类加载子系统\n\n\n# 1. 回顾JVM流程图\n\n 1. JVM简图\n\n\n\n 2. JVM完整图如下\n\n\n\n 3. 思考\n    \n    如何自己手写一个Java虚拟机,主要考虑哪些结构?\n    \n    * 类加载子系统\n    * 执行引擎\n\n\n# 2. 类加载器子系统的概述\n\n\n# 1. 类加载器的作用\n\n\n\n * 类加载器子系统负责从文件系统或者网络中加载Class文件,Class文件在文件开头有特定的文件不标识.\n * ClassLoader(类加载器)只负责class文件的加载,至于它是否可以运行,则由Execution Engine(执行引擎)决定\n * 加载的类信息存放于一块称为方法区的内存空间.除了类的信息外,方法区中还会存放运行时常量池信息,可能还包括字符串字面量和数字常量(这部分常量信息是Class文件中常量池部分的内存映射)\n\n\n# 2. 类加载器ClassLoader角色\n\n\n\n 1. class file存在于本地磁盘上,可以理解为设计师在纸上的模板,而最终这个模板再执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例\n 2. class file加载当JVM中,被称为DNA元数据模板,放在方法区.\n 3. 在.class文件->JVM->最终成为元数据模板,此过程就是要一个运输工具(类加载器Class Loader),扮演一个快递员的角色.\n\n\n# 3. 类的加载过程\n\n类加载的完整流程\n\n\n\n下面代码是如何加载呢?\n\n/**\n * @Author: CHGGX\n * @Date: 2020/08/30 7:44\n * @Description: <h1> 类加载器加载过程 </h1>\n */\npublic class HelloLoader {\n\n    public static void main(String[] args) {\n        System.out.println("欢迎来到类加载器的世界...");\n        System.out.println("现在开始旅程吧...");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 1. 运行代码后,生成字节码文件,在 target 目下的 classes文件夹下.\n\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class HelloLoader {\n    public HelloLoader() {\n    }\n\n    public static void main(String[] args) {\n        System.out.println("欢迎来到类加载器的世界...");\n        System.out.println("现在开始旅程吧...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> maven项目\n\n 2. 如何加载如类加载器\n\n\n\n\n# 1. 加载\n\n 1. 通过一个类的全限定类名获取定义此类的二进制字符流\n 2. 将这个字节流流代表的静态存储结构转化为方法区的运行时数据结构\n 3. 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口\n\n> 补充: 加载 .class文件的方式\n\n- 从本地系统中直接加载.\n- 通过网络获取,典型场景: Web Applet\n- 从zip压缩包中读取,成为日后jar,war格式的基础.\n- 运行时计算生成,使用最多的是: 动态代理技术\n- 有其他文件生成,典型场景: JSP应用\n- 从专有数据库中提取.class文件,使用较少\n- 从加密文件中获取,典型的防Class文件被反编译的保护措施.\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2. 验证\n\n * 验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求,保证被加载类的正确性,不会危害虚拟机自身安全.\n * 主要包括是4中验证: 文件格式验证、元数据验证、字节码验证、符号引用验证.\n\n> 工具：Binary Viewer查看 CA FE BA BE\n\n\n\n> 使用IDEA. 安装 jclasslib 插件\n\n\n\n安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了\n\n\n\n\n# 3. 准备\n\n * 为类变量分配内存并且设置该类变量的默认初始值，即零值.\n   \n   /**\n    * @Author: CHGGX\n    * @Date: 2020/08/30 9:14\n    * @Description: <h1> 类加载的准备阶段 </h1>\n    */\n   public class HelloApp {\n   \n       /**\n        * 准备阶段为 0,在下个阶段，也就是初始化的时候才是1\n        */\n       private static int a = 1;\n   \n       public static void main(String[] args) {\n           System.out.println(a);\n       }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n   \n   > 上面的变量a在准备阶段会赋初始值，但不是1，而是0。\n\n * 这里不包含用final修饰的static,因为final在编译的时候就会分配了,准备阶段会显式初始化.\n\n * 这里不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量是会随着对象器分配到Java堆中.\n\n\n# 4. 解析\n\n * 将常量池内的符号引用转换为直接引用的过程\n\n * 事实上,解析操作往往会伴随着JVM在执行完成初始化之后在执行.\n\n * 符号引用就是一组符号来描述所引用的目标.符号引用的字面量形式明确定义在《Java虚拟机规范》的class文件格式中.直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄.\n\n * 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。\n\n\n# 5. 初始化\n\n * 初始化阶段就是执行类构造方法<clinit>()的过程.\n\n * 此方法不需要定义,是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来.\n\n * 构造器方法中指令按语句在源文件中出现的顺序执行.\n\n * <clinit>()不同于类的构造器. (关联; 构造器是虚拟机视角下的<clinit>().\n\n * 若该类具有父类,JVM会保证子类的<clinit>()执行前,父类的<clinit>()已经执行完毕.\n\n * 虚拟机必须保证一个类的<clinit>()方法在多线程下会被同步加锁.\n\n# 1. 测试初始化执行类构造方法<clinit>()的过程\n\n/**\n * @Author: CHGGX\n * @Date: 2020/08/30 9:18\n * @Description: <h1> 类加在过程的初始化阶段 </h1>\n */\npublic class ClassInitTest {\n\n    private static int num = 1;\n\n    public static void main(String[] args) {\n        System.out.println(ClassInitTest.num);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n字节码文件\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class ClassInitTest {\n    private static int num = 1;\n\n    public ClassInitTest() {\n    }\n\n    public static void main(String[] args) {\n        System.out.println(num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n使用 jclasslib 插件\n\n\n\n> 任何一个类在声明后，都有生成一个构造器，默认是空参构造器\n\n# 2. 重新赋值后\n\n 1. 重新赋值\n\npublic class ClassInitTest {\n\n    private static int num = 1;\n\n    static{\n        num = 2;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(ClassInitTest.num);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n字节码文件\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class ClassInitTest {\n    private static int num = 1;\n\n    public ClassInitTest() {\n    }\n\n    public static void main(String[] args) {\n        System.out.println(num);\n    }\n\n    static {\n        num = 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n使用jclasslib插件\n\n\n\n> 先赋值为1,最后赋值为2.\n\n 2. 相反情况下的赋值(按顺序执行)\n\npublic class ClassInitTest {\n\n    private static int num = 1;\n\n    static{\n        num = 2;\n        number = 20;\n    }\n\n    /**\n     * linking环节的准备(prepare)阶段:\n     *      number = 0 --\x3e initial: 20 ---\x3e 10\n     */\n    private static int number =  10;\n\n    public static void main(String[] args) {\n        // 2\n        System.out.println(ClassInitTest.num);\n        // 10\n        System.out.println(ClassInitTest.number);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n字节码文件\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class ClassInitTest {\n    private static int num = 1;\n    private static int number;\n\n    public ClassInitTest() {\n    }\n\n    public static void main(String[] args) {\n        System.out.println(num);\n        System.out.println(number);\n    }\n\n    static {\n        num = 2;\n        number = 20;\n        number = 10;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n使用jclasslib插件\n\n\n\n> 注意: 此时打印num正确,number会报错非法的前向引用\n\n# 3. <clinit>()不同于类的构造器\n\n 1. 没有静态变量和静态代码块\n\npublic class ClassInitTest2 {\n\n    /**\n     * 任何类声明以后,至少存在一个类的构造器\n     */\n    private int a = 1;\n    \n    public static void main(String[] args) {\n       int b = 2;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 上面类中 没有声明静态变量和静态代码块 不会存在类的构造器方法clinit<>\n\n 2. 存在静态变量和代码块\n\npublic class ClassInitTest2 {\n\n    /**\n     * 任何类声明以后,至少存在一个类的构造器\n     */\n    private int a = 1;\n    private static int c = 3;\n    public static void main(String[] args) {\n       int b = 2;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n字节码\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class ClassInitTest2 {\n    private int a = 1;\n    private static int c = 3;\n\n    public ClassInitTest2() {\n    }\n\n    public static void main(String[] args) {\n        int b = true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n 3. init初始化方法(构造器)\n\npublic class ClassInitTest2 {\n\n    /**\n     * 任何类声明以后,至少存在一个类的构造器\n     */\n    private int a = 1;\n    private static int c = 3;\n    public static void main(String[] args) {\n       int b = 2;\n    }\n\n    public ClassInitTest2() {\n        a = 10;\n        int b = 20;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n字节码\n\npublic class ClassInitTest2 {\n    private int a = 1;\n    private static int c = 3;\n\n    public static void main(String[] args) {\n        int b = true;\n    }\n\n    public ClassInitTest2() {\n        this.a = 10;\n        int b = true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n# 4. 该类具有父类\n\npublic class ClassInitTest3 {\n\n    static class Father{\n        public static int A = 1;\n        static {\n            A = 2;\n        }\n    }\n\n    static class Son extends Father{\n        public static int B = A;\n    }\n\n    public static void main(String[] args){\n        // 2\n        System.out.println(Son.B);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n字节码\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class ClassInitTest3 {\n    public ClassInitTest3() {\n    }\n\n    public static void main(String[] args) {\n        System.out.println(ClassInitTest3.Son.B);\n    }\n\n    static class Son extends ClassInitTest3.Father {\n        public static int B;\n\n        Son() {\n        }\n\n        static {\n            B = A;\n        }\n    }\n\n    static class Father {\n        public static int A = 1;\n\n        Father() {\n        }\n\n        static {\n            A = 2;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n# 5. 虚拟机必须保证一个类的<clinit>()方法在多线程下会被同步加锁\n\npublic class DeadThreadTest {\n\n    public static void main(String[] args){\n        Runnable runnable = () -> {\n            System.out.println(Thread.currentThread().getName()+"开始");\n            DeadThread dead = new DeadThread();\n            System.out.println(Thread.currentThread().getName()+"结束");\n        };\n\n        // 创建线程\n        Thread t1 = new Thread(runnable, "线程1");\n        Thread t2 = new Thread(runnable, "线程2");\n\n        // 启动线程\n        t1.start();\n        t2.start();\n    }\n\n}\n\nclass DeadThread{\n    static {\n        if (true){\n            System.out.println(Thread.currentThread().getName()+"初始化当前类");\n            while (true){\n\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n结果\n\n线程1开始\n线程2开始\n线程1初始化当前类\n\n\n1\n2\n3\n\n\n\n# 4. 类加载器的分类\n\n * JVM支持两种类型的类加载器: 引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。\n\n * 从概念上来讲,自定义类加载器一般指的是程序员中由开发人员自定义的一类类加载器,但是Java虚拟机规范却没有这么定义,而是将所有派生于抽类ClassLoader的类加载器都划分为自定义类加载器。\n\n * 无论类加载器的类型如何划分,在程序中我们最常见的类加载器始终只有3个,如下所示\n   \n   \n\n> 这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。\n> \n> 引导类加载器: 使用c/c++编写,使用java代码不能获取\n> \n> 其他类加载器: 使用java编写\n> \n> 自定义加载器/系统加载器: 都是AppClassLoader sun.misc.Launcher$AppClassLoader\n\n**\n * @Author: CHGGX\n * @Date: 2020/09/05 8:48\n * @Description: <h1> 类加载器分类 </h1>\n */\npublic class ClassLoaderTest {\n\n    public static void main(String[] args) {\n        // 获取系统类加载器\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(systemClassLoader);\n        // sun.misc.Launcher$AppClassLoader@18b4aac2\n\n        // 系统类加载器获取其上层: 扩展类加载器\n        ClassLoader extClassLoader = systemClassLoader.getParent();\n        System.out.println(extClassLoader);\n        // sun.misc.Launcher$ExtClassLoader@1b6d3586\n\n        // 获取其上层: 引导类加载器\n        ClassLoader bootstrapClassLoader = extClassLoader.getParent();\n        System.out.println(bootstrapClassLoader);\n        // null\n\n        // 对于用户自定义类来说 默认使用系统类加载器进行加载\n        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();\n        System.out.println(classLoader);\n        // sun.misc.Launcher$AppClassLoader@18b4aac2\n\n        // String类使用: 引导类加载器进行加载的.---\x3eJava的核心类库都是使用引导类加载器进行加载的\n        ClassLoader classLoader1 = Spring.class.getClassLoader();\n        System.out.println(classLoader1);\n        // null\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n> 从结果看出我们无法直接获取引导类加载器,\n\n\n# 5. 虚拟机自带的加载器\n\n\n# 1. 启动类加载器(引导类加载器 Bootstrap ClassLoader)\n\n * 这个类加载使用C/C++语言实现的，嵌套在JVM内部。\n * 它用来加载Java的核心库（JAVA_HOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类\n * 并不继承自ava.lang.ClassLoader，没有父加载器。\n * 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。\n * 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类\n\n示例代码\n\n/**\n * @Author: CHGGX\n * @Date: 2020/09/05 8:48\n * @Description: <h1> 类加载器分类:  </h1>\n */\npublic class ClassLoaderTest2 {\n\n    public static void main(String[] args) {\n        System.out.println("启动类加载器");\n        // 获取BootstrapClassLoader能够加载的api的路径\n        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();\n        for (URL url : urls) {\n            System.out.println(url.toExternalForm());\n        }\n        // 从上面的路径中随意选择一个类,查看类加载器是什么?\n        ClassLoader classLoader = Provider.class.getClassLoader();\n        System.out.println(classLoader);\n        // null : 表明加载器为 引导类加载器\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n结果为\n\n启动类加载器\nfile:/E:/develop/Java/jdk1.8.0_192/jre/lib/resources.jar\nfile:/E:/develop/Java/jdk1.8.0_192/jre/lib/rt.jar\nfile:/E:/develop/Java/jdk1.8.0_192/jre/lib/sunrsasign.jar\nfile:/E:/develop/Java/jdk1.8.0_192/jre/lib/jsse.jar\nfile:/E:/develop/Java/jdk1.8.0_192/jre/lib/jce.jar\nfile:/E:/develop/Java/jdk1.8.0_192/jre/lib/charsets.jar\nfile:/E:/develop/Java/jdk1.8.0_192/jre/lib/jfr.jar\nfile:/E:/develop/Java/jdk1.8.0_192/jre/classes\nnull\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2. 扩展类加载器 (Extension ClassLoader)\n\n * Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。\n * 派生于ClassLoader类\n * 父类加载器为启动类加载器\n * 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。\n\n示例代码\n\npublic class ClassLoaderTest2 {\n\n    public static void main(String[] args) {\n        System.out.println("扩展类加载器");\n        String extDirs = System.getProperty("java.ext.dirs");\n        for (String path : extDirs.split(";")) {\n            System.out.println(path);\n        }\n        // 从上面的路径中随意选择一个类,查看类加载器是什么?\n        ClassLoader classLoader1 = CurveDB.class.getClassLoader();\n        System.out.println(classLoader1);\n        // sun.misc.Launcher$ExtClassLoader@4b67cf4d : 表明加载器为 扩展类加载器\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n结果为\n\n扩展类加载器\nE:\\develop\\Java\\jdk1.8.0_192\\jre\\lib\\ext\nC:\\WINDOWS\\Sun\\Java\\lib\\ext\nsun.misc.Launcher$ExtClassLoader@4b67cf4d\n\n\n1\n2\n3\n4\n\n\n\n# 3. 应用程序类加载器（系统类加载器，AppClassLoader）\n\n * java语言编写，由sun.misc.LaunchersAppClassLoader实现\n * 派生于ClassLoader类\n * 父类加载器为扩展类加载器\n * 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库\n * 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载\n * 通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器\n\n\n# 4. 用户自定义类加载器\n\n在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？\n\n * 隔离加载类\n * 修改类加载的方式\n * 扩展加载源\n * 防止源码泄漏\n\n用户自定义类加载器实现步骤：\n\n * 开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求\n * 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中\n * 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。\n\n\n# 6. 关于CLassLoader\n\nClassLoader类,它是一个抽象类,其后所有的类加载器都继承自ClassLoader(不包含启动类加载器)\n\n方法名称                                                          描述\npublic final ClassLoader getParent()                          返回该类加载器的超类加载器\npublic Class<?> loadClass(String name)                        加载名称为name的类,返回结果为java.lang.Class类的实例\nprotected Class<?> findClass(String name)                     查找名称为name的类,返回结果为java.lang.Class类的实例\nprotected final Class<?> findLoadedClass(String name)         查找名称为name的已经被加载过的类,返回结果为java.lang.Class类的实例\nprotected final Class<?> defineClass(byte[] b, int off, int   把字节数组b中的内容转换为一个Java类,返回结果为java.lang.Class类的实例\nlen)\nprotected final void resolveClass(Class<?> c)                 连接指定的一个Java类\n\nsun.misc.Launcher 它是一个java虚拟机的入口应用\n\n\n\n获取ClassLoader的途径\n\n * 获取当前ClassLoader：clazz.getClassLoader()\n * 获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()\n * 获取系统的ClassLoader：ClassLoader.getSystemClassLoader()\n * 获取调用者的ClassLoader：DriverManager.getCallerClassLoader()\n\n/**\n * @Author: CHGGX\n * @Date: 2020/09/05 8:48\n * @Description: <h1> 获取ClassLoader的途径 </h1>\n */\npublic class ClassLoaderTest3 {\n\n    /**\n     * 获取ClassLoader的途径\n     * - 获取当前ClassLoader：clazz.getClassLoader()\n     * - 获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()\n     * - 获取系统的ClassLoader：ClassLoader.getSystemClassLoader()\n     * - 获取调用者的ClassLoader：DriverManager.getCallerClassLoader()\n     * @param args\n     */\n    public static void main(String[] args) {\n\n\n        // 1. 获取当前ClassLoader：clazz.getClassLoader()\n        try {\n            ClassLoader classLoader = Class.forName("java.lang.String").getClassLoader();\n            System.out.println(classLoader);\n            // null 加载器类为: 引导类加载器\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        // 2. 获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        System.out.println(contextClassLoader);\n        // sun.misc.Launcher$AppClassLoader@18b4aac2\n\n        // 3. 获取系统的ClassLoader：ClassLoader.getSystemClassLoader()\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(systemClassLoader);\n        // sun.misc.Launcher$AppClassLoader@18b4aac2 应用类加载器\n        ClassLoader parent = systemClassLoader.getParent();\n        System.out.println(parent);\n        // sun.misc.Launcher$ExtClassLoader@1b6d3586 扩展类加载器\n\n        // - 获取调用者的ClassLoader：DriverManager.getCallerClassLoader()\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 7. 双亲委派机制\n\nJava虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。\n\n\n# 工作原理\n\n * 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；\n * 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；\n * 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\n\n\n\n\n# 双亲委派机制\n\n当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。\n\n\n\n\n# 沙箱安全机制\n\n自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\n\n\n# 优势\n\n * 避免重复的加载\n\n * 保护程序安全,防止核心API被随意篡改\n   \n   包 java.lang.* 开发中禁止使用编写自定义类\n\n\n# 8. 其它\n\n\n# 如何判断两个class对象是否相同\n\n在JVM中表示两个class对象是否为同一个类存在两个必要条件：\n\n * 类的完整类名必须一致，包括包名。\n * 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。\n\n换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。\n\nJVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。\n\n\n# 类的主动使用和被动使用\n\nJava程序对类的使用方式分为：主动使用和被动使用。\n\n主动使用，又分为七种情况：\n\n * 创建类的实例\n * 访问某个类或接口的静态变量，或者对该静态变量赋值\n * 调用类的静态方法I\n * 反射（比如：Class.forName（"com.atguigu.Test"））\n * 初始化一个类的子类\n * Java虚拟机启动时被标明为启动类的类\n * JDK7开始提供的动态语言支持：\n * java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化\n\n除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。',normalizedContent:'# jvm-类加载子系统\n\n\n# 1. 回顾jvm流程图\n\n 1. jvm简图\n\n\n\n 2. jvm完整图如下\n\n\n\n 3. 思考\n    \n    如何自己手写一个java虚拟机,主要考虑哪些结构?\n    \n    * 类加载子系统\n    * 执行引擎\n\n\n# 2. 类加载器子系统的概述\n\n\n# 1. 类加载器的作用\n\n\n\n * 类加载器子系统负责从文件系统或者网络中加载class文件,class文件在文件开头有特定的文件不标识.\n * classloader(类加载器)只负责class文件的加载,至于它是否可以运行,则由execution engine(执行引擎)决定\n * 加载的类信息存放于一块称为方法区的内存空间.除了类的信息外,方法区中还会存放运行时常量池信息,可能还包括字符串字面量和数字常量(这部分常量信息是class文件中常量池部分的内存映射)\n\n\n# 2. 类加载器classloader角色\n\n\n\n 1. class file存在于本地磁盘上,可以理解为设计师在纸上的模板,而最终这个模板再执行的时候是要加载到jvm当中来根据这个文件实例化出n个一模一样的实例\n 2. class file加载当jvm中,被称为dna元数据模板,放在方法区.\n 3. 在.class文件->jvm->最终成为元数据模板,此过程就是要一个运输工具(类加载器class loader),扮演一个快递员的角色.\n\n\n# 3. 类的加载过程\n\n类加载的完整流程\n\n\n\n下面代码是如何加载呢?\n\n/**\n * @author: chggx\n * @date: 2020/08/30 7:44\n * @description: <h1> 类加载器加载过程 </h1>\n */\npublic class helloloader {\n\n    public static void main(string[] args) {\n        system.out.println("欢迎来到类加载器的世界...");\n        system.out.println("现在开始旅程吧...");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 1. 运行代码后,生成字节码文件,在 target 目下的 classes文件夹下.\n\n//\n// source code recreated from a .class file by intellij idea\n// (powered by fernflower decompiler)\n//\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class helloloader {\n    public helloloader() {\n    }\n\n    public static void main(string[] args) {\n        system.out.println("欢迎来到类加载器的世界...");\n        system.out.println("现在开始旅程吧...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> maven项目\n\n 2. 如何加载如类加载器\n\n\n\n\n# 1. 加载\n\n 1. 通过一个类的全限定类名获取定义此类的二进制字符流\n 2. 将这个字节流流代表的静态存储结构转化为方法区的运行时数据结构\n 3. 在内存中生成一个代表这个类的java.lang.class对象,作为方法区这个类的各种数据的访问入口\n\n> 补充: 加载 .class文件的方式\n\n- 从本地系统中直接加载.\n- 通过网络获取,典型场景: web applet\n- 从zip压缩包中读取,成为日后jar,war格式的基础.\n- 运行时计算生成,使用最多的是: 动态代理技术\n- 有其他文件生成,典型场景: jsp应用\n- 从专有数据库中提取.class文件,使用较少\n- 从加密文件中获取,典型的防class文件被反编译的保护措施.\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2. 验证\n\n * 验证的目的在于确保class文件的字节流中包含信息符合当前虚拟机要求,保证被加载类的正确性,不会危害虚拟机自身安全.\n * 主要包括是4中验证: 文件格式验证、元数据验证、字节码验证、符号引用验证.\n\n> 工具：binary viewer查看 ca fe ba be\n\n\n\n> 使用idea. 安装 jclasslib 插件\n\n\n\n安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了\n\n\n\n\n# 3. 准备\n\n * 为类变量分配内存并且设置该类变量的默认初始值，即零值.\n   \n   /**\n    * @author: chggx\n    * @date: 2020/08/30 9:14\n    * @description: <h1> 类加载的准备阶段 </h1>\n    */\n   public class helloapp {\n   \n       /**\n        * 准备阶段为 0,在下个阶段，也就是初始化的时候才是1\n        */\n       private static int a = 1;\n   \n       public static void main(string[] args) {\n           system.out.println(a);\n       }\n   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n   \n   > 上面的变量a在准备阶段会赋初始值，但不是1，而是0。\n\n * 这里不包含用final修饰的static,因为final在编译的时候就会分配了,准备阶段会显式初始化.\n\n * 这里不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量是会随着对象器分配到java堆中.\n\n\n# 4. 解析\n\n * 将常量池内的符号引用转换为直接引用的过程\n\n * 事实上,解析操作往往会伴随着jvm在执行完成初始化之后在执行.\n\n * 符号引用就是一组符号来描述所引用的目标.符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中.直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄.\n\n * 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的constant_class_info/constant_fieldref_info、constant_methodref_info等。\n\n\n# 5. 初始化\n\n * 初始化阶段就是执行类构造方法<clinit>()的过程.\n\n * 此方法不需要定义,是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来.\n\n * 构造器方法中指令按语句在源文件中出现的顺序执行.\n\n * <clinit>()不同于类的构造器. (关联; 构造器是虚拟机视角下的<clinit>().\n\n * 若该类具有父类,jvm会保证子类的<clinit>()执行前,父类的<clinit>()已经执行完毕.\n\n * 虚拟机必须保证一个类的<clinit>()方法在多线程下会被同步加锁.\n\n# 1. 测试初始化执行类构造方法<clinit>()的过程\n\n/**\n * @author: chggx\n * @date: 2020/08/30 9:18\n * @description: <h1> 类加在过程的初始化阶段 </h1>\n */\npublic class classinittest {\n\n    private static int num = 1;\n\n    public static void main(string[] args) {\n        system.out.println(classinittest.num);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n字节码文件\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class classinittest {\n    private static int num = 1;\n\n    public classinittest() {\n    }\n\n    public static void main(string[] args) {\n        system.out.println(num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n使用 jclasslib 插件\n\n\n\n> 任何一个类在声明后，都有生成一个构造器，默认是空参构造器\n\n# 2. 重新赋值后\n\n 1. 重新赋值\n\npublic class classinittest {\n\n    private static int num = 1;\n\n    static{\n        num = 2;\n    }\n\n    public static void main(string[] args) {\n        system.out.println(classinittest.num);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n字节码文件\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class classinittest {\n    private static int num = 1;\n\n    public classinittest() {\n    }\n\n    public static void main(string[] args) {\n        system.out.println(num);\n    }\n\n    static {\n        num = 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n使用jclasslib插件\n\n\n\n> 先赋值为1,最后赋值为2.\n\n 2. 相反情况下的赋值(按顺序执行)\n\npublic class classinittest {\n\n    private static int num = 1;\n\n    static{\n        num = 2;\n        number = 20;\n    }\n\n    /**\n     * linking环节的准备(prepare)阶段:\n     *      number = 0 --\x3e initial: 20 ---\x3e 10\n     */\n    private static int number =  10;\n\n    public static void main(string[] args) {\n        // 2\n        system.out.println(classinittest.num);\n        // 10\n        system.out.println(classinittest.number);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n字节码文件\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class classinittest {\n    private static int num = 1;\n    private static int number;\n\n    public classinittest() {\n    }\n\n    public static void main(string[] args) {\n        system.out.println(num);\n        system.out.println(number);\n    }\n\n    static {\n        num = 2;\n        number = 20;\n        number = 10;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n使用jclasslib插件\n\n\n\n> 注意: 此时打印num正确,number会报错非法的前向引用\n\n# 3. <clinit>()不同于类的构造器\n\n 1. 没有静态变量和静态代码块\n\npublic class classinittest2 {\n\n    /**\n     * 任何类声明以后,至少存在一个类的构造器\n     */\n    private int a = 1;\n    \n    public static void main(string[] args) {\n       int b = 2;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 上面类中 没有声明静态变量和静态代码块 不会存在类的构造器方法clinit<>\n\n 2. 存在静态变量和代码块\n\npublic class classinittest2 {\n\n    /**\n     * 任何类声明以后,至少存在一个类的构造器\n     */\n    private int a = 1;\n    private static int c = 3;\n    public static void main(string[] args) {\n       int b = 2;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n字节码\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class classinittest2 {\n    private int a = 1;\n    private static int c = 3;\n\n    public classinittest2() {\n    }\n\n    public static void main(string[] args) {\n        int b = true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n 3. init初始化方法(构造器)\n\npublic class classinittest2 {\n\n    /**\n     * 任何类声明以后,至少存在一个类的构造器\n     */\n    private int a = 1;\n    private static int c = 3;\n    public static void main(string[] args) {\n       int b = 2;\n    }\n\n    public classinittest2() {\n        a = 10;\n        int b = 20;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n字节码\n\npublic class classinittest2 {\n    private int a = 1;\n    private static int c = 3;\n\n    public static void main(string[] args) {\n        int b = true;\n    }\n\n    public classinittest2() {\n        this.a = 10;\n        int b = true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n# 4. 该类具有父类\n\npublic class classinittest3 {\n\n    static class father{\n        public static int a = 1;\n        static {\n            a = 2;\n        }\n    }\n\n    static class son extends father{\n        public static int b = a;\n    }\n\n    public static void main(string[] args){\n        // 2\n        system.out.println(son.b);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n字节码\n\npackage com.chggx.jvm.chapter02.loader;\n\npublic class classinittest3 {\n    public classinittest3() {\n    }\n\n    public static void main(string[] args) {\n        system.out.println(classinittest3.son.b);\n    }\n\n    static class son extends classinittest3.father {\n        public static int b;\n\n        son() {\n        }\n\n        static {\n            b = a;\n        }\n    }\n\n    static class father {\n        public static int a = 1;\n\n        father() {\n        }\n\n        static {\n            a = 2;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n# 5. 虚拟机必须保证一个类的<clinit>()方法在多线程下会被同步加锁\n\npublic class deadthreadtest {\n\n    public static void main(string[] args){\n        runnable runnable = () -> {\n            system.out.println(thread.currentthread().getname()+"开始");\n            deadthread dead = new deadthread();\n            system.out.println(thread.currentthread().getname()+"结束");\n        };\n\n        // 创建线程\n        thread t1 = new thread(runnable, "线程1");\n        thread t2 = new thread(runnable, "线程2");\n\n        // 启动线程\n        t1.start();\n        t2.start();\n    }\n\n}\n\nclass deadthread{\n    static {\n        if (true){\n            system.out.println(thread.currentthread().getname()+"初始化当前类");\n            while (true){\n\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n结果\n\n线程1开始\n线程2开始\n线程1初始化当前类\n\n\n1\n2\n3\n\n\n\n# 4. 类加载器的分类\n\n * jvm支持两种类型的类加载器: 引导类加载器（bootstrap classloader）和自定义类加载器（user-defined classloader）。\n\n * 从概念上来讲,自定义类加载器一般指的是程序员中由开发人员自定义的一类类加载器,但是java虚拟机规范却没有这么定义,而是将所有派生于抽类classloader的类加载器都划分为自定义类加载器。\n\n * 无论类加载器的类型如何划分,在程序中我们最常见的类加载器始终只有3个,如下所示\n   \n   \n\n> 这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。\n> \n> 引导类加载器: 使用c/c++编写,使用java代码不能获取\n> \n> 其他类加载器: 使用java编写\n> \n> 自定义加载器/系统加载器: 都是appclassloader sun.misc.launcher$appclassloader\n\n**\n * @author: chggx\n * @date: 2020/09/05 8:48\n * @description: <h1> 类加载器分类 </h1>\n */\npublic class classloadertest {\n\n    public static void main(string[] args) {\n        // 获取系统类加载器\n        classloader systemclassloader = classloader.getsystemclassloader();\n        system.out.println(systemclassloader);\n        // sun.misc.launcher$appclassloader@18b4aac2\n\n        // 系统类加载器获取其上层: 扩展类加载器\n        classloader extclassloader = systemclassloader.getparent();\n        system.out.println(extclassloader);\n        // sun.misc.launcher$extclassloader@1b6d3586\n\n        // 获取其上层: 引导类加载器\n        classloader bootstrapclassloader = extclassloader.getparent();\n        system.out.println(bootstrapclassloader);\n        // null\n\n        // 对于用户自定义类来说 默认使用系统类加载器进行加载\n        classloader classloader = classloadertest.class.getclassloader();\n        system.out.println(classloader);\n        // sun.misc.launcher$appclassloader@18b4aac2\n\n        // string类使用: 引导类加载器进行加载的.---\x3ejava的核心类库都是使用引导类加载器进行加载的\n        classloader classloader1 = spring.class.getclassloader();\n        system.out.println(classloader1);\n        // null\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n> 从结果看出我们无法直接获取引导类加载器,\n\n\n# 5. 虚拟机自带的加载器\n\n\n# 1. 启动类加载器(引导类加载器 bootstrap classloader)\n\n * 这个类加载使用c/c++语言实现的，嵌套在jvm内部。\n * 它用来加载java的核心库（java_home/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供jvm自身需要的类\n * 并不继承自ava.lang.classloader，没有父加载器。\n * 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。\n * 出于安全考虑，bootstrap启动类加载器只加载包名为java、javax、sun等开头的类\n\n示例代码\n\n/**\n * @author: chggx\n * @date: 2020/09/05 8:48\n * @description: <h1> 类加载器分类:  </h1>\n */\npublic class classloadertest2 {\n\n    public static void main(string[] args) {\n        system.out.println("启动类加载器");\n        // 获取bootstrapclassloader能够加载的api的路径\n        url[] urls = sun.misc.launcher.getbootstrapclasspath().geturls();\n        for (url url : urls) {\n            system.out.println(url.toexternalform());\n        }\n        // 从上面的路径中随意选择一个类,查看类加载器是什么?\n        classloader classloader = provider.class.getclassloader();\n        system.out.println(classloader);\n        // null : 表明加载器为 引导类加载器\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n结果为\n\n启动类加载器\nfile:/e:/develop/java/jdk1.8.0_192/jre/lib/resources.jar\nfile:/e:/develop/java/jdk1.8.0_192/jre/lib/rt.jar\nfile:/e:/develop/java/jdk1.8.0_192/jre/lib/sunrsasign.jar\nfile:/e:/develop/java/jdk1.8.0_192/jre/lib/jsse.jar\nfile:/e:/develop/java/jdk1.8.0_192/jre/lib/jce.jar\nfile:/e:/develop/java/jdk1.8.0_192/jre/lib/charsets.jar\nfile:/e:/develop/java/jdk1.8.0_192/jre/lib/jfr.jar\nfile:/e:/develop/java/jdk1.8.0_192/jre/classes\nnull\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2. 扩展类加载器 (extension classloader)\n\n * java语言编写，由sun.misc.launcher$extclassloader实现。\n * 派生于classloader类\n * 父类加载器为启动类加载器\n * 从java.ext.dirs系统属性所指定的目录中加载类库，或从jdk的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载。\n\n示例代码\n\npublic class classloadertest2 {\n\n    public static void main(string[] args) {\n        system.out.println("扩展类加载器");\n        string extdirs = system.getproperty("java.ext.dirs");\n        for (string path : extdirs.split(";")) {\n            system.out.println(path);\n        }\n        // 从上面的路径中随意选择一个类,查看类加载器是什么?\n        classloader classloader1 = curvedb.class.getclassloader();\n        system.out.println(classloader1);\n        // sun.misc.launcher$extclassloader@4b67cf4d : 表明加载器为 扩展类加载器\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n结果为\n\n扩展类加载器\ne:\\develop\\java\\jdk1.8.0_192\\jre\\lib\\ext\nc:\\windows\\sun\\java\\lib\\ext\nsun.misc.launcher$extclassloader@4b67cf4d\n\n\n1\n2\n3\n4\n\n\n\n# 3. 应用程序类加载器（系统类加载器，appclassloader）\n\n * java语言编写，由sun.misc.launchersappclassloader实现\n * 派生于classloader类\n * 父类加载器为扩展类加载器\n * 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库\n * 该类加载是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载\n * 通过classloader#getsystemclassloader（）方法可以获取到该类加载器\n\n\n# 4. 用户自定义类加载器\n\n在java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？\n\n * 隔离加载类\n * 修改类加载的方式\n * 扩展加载源\n * 防止源码泄漏\n\n用户自定义类加载器实现步骤：\n\n * 开发人员可以通过继承抽象类ava.1ang.classloader类的方式，实现自己的类加载器，以满足一些特殊的需求\n * 在jdk1.2之前，在自定义类加载器时，总会去继承classloader类并重写loadclass（）方法，从而实现自定义的类加载类，但是在jdk1.2之后已不再建议用户去覆盖loadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中\n * 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承uriclassloader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。\n\n\n# 6. 关于classloader\n\nclassloader类,它是一个抽象类,其后所有的类加载器都继承自classloader(不包含启动类加载器)\n\n方法名称                                                          描述\npublic final classloader getparent()                          返回该类加载器的超类加载器\npublic class<?> loadclass(string name)                        加载名称为name的类,返回结果为java.lang.class类的实例\nprotected class<?> findclass(string name)                     查找名称为name的类,返回结果为java.lang.class类的实例\nprotected final class<?> findloadedclass(string name)         查找名称为name的已经被加载过的类,返回结果为java.lang.class类的实例\nprotected final class<?> defineclass(byte[] b, int off, int   把字节数组b中的内容转换为一个java类,返回结果为java.lang.class类的实例\nlen)\nprotected final void resolveclass(class<?> c)                 连接指定的一个java类\n\nsun.misc.launcher 它是一个java虚拟机的入口应用\n\n\n\n获取classloader的途径\n\n * 获取当前classloader：clazz.getclassloader()\n * 获取当前线程上下文的classloader：thread.currentthread().getcontextclassloader()\n * 获取系统的classloader：classloader.getsystemclassloader()\n * 获取调用者的classloader：drivermanager.getcallerclassloader()\n\n/**\n * @author: chggx\n * @date: 2020/09/05 8:48\n * @description: <h1> 获取classloader的途径 </h1>\n */\npublic class classloadertest3 {\n\n    /**\n     * 获取classloader的途径\n     * - 获取当前classloader：clazz.getclassloader()\n     * - 获取当前线程上下文的classloader：thread.currentthread().getcontextclassloader()\n     * - 获取系统的classloader：classloader.getsystemclassloader()\n     * - 获取调用者的classloader：drivermanager.getcallerclassloader()\n     * @param args\n     */\n    public static void main(string[] args) {\n\n\n        // 1. 获取当前classloader：clazz.getclassloader()\n        try {\n            classloader classloader = class.forname("java.lang.string").getclassloader();\n            system.out.println(classloader);\n            // null 加载器类为: 引导类加载器\n        } catch (classnotfoundexception e) {\n            e.printstacktrace();\n        }\n\n        // 2. 获取当前线程上下文的classloader：thread.currentthread().getcontextclassloader()\n        classloader contextclassloader = thread.currentthread().getcontextclassloader();\n        system.out.println(contextclassloader);\n        // sun.misc.launcher$appclassloader@18b4aac2\n\n        // 3. 获取系统的classloader：classloader.getsystemclassloader()\n        classloader systemclassloader = classloader.getsystemclassloader();\n        system.out.println(systemclassloader);\n        // sun.misc.launcher$appclassloader@18b4aac2 应用类加载器\n        classloader parent = systemclassloader.getparent();\n        system.out.println(parent);\n        // sun.misc.launcher$extclassloader@1b6d3586 扩展类加载器\n\n        // - 获取调用者的classloader：drivermanager.getcallerclassloader()\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 7. 双亲委派机制\n\njava虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。\n\n\n# 工作原理\n\n * 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；\n * 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；\n * 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\n\n\n\n\n# 双亲委派机制\n\n当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于spi接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 spi核心类，然后在加载spi接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。\n\n\n\n\n# 沙箱安全机制\n\n自定义string类，但是在加载自定义string类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\string.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\n\n\n# 优势\n\n * 避免重复的加载\n\n * 保护程序安全,防止核心api被随意篡改\n   \n   包 java.lang.* 开发中禁止使用编写自定义类\n\n\n# 8. 其它\n\n\n# 如何判断两个class对象是否相同\n\n在jvm中表示两个class对象是否为同一个类存在两个必要条件：\n\n * 类的完整类名必须一致，包括包名。\n * 加载这个类的classloader（指classloader实例对象）必须相同。\n\n换句话说，在jvm中，即使这两个类对象（class对象）来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的classloader实例对象不同，那么这两个类对象也是不相等的。\n\njvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的。\n\n\n# 类的主动使用和被动使用\n\njava程序对类的使用方式分为：主动使用和被动使用。\n\n主动使用，又分为七种情况：\n\n * 创建类的实例\n * 访问某个类或接口的静态变量，或者对该静态变量赋值\n * 调用类的静态方法i\n * 反射（比如：class.forname（"com.atguigu.test"））\n * 初始化一个类的子类\n * java虚拟机启动时被标明为启动类的类\n * jdk7开始提供的动态语言支持：\n * java.lang.invoke.methodhandle实例的解析结果ref getstatic、ref putstatic、ref invokestatic句柄对应的类没有初始化，则初始化\n\n除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-程序计数器(PC寄存器)",frontmatter:{title:"JVM-程序计数器(PC寄存器)",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/797fac/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/4.JVM-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8(PC%E5%AF%84%E5%AD%98%E5%99%A8).html",relativePath:"01.语言/01.JAVA语言/02.JVM/4.JVM-程序计数器(PC寄存器).md",key:"v-f3069b4a",path:"/pages/797fac/",headers:[{level:2,title:"1. 介绍",slug:"_1-介绍",normalizedTitle:"1. 介绍",charIndex:23},{level:2,title:"2. 作用",slug:"_2-作用",normalizedTitle:"2. 作用",charIndex:295},{level:2,title:"3. 案例",slug:"_3-案例",normalizedTitle:"3. 案例",charIndex:689},{level:2,title:"4. 常见问题",slug:"_4-常见问题",normalizedTitle:"4. 常见问题",charIndex:4213},{level:3,title:"使用PC寄存器存储字节码指令地址有什么用呢？（问什么使用PC寄存器记录当前线程执行地址呢？）",slug:"使用pc寄存器存储字节码指令地址有什么用呢-问什么使用pc寄存器记录当前线程执行地址呢",normalizedTitle:"使用pc寄存器存储字节码指令地址有什么用呢？（问什么使用pc寄存器记录当前线程执行地址呢？）",charIndex:4225},{level:3,title:"PC寄存器问什么会被设定为私有的？",slug:"pc寄存器问什么会被设定为私有的",normalizedTitle:"pc寄存器问什么会被设定为私有的？",charIndex:4369},{level:3,title:"CPU时间片",slug:"cpu时间片",normalizedTitle:"cpu时间片",charIndex:4551}],headersStr:"1. 介绍 2. 作用 3. 案例 4. 常见问题 使用PC寄存器存储字节码指令地址有什么用呢？（问什么使用PC寄存器记录当前线程执行地址呢？） PC寄存器问什么会被设定为私有的？ CPU时间片",content:'# JVM-程序计数器(PC寄存器)\n\n\n# 1. 介绍\n\nJVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。\n\n\n\n> 栈没有垃圾回收,有内存溢出(OOM)\n> \n> 堆和方法区有垃圾回收(GC/OOM)\n> \n> PC寄存器没有GC和OOM\n\n\n# 2. 作用\n\nPC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。\n\n\n\n它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。\n\n在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。\n\n任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。\n\n它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\n\n它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。\n\n> 游标,集合迭代器\n\n\n# 3. 案例\n\n我们首先写一个简单的代码\n\n/**\n * @Author: CHGGX\n * @Date: 2020/09/06 8:26\n * @Description: <h1> PC寄存器案例 </h1>\n */\npublic class PCRegisterTest {\n\n    public static void main(String[] args) {\n        int i = 10;\n        int j = 20;\n        int k = i + j;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n反编译命令\n\njavap -verbose PCRegisterTest.class\n或者 javap -v PCRegisterTest.class\n\n\n1\n2\n\n\n得到下面结果\n\nClassfile /D:/java-code/java/jvm/target/classes/com/chggx/jvm/chapter04/PCRegi\nsterTest.class\n  Last modified 2020-9-6; size 501 bytes\n  MD5 checksum 588b9b406f9e4a1537c4970fa22c6fd7\n  Compiled from "PCRegisterTest.java"\npublic class com.chggx.jvm.chapter04.PCRegisterTest\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #3.#21         // java/lang/Object."<init>":()V\n   #2 = Class              #22            // com/chggx/jvm/chapter04/PCRegiste\nrTest\n   #3 = Class              #23            // java/lang/Object\n   #4 = Utf8               <init>\n   #5 = Utf8               ()V\n   #6 = Utf8               Code\n   #7 = Utf8               LineNumberTable\n   #8 = Utf8               LocalVariableTable\n   #9 = Utf8               this\n  #10 = Utf8               Lcom/chggx/jvm/chapter04/PCRegisterTest;\n  #11 = Utf8               main\n  #12 = Utf8               ([Ljava/lang/String;)V\n  #13 = Utf8               args\n  #14 = Utf8               [Ljava/lang/String;\n  #15 = Utf8               i\n  #16 = Utf8               I\n  #17 = Utf8               j\n  #18 = Utf8               k\n  #19 = Utf8               SourceFile\n  #20 = Utf8               PCRegisterTest.java\n  #21 = NameAndType        #4:#5          // "<init>":()V\n  #22 = Utf8               com/chggx/jvm/chapter04/PCRegisterTest\n  #23 = Utf8               java/lang/Object\n{\n  public com.chggx.jvm.chapter04.PCRegisterTest();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object."<ini\nt>":()V\n         4: return\n      LineNumberTable:\n        line 8: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/chggx/jvm/chapter04/PCRegisterTest;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=4, args_size=1\n         0: bipush        10\n         2: istore_1\n         3: bipush        20\n         5: istore_2\n         6: iload_1\n         7: iload_2\n         8: iadd\n         9: istore_3\n        10: return\n      LineNumberTable:\n        line 11: 0\n        line 12: 3\n        line 13: 6\n        line 14: 10\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      11     0  args   [Ljava/lang/String;\n            3       8     1     i   I\n            6       5     2     j   I\n           10       1     3     k   I\n}\nSourceFile: "PCRegisterTest.java"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n从上面反编译结果可以看出: 发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。\n\n  stack=2, locals=4, args_size=1\n         0: bipush        10\n         2: istore_1\n         3: bipush        20\n         5: istore_2\n         6: iload_1\n         7: iload_2\n         8: iadd\n         9: istore_3\n        10: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n\n# 4. 常见问题\n\n\n# 使用PC寄存器存储字节码指令地址有什么用呢？（问什么使用PC寄存器记录当前线程执行地址呢？）\n\n因为CPU需要不停地奇幻各个线程，这个时候切换回来以后，就得知道接着从哪开始继续执行。\n\nJVM的字节码解释器就需要通过改变PC寄存器的值来明确下一跳应该执行什么样的字节码指令。\n\n\n\n\n# PC寄存器问什么会被设定为私有的？\n\n我们都知道所谓的多线程在一个特定的时间段内只会执行其中一个线程的方法，CPU会不停的做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器。这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。\n\n由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的是哦，一个处理器或者多个处理器中的一个内核，只会执行某个线程中的一条指令。\n\n这个必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\n\n\n\n\n# CPU时间片\n\nCPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。\n\n在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。\n\n但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。\n\n',normalizedContent:'# jvm-程序计数器(pc寄存器)\n\n\n# 1. 介绍\n\njvm中的程序计数寄存器（program counter register）中，register的命名源于cpu的寄存器，寄存器存储指令相关的现场信息。cpu只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为pc计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。jvm中的pc寄存器是对物理pc寄存器的一种抽象模拟。\n\n\n\n> 栈没有垃圾回收,有内存溢出(oom)\n> \n> 堆和方法区有垃圾回收(gc/oom)\n> \n> pc寄存器没有gc和oom\n\n\n# 2. 作用\n\npc寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。\n\n\n\n它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。\n\n在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。\n\n任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的jvm指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。\n\n它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\n\n它是唯一一个在java虚拟机规范中没有规定任何outotmemoryerror情况的区域。\n\n> 游标,集合迭代器\n\n\n# 3. 案例\n\n我们首先写一个简单的代码\n\n/**\n * @author: chggx\n * @date: 2020/09/06 8:26\n * @description: <h1> pc寄存器案例 </h1>\n */\npublic class pcregistertest {\n\n    public static void main(string[] args) {\n        int i = 10;\n        int j = 20;\n        int k = i + j;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n反编译命令\n\njavap -verbose pcregistertest.class\n或者 javap -v pcregistertest.class\n\n\n1\n2\n\n\n得到下面结果\n\nclassfile /d:/java-code/java/jvm/target/classes/com/chggx/jvm/chapter04/pcregi\nstertest.class\n  last modified 2020-9-6; size 501 bytes\n  md5 checksum 588b9b406f9e4a1537c4970fa22c6fd7\n  compiled from "pcregistertest.java"\npublic class com.chggx.jvm.chapter04.pcregistertest\n  minor version: 0\n  major version: 52\n  flags: acc_public, acc_super\nconstant pool:\n   #1 = methodref          #3.#21         // java/lang/object."<init>":()v\n   #2 = class              #22            // com/chggx/jvm/chapter04/pcregiste\nrtest\n   #3 = class              #23            // java/lang/object\n   #4 = utf8               <init>\n   #5 = utf8               ()v\n   #6 = utf8               code\n   #7 = utf8               linenumbertable\n   #8 = utf8               localvariabletable\n   #9 = utf8               this\n  #10 = utf8               lcom/chggx/jvm/chapter04/pcregistertest;\n  #11 = utf8               main\n  #12 = utf8               ([ljava/lang/string;)v\n  #13 = utf8               args\n  #14 = utf8               [ljava/lang/string;\n  #15 = utf8               i\n  #16 = utf8               i\n  #17 = utf8               j\n  #18 = utf8               k\n  #19 = utf8               sourcefile\n  #20 = utf8               pcregistertest.java\n  #21 = nameandtype        #4:#5          // "<init>":()v\n  #22 = utf8               com/chggx/jvm/chapter04/pcregistertest\n  #23 = utf8               java/lang/object\n{\n  public com.chggx.jvm.chapter04.pcregistertest();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // method java/lang/object."<ini\nt>":()v\n         4: return\n      linenumbertable:\n        line 8: 0\n      localvariabletable:\n        start  length  slot  name   signature\n            0       5     0  this   lcom/chggx/jvm/chapter04/pcregistertest;\n\n  public static void main(java.lang.string[]);\n    descriptor: ([ljava/lang/string;)v\n    flags: acc_public, acc_static\n    code:\n      stack=2, locals=4, args_size=1\n         0: bipush        10\n         2: istore_1\n         3: bipush        20\n         5: istore_2\n         6: iload_1\n         7: iload_2\n         8: iadd\n         9: istore_3\n        10: return\n      linenumbertable:\n        line 11: 0\n        line 12: 3\n        line 13: 6\n        line 14: 10\n      localvariabletable:\n        start  length  slot  name   signature\n            0      11     0  args   [ljava/lang/string;\n            3       8     1     i   i\n            6       5     2     j   i\n           10       1     3     k   i\n}\nsourcefile: "pcregistertest.java"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n从上面反编译结果可以看出: 发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。\n\n  stack=2, locals=4, args_size=1\n         0: bipush        10\n         2: istore_1\n         3: bipush        20\n         5: istore_2\n         6: iload_1\n         7: iload_2\n         8: iadd\n         9: istore_3\n        10: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n\n# 4. 常见问题\n\n\n# 使用pc寄存器存储字节码指令地址有什么用呢？（问什么使用pc寄存器记录当前线程执行地址呢？）\n\n因为cpu需要不停地奇幻各个线程，这个时候切换回来以后，就得知道接着从哪开始继续执行。\n\njvm的字节码解释器就需要通过改变pc寄存器的值来明确下一跳应该执行什么样的字节码指令。\n\n\n\n\n# pc寄存器问什么会被设定为私有的？\n\n我们都知道所谓的多线程在一个特定的时间段内只会执行其中一个线程的方法，cpu会不停的做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个pc寄存器。这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。\n\n由于cpu时间片轮限制，众多线程在并发执行过程中，任何一个确定的是哦，一个处理器或者多个处理器中的一个内核，只会执行某个线程中的一条指令。\n\n这个必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\n\n\n\n\n# cpu时间片\n\ncpu时间片即cpu分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。\n\n在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。\n\n但在微观上：由于只有一个cpu，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。\n\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-本地方法接口",frontmatter:{title:"JVM-本地方法接口",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/38174c/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/6.JVM-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3.html",relativePath:"01.语言/01.JAVA语言/02.JVM/6.JVM-本地方法接口.md",key:"v-f7888516",path:"/pages/38174c/",headers:[{level:2,title:"1. 什么是本地方法？",slug:"_1-什么是本地方法",normalizedTitle:"1. 什么是本地方法？",charIndex:19},{level:2,title:"2. 为什么使用Native Method?",slug:"_2-为什么使用native-method",normalizedTitle:"2. 为什么使用native method?",charIndex:870},{level:3,title:"与Java环境的交互",slug:"与java环境的交互",normalizedTitle:"与java环境的交互",charIndex:954},{level:3,title:"与操作系统的交互",slug:"与操作系统的交互",normalizedTitle:"与操作系统的交互",charIndex:1102},{level:3,title:"Sun's Java",slug:"sun-s-java",normalizedTitle:"sun's java",charIndex:1333},{level:2,title:"3. 现状",slug:"_3-现状",normalizedTitle:"3. 现状",charIndex:1651}],headersStr:"1. 什么是本地方法？ 2. 为什么使用Native Method? 与Java环境的交互 与操作系统的交互 Sun's Java 3. 现状",content:'# JVM-本地方法接口\n\n\n\n\n# 1. 什么是本地方法？\n\n简单地讲，一个Native Method就是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern "c" 告知c++编译器去调用一个c的函数。\n\n"A native method is a Java method whose implementation is provided by non-java code."（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）\n\n在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。\n\n本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/03 22:43\n * @Description: <h1> </h1>\n * native: 表名本地方法，与abstract相抵触，不共存\n */\npublic class IHaveNatives {\n\n    public native void native1(int x);\n\n    native static public long native2();\n\n    native synchronized private float native3(Object o);\n\n    native void native4(int[] ary) throws Exception;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外\n\n\n# 2. 为什么使用Native Method?\n\nava使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。\n\n\n# 与Java环境的交互\n\n有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。\n\n\n# 与操作系统的交互\n\nJVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。\n\n\n# Sun\'s Java\n\nSun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。\n\n\n# 3. 现状\n\n目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。',normalizedContent:'# jvm-本地方法接口\n\n\n\n\n# 1. 什么是本地方法？\n\n简单地讲，一个native method就是一个java调用非java代码的接囗。一个native method是这样一个java方法：该方法的实现由非java语言实现，比如c。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在c++中，你可以用extern "c" 告知c++编译器去调用一个c的函数。\n\n"a native method is a java method whose implementation is provided by non-java code."（本地方法是一个非java的方法，它的具体实现是非java代码的实现）\n\n在定义一个native method时，并不提供实现体（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的。\n\n本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合c/c++程序。\n\n/**\n * @author: chggx\n * @date: 2020/10/03 22:43\n * @description: <h1> </h1>\n * native: 表名本地方法，与abstract相抵触，不共存\n */\npublic class ihavenatives {\n\n    public native void native1(int x);\n\n    native static public long native2();\n\n    native synchronized private float native3(object o);\n\n    native void native4(int[] ary) throws exception;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外\n\n\n# 2. 为什么使用native method?\n\nava使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。\n\n\n# 与java环境的交互\n\n有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。你可以想想java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。\n\n\n# 与操作系统的交互\n\njvm支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至jvm的一些部分就是用c写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。\n\n\n# sun\'s java\n\nsun的解释器是用c实现的，这使得它能像一些普通的c一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.thread的setpriority（）方法是用java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用c实现的，并被植入jvm内部，在windows 95的平台上，这个本地方法最终将调用win32 setpriority（）api。这是一个本地方法的具体实现由jvm直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被jvw调用。\n\n\n# 3. 现状\n\n目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过java程序驱动打印机或者java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用socket通信，也可以使用web service等等，不多做介绍。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-虚拟机栈",frontmatter:{title:"JVM-虚拟机栈",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/42fe7b/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/5.JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.html",relativePath:"01.语言/01.JAVA语言/02.JVM/5.JVM-虚拟机栈.md",key:"v-6b7e9ccd",path:"/pages/42fe7b/",headers:[{level:2,title:"1. 虚拟机栈概述",slug:"_1-虚拟机栈概述",normalizedTitle:"1. 虚拟机栈概述",charIndex:44},{level:3,title:"Java虚拟机栈是什么？",slug:"java虚拟机栈是什么",normalizedTitle:"java虚拟机栈是什么？",charIndex:317},{level:3,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:455},{level:3,title:"作用",slug:"作用",normalizedTitle:"作用",charIndex:475},{level:3,title:"栈的特点",slug:"栈的特点",normalizedTitle:"栈的特点",charIndex:592},{level:3,title:"开发中遇到哪些异常？",slug:"开发中遇到哪些异常",normalizedTitle:"开发中遇到哪些异常？",charIndex:746},{level:3,title:"设置栈的内存大小",slug:"设置栈的内存大小",normalizedTitle:"设置栈的内存大小",charIndex:1607},{level:2,title:"2. 栈的存储单位",slug:"_2-栈的存储单位",normalizedTitle:"2. 栈的存储单位",charIndex:2335},{level:3,title:"栈中存储什么？",slug:"栈中存储什么",normalizedTitle:"栈中存储什么？",charIndex:2349},{level:3,title:"栈运行原理",slug:"栈运行原理",normalizedTitle:"栈运行原理",charIndex:2540},{level:3,title:"栈帧的内部结构",slug:"栈帧的内部结构",normalizedTitle:"栈帧的内部结构",charIndex:10283},{level:2,title:"3. 局部变量表（Local Variables Table）",slug:"_3-局部变量表-local-variables-table",normalizedTitle:"3. 局部变量表（local variables table）",charIndex:10531},{level:3,title:"局部变量表初识",slug:"局部变量表初识",normalizedTitle:"局部变量表初识",charIndex:10567},{level:3,title:"关于Slot理解",slug:"关于slot理解",normalizedTitle:"关于slot理解",charIndex:11114},{level:3,title:"Slot的重复利用",slug:"slot的重复利用",normalizedTitle:"slot的重复利用",charIndex:13033},{level:3,title:"静态变量与局部变量的对比",slug:"静态变量与局部变量的对比",normalizedTitle:"静态变量与局部变量的对比",charIndex:13298},{level:2,title:"4. 操作数栈（Operand Stack）",slug:"_4-操作数栈-operand-stack",normalizedTitle:"4. 操作数栈（operand stack）",charIndex:14064},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:2494},{level:2,title:"5. 代码追踪",slug:"_5-代码追踪",normalizedTitle:"5. 代码追踪",charIndex:14954},{level:2,title:"6. 栈顶缓存技术",slug:"_6-栈顶缓存技术",normalizedTitle:"6. 栈顶缓存技术",charIndex:16546},{level:2,title:"7. 动态链接（Dynamic Linking）",slug:"_7-动态链接-dynamic-linking",normalizedTitle:"7. 动态链接（dynamic linking）",charIndex:16788},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:1902},{level:3,title:"执行流程图",slug:"执行流程图",normalizedTitle:"执行流程图",charIndex:22584},{level:3,title:"为什么需要常量池？",slug:"为什么需要常量池",normalizedTitle:"为什么需要常量池？",charIndex:22596},{level:2,title:"8. 方法的调用: 解析与分派",slug:"_8-方法的调用-解析与分派",normalizedTitle:"8. 方法的调用: 解析与分派",charIndex:22641},{level:3,title:"静态链接和动态链接",slug:"静态链接和动态链接",normalizedTitle:"静态链接和动态链接",charIndex:22661},{level:4,title:"静态链接：",slug:"静态链接",normalizedTitle:"静态链接：",charIndex:22714},{level:4,title:"动态链接：",slug:"动态链接",normalizedTitle:"动态链接：",charIndex:22804},{level:3,title:"早起绑定和晚期绑定",slug:"早起绑定和晚期绑定",normalizedTitle:"早起绑定和晚期绑定",charIndex:22897},{level:4,title:"早期绑定",slug:"早期绑定",normalizedTitle:"早期绑定",charIndex:22976},{level:4,title:"晚期绑定",slug:"晚期绑定",normalizedTitle:"晚期绑定",charIndex:22902},{level:4,title:"示例",slug:"示例-2",normalizedTitle:"示例",charIndex:1902},{level:3,title:"虚方法和非虚方法",slug:"虚方法和非虚方法",normalizedTitle:"虚方法和非虚方法",charIndex:24950},{level:4,title:"非虚方法",slug:"非虚方法",normalizedTitle:"非虚方法",charIndex:24954},{level:4,title:"虚拟机中提供了以下几条方法调用指令",slug:"虚拟机中提供了以下几条方法调用指令",normalizedTitle:"虚拟机中提供了以下几条方法调用指令",charIndex:25134},{level:5,title:"普通调用指令示例",slug:"普通调用指令示例",normalizedTitle:"普通调用指令示例",charIndex:25486},{level:4,title:"invokedynamic指令",slug:"invokedynamic指令",normalizedTitle:"invokedynamic指令",charIndex:27521},{level:5,title:"动态类型语言和静态类型语言",slug:"动态类型语言和静态类型语言",normalizedTitle:"动态类型语言和静态类型语言",charIndex:27865},{level:3,title:"方法的重写",slug:"方法的重写",normalizedTitle:"方法的重写",charIndex:25109},{level:4,title:"Java语言中方法重写的本质",slug:"java语言中方法重写的本质",normalizedTitle:"java语言中方法重写的本质",charIndex:28698},{level:4,title:"IllegalAccessError 介绍",slug:"illegalaccesserror-介绍",normalizedTitle:"illegalaccesserror 介绍",charIndex:28957},{level:3,title:"虚方法表",slug:"虚方法表",normalizedTitle:"虚方法表",charIndex:29066},{level:4,title:"示例",slug:"示例-3",normalizedTitle:"示例",charIndex:1902},{level:2,title:"9. 方法返回地址（Return Address）",slug:"_9-方法返回地址-return-address",normalizedTitle:"9. 方法返回地址（return address）",charIndex:29354},{level:4,title:"当一个方法开始执行后，只有两种方式可以退出这个方法：",slug:"当一个方法开始执行后-只有两种方式可以退出这个方法",normalizedTitle:"当一个方法开始执行后，只有两种方式可以退出这个方法：",charIndex:31117},{level:2,title:"10. 一些附加信息",slug:"_10-一些附加信息",normalizedTitle:"10. 一些附加信息",charIndex:31569},{level:2,title:"11. 栈的相关面试题",slug:"_11-栈的相关面试题",normalizedTitle:"11. 栈的相关面试题",charIndex:31630},{level:3,title:"1. 举例栈溢出的情况？",slug:"_1-举例栈溢出的情况",normalizedTitle:"1. 举例栈溢出的情况？",charIndex:31646},{level:3,title:"2. 调整栈大小，就能保证不出现溢出吗？",slug:"_2-调整栈大小-就能保证不出现溢出吗",normalizedTitle:"2. 调整栈大小，就能保证不出现溢出吗？",charIndex:31704},{level:3,title:"3. 分配的占内存越大越好吗？",slug:"_3-分配的占内存越大越好吗",normalizedTitle:"3. 分配的占内存越大越好吗？",charIndex:31733},{level:3,title:"4. 垃圾回收是否会涉及到虚拟机栈？",slug:"_4-垃圾回收是否会涉及到虚拟机栈",normalizedTitle:"4. 垃圾回收是否会涉及到虚拟机栈？",charIndex:31757},{level:3,title:"5. 方法中定义的局部变量是否线程安全？",slug:"_5-方法中定义的局部变量是否线程安全",normalizedTitle:"5. 方法中定义的局部变量是否线程安全？",charIndex:31871}],headersStr:"1. 虚拟机栈概述 Java虚拟机栈是什么？ 生命周期 作用 栈的特点 开发中遇到哪些异常？ 设置栈的内存大小 2. 栈的存储单位 栈中存储什么？ 栈运行原理 栈帧的内部结构 3. 局部变量表（Local Variables Table） 局部变量表初识 关于Slot理解 Slot的重复利用 静态变量与局部变量的对比 4. 操作数栈（Operand Stack） 概念 5. 代码追踪 6. 栈顶缓存技术 7. 动态链接（Dynamic Linking） 示例 执行流程图 为什么需要常量池？ 8. 方法的调用: 解析与分派 静态链接和动态链接 静态链接： 动态链接： 早起绑定和晚期绑定 早期绑定 晚期绑定 示例 虚方法和非虚方法 非虚方法 虚拟机中提供了以下几条方法调用指令 普通调用指令示例 invokedynamic指令 动态类型语言和静态类型语言 方法的重写 Java语言中方法重写的本质 IllegalAccessError 介绍 虚方法表 示例 9. 方法返回地址（Return Address） 当一个方法开始执行后，只有两种方式可以退出这个方法： 10. 一些附加信息 11. 栈的相关面试题 1. 举例栈溢出的情况？ 2. 调整栈大小，就能保证不出现溢出吗？ 3. 分配的占内存越大越好吗？ 4. 垃圾回收是否会涉及到虚拟机栈？ 5. 方法中定义的局部变量是否线程安全？",content:'# JVM-虚拟机栈（Java Virtual Machine Stacks）\n\n\n# 1. 虚拟机栈概述\n\n由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。\n\n优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。\n\n有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java栈（stack）？为什么？\n\n首先栈是运行时的单位，而堆是存储的单位\n\n * 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。\n * 堆解决的是数据存储的问题，即数据怎么放，放哪里。\n\n\n# Java虚拟机栈是什么？\n\nJava虚拟机栈（Java Virtual Machine Stacks），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应一次次的Java方法调用。\n\n> 线程是私有的\n\n\n\n\n# 生命周期\n\n生命周期和线程一直\n\n\n# 作用\n\n主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分变量，并参与方法的调用和返回。\n\n * 局部变量：相较于成员变量（属性）\n * 基本数据变量：相较于引用类型变量（类、数组、接口）\n\n\n# 栈的特点\n\n * 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\n\n * JVM直接对Java栈的操作只用两个：\n   \n   1）每个方法执行，伴随着进栈（入栈、压栈）\n   \n   2）执行结束后的出战工作\n\n * 对于栈来说不存在垃圾回收(GC)问题（栈存在溢出OOM的情况）\n\n\n\n\n# 开发中遇到哪些异常？\n\n栈中可能出现的异常\n\nJava 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。\n\n 1. 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError异常。\n\n/**\n * @Author: CHGGX\n * @Date: 2020/09/06 11:48\n * @Description: <h1> 栈中可能出现的异常 </h1>\n */\npublic class StackError {\n\n    /**\n     * 演示栈中的异常：StackOverflowError\n     * @param args\n     */\n    public static void main(String[] args) {\n       main(args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n抛出异常\n\nException in thread "main" java.lang.StackOverflowError\n\tat com.chggx.jvm.chapter05.StackError.main(StackError.java:11)\n\tat com.chggx.jvm.chapter05.StackError.main(StackError.java:11)\n\tat com.chggx.jvm.chapter05.StackError.main(StackError.java:11)\n...\n\n\n1\n2\n3\n4\n5\n\n 2. 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError异常。\n\n\n# 设置栈的内存大小\n\n我们可以使用参数 -Xss 选项来设置线程的最大站空间，栈的大小直接决定了函数的最大可达深度。\n\n设置线程堆栈大小(以字节为单位)。附加字母k或k表示KB, m或m表示MB, g或g表示GB。默认值取决于平台:\n\n * Linux/x64(64位):1024 KB\n\n * macOS(64位):1024 KB\n\n * Oracle Solaris/x64(64位):1024 KB\n\n * Windows:默认值取决于虚拟内存\n\n下面的例子将线程栈大小设置为1024 KB，单位为不同:\n\n-Xss1m\n-Xss1024k\n-Xss1048576\n\n\n1\n2\n3\n\n\n示例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/09/06 11:48\n * @Description: <h1> 设置栈的大小 </h1>\n */\npublic class StackError2 {\n\n    private static int count = 1;\n    /**\n     * 默认情况下： count： 11413\n     * 设置栈的大小：-Xss256k count：2468\n     * @param args\n     */\n    public static void main(String[] args) {\n        System.out.println(count);\n        count++;\n       main(args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2. 栈的存储单位\n\n\n# 栈中存储什么？\n\n * 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。\n\n * 在这个线程正在执行的每个方法都有各自对应一个栈帧（Stack Frame）。\n\n * 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。\n\n> OOP的基本概念：类和对象\n> \n> 类中基本结构：field（属性、字段、域）、method\n\n\n# 栈运行原理\n\n 1. JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出” 或 “后进先出”原则。\n\n 2. 在一条活动线程中，一个时间点上，只会有一个活跃的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method）, 定义这个方法的类就是当前类（Current Class）。\n\n\n\n 3. 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。\n\n 4. 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶部，称为新的当前栈帧。\n\n 5. 不同线程中所包含的栈帧是不允许存在相互引用的，既不能在一个栈帧之中引用另一个线程的栈帧。\n\n 6. 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回来此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。\n\n 7. Java方法有两种返回函数的方式：\n    \n    * 一种是正常的函数返回，使用return指令。\n    * 一种是抛出异常。\n    \n    > 不管使用哪种方式，都会导致栈帧被弹出\n\n示例代码\n\n/**\n * @Author: CHGGX\n * @Date: 2020/09/06 14:42\n * @Description: <h1> 栈帧运行原理示例 </h1>\n */\npublic class StackFrameTest {\n\n    public static void main(String[] args) {\n        StackFrameTest stackFrameTest = new StackFrameTest();\n        stackFrameTest.method1();\n    }\n\n    public void method1(){\n        System.out.println("method1()开始执行。。。");\n        method2();\n        System.out.println("method1()执行结束。。。");\n    }\n\n    public int method2() {\n        System.out.println("method2()开始执行。。。");\n        int i = 10;\n        int m = (int)method3();\n        System.out.println("method2()即将结束。。。");\n        return i + m;\n    }\n\n    public double method3() {\n        System.out.println("method3()开始执行。。。");\n        double j = 20.0;\n        System.out.println("method3()即将结束。。。");\n        return j;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n运行结果\n\nmethod1()开始执行。。。\nmethod2()开始执行。。。\nmethod3()开始执行。。。\nmethod3()即将结束。。。\nmethod2()即将结束。。。\nmethod1()执行结束。。。\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过DEGUB模式查看栈信息（满足 先进后出/后进先出原则）\n\n\n\n反编译\n\njavap -v StackFrameTest.class\n\n\n1\n\n\n{\n  public com.chggx.jvm.chapter05.stackframe.StackFrameTest();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object."<ini\nt>":()V\n         4: return\n      LineNumberTable:\n        line 8: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/chggx/jvm/chapter05/stackframe/StackF\nrameTest;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=2, args_size=1\n         0: new           #2                  // class com/chggx/jvm/chapter05\n/stackframe/StackFrameTest\n         3: dup\n         4: invokespecial #3                  // Method "<init>":()V\n         7: astore_1\n         8: aload_1\n         9: invokevirtual #4                  // Method method1:()V\n        12: goto          20\n        15: astore_1\n        16: aload_1\n        17: invokevirtual #6                  // Method java/lang/Exception.pr\nintStackTrace:()V\n        20: getstatic     #7                  // Field java/lang/System.out:Lj\nava/io/PrintStream;\n        23: ldc           #8                  // String main()正常结束\n        25: invokevirtual #9                  // Method java/io/PrintStream.pr\nintln:(Ljava/lang/String;)V\n        28: return\n      Exception table:\n         from    to  target type\n             0    12    15   Class java/lang/Exception\n      LineNumberTable:\n        line 18: 0\n        line 19: 8\n        line 22: 12\n        line 20: 15\n        line 21: 16\n        line 23: 20\n        line 24: 28\n      LocalVariableTable: // 局部变量表\n        Start  Length  Slot  Name   Signature\n            8       4     1 stackFrameTest   Lcom/chggx/jvm/chapter05/stackfra\nme/StackFrameTest;\n           16       4     1     e   Ljava/lang/Exception;\n            0      29     0  args   [Ljava/lang/String;\n      StackMapTable: number_of_entries = 2\n        frame_type = 79 /* same_locals_1_stack_item */\n          stack = [ class java/lang/Exception ]\n        frame_type = 4 /* same */\n\n  public void method1();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #7                  // Field java/lang/System.out:Lj\nava/io/PrintStream;\n         3: ldc           #10                 // String method1()开始执行。。\n。\n         5: invokevirtual #9                  // Method java/io/PrintStream.pr\nintln:(Ljava/lang/String;)V\n         8: aload_0\n         9: invokevirtual #11                 // Method method2:()I\n        12: pop\n        13: getstatic     #7                  // Field java/lang/System.out:Lj\nava/io/PrintStream;\n        16: ldc           #12                 // String method1()执行结束。。\n。\n        18: invokevirtual #9                  // Method java/io/PrintStream.pr\nintln:(Ljava/lang/String;)V\n        21: return\n      LineNumberTable:\n        line 27: 0\n        line 28: 8\n        line 29: 13\n        line 31: 21\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      22     0  this   Lcom/chggx/jvm/chapter05/stackframe/StackF\nrameTest;\n\n  public int method2();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: getstatic     #7                  // Field java/lang/System.out:Lj\nava/io/PrintStream;\n         3: ldc           #13                 // String method2()开始执行。。\n。\n         5: invokevirtual #9                  // Method java/io/PrintStream.pr\nintln:(Ljava/lang/String;)V\n         8: bipush        10\n        10: istore_1\n        11: aload_0\n        12: invokevirtual #14                 // Method method3:()D\n        15: d2i\n        16: istore_2\n        17: getstatic     #7                  // Field java/lang/System.out:Lj\nava/io/PrintStream;\n        20: ldc           #15                 // String method2()即将结束。。\n。\n        22: invokevirtual #9                  // Method java/io/PrintStream.pr\nintln:(Ljava/lang/String;)V\n        25: iload_1\n        26: iload_2\n        27: iadd\n        28: ireturn\n      LineNumberTable:\n        line 34: 0\n        line 35: 8\n        line 36: 11\n        line 37: 17\n        line 38: 25\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      29     0  this   Lcom/chggx/jvm/chapter05/stackframe/StackF\nrameTest;\n           11      18     1     i   I\n           17      12     2     m   I\n\n  public double method3();\n    descriptor: ()D\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: getstatic     #7                  // Field java/lang/System.out:Lj\nava/io/PrintStream;\n         3: ldc           #16                 // String method3()开始执行。。\n。\n         5: invokevirtual #9                  // Method java/io/PrintStream.pr\nintln:(Ljava/lang/String;)V\n         8: ldc2_w        #17                 // double 20.0d\n        11: dstore_1\n        12: getstatic     #7                  // Field java/lang/System.out:Lj\nava/io/PrintStream;\n        15: ldc           #19                 // String method3()即将结束。。\n。\n        17: invokevirtual #9                  // Method java/io/PrintStream.pr\nintln:(Ljava/lang/String;)V\n        20: dload_1\n        21: dreturn\n      LineNumberTable:\n        line 42: 0\n        line 43: 8\n        line 44: 12\n        line 45: 20\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      22     0  this   Lcom/chggx/jvm/chapter05/stackframe/StackF\nrameTest;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n\n\n\n# 栈帧的内部结构\n\n每个栈帧中存储着：\n\n * 局部变量表（Local Variables）\n * 操作数栈（operand Stack）（或表达式栈）\n * 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）\n * 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）\n * 一些附加信息\n\n\n\n并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的\n\n\n\n\n# 3. 局部变量表（Local Variables Table）\n\n\n# 局部变量表初识\n\n 1. 局部变量表也被称之为局部变量数组或本地变量表\n\n 2. 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。\n\n 3. 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。\n\n 4. 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。\n\n通过 javap -v xxx.class 解析查看局部变量表\n\n\n\n通过jclasslib 查看\n\n\n\n 5. 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。\n 6. 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。\n\n\n# 关于Slot理解\n\n 1. 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束 (0,-1)。\n\n 2. 局部变量表，最基本的存储单位Slot(变量槽)。\n\n 3. 局部变量表中存放编译期可知的各种基本数据类型（8种）、引用类型（reference）、returnAddress类型的变量\n\n 4. 在局部变量表里，32位以内的类型只占用一个Slot（包括引用类型（reference）、returnAddress类型），64的类型（long和double）占用两个slot。\n    \n    * byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。\n    * long和double则占两个slot。\n\n 5. JVM会为局部变量中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量中指定的局部变量值。\n\n 6. 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上。\n\n 7. 如果需要访问局部变量表中的一个6bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）\n\n 8. 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用的this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列\n    \n    /**\n         * 如果当前帧是由构造方法或者实例方法创建的，那么`该对象引用的this将会存放在index为0的slot处`，其余的参数按照参数表顺序继续排列\n         */\n        public LocalVariablesTest() {\n            this.count = 1;\n        }\n    \n        public static void testStatic(){\n            LocalVariablesTest localVariablesTest = new LocalVariablesTest();\n            Date date = new Date();\n            int count = 10;\n            System.out.println(count);\n            // 静态方法中，不能使用 this\n            // 原因： this变量不存在于当前方法的局部变量表中\n            // System.out.println(this.count);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n\n示例代码\n\n/** 关于Slot的使用理解\n * 如果当前帧是由构造方法或者实例方法创建的，那么`该对象引用的this将会存放在index为0的slot处`，其余的参数按照参数表顺序继续排列\n */\n\npublic LocalVariablesTest() {\n    this.count = 1;\n}\n\n\npublic void test1(){\n    Date date = new Date();\n    String name1 = "chggx";\n    String info = test2(date,name1);\n    System.out.println(date+name1);\n}\n\npublic String test2(Date dateP, String name2) {\n    dateP = null;\n    name2 = "xiaoming";\n    double wight = 130.5;\n    char gender = \'男\';\n    return dateP + name2;\n}\n\npublic void test3(){\n    count++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n构造函数\n\n\n\ntest1\n\n\n\ntest2 （long/double）\n\n\n\ntest3\n\n\n\n\n# Slot的重复利用\n\n栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。\n\npublic void test4() {\n    int a = 0;\n    {\n        int b = 0;\n        b = a + 1;\n    }\n    //变量c使用之前已经销毁的变量b占据的slot的位置\n    int c = a + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\n# 静态变量与局部变量的对比\n\n变量的分类：\n   1. 按照数据类型分：① 基本数据类型  ② 引用数据类型\n   2. 按照在类中声明的位置分：\n        ① 成员变量：在使用前，都经历过默认初始化赋值\n                类变量： linking的prepare阶段：给类变量默认赋值  ---\x3e initial阶段：给类变量显式赋值即静态代码块赋值\n                实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值\n        ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n 1. 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。\n\n 2. 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。\n\n 3. 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。\n\n    public void test5Temp(){\n        int num;\n//        System.out.println(num);//错误信息：变量num未进行初始化 Variable \'num\' might not have been initialized\n    }\n\n\n1\n2\n3\n4\n\n\n 4. 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。\n\n 5. 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。\n\n\n# 4. 操作数栈（Operand Stack）\n\n * 栈： 可以使用数组或链表。\n\n\n# 概念\n\n 1. 每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为 表达式栈（Expression Stack）\n\n 2. 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）\n    \n    * 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈\n    * 比如：执行复制、交换、求和等操作\n\n\n\n示例代码\n\n\n\n 3.  操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。\n\n 4.  操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。\n     \n     > 这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的\n\n 5.  每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。\n\n 6.  栈中的任何一个元素都是可以任意的Java数据类型\n     \n     * 32bit的类型占用一个栈单位深度\n     * 64bit的类型占用两个栈单位深度\n     \n     > 同局部变量表\n\n 7.  操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问\n\n 8.  如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。\n\n 9.  操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|\n\n 10. 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。\n\n\n# 5. 代码追踪\n\n 1. 代码\n\npublic class OperandStackTest {\n\n    public void testAddOperation(){\n      byte i = 15;\n      int j = 8;\n      int k = i + j;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 使用 javap 命令编译class文件：javap -v 类名.class\n\n{\n  public com.chggx.jvm.chapter05.operandstack.OperandStackTest();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object."<init>":()V\n         4: return\n      LineNumberTable:\n        line 8: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/chggx/jvm/chapter05/operandstack/OperandStackTest;\n\n  public void testAddOperation();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=4, args_size=1\n         0: bipush        15\n         2: istore_1\n         3: bipush        8\n         5: istore_2\n         6: iload_1\n         7: iload_2\n         8: iadd\n         9: istore_3\n        10: return\n      LineNumberTable:\n        line 11: 0\n        line 12: 3\n        line 13: 6\n        line 14: 10\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      11     0  this   Lcom/chggx/jvm/chapter05/operandstack/OperandStackTest;\n            3       8     1     i   B\n            6       5     2     j   I\n           10       1     3     k   I\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n 3. jclasslib\n\n\n\n局部变量表 （Local Variables Table）\n\n\n\n 4. 执行流程\n\n\n\n\n\n\n\n\n\n\n# 6. 栈顶缓存技术\n\n前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要个更多的指令分派次数和内存读、写次数。\n\n由于操作数时存储在内存中的，因此频繁地执行内存读、写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读、写次数，提升执行引擎的执行效率。\n\n> 寄存器：指令少，执行速度快。\n\n\n# 7. 动态链接（Dynamic Linking）\n\n动态链接（或指向运行时常量池的方法引用）\n\n * 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invoedynamic指令。\n * 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调动了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。\n\n\n# 示例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/02 8:30\n * @Description: <h1> 动态链接 （Dynamic Linking） </h1>\n */\npublic class DynamicLinkingTest {\n\n    int num = 10;\n\n    public void methodA(){\n        System.out.println("methodA...");\n    }\n\n    public void methodB(){\n        System.out.println("methodB...");\n\n        methodA();\n\n        num++;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n字节码\n\nD:\\java-code\\java\\jvm\\target\\classes\\com\\chggx\\jvm\\chapter05\\dynamiclink>javap\n -v DynamicLinkingTest.class\nClassfile /D:/java-code/java/jvm/target/classes/com/chggx/jvm/chapter05/dynami\nclink/DynamicLinkingTest.class\n  Last modified 2020-10-2; size 742 bytes\n  MD5 checksum e156713fd6bff7d2a0bb8902bdfc7995\n  Compiled from "DynamicLinkingTest.java"\npublic class com.chggx.jvm.chapter05.dynamiclink.DynamicLinkingTest\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool: // 常量池\n   #1 = Methodref          #9.#23         // java/lang/Object."<init>":()V\n   #2 = Fieldref           #8.#24         // com/chggx/jvm/chapter05/dynamicli\nnk/DynamicLinkingTest.num:I\n   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/Pri\nntStream;\n   #4 = String             #27            // methodA...\n   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljav\na/lang/String;)V\n   #6 = String             #30            // methodB...\n   #7 = Methodref          #8.#31         // com/chggx/jvm/chapter05/dynamicli\nnk/DynamicLinkingTest.methodA:()V\n   #8 = Class              #32            // com/chggx/jvm/chapter05/dynamicli\nnk/DynamicLinkingTest\n   #9 = Class              #33            // java/lang/Object\n  #10 = Utf8               num\n  #11 = Utf8               I\n  #12 = Utf8               <init>\n  #13 = Utf8               ()V\n  #14 = Utf8               Code\n  #15 = Utf8               LineNumberTable\n  #16 = Utf8               LocalVariableTable\n  #17 = Utf8               this\n  #18 = Utf8               Lcom/chggx/jvm/chapter05/dynamiclink/DynamicLinking\nTest;\n  #19 = Utf8               methodA\n  #20 = Utf8               methodB\n  #21 = Utf8               SourceFile\n  #22 = Utf8               DynamicLinkingTest.java\n  #23 = NameAndType        #12:#13        // "<init>":()V\n  #24 = NameAndType        #10:#11        // num:I\n  #25 = Class              #34            // java/lang/System\n  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;\n  #27 = Utf8               methodA...\n  #28 = Class              #37            // java/io/PrintStream\n  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V\n  #30 = Utf8               methodB...\n  #31 = NameAndType        #19:#13        // methodA:()V\n  #32 = Utf8               com/chggx/jvm/chapter05/dynamiclink/DynamicLinkingT\nest\n  #33 = Utf8               java/lang/Object\n  #34 = Utf8               java/lang/System\n  #35 = Utf8               out\n  #36 = Utf8               Ljava/io/PrintStream;\n  #37 = Utf8               java/io/PrintStream\n  #38 = Utf8               println\n  #39 = Utf8               (Ljava/lang/String;)V\n{\n  int num;\n    descriptor: I\n    flags:\n\n  public com.chggx.jvm.chapter05.dynamiclink.DynamicLinkingTest();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object."<ini\nt>":()V\n         4: aload_0\n         5: bipush        10\n         7: putfield      #2                  // Field num:I\n        10: return\n      LineNumberTable:\n        line 8: 0\n        line 10: 4\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      11     0  this   Lcom/chggx/jvm/chapter05/dynamiclink/Dynam\nicLinkingTest;\n\n  public void methodA();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #3                  // Field java/lang/System.out:Lj\nava/io/PrintStream;\n         3: ldc           #4                  // String methodA...\n         5: invokevirtual #5                  // Method java/io/PrintStream.pr\nintln:(Ljava/lang/String;)V\n         8: return\n      LineNumberTable:\n        line 13: 0\n        line 14: 8\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  this   Lcom/chggx/jvm/chapter05/dynamiclink/Dynam\nicLinkingTest;\n\n  public void methodB();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=3, locals=1, args_size=1\n         0: getstatic     #3                  // Field java/lang/System.out:Lj\nava/io/PrintStream;\n         3: ldc           #6                  // String methodB...\n         5: invokevirtual #5                  // Method java/io/PrintStream.pr\nintln:(Ljava/lang/String;)V\n         8: aload_0\n         9: invokevirtual #7                  // Method methodA:()V\n        12: aload_0\n        13: dup\n        14: getfield      #2                  // Field num:I\n        17: iconst_1\n        18: iadd\n        19: putfield      #2                  // Field num:I\n        22: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n\n\n> Methodref: 方法引用\n\n\n# 执行流程图\n\n\n\n\n# 为什么需要常量池？\n\n常量池的作用：就是为了提供一些符号和常量，便于指令的识别。\n\n\n# 8. 方法的调用: 解析与分派\n\n\n# 静态链接和动态链接\n\n 1. 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。\n\n# 静态链接：\n\n当一个字节码文件被转装进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。\n\n# 动态链接：\n\n如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。\n\n\n# 早起绑定和晚期绑定\n\n 2. 对应的方法的绑定机制为：早起绑定和晚期绑定，绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。\n\n# 早期绑定\n\n早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，级即可将这个方法与所述的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方法将符号引用转换为直接引用。\n\n# 晚期绑定\n\n如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。\n\n# 示例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/03 9:19\n * @Description: <h1> 早期绑定和晚期绑定 </h1>\n */\npublic class Animal{\n\n    public void eat() {\n        System.out.println("动物进食");\n    }\n\n}\n\npublic interface HuntAble{\n\n    void hunt();\n\n}\n\npublic class Dog extends Animal implements HuntAble{\n\n    // @Override\n    // public void hunt() {\n    //     System.out.println("狗吃骨头");\n    // }\n\n    @Override\n    public void eat() {\n        System.out.println("捕食耗子，多管闲事");\n    }\n}\n\n\npublic class Cat extends Animal implements HuntAble{\n\n    /**\n     * 表现为： 早期绑定\n     */\n    public Cat() {\n        super();\n    }\n\n    /**\n     * 表现为： 早期绑定\n     * @param name\n     */\n    public Cat(String name){\n        this();\n    }\n\n    @Override\n    public void hunt() {\n        System.out.println("猫吃鱼");\n    }\n\n    @Override\n    public void eat() {\n        // 早期绑定\n        super.eat();\n        System.out.println("猫捉老鼠，天经地义");\n    }\n}\n\n/**\n * 多态\n */\npublic class AnimalTest {\n\n    /**\n     * 表现为： 晚期绑定\n     * @param animal\n     */\n    public void showAnimal(Animal animal){\n        animal.eat();\n    }\n\n    /**\n     * 表现为： 晚期绑定\n     * @param huntAble\n     */\n    public void showHunt(HuntAble huntAble){\n        huntAble.hunt();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n> 使用 jclasslib\n\n随着高级语言的横空出世，蕾丝Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种方式。\n\nJava中的任何一个普通的方法其实都具备虚函数的特性，它们相当于C++语言中的虚函数（C++则需要使用关键字virtual老显示定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来表标记这个方法。（final标记的方法不能被重写，无多态性）\n\n\n\n> virtual: 对应上图标记处\n\n\n# 虚方法和非虚方法\n\n# 非虚方法\n\n * 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。\n * 静态方法、私有方法、final方法、实例构造器、父类方法都是废墟方法。\n * 其他方法称为虚方法。\n\n> 子类对象的多态性使用前提：\n> \n> ① 类的继承关系\n> \n> ② 方法的重写\n> \n> ③ 与非虚方法相抵触\n\n# 虚拟机中提供了以下几条方法调用指令\n\n 1. 普通调用指令\n    * invokestatic：调用静态方法，解析阶段确定唯一方法版本\n    * invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本\n    * invokevirtual：调用所有虚方法\n    * invokeinterface：调用所接口\n 2. 动态调用指令\n    * invokedynamic：动态解析出需要调用的方法，然后执行\n\n> 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invoedynamic指令则支持由用户确定方法版。其中invokestatic指令和invoespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。\n\n# 普通调用指令示例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/03 10:45\n * @Description: <h1> 虚拟机中提供了以下几条方法调用指令 </h1>\n *  非虚方法\n *  - invokestatic：调用静态方法，解析阶段确定唯一方法版本\n *  - invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本\n *  虚方法\n *  - invokevirtual：调用所有虚方法\n *  - invokeinterface：调用所接口\n */\nclass Father {\n\n    public Father() {\n        System.out.println("father的构造器");\n    }\n\n    public static void showStatic(String str) {\n        System.out.println("father " + str);\n    }\n\n    public final void showFinal() {\n        System.out.println("father show final");\n    }\n\n    public void showCommon() {\n        System.out.println("father 普通方法");\n    }\n\n}\n\npublic class Son extends Father {\n\n    public Son() {\n        // invokestatic\n        super();\n    }\n\n    public Son(int age) {\n        // invokestatic\n        this();\n    }\n\n    /**\n     * 不是重写父类的静态方法，因为静态方法不能被重写\n     * @param str\n     */\n    public static void showStatic(String str) {\n        System.out.println("son " + str);\n    }\n\n    private void showPrivate(String str) {\n        System.out.println("son private " + str);\n    }\n\n    public void show() {\n        /*非虚方法*/\n        // invokestatic\n        showStatic("chggx.com");\n        // invokestatic\n        super.showStatic("good!");\n        // invokespecial\n        showPrivate("hello！");\n        // invokespecial\n        super.showCommon();\n        // invokespecial\n        super.showFinal();\n\n        // invokevirtual 因为此方法声明有final，不能被子类重写，所以也被认为此方法是非虚方法。\n        showFinal();\n\n        /*虚方法*/\n        // invokevirtual\n        showCommon();\n        // invokevirtual 自定义的方法\n        info();\n\n        MethodInterface in = null;\n        // invokeinterface\n        in.methodA();\n    }\n\n    public void info(){\n\n    }\n\n}\n\ninterface MethodInterface{\n    void methodA();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n# invokedynamic指令\n\n 1. JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现 【动态类型语言】支持而做的一种改进。\n 2. 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。\n 3. Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改。而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。\n\n# 动态类型语言和静态类型语言\n\n动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。\n\n说的再直白一点就是，静态类型语言是判断变量自身的类型信息，动态类型语言是判断变量值的类型信息，变量没有类型信，变量值才有类型信息，这是动态语言的一个重要特性。\n\n> Java：静态类型语言\n> \n> Python： 动态类型语言\n\n示例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/03 15:49\n * @Description: <h1> 静态类型语言和动态类型语言 </h1>\n * 体会 invokedynamic\n */\ninterface Func{\n    public boolean func(String str);\n}\n\npublic class Lambda {\n\n    public void lambda(Func func){\n        return;\n    }\n\n    public static void main(String[] args) {\n        Lambda lambda = new Lambda();\n        Func func = s->{\n            return true;\n        };\n\n        lambda.lambda(func);\n\n        lambda.lambda(s->{\n            return true;\n        });\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n> 调用lambda表达式出现 invokedynamic 关键字\n\n\n# 方法的重写\n\n# Java语言中方法重写的本质\n\n 1. 找到操作数栈的第一个元素多执行的对象的实际类型，记作C。\n 2. 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。\n 3. 否则，按照继承关系从下往上依次往C的各个弗雷进行第2步的搜索和验证过程。\n 4. 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。\n\n# IllegalAccessError 介绍\n\n程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个了发生了不兼容的改变。\n\n\n# 虚方法表\n\n * 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能印象到执行效率。因此，为了提高程序性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。\n\n * 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。\n\n * 那么虚方法表什么时候被创建？\n   \n   虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。\n\n# 示例\n\n\n\n\n# 9. 方法返回地址（Return Address）\n\n * 存放调用该方法的PC寄存器的值。\n\n * 一个方法的结束，用两种方式：\n   \n   正常执行 完成\n   \n   出现未处理的异常，非正常退出\n\n * 无论通过那种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\n\n * 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。\n\n * 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。\n\npublic class ReturnAddressTest {\n\n    public boolean methodBoolean() {\n        return false;\n    }\n\n    public byte methodByte() {\n        return 0;\n    }\n\n    public short methodShort() {\n        return 0;\n    }\n\n    public int methodInt() {\n        return 0;\n    }\n\n    public long methodLong() {\n        return 0L;\n    }\n\n    public float methodFloat() {\n        return 0.0f;\n    }\n\n    public double methodDouble() {\n        return 0.0;\n    }\n\n    public String methodString() {\n        return null;\n    }\n\n    public Date methodDate() {\n        return null;\n    }\n\n    public void methodVoid() {\n\n    }\n\n    static {\n        int i = 10;\n    }\n\n    public void method2() {\n\n        try {\n            method1();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public void method1() throws Exception {\n        FileReader fis = new FileReader("chggx.com");\n        char[] chars = new char[1024];\n        int len;\n        while ((len = fis.read(chars)) != -1) {\n            String str = new String(chars, 0, len);\n            System.out.println(str);\n        }\n        fis.close();\n    }\n\n    public static void main(String[] args) {\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n# 当一个方法开始执行后，只有两种方式可以退出这个方法：\n\n执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正产完成出口。\n\n * 一个方法在正常调用完成之后究竟是用哪一种返回指令还需要根据方法返回值的实际数据类型而定。\n * 在字节码指令中，返回指令包含itrturn（方返回值是boolean、byte、char、short和int类型时使用）、lreturn（long）、freturn（float）、dreturn（double）、以及areturn（引用类型），另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。\n\n在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在笨方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。\n\n方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。\n\n\n# 10. 一些附加信息\n\n栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。\n\n\n# 11. 栈的相关面试题\n\n\n# 1. 举例栈溢出的情况？\n\nStackOverflowError\n\n * 通过-Xss设置栈的大小；OOM\n\n\n# 2. 调整栈大小，就能保证不出现溢出吗？\n\n不能\n\n\n# 3. 分配的占内存越大越好吗？\n\n不是\n\n\n# 4. 垃圾回收是否会涉及到虚拟机栈？\n\n不会的\n\n            GC\n        ×   ×\n虚拟机栈    √   ×\n本地方法栈   √   ×\n堆       √   √\n方法区     √   √\n\n\n# 5. 方法中定义的局部变量是否线程安全？\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/03 22:16\n * @Description: <h1> 方法中定义的局部变量是否线程安全？  </h1>\n *  何为线程安全？\n *      如果只有一个线程才可以操作此数据，则笔试线程安全的。\n *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。\n */\npublic class StringBuilderTest {\n\n    /**\n     * s1的声明方式是线程安全的\n     */\n    public static void method1(){\n        // StringBuilder：线程不安全\n        StringBuilder s1 = new StringBuilder();\n        s1.append("a");\n        s1.append("b");\n        // ...\n    }\n\n    /**\n     * sb的操作过程：是线程不安全的\n     * @param sb\n     */\n    public static void method2(StringBuilder sb){\n        sb.append("a");\n        sb.append("b");\n        // ...\n    }\n\n    /**\n     * builder的操作： 是线程不安全的\n     * @return\n     */\n    public static StringBuilder method3(){\n        StringBuilder builder = new StringBuilder();\n        builder.append("a");\n        builder.append("b");\n        return builder;\n    }\n\n    /**\n     * builder的操作： 是线程安全的 (类似于method1)\n     * @return\n     */\n    public static String method4(){\n        StringBuilder builder = new StringBuilder();\n        builder.append("a");\n        builder.append("b");\n        return builder.toString();\n    }\n\n    public static void main(String[] args) {\n        StringBuilder stringBuilder = new StringBuilder();\n\n        new Thread(()->{\n            stringBuilder.append("a");\n            stringBuilder.append("b");\n        }).start();\n\n        method2(stringBuilder);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n',normalizedContent:'# jvm-虚拟机栈（java virtual machine stacks）\n\n\n# 1. 虚拟机栈概述\n\n由于跨平台性的设计，java的指令都是根据栈来设计的。不同平台cpu架构不同，所以不能设计为基于寄存器的。\n\n优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。\n\n有不少java开发人员一提到java内存结构，就会非常粗粒度地将jvm中的内存区理解为仅有java堆（heap）和java栈（stack）？为什么？\n\n首先栈是运行时的单位，而堆是存储的单位\n\n * 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。\n * 堆解决的是数据存储的问题，即数据怎么放，放哪里。\n\n\n# java虚拟机栈是什么？\n\njava虚拟机栈（java virtual machine stacks），早期也叫java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（stack frame），对应一次次的java方法调用。\n\n> 线程是私有的\n\n\n\n\n# 生命周期\n\n生命周期和线程一直\n\n\n# 作用\n\n主管java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分变量，并参与方法的调用和返回。\n\n * 局部变量：相较于成员变量（属性）\n * 基本数据变量：相较于引用类型变量（类、数组、接口）\n\n\n# 栈的特点\n\n * 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\n\n * jvm直接对java栈的操作只用两个：\n   \n   1）每个方法执行，伴随着进栈（入栈、压栈）\n   \n   2）执行结束后的出战工作\n\n * 对于栈来说不存在垃圾回收(gc)问题（栈存在溢出oom的情况）\n\n\n\n\n# 开发中遇到哪些异常？\n\n栈中可能出现的异常\n\njava 虚拟机规范允许java栈的大小是动态的或者是固定不变的。\n\n 1. 如果采用固定大小的java虚拟机栈，那每一个线程的java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个stackoverflowerror异常。\n\n/**\n * @author: chggx\n * @date: 2020/09/06 11:48\n * @description: <h1> 栈中可能出现的异常 </h1>\n */\npublic class stackerror {\n\n    /**\n     * 演示栈中的异常：stackoverflowerror\n     * @param args\n     */\n    public static void main(string[] args) {\n       main(args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n抛出异常\n\nexception in thread "main" java.lang.stackoverflowerror\n\tat com.chggx.jvm.chapter05.stackerror.main(stackerror.java:11)\n\tat com.chggx.jvm.chapter05.stackerror.main(stackerror.java:11)\n\tat com.chggx.jvm.chapter05.stackerror.main(stackerror.java:11)\n...\n\n\n1\n2\n3\n4\n5\n\n 2. 如果java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个 outofmemoryerror异常。\n\n\n# 设置栈的内存大小\n\n我们可以使用参数 -xss 选项来设置线程的最大站空间，栈的大小直接决定了函数的最大可达深度。\n\n设置线程堆栈大小(以字节为单位)。附加字母k或k表示kb, m或m表示mb, g或g表示gb。默认值取决于平台:\n\n * linux/x64(64位):1024 kb\n\n * macos(64位):1024 kb\n\n * oracle solaris/x64(64位):1024 kb\n\n * windows:默认值取决于虚拟内存\n\n下面的例子将线程栈大小设置为1024 kb，单位为不同:\n\n-xss1m\n-xss1024k\n-xss1048576\n\n\n1\n2\n3\n\n\n示例\n\n/**\n * @author: chggx\n * @date: 2020/09/06 11:48\n * @description: <h1> 设置栈的大小 </h1>\n */\npublic class stackerror2 {\n\n    private static int count = 1;\n    /**\n     * 默认情况下： count： 11413\n     * 设置栈的大小：-xss256k count：2468\n     * @param args\n     */\n    public static void main(string[] args) {\n        system.out.println(count);\n        count++;\n       main(args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2. 栈的存储单位\n\n\n# 栈中存储什么？\n\n * 每个线程都有自己的栈，栈中的数据都是以栈帧（stack frame）的格式存在。\n\n * 在这个线程正在执行的每个方法都有各自对应一个栈帧（stack frame）。\n\n * 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。\n\n> oop的基本概念：类和对象\n> \n> 类中基本结构：field（属性、字段、域）、method\n\n\n# 栈运行原理\n\n 1. jvm直接对java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出” 或 “后进先出”原则。\n\n 2. 在一条活动线程中，一个时间点上，只会有一个活跃的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（current frame），与当前栈帧相对应的方法就是当前方法（current method）, 定义这个方法的类就是当前类（current class）。\n\n\n\n 3. 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。\n\n 4. 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶部，称为新的当前栈帧。\n\n 5. 不同线程中所包含的栈帧是不允许存在相互引用的，既不能在一个栈帧之中引用另一个线程的栈帧。\n\n 6. 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回来此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。\n\n 7. java方法有两种返回函数的方式：\n    \n    * 一种是正常的函数返回，使用return指令。\n    * 一种是抛出异常。\n    \n    > 不管使用哪种方式，都会导致栈帧被弹出\n\n示例代码\n\n/**\n * @author: chggx\n * @date: 2020/09/06 14:42\n * @description: <h1> 栈帧运行原理示例 </h1>\n */\npublic class stackframetest {\n\n    public static void main(string[] args) {\n        stackframetest stackframetest = new stackframetest();\n        stackframetest.method1();\n    }\n\n    public void method1(){\n        system.out.println("method1()开始执行。。。");\n        method2();\n        system.out.println("method1()执行结束。。。");\n    }\n\n    public int method2() {\n        system.out.println("method2()开始执行。。。");\n        int i = 10;\n        int m = (int)method3();\n        system.out.println("method2()即将结束。。。");\n        return i + m;\n    }\n\n    public double method3() {\n        system.out.println("method3()开始执行。。。");\n        double j = 20.0;\n        system.out.println("method3()即将结束。。。");\n        return j;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n运行结果\n\nmethod1()开始执行。。。\nmethod2()开始执行。。。\nmethod3()开始执行。。。\nmethod3()即将结束。。。\nmethod2()即将结束。。。\nmethod1()执行结束。。。\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过degub模式查看栈信息（满足 先进后出/后进先出原则）\n\n\n\n反编译\n\njavap -v stackframetest.class\n\n\n1\n\n\n{\n  public com.chggx.jvm.chapter05.stackframe.stackframetest();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // method java/lang/object."<ini\nt>":()v\n         4: return\n      linenumbertable:\n        line 8: 0\n      localvariabletable:\n        start  length  slot  name   signature\n            0       5     0  this   lcom/chggx/jvm/chapter05/stackframe/stackf\nrametest;\n\n  public static void main(java.lang.string[]);\n    descriptor: ([ljava/lang/string;)v\n    flags: acc_public, acc_static\n    code:\n      stack=2, locals=2, args_size=1\n         0: new           #2                  // class com/chggx/jvm/chapter05\n/stackframe/stackframetest\n         3: dup\n         4: invokespecial #3                  // method "<init>":()v\n         7: astore_1\n         8: aload_1\n         9: invokevirtual #4                  // method method1:()v\n        12: goto          20\n        15: astore_1\n        16: aload_1\n        17: invokevirtual #6                  // method java/lang/exception.pr\nintstacktrace:()v\n        20: getstatic     #7                  // field java/lang/system.out:lj\nava/io/printstream;\n        23: ldc           #8                  // string main()正常结束\n        25: invokevirtual #9                  // method java/io/printstream.pr\nintln:(ljava/lang/string;)v\n        28: return\n      exception table:\n         from    to  target type\n             0    12    15   class java/lang/exception\n      linenumbertable:\n        line 18: 0\n        line 19: 8\n        line 22: 12\n        line 20: 15\n        line 21: 16\n        line 23: 20\n        line 24: 28\n      localvariabletable: // 局部变量表\n        start  length  slot  name   signature\n            8       4     1 stackframetest   lcom/chggx/jvm/chapter05/stackfra\nme/stackframetest;\n           16       4     1     e   ljava/lang/exception;\n            0      29     0  args   [ljava/lang/string;\n      stackmaptable: number_of_entries = 2\n        frame_type = 79 /* same_locals_1_stack_item */\n          stack = [ class java/lang/exception ]\n        frame_type = 4 /* same */\n\n  public void method1();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #7                  // field java/lang/system.out:lj\nava/io/printstream;\n         3: ldc           #10                 // string method1()开始执行。。\n。\n         5: invokevirtual #9                  // method java/io/printstream.pr\nintln:(ljava/lang/string;)v\n         8: aload_0\n         9: invokevirtual #11                 // method method2:()i\n        12: pop\n        13: getstatic     #7                  // field java/lang/system.out:lj\nava/io/printstream;\n        16: ldc           #12                 // string method1()执行结束。。\n。\n        18: invokevirtual #9                  // method java/io/printstream.pr\nintln:(ljava/lang/string;)v\n        21: return\n      linenumbertable:\n        line 27: 0\n        line 28: 8\n        line 29: 13\n        line 31: 21\n      localvariabletable:\n        start  length  slot  name   signature\n            0      22     0  this   lcom/chggx/jvm/chapter05/stackframe/stackf\nrametest;\n\n  public int method2();\n    descriptor: ()i\n    flags: acc_public\n    code:\n      stack=2, locals=3, args_size=1\n         0: getstatic     #7                  // field java/lang/system.out:lj\nava/io/printstream;\n         3: ldc           #13                 // string method2()开始执行。。\n。\n         5: invokevirtual #9                  // method java/io/printstream.pr\nintln:(ljava/lang/string;)v\n         8: bipush        10\n        10: istore_1\n        11: aload_0\n        12: invokevirtual #14                 // method method3:()d\n        15: d2i\n        16: istore_2\n        17: getstatic     #7                  // field java/lang/system.out:lj\nava/io/printstream;\n        20: ldc           #15                 // string method2()即将结束。。\n。\n        22: invokevirtual #9                  // method java/io/printstream.pr\nintln:(ljava/lang/string;)v\n        25: iload_1\n        26: iload_2\n        27: iadd\n        28: ireturn\n      linenumbertable:\n        line 34: 0\n        line 35: 8\n        line 36: 11\n        line 37: 17\n        line 38: 25\n      localvariabletable:\n        start  length  slot  name   signature\n            0      29     0  this   lcom/chggx/jvm/chapter05/stackframe/stackf\nrametest;\n           11      18     1     i   i\n           17      12     2     m   i\n\n  public double method3();\n    descriptor: ()d\n    flags: acc_public\n    code:\n      stack=2, locals=3, args_size=1\n         0: getstatic     #7                  // field java/lang/system.out:lj\nava/io/printstream;\n         3: ldc           #16                 // string method3()开始执行。。\n。\n         5: invokevirtual #9                  // method java/io/printstream.pr\nintln:(ljava/lang/string;)v\n         8: ldc2_w        #17                 // double 20.0d\n        11: dstore_1\n        12: getstatic     #7                  // field java/lang/system.out:lj\nava/io/printstream;\n        15: ldc           #19                 // string method3()即将结束。。\n。\n        17: invokevirtual #9                  // method java/io/printstream.pr\nintln:(ljava/lang/string;)v\n        20: dload_1\n        21: dreturn\n      linenumbertable:\n        line 42: 0\n        line 43: 8\n        line 44: 12\n        line 45: 20\n      localvariabletable:\n        start  length  slot  name   signature\n            0      22     0  this   lcom/chggx/jvm/chapter05/stackframe/stackf\nrametest;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n\n\n\n# 栈帧的内部结构\n\n每个栈帧中存储着：\n\n * 局部变量表（local variables）\n * 操作数栈（operand stack）（或表达式栈）\n * 动态链接（dynamic linking）（或指向运行时常量池的方法引用）\n * 方法返回地址（return address）（或方法正常退出或者异常退出的定义）\n * 一些附加信息\n\n\n\n并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的\n\n\n\n\n# 3. 局部变量表（local variables table）\n\n\n# 局部变量表初识\n\n 1. 局部变量表也被称之为局部变量数组或本地变量表\n\n 2. 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnaddress类型。\n\n 3. 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。\n\n 4. 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。\n\n通过 javap -v xxx.class 解析查看局部变量表\n\n\n\n通过jclasslib 查看\n\n\n\n 5. 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。\n 6. 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。\n\n\n# 关于slot理解\n\n 1. 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束 (0,-1)。\n\n 2. 局部变量表，最基本的存储单位slot(变量槽)。\n\n 3. 局部变量表中存放编译期可知的各种基本数据类型（8种）、引用类型（reference）、returnaddress类型的变量\n\n 4. 在局部变量表里，32位以内的类型只占用一个slot（包括引用类型（reference）、returnaddress类型），64的类型（long和double）占用两个slot。\n    \n    * byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。\n    * long和double则占两个slot。\n\n 5. jvm会为局部变量中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量中指定的局部变量值。\n\n 6. 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上。\n\n 7. 如果需要访问局部变量表中的一个6bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）\n\n 8. 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用的this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列\n    \n    /**\n         * 如果当前帧是由构造方法或者实例方法创建的，那么`该对象引用的this将会存放在index为0的slot处`，其余的参数按照参数表顺序继续排列\n         */\n        public localvariablestest() {\n            this.count = 1;\n        }\n    \n        public static void teststatic(){\n            localvariablestest localvariablestest = new localvariablestest();\n            date date = new date();\n            int count = 10;\n            system.out.println(count);\n            // 静态方法中，不能使用 this\n            // 原因： this变量不存在于当前方法的局部变量表中\n            // system.out.println(this.count);\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n\n示例代码\n\n/** 关于slot的使用理解\n * 如果当前帧是由构造方法或者实例方法创建的，那么`该对象引用的this将会存放在index为0的slot处`，其余的参数按照参数表顺序继续排列\n */\n\npublic localvariablestest() {\n    this.count = 1;\n}\n\n\npublic void test1(){\n    date date = new date();\n    string name1 = "chggx";\n    string info = test2(date,name1);\n    system.out.println(date+name1);\n}\n\npublic string test2(date datep, string name2) {\n    datep = null;\n    name2 = "xiaoming";\n    double wight = 130.5;\n    char gender = \'男\';\n    return datep + name2;\n}\n\npublic void test3(){\n    count++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n构造函数\n\n\n\ntest1\n\n\n\ntest2 （long/double）\n\n\n\ntest3\n\n\n\n\n# slot的重复利用\n\n栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。\n\npublic void test4() {\n    int a = 0;\n    {\n        int b = 0;\n        b = a + 1;\n    }\n    //变量c使用之前已经销毁的变量b占据的slot的位置\n    int c = a + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\n# 静态变量与局部变量的对比\n\n变量的分类：\n   1. 按照数据类型分：① 基本数据类型  ② 引用数据类型\n   2. 按照在类中声明的位置分：\n        ① 成员变量：在使用前，都经历过默认初始化赋值\n                类变量： linking的prepare阶段：给类变量默认赋值  ---\x3e initial阶段：给类变量显式赋值即静态代码块赋值\n                实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值\n        ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n 1. 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。\n\n 2. 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。\n\n 3. 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。\n\n    public void test5temp(){\n        int num;\n//        system.out.println(num);//错误信息：变量num未进行初始化 variable \'num\' might not have been initialized\n    }\n\n\n1\n2\n3\n4\n\n\n 4. 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。\n\n 5. 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。\n\n\n# 4. 操作数栈（operand stack）\n\n * 栈： 可以使用数组或链表。\n\n\n# 概念\n\n 1. 每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（last - in - first -out）的 操作数栈，也可以称之为 表达式栈（expression stack）\n\n 2. 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）\n    \n    * 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈\n    * 比如：执行复制、交换、求和等操作\n\n\n\n示例代码\n\n\n\n 3.  操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。\n\n 4.  操作数栈就是jvm执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。\n     \n     > 这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的\n\n 5.  每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的code属性中，为maxstack的值。\n\n 6.  栈中的任何一个元素都是可以任意的java数据类型\n     \n     * 32bit的类型占用一个栈单位深度\n     * 64bit的类型占用两个栈单位深度\n     \n     > 同局部变量表\n\n 7.  操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问\n\n 8.  如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新pc寄存器中下一条需要执行的字节码指令。\n\n 9.  操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|\n\n 10. 另外，我们说java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。\n\n\n# 5. 代码追踪\n\n 1. 代码\n\npublic class operandstacktest {\n\n    public void testaddoperation(){\n      byte i = 15;\n      int j = 8;\n      int k = i + j;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 使用 javap 命令编译class文件：javap -v 类名.class\n\n{\n  public com.chggx.jvm.chapter05.operandstack.operandstacktest();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // method java/lang/object."<init>":()v\n         4: return\n      linenumbertable:\n        line 8: 0\n      localvariabletable:\n        start  length  slot  name   signature\n            0       5     0  this   lcom/chggx/jvm/chapter05/operandstack/operandstacktest;\n\n  public void testaddoperation();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=2, locals=4, args_size=1\n         0: bipush        15\n         2: istore_1\n         3: bipush        8\n         5: istore_2\n         6: iload_1\n         7: iload_2\n         8: iadd\n         9: istore_3\n        10: return\n      linenumbertable:\n        line 11: 0\n        line 12: 3\n        line 13: 6\n        line 14: 10\n      localvariabletable:\n        start  length  slot  name   signature\n            0      11     0  this   lcom/chggx/jvm/chapter05/operandstack/operandstacktest;\n            3       8     1     i   b\n            6       5     2     j   i\n           10       1     3     k   i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n 3. jclasslib\n\n\n\n局部变量表 （local variables table）\n\n\n\n 4. 执行流程\n\n\n\n\n\n\n\n\n\n\n# 6. 栈顶缓存技术\n\n前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要个更多的指令分派次数和内存读、写次数。\n\n由于操作数时存储在内存中的，因此频繁地执行内存读、写操作必然会影响执行速度。为了解决这个问题，hotspot jvm的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理cpu的寄存器中，以此降低对内存的读、写次数，提升执行引擎的执行效率。\n\n> 寄存器：指令少，执行速度快。\n\n\n# 7. 动态链接（dynamic linking）\n\n动态链接（或指向运行时常量池的方法引用）\n\n * 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（dynamic linking）。比如：invoedynamic指令。\n * 在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic reference）保存在class文件的常量池里。比如：描述一个方法调动了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。\n\n\n# 示例\n\n/**\n * @author: chggx\n * @date: 2020/10/02 8:30\n * @description: <h1> 动态链接 （dynamic linking） </h1>\n */\npublic class dynamiclinkingtest {\n\n    int num = 10;\n\n    public void methoda(){\n        system.out.println("methoda...");\n    }\n\n    public void methodb(){\n        system.out.println("methodb...");\n\n        methoda();\n\n        num++;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n字节码\n\nd:\\java-code\\java\\jvm\\target\\classes\\com\\chggx\\jvm\\chapter05\\dynamiclink>javap\n -v dynamiclinkingtest.class\nclassfile /d:/java-code/java/jvm/target/classes/com/chggx/jvm/chapter05/dynami\nclink/dynamiclinkingtest.class\n  last modified 2020-10-2; size 742 bytes\n  md5 checksum e156713fd6bff7d2a0bb8902bdfc7995\n  compiled from "dynamiclinkingtest.java"\npublic class com.chggx.jvm.chapter05.dynamiclink.dynamiclinkingtest\n  minor version: 0\n  major version: 52\n  flags: acc_public, acc_super\nconstant pool: // 常量池\n   #1 = methodref          #9.#23         // java/lang/object."<init>":()v\n   #2 = fieldref           #8.#24         // com/chggx/jvm/chapter05/dynamicli\nnk/dynamiclinkingtest.num:i\n   #3 = fieldref           #25.#26        // java/lang/system.out:ljava/io/pri\nntstream;\n   #4 = string             #27            // methoda...\n   #5 = methodref          #28.#29        // java/io/printstream.println:(ljav\na/lang/string;)v\n   #6 = string             #30            // methodb...\n   #7 = methodref          #8.#31         // com/chggx/jvm/chapter05/dynamicli\nnk/dynamiclinkingtest.methoda:()v\n   #8 = class              #32            // com/chggx/jvm/chapter05/dynamicli\nnk/dynamiclinkingtest\n   #9 = class              #33            // java/lang/object\n  #10 = utf8               num\n  #11 = utf8               i\n  #12 = utf8               <init>\n  #13 = utf8               ()v\n  #14 = utf8               code\n  #15 = utf8               linenumbertable\n  #16 = utf8               localvariabletable\n  #17 = utf8               this\n  #18 = utf8               lcom/chggx/jvm/chapter05/dynamiclink/dynamiclinking\ntest;\n  #19 = utf8               methoda\n  #20 = utf8               methodb\n  #21 = utf8               sourcefile\n  #22 = utf8               dynamiclinkingtest.java\n  #23 = nameandtype        #12:#13        // "<init>":()v\n  #24 = nameandtype        #10:#11        // num:i\n  #25 = class              #34            // java/lang/system\n  #26 = nameandtype        #35:#36        // out:ljava/io/printstream;\n  #27 = utf8               methoda...\n  #28 = class              #37            // java/io/printstream\n  #29 = nameandtype        #38:#39        // println:(ljava/lang/string;)v\n  #30 = utf8               methodb...\n  #31 = nameandtype        #19:#13        // methoda:()v\n  #32 = utf8               com/chggx/jvm/chapter05/dynamiclink/dynamiclinkingt\nest\n  #33 = utf8               java/lang/object\n  #34 = utf8               java/lang/system\n  #35 = utf8               out\n  #36 = utf8               ljava/io/printstream;\n  #37 = utf8               java/io/printstream\n  #38 = utf8               println\n  #39 = utf8               (ljava/lang/string;)v\n{\n  int num;\n    descriptor: i\n    flags:\n\n  public com.chggx.jvm.chapter05.dynamiclink.dynamiclinkingtest();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // method java/lang/object."<ini\nt>":()v\n         4: aload_0\n         5: bipush        10\n         7: putfield      #2                  // field num:i\n        10: return\n      linenumbertable:\n        line 8: 0\n        line 10: 4\n      localvariabletable:\n        start  length  slot  name   signature\n            0      11     0  this   lcom/chggx/jvm/chapter05/dynamiclink/dynam\niclinkingtest;\n\n  public void methoda();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #3                  // field java/lang/system.out:lj\nava/io/printstream;\n         3: ldc           #4                  // string methoda...\n         5: invokevirtual #5                  // method java/io/printstream.pr\nintln:(ljava/lang/string;)v\n         8: return\n      linenumbertable:\n        line 13: 0\n        line 14: 8\n      localvariabletable:\n        start  length  slot  name   signature\n            0       9     0  this   lcom/chggx/jvm/chapter05/dynamiclink/dynam\niclinkingtest;\n\n  public void methodb();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=3, locals=1, args_size=1\n         0: getstatic     #3                  // field java/lang/system.out:lj\nava/io/printstream;\n         3: ldc           #6                  // string methodb...\n         5: invokevirtual #5                  // method java/io/printstream.pr\nintln:(ljava/lang/string;)v\n         8: aload_0\n         9: invokevirtual #7                  // method methoda:()v\n        12: aload_0\n        13: dup\n        14: getfield      #2                  // field num:i\n        17: iconst_1\n        18: iadd\n        19: putfield      #2                  // field num:i\n        22: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n\n\n> methodref: 方法引用\n\n\n# 执行流程图\n\n\n\n\n# 为什么需要常量池？\n\n常量池的作用：就是为了提供一些符号和常量，便于指令的识别。\n\n\n# 8. 方法的调用: 解析与分派\n\n\n# 静态链接和动态链接\n\n 1. 在jvm中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。\n\n# 静态链接：\n\n当一个字节码文件被转装进jvm内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。\n\n# 动态链接：\n\n如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。\n\n\n# 早起绑定和晚期绑定\n\n 2. 对应的方法的绑定机制为：早起绑定和晚期绑定，绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。\n\n# 早期绑定\n\n早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，级即可将这个方法与所述的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方法将符号引用转换为直接引用。\n\n# 晚期绑定\n\n如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。\n\n# 示例\n\n/**\n * @author: chggx\n * @date: 2020/10/03 9:19\n * @description: <h1> 早期绑定和晚期绑定 </h1>\n */\npublic class animal{\n\n    public void eat() {\n        system.out.println("动物进食");\n    }\n\n}\n\npublic interface huntable{\n\n    void hunt();\n\n}\n\npublic class dog extends animal implements huntable{\n\n    // @override\n    // public void hunt() {\n    //     system.out.println("狗吃骨头");\n    // }\n\n    @override\n    public void eat() {\n        system.out.println("捕食耗子，多管闲事");\n    }\n}\n\n\npublic class cat extends animal implements huntable{\n\n    /**\n     * 表现为： 早期绑定\n     */\n    public cat() {\n        super();\n    }\n\n    /**\n     * 表现为： 早期绑定\n     * @param name\n     */\n    public cat(string name){\n        this();\n    }\n\n    @override\n    public void hunt() {\n        system.out.println("猫吃鱼");\n    }\n\n    @override\n    public void eat() {\n        // 早期绑定\n        super.eat();\n        system.out.println("猫捉老鼠，天经地义");\n    }\n}\n\n/**\n * 多态\n */\npublic class animaltest {\n\n    /**\n     * 表现为： 晚期绑定\n     * @param animal\n     */\n    public void showanimal(animal animal){\n        animal.eat();\n    }\n\n    /**\n     * 表现为： 晚期绑定\n     * @param huntable\n     */\n    public void showhunt(huntable huntable){\n        huntable.hunt();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n> 使用 jclasslib\n\n随着高级语言的横空出世，蕾丝java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种方式。\n\njava中的任何一个普通的方法其实都具备虚函数的特性，它们相当于c++语言中的虚函数（c++则需要使用关键字virtual老显示定义）。如果在java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来表标记这个方法。（final标记的方法不能被重写，无多态性）\n\n\n\n> virtual: 对应上图标记处\n\n\n# 虚方法和非虚方法\n\n# 非虚方法\n\n * 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。\n * 静态方法、私有方法、final方法、实例构造器、父类方法都是废墟方法。\n * 其他方法称为虚方法。\n\n> 子类对象的多态性使用前提：\n> \n> ① 类的继承关系\n> \n> ② 方法的重写\n> \n> ③ 与非虚方法相抵触\n\n# 虚拟机中提供了以下几条方法调用指令\n\n 1. 普通调用指令\n    * invokestatic：调用静态方法，解析阶段确定唯一方法版本\n    * invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本\n    * invokevirtual：调用所有虚方法\n    * invokeinterface：调用所接口\n 2. 动态调用指令\n    * invokedynamic：动态解析出需要调用的方法，然后执行\n\n> 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invoedynamic指令则支持由用户确定方法版。其中invokestatic指令和invoespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。\n\n# 普通调用指令示例\n\n/**\n * @author: chggx\n * @date: 2020/10/03 10:45\n * @description: <h1> 虚拟机中提供了以下几条方法调用指令 </h1>\n *  非虚方法\n *  - invokestatic：调用静态方法，解析阶段确定唯一方法版本\n *  - invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本\n *  虚方法\n *  - invokevirtual：调用所有虚方法\n *  - invokeinterface：调用所接口\n */\nclass father {\n\n    public father() {\n        system.out.println("father的构造器");\n    }\n\n    public static void showstatic(string str) {\n        system.out.println("father " + str);\n    }\n\n    public final void showfinal() {\n        system.out.println("father show final");\n    }\n\n    public void showcommon() {\n        system.out.println("father 普通方法");\n    }\n\n}\n\npublic class son extends father {\n\n    public son() {\n        // invokestatic\n        super();\n    }\n\n    public son(int age) {\n        // invokestatic\n        this();\n    }\n\n    /**\n     * 不是重写父类的静态方法，因为静态方法不能被重写\n     * @param str\n     */\n    public static void showstatic(string str) {\n        system.out.println("son " + str);\n    }\n\n    private void showprivate(string str) {\n        system.out.println("son private " + str);\n    }\n\n    public void show() {\n        /*非虚方法*/\n        // invokestatic\n        showstatic("chggx.com");\n        // invokestatic\n        super.showstatic("good!");\n        // invokespecial\n        showprivate("hello！");\n        // invokespecial\n        super.showcommon();\n        // invokespecial\n        super.showfinal();\n\n        // invokevirtual 因为此方法声明有final，不能被子类重写，所以也被认为此方法是非虚方法。\n        showfinal();\n\n        /*虚方法*/\n        // invokevirtual\n        showcommon();\n        // invokevirtual 自定义的方法\n        info();\n\n        methodinterface in = null;\n        // invokeinterface\n        in.methoda();\n    }\n\n    public void info(){\n\n    }\n\n}\n\ninterface methodinterface{\n    void methoda();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n# invokedynamic指令\n\n 1. jvm字节码指令集一直比较稳定，一直到java7中才增加了一个invokedynamic指令，这是java为了实现 【动态类型语言】支持而做的一种改进。\n 2. 但是在java7中并没有提供直接生成invokedynamic指令的方法，需要借助asm这种底层字节码工具来产生invokedynamic指令。直到java8的lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接的生成方式。\n 3. java7中增加的动态语言类型支持的本质是对java虚拟机规范的修改。而不是对java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在java平台的动态语言的编译器。\n\n# 动态类型语言和静态类型语言\n\n动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。\n\n说的再直白一点就是，静态类型语言是判断变量自身的类型信息，动态类型语言是判断变量值的类型信息，变量没有类型信，变量值才有类型信息，这是动态语言的一个重要特性。\n\n> java：静态类型语言\n> \n> python： 动态类型语言\n\n示例\n\n/**\n * @author: chggx\n * @date: 2020/10/03 15:49\n * @description: <h1> 静态类型语言和动态类型语言 </h1>\n * 体会 invokedynamic\n */\ninterface func{\n    public boolean func(string str);\n}\n\npublic class lambda {\n\n    public void lambda(func func){\n        return;\n    }\n\n    public static void main(string[] args) {\n        lambda lambda = new lambda();\n        func func = s->{\n            return true;\n        };\n\n        lambda.lambda(func);\n\n        lambda.lambda(s->{\n            return true;\n        });\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n> 调用lambda表达式出现 invokedynamic 关键字\n\n\n# 方法的重写\n\n# java语言中方法重写的本质\n\n 1. 找到操作数栈的第一个元素多执行的对象的实际类型，记作c。\n 2. 如果在类型c中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.illegalaccesserror 异常。\n 3. 否则，按照继承关系从下往上依次往c的各个弗雷进行第2步的搜索和验证过程。\n 4. 如果始终没有找到合适的方法，则抛出 java.lang.abstractmethoderror 异常。\n\n# illegalaccesserror 介绍\n\n程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个了发生了不兼容的改变。\n\n\n# 虚方法表\n\n * 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能印象到执行效率。因此，为了提高程序性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。\n\n * 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。\n\n * 那么虚方法表什么时候被创建？\n   \n   虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，jvm会把该类的方法表也初始化完毕。\n\n# 示例\n\n\n\n\n# 9. 方法返回地址（return address）\n\n * 存放调用该方法的pc寄存器的值。\n\n * 一个方法的结束，用两种方式：\n   \n   正常执行 完成\n   \n   出现未处理的异常，非正常退出\n\n * 无论通过那种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\n\n * 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置pc寄存器值等，让调用者方法继续执行下去。\n\n * 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。\n\npublic class returnaddresstest {\n\n    public boolean methodboolean() {\n        return false;\n    }\n\n    public byte methodbyte() {\n        return 0;\n    }\n\n    public short methodshort() {\n        return 0;\n    }\n\n    public int methodint() {\n        return 0;\n    }\n\n    public long methodlong() {\n        return 0l;\n    }\n\n    public float methodfloat() {\n        return 0.0f;\n    }\n\n    public double methoddouble() {\n        return 0.0;\n    }\n\n    public string methodstring() {\n        return null;\n    }\n\n    public date methoddate() {\n        return null;\n    }\n\n    public void methodvoid() {\n\n    }\n\n    static {\n        int i = 10;\n    }\n\n    public void method2() {\n\n        try {\n            method1();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n\n    }\n\n    public void method1() throws exception {\n        filereader fis = new filereader("chggx.com");\n        char[] chars = new char[1024];\n        int len;\n        while ((len = fis.read(chars)) != -1) {\n            string str = new string(chars, 0, len);\n            system.out.println(str);\n        }\n        fis.close();\n    }\n\n    public static void main(string[] args) {\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n# 当一个方法开始执行后，只有两种方式可以退出这个方法：\n\n执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正产完成出口。\n\n * 一个方法在正常调用完成之后究竟是用哪一种返回指令还需要根据方法返回值的实际数据类型而定。\n * 在字节码指令中，返回指令包含itrturn（方返回值是boolean、byte、char、short和int类型时使用）、lreturn（long）、freturn（float）、dreturn（double）、以及areturn（引用类型），另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。\n\n在方法执行的过程中遇到了异常（exception），并且这个异常没有在方法内进行处理，也就是只要在笨方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。\n\n方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。\n\n\n# 10. 一些附加信息\n\n栈帧中还允许携带与java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。\n\n\n# 11. 栈的相关面试题\n\n\n# 1. 举例栈溢出的情况？\n\nstackoverflowerror\n\n * 通过-xss设置栈的大小；oom\n\n\n# 2. 调整栈大小，就能保证不出现溢出吗？\n\n不能\n\n\n# 3. 分配的占内存越大越好吗？\n\n不是\n\n\n# 4. 垃圾回收是否会涉及到虚拟机栈？\n\n不会的\n\n            gc\n        ×   ×\n虚拟机栈    √   ×\n本地方法栈   √   ×\n堆       √   √\n方法区     √   √\n\n\n# 5. 方法中定义的局部变量是否线程安全？\n\n/**\n * @author: chggx\n * @date: 2020/10/03 22:16\n * @description: <h1> 方法中定义的局部变量是否线程安全？  </h1>\n *  何为线程安全？\n *      如果只有一个线程才可以操作此数据，则笔试线程安全的。\n *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。\n */\npublic class stringbuildertest {\n\n    /**\n     * s1的声明方式是线程安全的\n     */\n    public static void method1(){\n        // stringbuilder：线程不安全\n        stringbuilder s1 = new stringbuilder();\n        s1.append("a");\n        s1.append("b");\n        // ...\n    }\n\n    /**\n     * sb的操作过程：是线程不安全的\n     * @param sb\n     */\n    public static void method2(stringbuilder sb){\n        sb.append("a");\n        sb.append("b");\n        // ...\n    }\n\n    /**\n     * builder的操作： 是线程不安全的\n     * @return\n     */\n    public static stringbuilder method3(){\n        stringbuilder builder = new stringbuilder();\n        builder.append("a");\n        builder.append("b");\n        return builder;\n    }\n\n    /**\n     * builder的操作： 是线程安全的 (类似于method1)\n     * @return\n     */\n    public static string method4(){\n        stringbuilder builder = new stringbuilder();\n        builder.append("a");\n        builder.append("b");\n        return builder.tostring();\n    }\n\n    public static void main(string[] args) {\n        stringbuilder stringbuilder = new stringbuilder();\n\n        new thread(()->{\n            stringbuilder.append("a");\n            stringbuilder.append("b");\n        }).start();\n\n        method2(stringbuilder);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-本地方法栈",frontmatter:{title:"JVM-本地方法栈",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/ba6197/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/7.JVM-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88.html",relativePath:"01.语言/01.JAVA语言/02.JVM/7.JVM-本地方法栈.md",key:"v-6d5c62aa",path:"/pages/ba6197/",headersStr:null,content:"# JVM-本地方法栈\n\n * Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。\n\n * 本地方法栈，也是线程私有的。\n\n * 允许被实现成固定或者可动态扩展的内存大小。（在内存溢出方面是相同的）\n   \n   如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError异常。\n   \n   㘝本地方法栈可以动态扩展，并且在常是扩展的时候无法申请到足够的内存，或者在创建新的线程是没有足够的内存去创建对应的本地方法栈，那么Java虚拟机栈将会抛出一个OutOfMemoryError异常。\n\n * 本地方法是使用C语言实现的。\n\n * 它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。\n\n\n\n当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。\n\n * 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。\n * 它甚至可以直接使用本地处理器中的寄存器\n * 直接从本地内存的堆中分配任意数量的内存。\n\n并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。\n\n在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。",normalizedContent:"# jvm-本地方法栈\n\n * java虚拟机栈用于管理java方法的调用，而本地方法栈用于管理本地方法的调用。\n\n * 本地方法栈，也是线程私有的。\n\n * 允许被实现成固定或者可动态扩展的内存大小。（在内存溢出方面是相同的）\n   \n   如果线程请求分配的栈容量超过本地方法栈允许的最大容量，java虚拟机将会抛出一个stackoverflowerror异常。\n   \n   㘝本地方法栈可以动态扩展，并且在常是扩展的时候无法申请到足够的内存，或者在创建新的线程是没有足够的内存去创建对应的本地方法栈，那么java虚拟机栈将会抛出一个outofmemoryerror异常。\n\n * 本地方法是使用c语言实现的。\n\n * 它的具体做法是native method stack中登记native方法，在execution engine执行时加载本地方法库。\n\n\n\n当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。\n\n * 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。\n * 它甚至可以直接使用本地处理器中的寄存器\n * 直接从本地内存的堆中分配任意数量的内存。\n\n并不是所有的jvm都支持本地方法。因为java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果jvm产品不打算支持native方法，也可以无需实现本地方法栈。\n\n在hotspot jvm中，直接将本地方法栈和虚拟机栈合二为一。",charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-堆",frontmatter:{title:"JVM-堆",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/32d7be/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/8.JVM-%E5%A0%86.html",relativePath:"01.语言/01.JAVA语言/02.JVM/8.JVM-堆.md",key:"v-0658261e",path:"/pages/32d7be/",headers:[{level:2,title:"1. 堆的核心",slug:"_1-堆的核心",normalizedTitle:"1. 堆的核心",charIndex:62},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:74},{level:3,title:"内存细分",slug:"内存细分",normalizedTitle:"内存细分",charIndex:1337},{level:4,title:"堆空间内部结构",slug:"堆空间内部结构",normalizedTitle:"堆空间内部结构",charIndex:1794},{level:5,title:"JDK7",slug:"jdk7",normalizedTitle:"jdk7",charIndex:1805},{level:5,title:"JDK8",slug:"jdk8",normalizedTitle:"jdk8",charIndex:1815},{level:2,title:"2. 设置堆内存大小与OOM",slug:"_2-设置堆内存大小与oom",normalizedTitle:"2. 设置堆内存大小与oom",charIndex:1887},{level:3,title:"堆空间大小设置",slug:"堆空间大小设置",normalizedTitle:"堆空间大小设置",charIndex:1906},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:861},{level:3,title:"OutOfMemory举例",slug:"outofmemory举例",normalizedTitle:"outofmemory举例",charIndex:3455},{level:2,title:"3. 年轻代与老年代",slug:"_3-年轻代与老年代",normalizedTitle:"3. 年轻代与老年代",charIndex:4439},{level:2,title:"4. 图解对象分配过程",slug:"_4-图解对象分配过程",normalizedTitle:"4. 图解对象分配过程",charIndex:5854},{level:3,title:"1. 概述",slug:"_1-概述",normalizedTitle:"1. 概述",charIndex:5870},{level:3,title:"2. 图解对象分配",slug:"_2-图解对象分配",normalizedTitle:"2. 图解对象分配",charIndex:6400},{level:3,title:"3. 思考：幸存者区满了后？",slug:"_3-思考-幸存者区满了后",normalizedTitle:"3. 思考：幸存者区满了后？",charIndex:6816},{level:3,title:"4. 对象分配的特殊情况",slug:"_4-对象分配的特殊情况",normalizedTitle:"4. 对象分配的特殊情况",charIndex:7012},{level:3,title:"5. 代码演示对象分配过程",slug:"_5-代码演示对象分配过程",normalizedTitle:"5. 代码演示对象分配过程",charIndex:7031},{level:3,title:"6.  常用调优工具",slug:"_6-常用调优工具",normalizedTitle:"6.  常用调优工具",charIndex:null},{level:3,title:"7. 总结",slug:"_7-总结",normalizedTitle:"7. 总结",charIndex:8168},{level:2,title:"5. Minor GC、Major GC、FULL GC",slug:"_5-minor-gc、major-gc、full-gc",normalizedTitle:"5. minor gc、major gc、full gc",charIndex:8280},{level:3,title:"概述",slug:"概述-2",normalizedTitle:"概述",charIndex:74},{level:3,title:"最简单的分代式GC策略的触发条件",slug:"最简单的分代式gc策略的触发条件",normalizedTitle:"最简单的分代式gc策略的触发条件",charIndex:8930},{level:3,title:"示例",slug:"示例-2",normalizedTitle:"示例",charIndex:861},{level:2,title:"6. 堆空间分代思想",slug:"_6-堆空间分代思想",normalizedTitle:"6. 堆空间分代思想",charIndex:12548},{level:3,title:"为什么需要把Java堆分代？不分代就不能正常工作了吗？",slug:"为什么需要把java堆分代-不分代就不能正常工作了吗",normalizedTitle:"为什么需要把java堆分代？不分代就不能正常工作了吗？",charIndex:12563},{level:2,title:"7. 内存分配策略",slug:"_7-内存分配策略",normalizedTitle:"7. 内存分配策略",charIndex:12904},{level:2,title:"8. 为对象分配内存：TLAB",slug:"_8-为对象分配内存-tlab",normalizedTitle:"8. 为对象分配内存：tlab",charIndex:13574},{level:3,title:"问题：堆空间都是共享的么？",slug:"问题-堆空间都是共享的么",normalizedTitle:"问题：堆空间都是共享的么？",charIndex:13594},{level:3,title:"为什么有TLAB？",slug:"为什么有tlab",normalizedTitle:"为什么有tlab？",charIndex:13650},{level:3,title:"什么是TLAB",slug:"什么是tlab",normalizedTitle:"什么是tlab",charIndex:13840},{level:3,title:"TLAB分配过程",slug:"tlab分配过程",normalizedTitle:"tlab分配过程",charIndex:14285},{level:2,title:"9. 小结：堆空间的参数设置",slug:"_9-小结-堆空间的参数设置",normalizedTitle:"9. 小结：堆空间的参数设置",charIndex:14340},{level:2,title:"10. 堆是分配对象的唯一选择吗？",slug:"_10-堆是分配对象的唯一选择吗",normalizedTitle:"10. 堆是分配对象的唯一选择吗？",charIndex:15306},{level:3,title:"1. 逃逸分析",slug:"_1-逃逸分析",normalizedTitle:"1. 逃逸分析",charIndex:15332},{level:4,title:"1. 完整的逃逸分析代码举例",slug:"_1-完整的逃逸分析代码举例",normalizedTitle:"1. 完整的逃逸分析代码举例",charIndex:16606},{level:4,title:"2. 参数设置",slug:"_2-参数设置",normalizedTitle:"2. 参数设置",charIndex:17525},{level:4,title:"3. 结论",slug:"_3-结论",normalizedTitle:"3. 结论",charIndex:17679},{level:3,title:"2. 逃逸分析：代码优化",slug:"_2-逃逸分析-代码优化",normalizedTitle:"2. 逃逸分析：代码优化",charIndex:17715},{level:4,title:"栈上分配",slug:"栈上分配",normalizedTitle:"栈上分配",charIndex:632},{level:4,title:"举例",slug:"举例",normalizedTitle:"举例",charIndex:3466},{level:3,title:"同步省略",slug:"同步省略",normalizedTitle:"同步省略",charIndex:17829},{level:3,title:"分离对象和标量替换",slug:"分离对象和标量替换",normalizedTitle:"分离对象和标量替换",charIndex:19818},{level:3,title:"代码优化之标量替换",slug:"代码优化之标量替换",normalizedTitle:"代码优化之标量替换",charIndex:20576},{level:3,title:"逃逸分析的不足",slug:"逃逸分析的不足",normalizedTitle:"逃逸分析的不足",charIndex:21039},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:14343}],headersStr:"1. 堆的核心 概述 内存细分 堆空间内部结构 JDK7 JDK8 2. 设置堆内存大小与OOM 堆空间大小设置 示例 OutOfMemory举例 3. 年轻代与老年代 4. 图解对象分配过程 1. 概述 2. 图解对象分配 3. 思考：幸存者区满了后？ 4. 对象分配的特殊情况 5. 代码演示对象分配过程 6.  常用调优工具 7. 总结 5. Minor GC、Major GC、FULL GC 概述 最简单的分代式GC策略的触发条件 示例 6. 堆空间分代思想 为什么需要把Java堆分代？不分代就不能正常工作了吗？ 7. 内存分配策略 8. 为对象分配内存：TLAB 问题：堆空间都是共享的么？ 为什么有TLAB？ 什么是TLAB TLAB分配过程 9. 小结：堆空间的参数设置 10. 堆是分配对象的唯一选择吗？ 1. 逃逸分析 1. 完整的逃逸分析代码举例 2. 参数设置 3. 结论 2. 逃逸分析：代码优化 栈上分配 举例 同步省略 分离对象和标量替换 代码优化之标量替换 逃逸分析的不足 小结",content:'# JVM-堆\n\n> 堆相当于一个进程，一个进程对应一个JVM实例，一个进程对应多个线程，他们是共享同一堆空间的。\n\n\n# 1. 堆的核心\n\n\n# 概述\n\n 1. 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。\n\n 2. Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。\n    \n    * 堆内存的大小是可以调节的。\n\n 3. 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。\n\n 4. 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。\n\n> -Xms10m：最小堆内存\n> \n> -Xmx10m：最大堆内存\n> \n> 下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk 中bin目录下提供的插件\n\n\n\n 5. 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）\n    \n    * 我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。\n    * 因为还有一些对象是在栈上分配的\n\n 6. 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。]\n\n 7. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。\n    \n    * 也就是触发了GC的时候，才会进行回收\n    * 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word\n\n 8. 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。\n\n示例\n\npublic class SimpleHeap {\n\n    private int id;\n\n    public SimpleHeap(int id) {\n        this.id = id;\n    }\n\n    public void show() {\n        System.out.println("My ID is " + id);\n    }\n\n    public static void main(String[] args) {\n        SimpleHeap s1 = new SimpleHeap(1);\n        SimpleHeap s2 = new SimpleHeap(2);\n        \n        int[] arr = new int[10];\n        Object[] arr1 = new Object[10];\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n\n# 内存细分\n\n现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：\n\n 1. Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区\n    \n    * Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区\n    * Tenure generation space 养老区 Old/Tenure\n    * Permanent Space永久区 Perm\n\n 2. Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间\n    \n    * Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区\n    * Tenure generation space 养老区 Old/Tenure\n    * Meta Space 元空间 Meta\n\n 3. 约定：新生区 -> 新生代 -> 年轻代 、 养老区 -> 老年区 -> 老年代、 永久区 -> 永久代\n\n# 堆空间内部结构\n\n# JDK7\n\n\n\n# JDK8\n\n\n\n测试\n\n> -Xms10m -Xmx10m -XX:+PrintGCDetails\n\nJava8\n\n\n\nJava7\n\n\n\n\n# 2. 设置堆内存大小与OOM\n\n\n# 堆空间大小设置\n\n 1. Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项“-Xmx”和”-Xms：来进行设置。\n    \n    * “-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize\n    * “-Xmx”用于表示堆区的最大内存，等价于-XX:MaxHeapSize\n\n 2. 一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。\n\n 3. 通常会将-Xmx和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算机堆区的大小，从而提高性能。\n\n 4. 默认情况下，初始内存大小：物理电脑内存大小 / 64\n    \n    最大内存大小：物理电脑内存大小 / 4\n\n\n# 示例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/04 11:16\n * @Description: <h1>  </h1>\n * 1. 设置堆空间大小的参数\n * -Xms：用来设置堆空间（年轻代+老年代）的初始内存大小\n * -X 是jvm的运行参数\n * ms 是memory start\n * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小\n * <p>\n * 2. 默认堆空间的大小\n * 初始内存大小：物理电脑内存大小 / 64\n * 最大内存大小：物理电脑内存大小  / 4\n * <p>\n * 3. 手动设置：-Xms600m -Xmx600m\n * 开发中建议：将初始化堆内存和最大堆内存设置成相同的值。\n * <p>\n * 4. 查看设置的参数：\n * 方式一： jps / jstat -gc 进程ID\n * 方式二：-XX+PrintGCDetails\n */\npublic class HeapSpaceInitial {\n\n    public static void main(String[] args) {\n        // 返回Java虚拟机中的对内存总量\n        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\n        // 返回Java虚拟机视图使用的最大堆内存容量\n        long maxMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\n\n        System.out.println("-Xms : " + initialMemory + "M");\n        System.out.println("-Xmx : " + maxMemory + "M");\n\n        System.out.println("系统内存大小为: " + initialMemory * 64.0 / 1024 + "G");\n        System.out.println("系统内存大小为: " + maxMemory * 4.0 / 1024 + "G");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n如何查看堆内存的内存分配情况\n\njps  ->  jstat -gc 进程id\n\n\n1\n\n\n\n\n-XX:+PrintGCDetails\n\n\n1\n\n\n\n\n\n# OutOfMemory举例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/04 12:48\n * @Description: <h1> OOM（OutOfMemory）举例 </h1>\n * -Xms600m -Xmx600m\n */\npublic class OOMTest {\n\n    public static void main(String[] args) {\n        ArrayList<Picture> list = new ArrayList<>();\n        while (true){\n            try {\n                Thread.sleep(20);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            list.add(new Picture(new Random().nextInt(1024 * 1024)));\n        }\n    }\n\n}\n\nclass Picture{\n\n    /**\n     * 图片字节数组\n     */\n    private byte[] pixels;\n\n    public Picture(int length){\n        this.pixels = new byte[length];\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n报错信息：\n\nException in thread "main" java.lang.OutOfMemoryError: Java heap space\n\tat com.chggx.jvm.chapter08.Picture.<init>(OOMTest.java:36)\n\tat com.chggx.jvm.chapter08.OOMTest.main(OOMTest.java:22)\n\n\n\n1\n2\n3\n4\n\n\n\n# 3. 年轻代与老年代\n\n 1. 存储在JVM中的Java对象可以被划分为两类：\n    \n    * 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速（生命周期短的，及时回收即可）\n    \n    * 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。\n\n 2. Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）\n    \n    其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区；也叫幸存者区）\n\n\n\n下面这参数开发中一般不会调：\n\n\n\n * Eden：From：to -> 8:1:1\n * 新生代：老年代 - > 1 : 2\n\n配置新生代与老年代在堆结构的占比。\n\n * 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3\n * 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5\n\n> 当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/06 11:33\n * @Description: <h1> 年轻代、老年代 </h1>\n * -Xms600m -Xmx600m\n *\n * -XX:NewRatio：设置新生代与老年代的比例。默认值2.\n * -XX:SurvivorRatio：设置新生代中Eden区域与survivor区的比例，默认值为8\n * -XX:-UseAdaptiveSizePolicy ： 关闭自适应的内存分配策略（暂时用不到）\n * -Xmn: 设置新生代的空间大小。（一般不设置）\n */\npublic class EdenSurvivorTest {\n\n    public static void main(String[] args) {\n        System.out.println("我只是来打酱油的~");\n        try {\n            Thread.sleep(1000000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n 1. 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8\n\n 2. 几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）\n    \n    * IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。\n\n 3. 可以使用选项"-Xmn"设置新生代最大内存大小\n    \n    * 这个参数一般使用默认值就可以了。\n\n\n\n\n# 4. 图解对象分配过程\n\n\n# 1. 概述\n\n为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。\n\n * new的对象先放伊甸园区。此区有大小限制。\n\n * 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区\n\n * 然后将伊甸园中的剩余对象移动到幸存者0区。\n\n * 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。\n\n * 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。\n\n * 啥时候能去养老区呢？可以设置次数。默认是15次。\n\n * 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理\n\n * 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。\n   \n   * 可以设置参数：-Xx:MaxTenuringThreshold= N进行设置\n\n\n# 2. 图解对象分配\n\n 1. 我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作\n\n\n\n当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区（幸存者区/From）。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。\n\n 2. 同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1\n\n\n\n> so、s1谁空谁为To区\n\n 3. 我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中\n\n\n\n\n# 3. 思考：幸存者区满了后？\n\n特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作\n\n如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代\n\n> 举例：以当兵为例，正常人的晋升可能是 ： 新兵 -> 班长 -> 排长 -> 连长\n> \n> 但是也有可能有些人因为做了非常大的贡献，直接从 新兵 -> 排长\n\n\n# 4. 对象分配的特殊情况\n\n\n\n\n# 5. 代码演示对象分配过程\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/06 15:27\n * @Description: <h1> </h1>\n * -Xms600m -Xmx600m\n */\npublic class HeapInstanceTest {\n\n    byte[] buffer = new byte[new Random().nextInt(1024 * 200)];\n\n  public static void main(String[] args) {\n    ArrayList<HeapInstanceTest> list = new ArrayList<>();\n    while (true){\n      list.add(new HeapInstanceTest());\n      try {\n        Thread.sleep(10);\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n然后设置JVM参数\n\n-Xms600m -Xmx600m\n\n\n1\n\n\n然后cmd输入下面命令，打开VisualVM图形化界面\n\njvisualvm\n\n\n1\n\n\n然后通过执行上面代码，通过VisualGC进行动态化查看\n\n\n\n结果：\n\nException in thread "main" java.lang.OutOfMemoryError: Java heap space\n\tat com.chggx.jvm.chapter08.newold.HeapInstanceTest.<init>(HeapInstanceTest.java:14)\n\tat com.chggx.jvm.chapter08.newold.HeapInstanceTest.main(HeapInstanceTest.java:19)\n\nProcess finished with exit code 1\n\n\n1\n2\n3\n4\n5\n\n\n\n# 6. 常用调优工具\n\n * JDK命令行\n * Eclipse：Memory Analyzer Tool\n * Jconsole\n * Visual VM（实时监控 推荐~）\n * Jprofiler（推荐~）\n * Java Flight Recorder（实时监控）\n * GCViewer\n * GCEasy\n\n\n# 7. 总结\n\n * 对于幸存者s0，s1区的总结：复制之后又交换，谁空谁是to\n * 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区、元空间收集。\n * 新生代采用复制算法的目的：是为了减少内碎片\n\n\n# 5. Minor GC、Major GC、FULL GC\n\n\n# 概述\n\nJVM在进行GC时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指新生代。\n\n针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）\n\n 1. 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：\n    \n    * 新生代收集（Minor GC/Young GC）：只是新生代（Eden、s0、s1）的垃圾收集\n    \n    * 老年代收集（Major GC/old GC）：只是老年代的圾收集。\n      \n      ① 目前，只有CMS GC会有单独收集老年代的行为。\n      \n      ② 注意，很多时候Major GC会和FullGC混淆使用，需要具体分辨是老年代回收还是整堆回收。\n    \n    * 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。\n      \n      ① 目前，只有G1 GC会有这种行为\n\n 2. 整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。\n\n> 我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题\n> \n> 而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上\n\n\n# 最简单的分代式GC策略的触发条件\n\n 1. 年轻代GC（Minor GC）触发机制：\n    \n    * 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）\n    * 因为Java对象大多都具备 朝生夕灭 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\n    * Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行\n    \n    > STW：stop the word\n\n\n\n 2. 老年代GC （Major GC/Full GC）触发机制：\n    \n    * 指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了。\n    \n    * 出现了Major Gc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）\n      \n      ① 也就是在老年代空间不足时，会先尝试触发Minor Gc。如果之后空间还不足，则触发Major GC\n    \n    * Major GC的速度一般会比Minor Gc（年轻代）慢10倍以上，STW的时间更长，\n    \n    * 如果Major GC后，内存还不足，就报OOM了。\n\n 3. Full GC触发机制：\n    \n    触发Full GC 执行的情况有如下5种：\n    \n    * 调用System.gc()时，系统建议执行Full GC，但是不必然执行\n    * 老年代空间不足\n    * 方法区空间不足\n    * 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n    * 由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n    \n    > 说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些。\n\n\n# 示例\n\n/**\n * @Author: CHGGX\n * @Date: 2020/10/07 17:57\n * @Description: <h1> </h1>\n * 参数设置：\n *      -Xms10m -Xmx10m -XX:+PrintGCDetails\n */\npublic class GCTest {\n\n    public static void main(String[] args) {\n        int i = 0;\n        try {\n            ArrayList<String> list = new ArrayList<>();\n            String a = "chggx.com";\n            while (true) {\n                list.add(a);\n                a = a + a;\n                i++;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println("遍历次数为：" + i);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n参数设置：\n\n-Xms10m -Xmx10m -XX:+PrintGCDetails\n\n\n1\n\n\n结果：\n\n[GC (Allocation Failure) [PSYoungGen: 2006K->494K(2560K)] 2006K->878K(9728K), 0.0014059 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[GC (Allocation Failure) [PSYoungGen: 2426K->468K(2560K)] 2810K->1868K(9728K), 0.0017104 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Ergonomics) [PSYoungGen: 1726K->0K(2560K)] [ParOldGen: 7160K->5207K(7168K)] 8887K->5207K(9728K), [Metaspace: 3165K->3165K(1056768K)], 0.0097203 secs] [Times: user=0.00 sys=0.02, real=0.01 secs] \n[GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] 5207K->5207K(9728K), 0.0008749 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] [ParOldGen: 5207K->5189K(7168K)] 5207K->5189K(9728K), [Metaspace: 3165K->3165K(1056768K)], 0.0118300 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \nHeap\n PSYoungGen      total 2560K, used 80K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)\n  eden space 2048K, 3% used [0x00000000ffd00000,0x00000000ffd14018,0x00000000fff00000)\n  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)\n  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)\n ParOldGen       total 7168K, used 5189K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)\n  object space 7168K, 72% used [0x00000000ff600000,0x00000000ffb11758,0x00000000ffd00000)\n Metaspace       used 3219K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K\nException in thread "main" java.lang.OutOfMemoryError: Java heap space\n\tat java.util.Arrays.copyOfRange(Arrays.java:3664)\n\tat java.lang.String.<init>(String.java:207)\n\tat java.lang.StringBuilder.toString(StringBuilder.java:407)\n\tat com.chggx.jvm.chapter08.gc.GCTest.main(GCTest.java:21)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常\n\n\n# 6. 堆空间分代思想\n\n\n# 为什么需要把Java堆分代？不分代就不能正常工作了吗？\n\n 1. 经研究，不同对象的生命周期不同。70%-80%的对象为临时对象。\n    * 新生代：有Eden、两块大小相同的survivor（又称为from、to，s0/s1）构成，to宗伟总为空。\n    * 老年代：存放新生代中经历多次GC任然存活的对象。\n\n\n\n 2. 其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。\n\n\n\n\n# 7. 内存分配策略\n\n如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代\n\n对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置\n\n针对不同年龄段的对象分配原则如下所示：\n\n * 优先分配到Eden\n   \n   * 开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢\n\n * 大对象直接分配到老年代\n   \n   * 尽量避免程序中出现过多的大对象\n\n * 长期存活的对象分配到老年代\n\n * 动态对象年龄判断\n   \n   * 如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。\n\n * 空间分配担保： -Xx:HandlePromotionFailure\n   \n   * 也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。\n\n\n# 8. 为对象分配内存：TLAB\n\n\n# 问题：堆空间都是共享的么？\n\n不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占\n\n\n# 为什么有TLAB？\n\nTLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区\n\n * 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据\n\n * 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的\n\n * 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。\n\n\n# 什么是TLAB\n\n从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。\n\n多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。\n\n据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。\n\n\n\n尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。\n\n在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。\n\n默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。\n\n一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。\n\n\n# TLAB分配过程\n\n对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配\n\n\n\n\n# 9. 小结：堆空间的参数设置\n\n * -XX：+PrintFlagsInitial：查看所有的参数的默认初始值\n * -XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）\n * -Xms：初始堆空间内存（默认为物理内存的1/64）\n * -Xmx：最大堆空间内存（默认为物理内存的1/4）\n * -Xmn：设置新生代的大小。（初始值及最大值）\n * -XX:NewRatio：配置新生代与老年代在堆结构的占比\n * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例\n * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄\n * -XX：+PrintGCDetails：输出详细的GC处理日志\n   * 打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc\n * -XX:HandlePromotionFalilure：是否设置空间分配担保\n\n在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I\n\n * 如果大于，则此次Minor GC是安全的\n * 如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。\n   * 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。\n   * 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；\n   * 如果小于，则改为进行一次FullGC。\n   * 如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。\n\n在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。\n\n\n# 10. 堆是分配对象的唯一选择吗？\n\n不是\n\n\n# 1. 逃逸分析\n\n在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：\n\n随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。\n\n在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。\n\n此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。\n\n 1. 如何将堆上的对象分配到栈，需要使用逃逸分析手段。\n\n 2. 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。\n\n 3. 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：\n    \n    * 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。\n    * 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。\n\n 4. 逃逸分析举例\n\n没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析\n\npublic void my_method() {\n    V v = new V();\n    // use v\n    // ....\n    v = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n针对下面的代码\n\npublic static StringBuffer createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果想要StringBuffer sb不发生逃逸，可以这样写\n\npublic static String createStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 1. 完整的逃逸分析代码举例\n\n如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。\n\n/**\n * 逃逸分析\n * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。\n * @author: CHGGX\n * @create: 2020-07-07-20:05\n */\npublic class EscapeAnalysis {\n\n    public EscapeAnalysis obj;\n\n    /**\n     * 方法返回EscapeAnalysis对象，发生逃逸\n     * @return\n     */\n    public EscapeAnalysis getInstance() {\n        return obj == null ? new EscapeAnalysis():obj;\n    }\n\n    /**\n     * 为成员属性赋值，发生逃逸\n     */\n    public void setObj() {\n        this.obj = new EscapeAnalysis();\n    }\n\n    /**\n     * 对象的作用于仅在当前方法中有效，没有发生逃逸\n     */\n    public void useEscapeAnalysis() {\n        EscapeAnalysis e = new EscapeAnalysis();\n    }\n\n    /**\n     * 引用成员变量的值，发生逃逸\n     */\n    public void useEscapeAnalysis2() {\n        EscapeAnalysis e = getInstance();\n        // getInstance().XXX  发生逃逸\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n# 2. 参数设置\n\n在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析\n\n如果使用的是较早的版本，开发人员则可以通过：\n\n * 选项“-xx：+DoEscapeAnalysis"显式开启逃逸分析\n * 通过选项“-xx：+PrintEscapeAnalysis"查看逃逸分析的筛选结果\n\n# 3. 结论\n\n开发中能使用局部变量的，就不要使用在方法外定义。\n\n\n# 2. 逃逸分析：代码优化\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n * 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配\n * 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n * 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。\n\n# 栈上分配\n\nJIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。\n\n常见的栈上分配的场景\n\n> 在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。\n\n# 举例\n\n我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况\n\n/**\n * 栈上分配\n * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\n * @author: 陌溪\n * @create: 2020-07-07-20:23\n */\nclass User {\n    private String name;\n    private String age;\n    private String gender;\n    private String phone;\n}\npublic class StackAllocation {\n    public static void main(String[] args) throws InterruptedException {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 100000000; i++) {\n            alloc();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println("花费的时间为：" + (end - start) + " ms");\n\n        // 为了方便查看堆内存中对象个数，线程sleep\n        Thread.sleep(10000000);\n    }\n\n    private static void alloc() {\n        User user = new User();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n设置JVM参数，表示未开启逃逸分析\n\n-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\n\n\n1\n\n\n运行结果，同时还触发了GC操作\n\n花费的时间为：664 ms\n\n\n1\n\n\n然后查看内存的情况，发现有大量的User存储在堆中\n\n\n\n我们在开启逃逸分析\n\n-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails\n\n\n1\n\n\n然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作\n\n花费的时间为：5 ms\n\n\n1\n\n\n然后在看内存情况，我们发现只有很少的User对象，说明User发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失\n\n\n\n\n# 同步省略\n\n线程同步的代价是相当高的，同步的后果是降低并发性和性能。\n\n在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。\n\n例如下面的代码\n\npublic void f() {\n    Object hellis = new Object();\n    synchronized(hellis) {\n        System.out.println(hellis);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：\n\npublic void f() {\n    Object hellis = new Object();\n\tSystem.out.println(hellis);\n}\n\n\n1\n2\n3\n4\n\n\n我们将其转换成字节码\n\n\n\n\n# 分离对象和标量替换\n\n标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。\n\n相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\n\n在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过J工T优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。\n\npublic static void main(String args[]) {\n    alloc();\n}\nclass Point {\n    private int x;\n    private int y;\n}\nprivate static void alloc() {\n    Point point = new Point(1,2);\n    System.out.println("point.x" + point.x + ";point.y" + point.y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n以上代码，经过标量替换后，就会变成\n\nprivate static void alloc() {\n    int x = 1;\n    int y = 2;\n    System.out.println("point.x = " + x + "; point.y=" + y);\n}\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。\n\n\n# 代码优化之标量替换\n\n上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：\n\n-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations\n\n\n1\n\n\n这里设置参数如下：\n\n * 参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。\n * 参数-XX:+DoEscapeAnalysis：启用逃逸分析\n * 参数-Xmx10m：指定了堆空间最大为10MB\n * 参数-XX:+PrintGC：将打印Gc日志。\n * 参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配\n\n\n# 逃逸分析的不足\n\n关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。\n\n其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\n\n虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。\n\n目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。\n\n\n# 小结\n\n年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。\n\n老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。\n\n当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。',normalizedContent:'# jvm-堆\n\n> 堆相当于一个进程，一个进程对应一个jvm实例，一个进程对应多个线程，他们是共享同一堆空间的。\n\n\n# 1. 堆的核心\n\n\n# 概述\n\n 1. 一个jvm实例只存在一个堆内存，堆也是java内存管理的核心区域。\n\n 2. java堆区在jvm启动的时候即被创建，其空间大小也就确定了。是jvm管理的最大一块内存空间。\n    \n    * 堆内存的大小是可以调节的。\n\n 3. 《java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。\n\n 4. 所有的线程共享java堆，在这里还可以划分线程私有的缓冲区（thread local allocation buffer，tlab）。\n\n> -xms10m：最小堆内存\n> \n> -xmx10m：最大堆内存\n> \n> 下图就是使用：java visualvm查看堆空间的内容，通过 jdk 中bin目录下提供的插件\n\n\n\n 5. 《java虚拟机规范》中对java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（the heap is the run-time data area from which memory for all class instances and arrays is allocated）\n    \n    * 我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。\n    * 因为还有一些对象是在栈上分配的\n\n 6. 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。]\n\n 7. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。\n    \n    * 也就是触发了gc的时候，才会进行回收\n    * 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word\n\n 8. 堆，是gc（garbage collection，垃圾收集器）执行垃圾回收的重点区域。\n\n示例\n\npublic class simpleheap {\n\n    private int id;\n\n    public simpleheap(int id) {\n        this.id = id;\n    }\n\n    public void show() {\n        system.out.println("my id is " + id);\n    }\n\n    public static void main(string[] args) {\n        simpleheap s1 = new simpleheap(1);\n        simpleheap s2 = new simpleheap(2);\n        \n        int[] arr = new int[10];\n        object[] arr1 = new object[10];\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n\n# 内存细分\n\n现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：\n\n 1. java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区\n    \n    * young generation space 新生区 young/new 又被划分为eden区和survivor区\n    * tenure generation space 养老区 old/tenure\n    * permanent space永久区 perm\n\n 2. java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间\n    \n    * young generation space 新生区 young/new 又被划分为eden区和survivor区\n    * tenure generation space 养老区 old/tenure\n    * meta space 元空间 meta\n\n 3. 约定：新生区 -> 新生代 -> 年轻代 、 养老区 -> 老年区 -> 老年代、 永久区 -> 永久代\n\n# 堆空间内部结构\n\n# jdk7\n\n\n\n# jdk8\n\n\n\n测试\n\n> -xms10m -xmx10m -xx:+printgcdetails\n\njava8\n\n\n\njava7\n\n\n\n\n# 2. 设置堆内存大小与oom\n\n\n# 堆空间大小设置\n\n 1. java堆区用于存储java对象实例，那么堆的大小在jvm启动时就已经设定好了，大家可以通过选项“-xmx”和”-xms：来进行设置。\n    \n    * “-xms”用于表示堆区的起始内存，等价于-xx:initialheapsize\n    * “-xmx”用于表示堆区的最大内存，等价于-xx:maxheapsize\n\n 2. 一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofmemoryerror异常。\n\n 3. 通常会将-xmx和-xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算机堆区的大小，从而提高性能。\n\n 4. 默认情况下，初始内存大小：物理电脑内存大小 / 64\n    \n    最大内存大小：物理电脑内存大小 / 4\n\n\n# 示例\n\n/**\n * @author: chggx\n * @date: 2020/10/04 11:16\n * @description: <h1>  </h1>\n * 1. 设置堆空间大小的参数\n * -xms：用来设置堆空间（年轻代+老年代）的初始内存大小\n * -x 是jvm的运行参数\n * ms 是memory start\n * -xmx：用来设置堆空间（年轻代+老年代）的最大内存大小\n * <p>\n * 2. 默认堆空间的大小\n * 初始内存大小：物理电脑内存大小 / 64\n * 最大内存大小：物理电脑内存大小  / 4\n * <p>\n * 3. 手动设置：-xms600m -xmx600m\n * 开发中建议：将初始化堆内存和最大堆内存设置成相同的值。\n * <p>\n * 4. 查看设置的参数：\n * 方式一： jps / jstat -gc 进程id\n * 方式二：-xx+printgcdetails\n */\npublic class heapspaceinitial {\n\n    public static void main(string[] args) {\n        // 返回java虚拟机中的对内存总量\n        long initialmemory = runtime.getruntime().totalmemory() / 1024 / 1024;\n        // 返回java虚拟机视图使用的最大堆内存容量\n        long maxmemory = runtime.getruntime().totalmemory() / 1024 / 1024;\n\n        system.out.println("-xms : " + initialmemory + "m");\n        system.out.println("-xmx : " + maxmemory + "m");\n\n        system.out.println("系统内存大小为: " + initialmemory * 64.0 / 1024 + "g");\n        system.out.println("系统内存大小为: " + maxmemory * 4.0 / 1024 + "g");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n如何查看堆内存的内存分配情况\n\njps  ->  jstat -gc 进程id\n\n\n1\n\n\n\n\n-xx:+printgcdetails\n\n\n1\n\n\n\n\n\n# outofmemory举例\n\n/**\n * @author: chggx\n * @date: 2020/10/04 12:48\n * @description: <h1> oom（outofmemory）举例 </h1>\n * -xms600m -xmx600m\n */\npublic class oomtest {\n\n    public static void main(string[] args) {\n        arraylist<picture> list = new arraylist<>();\n        while (true){\n            try {\n                thread.sleep(20);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            list.add(new picture(new random().nextint(1024 * 1024)));\n        }\n    }\n\n}\n\nclass picture{\n\n    /**\n     * 图片字节数组\n     */\n    private byte[] pixels;\n\n    public picture(int length){\n        this.pixels = new byte[length];\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n报错信息：\n\nexception in thread "main" java.lang.outofmemoryerror: java heap space\n\tat com.chggx.jvm.chapter08.picture.<init>(oomtest.java:36)\n\tat com.chggx.jvm.chapter08.oomtest.main(oomtest.java:22)\n\n\n\n1\n2\n3\n4\n\n\n\n# 3. 年轻代与老年代\n\n 1. 存储在jvm中的java对象可以被划分为两类：\n    \n    * 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速（生命周期短的，及时回收即可）\n    \n    * 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与jvm的生命周期保持一致。\n\n 2. java堆区进一步细分的话，可以划分为年轻代（younggen）和老年代（oldgen）\n    \n    其中年轻代又可以划分为eden空间、survivor0空间和survivor1空间（有时也叫做from区、to区；也叫幸存者区）\n\n\n\n下面这参数开发中一般不会调：\n\n\n\n * eden：from：to -> 8:1:1\n * 新生代：老年代 - > 1 : 2\n\n配置新生代与老年代在堆结构的占比。\n\n * 默认-xx:newratio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3\n * 可以修改-xx:newratio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5\n\n> 当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优\n\n/**\n * @author: chggx\n * @date: 2020/10/06 11:33\n * @description: <h1> 年轻代、老年代 </h1>\n * -xms600m -xmx600m\n *\n * -xx:newratio：设置新生代与老年代的比例。默认值2.\n * -xx:survivorratio：设置新生代中eden区域与survivor区的比例，默认值为8\n * -xx:-useadaptivesizepolicy ： 关闭自适应的内存分配策略（暂时用不到）\n * -xmn: 设置新生代的空间大小。（一般不设置）\n */\npublic class edensurvivortest {\n\n    public static void main(string[] args) {\n        system.out.println("我只是来打酱油的~");\n        try {\n            thread.sleep(1000000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n 1. 在hotspot中，eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:survivorratio”调整这个空间比例。比如-xx:survivorratio=8\n\n 2. 几乎所有的java对象都是在eden区被new出来的。绝大部分的java对象的销毁都在新生代进行了。（有些大的对象在eden区无法存储时候，将直接进入老年代）\n    \n    * ibm公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。\n\n 3. 可以使用选项"-xmn"设置新生代最大内存大小\n    \n    * 这个参数一般使用默认值就可以了。\n\n\n\n\n# 4. 图解对象分配过程\n\n\n# 1. 概述\n\n为新对象分配内存是一件非常严谨和复杂的任务，jm的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑gc执行完内存回收后是否会在内存空间中产生内存碎片。\n\n * new的对象先放伊甸园区。此区有大小限制。\n\n * 当伊甸园的空间填满时，程序又需要创建对象，jvm的垃圾回收器将对伊甸园区进行垃圾回收（minorgc），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区\n\n * 然后将伊甸园中的剩余对象移动到幸存者0区。\n\n * 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。\n\n * 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。\n\n * 啥时候能去养老区呢？可以设置次数。默认是15次。\n\n * 在养老区，相对悠闲。当养老区内存不足时，再次触发gc：major gc，进行养老区的内存清理\n\n * 若养老区执行了major gc之后，发现依然无法进行对象的保存，就会产生oom异常。\n   \n   * 可以设置参数：-xx:maxtenuringthreshold= n进行设置\n\n\n# 2. 图解对象分配\n\n 1. 我们创建的对象，一般都是存放在eden区的，当我们eden区满了后，就会触发gc操作，一般被称为 ygc / minor gc操作\n\n\n\n当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在s0(survivor from)区（幸存者区/from）。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。\n\n 2. 同时eden区继续存放对象，当eden区再次存满的时候，又会触发一个minorgc操作，此时gc将会把 eden和survivor from中的对象 进行一次收集，把存活的对象放到 survivor to区，同时让年龄 + 1\n\n\n\n> so、s1谁空谁为to区\n\n 3. 我们继续不断的进行对象生成 和 垃圾回收，当survivor中的对象的年龄达到15的时候，将会触发一次 promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中\n\n\n\n\n# 3. 思考：幸存者区满了后？\n\n特别注意，在eden区满了的时候，才会触发minorgc，而幸存者区满了后，不会触发minorgc操作\n\n如果survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代\n\n> 举例：以当兵为例，正常人的晋升可能是 ： 新兵 -> 班长 -> 排长 -> 连长\n> \n> 但是也有可能有些人因为做了非常大的贡献，直接从 新兵 -> 排长\n\n\n# 4. 对象分配的特殊情况\n\n\n\n\n# 5. 代码演示对象分配过程\n\n/**\n * @author: chggx\n * @date: 2020/10/06 15:27\n * @description: <h1> </h1>\n * -xms600m -xmx600m\n */\npublic class heapinstancetest {\n\n    byte[] buffer = new byte[new random().nextint(1024 * 200)];\n\n  public static void main(string[] args) {\n    arraylist<heapinstancetest> list = new arraylist<>();\n    while (true){\n      list.add(new heapinstancetest());\n      try {\n        thread.sleep(10);\n      } catch (interruptedexception e) {\n        e.printstacktrace();\n      }\n    }\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n然后设置jvm参数\n\n-xms600m -xmx600m\n\n\n1\n\n\n然后cmd输入下面命令，打开visualvm图形化界面\n\njvisualvm\n\n\n1\n\n\n然后通过执行上面代码，通过visualgc进行动态化查看\n\n\n\n结果：\n\nexception in thread "main" java.lang.outofmemoryerror: java heap space\n\tat com.chggx.jvm.chapter08.newold.heapinstancetest.<init>(heapinstancetest.java:14)\n\tat com.chggx.jvm.chapter08.newold.heapinstancetest.main(heapinstancetest.java:19)\n\nprocess finished with exit code 1\n\n\n1\n2\n3\n4\n5\n\n\n\n# 6. 常用调优工具\n\n * jdk命令行\n * eclipse：memory analyzer tool\n * jconsole\n * visual vm（实时监控 推荐~）\n * jprofiler（推荐~）\n * java flight recorder（实时监控）\n * gcviewer\n * gceasy\n\n\n# 7. 总结\n\n * 对于幸存者s0，s1区的总结：复制之后又交换，谁空谁是to\n * 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区、元空间收集。\n * 新生代采用复制算法的目的：是为了减少内碎片\n\n\n# 5. minor gc、major gc、full gc\n\n\n# 概述\n\njvm在进行gc时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指新生代。\n\n针对hotspot vm的实现，它里面的gc按照回收区域又分为两大种类型：一种是部分收集（partial gc），一种是整堆收集（fullgc）\n\n 1. 部分收集：不是完整收集整个java堆的垃圾收集。其中又分为：\n    \n    * 新生代收集（minor gc/young gc）：只是新生代（eden、s0、s1）的垃圾收集\n    \n    * 老年代收集（major gc/old gc）：只是老年代的圾收集。\n      \n      ① 目前，只有cms gc会有单独收集老年代的行为。\n      \n      ② 注意，很多时候major gc会和fullgc混淆使用，需要具体分辨是老年代回收还是整堆回收。\n    \n    * 混合收集（mixed gc）：收集整个新生代以及部分老年代的垃圾收集。\n      \n      ① 目前，只有g1 gc会有这种行为\n\n 2. 整堆收集（fullgc）：收集整个java堆和方法区的垃圾收集。\n\n> 我们都知道，jvm的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现stw的问题\n> \n> 而 major gc 和 full gc出现stw的时间，是minor gc的10倍以上\n\n\n# 最简单的分代式gc策略的触发条件\n\n 1. 年轻代gc（minor gc）触发机制：\n    \n    * 当年轻代空间不足时，就会触发minor gc，这里的年轻代满指的是eden代满，survivor满不会引发gc。（每次minor gc会清理年轻代的内存。）\n    * 因为java对象大多都具备 朝生夕灭 的特性，所以minor gc非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\n    * minor gc会引发stw，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行\n    \n    > stw：stop the word\n\n\n\n 2. 老年代gc （major gc/full gc）触发机制：\n    \n    * 指发生在老年代的gc，对象从老年代消失时，我们说 “major gc” 或 “full gc” 发生了。\n    \n    * 出现了major gc，经常会伴随至少一次的minor gc（但非绝对的，在paralle1 scavenge收集器的收集策略里就有直接进行majorgc的策略选择过程）\n      \n      ① 也就是在老年代空间不足时，会先尝试触发minor gc。如果之后空间还不足，则触发major gc\n    \n    * major gc的速度一般会比minor gc（年轻代）慢10倍以上，stw的时间更长，\n    \n    * 如果major gc后，内存还不足，就报oom了。\n\n 3. full gc触发机制：\n    \n    触发full gc 执行的情况有如下5种：\n    \n    * 调用system.gc()时，系统建议执行full gc，但是不必然执行\n    * 老年代空间不足\n    * 方法区空间不足\n    * 通过minor gc后进入老年代的平均大小大于老年代的可用内存\n    * 由eden区、survivor spacee（from space）区向survivor spacel（to space）区复制时，对象大小大于to space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n    \n    > 说明：full gc 是开发或调优中尽量要避免的。这样暂时时间会短一些。\n\n\n# 示例\n\n/**\n * @author: chggx\n * @date: 2020/10/07 17:57\n * @description: <h1> </h1>\n * 参数设置：\n *      -xms10m -xmx10m -xx:+printgcdetails\n */\npublic class gctest {\n\n    public static void main(string[] args) {\n        int i = 0;\n        try {\n            arraylist<string> list = new arraylist<>();\n            string a = "chggx.com";\n            while (true) {\n                list.add(a);\n                a = a + a;\n                i++;\n            }\n        } catch (exception e) {\n            e.printstacktrace();\n            system.out.println("遍历次数为：" + i);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n参数设置：\n\n-xms10m -xmx10m -xx:+printgcdetails\n\n\n1\n\n\n结果：\n\n[gc (allocation failure) [psyounggen: 2006k->494k(2560k)] 2006k->878k(9728k), 0.0014059 secs] [times: user=0.00 sys=0.00, real=0.00 secs] \n[gc (allocation failure) [psyounggen: 2426k->468k(2560k)] 2810k->1868k(9728k), 0.0017104 secs] [times: user=0.00 sys=0.00, real=0.00 secs] \n[full gc (ergonomics) [psyounggen: 1726k->0k(2560k)] [paroldgen: 7160k->5207k(7168k)] 8887k->5207k(9728k), [metaspace: 3165k->3165k(1056768k)], 0.0097203 secs] [times: user=0.00 sys=0.02, real=0.01 secs] \n[gc (allocation failure) [psyounggen: 0k->0k(2560k)] 5207k->5207k(9728k), 0.0008749 secs] [times: user=0.00 sys=0.00, real=0.00 secs] \n[full gc (allocation failure) [psyounggen: 0k->0k(2560k)] [paroldgen: 5207k->5189k(7168k)] 5207k->5189k(9728k), [metaspace: 3165k->3165k(1056768k)], 0.0118300 secs] [times: user=0.00 sys=0.00, real=0.01 secs] \nheap\n psyounggen      total 2560k, used 80k [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)\n  eden space 2048k, 3% used [0x00000000ffd00000,0x00000000ffd14018,0x00000000fff00000)\n  from space 512k, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)\n  to   space 512k, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)\n paroldgen       total 7168k, used 5189k [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)\n  object space 7168k, 72% used [0x00000000ff600000,0x00000000ffb11758,0x00000000ffd00000)\n metaspace       used 3219k, capacity 4496k, committed 4864k, reserved 1056768k\n  class space    used 348k, capacity 388k, committed 512k, reserved 1048576k\nexception in thread "main" java.lang.outofmemoryerror: java heap space\n\tat java.util.arrays.copyofrange(arrays.java:3664)\n\tat java.lang.string.<init>(string.java:207)\n\tat java.lang.stringbuilder.tostring(stringbuilder.java:407)\n\tat com.chggx.jvm.chapter08.gc.gctest.main(gctest.java:21)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 触发oom的时候，一定是进行了一次full gc，因为只有在老年代空间不足时候，才会爆出oom异常\n\n\n# 6. 堆空间分代思想\n\n\n# 为什么需要把java堆分代？不分代就不能正常工作了吗？\n\n 1. 经研究，不同对象的生命周期不同。70%-80%的对象为临时对象。\n    * 新生代：有eden、两块大小相同的survivor（又称为from、to，s0/s1）构成，to宗伟总为空。\n    * 老年代：存放新生代中经历多次gc任然存活的对象。\n\n\n\n 2. 其实不分代完全可以，分代的唯一理由就是优化gc性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。gc的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当gc的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。\n\n\n\n\n# 7. 内存分配策略\n\n如果对象在eden出生并经过第一次minor gc后仍然存活，并且能被survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次minorgc，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个jvm、每个gc都有所不同）时，就会被晋升到老年代\n\n对象晋升老年代的年龄阀值，可以通过选项-xx:maxtenuringthreshold来设置\n\n针对不同年龄段的对象分配原则如下所示：\n\n * 优先分配到eden\n   \n   * 开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发major gc的次数比 minor gc要更少，因此可能回收起来就会比较慢\n\n * 大对象直接分配到老年代\n   \n   * 尽量避免程序中出现过多的大对象\n\n * 长期存活的对象分配到老年代\n\n * 动态对象年龄判断\n   \n   * 如果survivor区中相同年龄的所有对象大小的总和大于survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到maxtenuringthreshold 中要求的年龄。\n\n * 空间分配担保： -xx:handlepromotionfailure\n   \n   * 也就是经过minor gc后，所有的对象都存活，因为survivor比较小，所以就需要将survivor无法容纳的对象，存放到老年代中。\n\n\n# 8. 为对象分配内存：tlab\n\n\n# 问题：堆空间都是共享的么？\n\n不一定，因为还有tlab这个概念，在堆中划分出一块区域，为每个线程所独占\n\n\n# 为什么有tlab？\n\ntlab：thread local allocation buffer，也就是为每个线程单独分配了一个缓冲区\n\n * 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据\n\n * 由于对象实例的创建在jvm中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的\n\n * 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。\n\n\n# 什么是tlab\n\n从内存模型而不是垃圾收集的角度，对eden区域继续进行划分，jvm为每个线程分配了一个私有缓存区域，它包含在eden空间内。\n\n多线程同时分配内存时，使用tlab可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。\n\n据我所知所有openjdk衍生出来的jvm都提供了tlab的设计。\n\n\n\n尽管不是所有的对象实例都能够在tlab中成功分配内存，但jvm确实是将tlab作为内存分配的首选。\n\n在程序中，开发人员可以通过选项“-xx:usetlab”设置是否开启tlab空间。\n\n默认情况下，tlab空间的内存非常小，仅占有整个eden空间的1，当然我们可以通过选项“-xx:tlabwastetargetpercent”设置tlab空间所占用eden空间的百分比大小。\n\n一旦对象在tlab空间分配内存失败时，jvm就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在eden空间中分配内存。\n\n\n# tlab分配过程\n\n对象首先是通过tlab开辟空间，如果不能放入，那么需要通过eden来进行分配\n\n\n\n\n# 9. 小结：堆空间的参数设置\n\n * -xx：+printflagsinitial：查看所有的参数的默认初始值\n * -xx：+printflagsfinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）\n * -xms：初始堆空间内存（默认为物理内存的1/64）\n * -xmx：最大堆空间内存（默认为物理内存的1/4）\n * -xmn：设置新生代的大小。（初始值及最大值）\n * -xx:newratio：配置新生代与老年代在堆结构的占比\n * -xx:survivorratio：设置新生代中eden和s0/s1空间的比例\n * -xx:maxtenuringthreshold：设置新生代垃圾的最大年龄\n * -xx：+printgcdetails：输出详细的gc处理日志\n   * 打印gc简要信息：①-xx：+printgc ② - verbose:gc\n * -xx:handlepromotionfalilure：是否设置空间分配担保\n\n在发生minor gc之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。i\n\n * 如果大于，则此次minor gc是安全的\n * 如果小于，则虚拟机会查看-xx:handlepromotionfailure设置值是否允担保失败。\n   * 如果handlepromotionfailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。\n   * 如果大于，则尝试进行一次minor gc，但这次minor gc依然是有风险的；\n   * 如果小于，则改为进行一次fullgc。\n   * 如果handlepromotionfailure=false，则改为进行一次ful1 gc。\n\n在jdk6 update24之后，handlepromotionfailure参数不会再影响到虚拟机的空间分配担保策略，观察openjdk中的源码变化，虽然源码中还定义了handlepromotionfailure参数，但是在代码中已经不会再使用它。jdk6 update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行minor gc，否则将进行fullgc。\n\n\n# 10. 堆是分配对象的唯一选择吗？\n\n不是\n\n\n# 1. 逃逸分析\n\n在《深入理解java虚拟机》中关于java堆内存有这样一段描述：\n\n随着jit编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。\n\n在java虚拟机中，对象是在java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（escape analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。\n\n此外，前面提到的基于openjdk深度定制的taobaovm，其中创新的gcih（gc invisible heap）技术实现off-heap，将生命周期较长的java对象从heap中移至heap外，并且gc不能管理gcih内部的java对象，以此达到降低gc的回收频率和提升gc的回收效率的目的。\n\n 1. 如何将堆上的对象分配到栈，需要使用逃逸分析手段。\n\n 2. 这是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。\n\n 3. 通过逃逸分析，java hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：\n    \n    * 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。\n    * 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。\n\n 4. 逃逸分析举例\n\n没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析\n\npublic void my_method() {\n    v v = new v();\n    // use v\n    // ....\n    v = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n针对下面的代码\n\npublic static stringbuffer createstringbuffer(string s1, string s2) {\n    stringbuffer sb = new stringbuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果想要stringbuffer sb不发生逃逸，可以这样写\n\npublic static string createstringbuffer(string s1, string s2) {\n    stringbuffer sb = new stringbuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.tostring();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 1. 完整的逃逸分析代码举例\n\n如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。\n\n/**\n * 逃逸分析\n * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。\n * @author: chggx\n * @create: 2020-07-07-20:05\n */\npublic class escapeanalysis {\n\n    public escapeanalysis obj;\n\n    /**\n     * 方法返回escapeanalysis对象，发生逃逸\n     * @return\n     */\n    public escapeanalysis getinstance() {\n        return obj == null ? new escapeanalysis():obj;\n    }\n\n    /**\n     * 为成员属性赋值，发生逃逸\n     */\n    public void setobj() {\n        this.obj = new escapeanalysis();\n    }\n\n    /**\n     * 对象的作用于仅在当前方法中有效，没有发生逃逸\n     */\n    public void useescapeanalysis() {\n        escapeanalysis e = new escapeanalysis();\n    }\n\n    /**\n     * 引用成员变量的值，发生逃逸\n     */\n    public void useescapeanalysis2() {\n        escapeanalysis e = getinstance();\n        // getinstance().xxx  发生逃逸\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n# 2. 参数设置\n\n在jdk 1.7 版本之后，hotspot中默认就已经开启了逃逸分析\n\n如果使用的是较早的版本，开发人员则可以通过：\n\n * 选项“-xx：+doescapeanalysis"显式开启逃逸分析\n * 通过选项“-xx：+printescapeanalysis"查看逃逸分析的筛选结果\n\n# 3. 结论\n\n开发中能使用局部变量的，就不要使用在方法外定义。\n\n\n# 2. 逃逸分析：代码优化\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n * 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配\n * 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\n * 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在cpu寄存器中。\n\n# 栈上分配\n\njit编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。\n\n常见的栈上分配的场景\n\n> 在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。\n\n# 举例\n\n我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况\n\n/**\n * 栈上分配\n * -xmx1g -xms1g -xx:-doescapeanalysis -xx:+printgcdetails\n * @author: 陌溪\n * @create: 2020-07-07-20:23\n */\nclass user {\n    private string name;\n    private string age;\n    private string gender;\n    private string phone;\n}\npublic class stackallocation {\n    public static void main(string[] args) throws interruptedexception {\n        long start = system.currenttimemillis();\n        for (int i = 0; i < 100000000; i++) {\n            alloc();\n        }\n        long end = system.currenttimemillis();\n        system.out.println("花费的时间为：" + (end - start) + " ms");\n\n        // 为了方便查看堆内存中对象个数，线程sleep\n        thread.sleep(10000000);\n    }\n\n    private static void alloc() {\n        user user = new user();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n设置jvm参数，表示未开启逃逸分析\n\n-xmx1g -xms1g -xx:-doescapeanalysis -xx:+printgcdetails\n\n\n1\n\n\n运行结果，同时还触发了gc操作\n\n花费的时间为：664 ms\n\n\n1\n\n\n然后查看内存的情况，发现有大量的user存储在堆中\n\n\n\n我们在开启逃逸分析\n\n-xmx1g -xms1g -xx:+doescapeanalysis -xx:+printgcdetails\n\n\n1\n\n\n然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生gc操作\n\n花费的时间为：5 ms\n\n\n1\n\n\n然后在看内存情况，我们发现只有很少的user对象，说明user发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失\n\n\n\n\n# 同步省略\n\n线程同步的代价是相当高的，同步的后果是降低并发性和性能。\n\n在动态编译同步块的时候，jit编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么jit编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。\n\n例如下面的代码\n\npublic void f() {\n    object hellis = new object();\n    synchronized(hellis) {\n        system.out.println(hellis);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在jit编译阶段就会被优化掉，优化成：\n\npublic void f() {\n    object hellis = new object();\n\tsystem.out.println(hellis);\n}\n\n\n1\n2\n3\n4\n\n\n我们将其转换成字节码\n\n\n\n\n# 分离对象和标量替换\n\n标量（scalar）是指一个无法再分解成更小的数据的数据。java中的原始数据类型就是标量。\n\n相对的，那些还可以分解的数据叫做聚合量（aggregate），java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\n\n在jit阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过j工t优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。\n\npublic static void main(string args[]) {\n    alloc();\n}\nclass point {\n    private int x;\n    private int y;\n}\nprivate static void alloc() {\n    point point = new point(1,2);\n    system.out.println("point.x" + point.x + ";point.y" + point.y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n以上代码，经过标量替换后，就会变成\n\nprivate static void alloc() {\n    int x = 1;\n    int y = 2;\n    system.out.println("point.x = " + x + "; point.y=" + y);\n}\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。\n\n\n# 代码优化之标量替换\n\n上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于user对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5gb。如果堆空间小于这个值，就必然会发生gc。使用如下参数运行上述代码：\n\n-server -xmx100m -xms100m -xx:+doescapeanalysis -xx:+printgc -xx:+eliminateallocations\n\n\n1\n\n\n这里设置参数如下：\n\n * 参数-server：启动server模式，因为在server模式下，才可以启用逃逸分析。\n * 参数-xx:+doescapeanalysis：启用逃逸分析\n * 参数-xmx10m：指定了堆空间最大为10mb\n * 参数-xx:+printgc：将打印gc日志。\n * 参数一xx：+eliminateallocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配\n\n\n# 逃逸分析的不足\n\n关于逃逸分析的论文在1999年就已经发表了，但直到jdk1.6才有实现，而且这项技术到如今也并不是十分成熟的。\n\n其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\n\n虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，jvm会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于jvm设计者的选择。据我所知，oracle hotspot jvm中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。\n\n目前很多书籍还是基于jdk7以前的版本，jdk已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。\n\n\n# 小结\n\n年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。\n\n老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的java对象。当然，也有特殊情况，我们知道普通的对象会被分配在tlab上；如果对象较大，jvm会试图直接分配在eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，jvm就会直接分配到老年代。当gc只发生在年轻代中，回收年轻代对象的行为被称为minorgc。\n\n当gc发生在老年代时则被称为majorgc或者fullgc。一般的，minorgc的发生频率要比majorgc高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"JVM-方法区",frontmatter:{title:"JVM-方法区",date:"2023-02-25T14:09:08.000Z",permalink:"/pages/2f74c5/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/01.JAVA%E8%AF%AD%E8%A8%80/02.JVM/9.JVM-%E6%96%B9%E6%B3%95%E5%8C%BA.html",relativePath:"01.语言/01.JAVA语言/02.JVM/9.JVM-方法区.md",key:"v-53e281ba",path:"/pages/2f74c5/",headers:[{level:2,title:"1. 栈、堆、方法区的交互关系",slug:"_1-栈、堆、方法区的交互关系",normalizedTitle:"1. 栈、堆、方法区的交互关系",charIndex:14},{level:3,title:"1.1 从线程共享与否的角度来看",slug:"_1-1-从线程共享与否的角度来看",normalizedTitle:"1.1 从线程共享与否的角度来看",charIndex:52},{level:3,title:"1.2 栈、堆、方法区的交互关系",slug:"_1-2-栈、堆、方法区的交互关系",normalizedTitle:"1.2 栈、堆、方法区的交互关系",charIndex:120},{level:2,title:"2. 方法区的理解",slug:"_2-方法区的理解",normalizedTitle:"2. 方法区的理解",charIndex:221},{level:3,title:"HotSpot中方法区的演进",slug:"hotspot中方法区的演进",normalizedTitle:"hotspot中方法区的演进",charIndex:824},{level:2,title:"3. 设置方法区大小与OOM",slug:"_3-设置方法区大小与oom",normalizedTitle:"3. 设置方法区大小与oom",charIndex:1288},{level:3,title:"jdk7及以前",slug:"jdk7及以前",normalizedTitle:"jdk7及以前",charIndex:1339},{level:3,title:"JDK8以后",slug:"jdk8以后",normalizedTitle:"jdk8以后",charIndex:1509},{level:3,title:"OOM: PermGen和 OOM：MetaSpace（处理结果OOM）",slug:"oom-permgen和-oom-metaspace-处理结果oom",normalizedTitle:"oom: permgen和 oom：metaspace（处理结果oom）",charIndex:2491},{level:2,title:"4. 方法区的内部结构",slug:"_4-方法区的内部结构",normalizedTitle:"4. 方法区的内部结构",charIndex:3053},{level:3,title:"类型信息",slug:"类型信息",normalizedTitle:"类型信息",charIndex:2879},{level:3,title:"域信息",slug:"域信息",normalizedTitle:"域信息",charIndex:3376},{level:3,title:"方法（Method）信息",slug:"方法-method-信息",normalizedTitle:"方法（method）信息",charIndex:3504},{level:3,title:"non-final的类变量",slug:"non-final的类变量",normalizedTitle:"non-final的类变量",charIndex:3817},{level:3,title:"全局常量",slug:"全局常量",normalizedTitle:"全局常量",charIndex:4420},{level:3,title:"运行时常量池 VS 常量池",slug:"运行时常量池-vs-常量池",normalizedTitle:"运行时常量池 vs 常量池",charIndex:4500},{level:4,title:"常量池 (Constant Pool)",slug:"常量池-constant-pool",normalizedTitle:"常量池 (constant pool)",charIndex:4656},{level:5,title:"为什么需要常量池？",slug:"为什么需要常量池",normalizedTitle:"为什么需要常量池？",charIndex:4778},{level:6,title:"jclasslib查看具体类的常量池",slug:"jclasslib查看具体类的常量池",normalizedTitle:"jclasslib查看具体类的常量池",charIndex:5146},{level:5,title:"常量池中有什么",slug:"常量池中有什么",normalizedTitle:"常量池中有什么",charIndex:5190},{level:5,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:5240},{level:4,title:"运行时常量池",slug:"运行时常量池",normalizedTitle:"运行时常量池",charIndex:4500},{level:2,title:"5. 方法区使用举例",slug:"_5-方法区使用举例",normalizedTitle:"5. 方法区使用举例",charIndex:5825},{level:2,title:"6. 方法区的演进细节",slug:"_6-方法区的演进细节",normalizedTitle:"6. 方法区的演进细节",charIndex:6339},{level:3,title:"JDK6]",slug:"jdk6",normalizedTitle:"jdk6]",charIndex:6610},{level:3,title:"JDK7",slug:"jdk7",normalizedTitle:"jdk7",charIndex:845},{level:3,title:"JDK8",slug:"jdk8",normalizedTitle:"jdk8",charIndex:1053},{level:3,title:"为什么永久代要被元空间替代？",slug:"为什么永久代要被元空间替代",normalizedTitle:"为什么永久代要被元空间替代？",charIndex:6644},{level:3,title:"StringTable为什么要调整位置",slug:"stringtable为什么要调整位置",normalizedTitle:"stringtable为什么要调整位置",charIndex:7576},{level:3,title:"静态变量存放在那里？",slug:"静态变量存放在那里",normalizedTitle:"静态变量存放在那里？",charIndex:7762},{level:2,title:"7. 方法区的垃圾回收",slug:"_7-方法区的垃圾回收",normalizedTitle:"7. 方法区的垃圾回收",charIndex:8308},{level:2,title:"8. 总结",slug:"_8-总结",normalizedTitle:"8. 总结",charIndex:9466}],headersStr:"1. 栈、堆、方法区的交互关系 1.1 从线程共享与否的角度来看 1.2 栈、堆、方法区的交互关系 2. 方法区的理解 HotSpot中方法区的演进 3. 设置方法区大小与OOM jdk7及以前 JDK8以后 OOM: PermGen和 OOM：MetaSpace（处理结果OOM） 4. 方法区的内部结构 类型信息 域信息 方法（Method）信息 non-final的类变量 全局常量 运行时常量池 VS 常量池 常量池 (Constant Pool) 为什么需要常量池？ jclasslib查看具体类的常量池 常量池中有什么 小结 运行时常量池 5. 方法区使用举例 6. 方法区的演进细节 JDK6] JDK7 JDK8 为什么永久代要被元空间替代？ StringTable为什么要调整位置 静态变量存放在那里？ 7. 方法区的垃圾回收 8. 总结",content:'# JVM-方法区\n\n\n# 1. 栈、堆、方法区的交互关系\n\n\n\n> 运行时数据区的最后一部分\n\n\n# 1.1 从线程共享与否的角度来看\n\n\n\n> 上面为：JDK1.7 （1.8有所不同）\n> \n> 堆，元空间：既有异常（OOM）\n\n\n# 1.2 栈、堆、方法区的交互关系\n\n\n\n * Person：存放在元空间，也可以说方法区\n * person：存放在Java栈的局部变量表中\n * new Person()：存放在Java堆中\n\n\n# 2. 方法区的理解\n\n《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。\n\n所以，方法区看作是一块独立于Java堆的内存空间\n\n\n\n> 堆：目的存放“new”的对象 “new Person()“【主要存放的是 实例化的对象】\n> \n> 方法区：存放类的class\n\n 1. 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。\n\n 2. 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。\n\n 3. 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。\n\n 4. 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace\n    \n    * 加载大量的第三方的jar包\n    \n    * Tomcat部署的工程过多（30~50个）\n    \n    * 大量动态的生成反射类\n\n 5. 关闭JVM就会释放这个区域的内存。\n\n\n# HotSpot中方法区的演进\n\n 1. 在JDK7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。\n 2. 本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念\n\n * 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX:MaxPermSize上限）\n\n 3. 而到了JDK8,终于完全废弃了永久代概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来替代。\n    \n    \n\n 4. 元空间的本质和永久代类似，都是JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存.\n\n 5. 永久代、元空间二者并不是只是名字变了，内部结果也调整了。\n\n 6. 根据《Java虚拟机规范》的规定，如果方法区无法妈祖新的内存分配需求时，将抛出OOM异常。\n\n\n# 3. 设置方法区大小与OOM\n\n方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。\n\n\n# jdk7及以前\n\n * 通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M\n * -XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M\n * 当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。\n\n\n\n\n# JDK8以后\n\n 1. 元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定\n\n-XX:MetaspaceSize=100m -XX:MaxMetaspaceSize=100m\n\n\n1\n\n\n\n\n 2. 默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。\n\n\n\n> 元空间使用本地内存\n\n 3. 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace\n\n 4. -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。\n\n 5. 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。\n\npublic class MethodAreaDemo {\n\n    public static void main(String[] args) {\n        System.out.println("start...");\n        try {\n            Thread.sleep(10000000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println("end...");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# OOM: PermGen和 OOM：MetaSpace（处理结果OOM）\n\n 1. 要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）\n    \n    * 内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题\n\n 2. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。\n\n 3. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。\n\n\n# 4. 方法区的内部结构\n\n\n\n《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。\n\n\n\n\n# 类型信息\n\n对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：\n\n * 这个类型的完整有效名称（全名=包名.类名）\n * 这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）\n * 这个类型的修饰符（public，abstract，final的某个子集）\n * 这个类型直接接口的一个有序列表\n\n\n# 域信息\n\nJVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。\n\n域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）\n\n\n# 方法（Method）信息\n\nJVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：\n\n * 方法名称\n * 方法的返回类型（或void）\n * 方法参数的数量和类型（按顺序）\n * 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）\n * 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）\n * 异常表（abstract和native方法除外）\n\n> 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引\n\n\n# non-final的类变量\n\n静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分\n\n类变量被类的所有实例共享，即使没有类实例时，你也可以访问它\n\n/**\n * non-final的类变量\n *\n * @author: CHGGX\n * @create: 2020-07-08-16:54\n */\npublic class MethodAreaTest {\n    public static void main(String[] args) {\n        Order order = new Order();\n        order.hello();\n        System.out.println(order.count);\n    }\n}\nclass Order {\n    public static int count = 1;\n    public static final int number = 2;\n    public static void hello() {\n        System.out.println("hello!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如上代码所示，即使我们把order设置为null，也不会出现空指针异常\n\n\n# 全局常量\n\n全局常量就是使用 static final 进行修饰\n\n被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。\n\n\n# 运行时常量池 VS 常量池\n\n运行时常量池，就是运行时常量池\n\n\n\n * 方法区，内部包含了运行时常量池\n * 字节码文件，内部包含了常量池\n * 要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。\n * 要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。\n\n# 常量池 (Constant Pool)\n\n\n\n一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用\n\n# 为什么需要常量池？\n\n一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。\n\n比如：如下的代码：\n\npublic class SimpleClass {\n    public void sayHello() {\n        System.out.println("hello");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。\n\n# jclasslib查看具体类的常量池\n\n\n\n#1: 代表使用的是 常量池里的\n\n\n\n# 常量池中有什么\n\n * 数量值\n * 字符串值\n * 类引用\n * 字段引用\n * 方法引用\n\n# 小结\n\n常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型\n\n# 运行时常量池\n\n * 运行时常量池（Runtime Constant Pool）是方法区的一部分。\n\n * 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\n * 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。\n\n * JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。\n\n * 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。\n   \n   * 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。 String.intern()\n\n * 运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包- 含的数据却比符号表要更加丰富一些。\n\n * 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。\n\n\n# 5. 方法区使用举例\n\n如下代码\n\npublic class MethodAreaDemo {\n    public static void main(String args[]) {\n        int x = 500;\n        int y = 100;\n        int a = x / y;\n        int b = 50;\n        System.out.println(a+b);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n字节码执行过程展示\n\n\n\n首先现将操作数500放入到操作数栈中\n\n\n\n然后存储到局部变量表中\n\n\n\n然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作\n\n\n\n将500 和 100 进行一个除法运算，在把结果入栈\n\n\n\n在最后就是输出流，需要调用运行时常量池的常量\n\n\n\n最后调用invokevirtual（虚方法调用），然后返回\n\n\n\n返回时\n\n\n\n程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。\n\n\n# 6. 方法区的演进细节\n\n首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一\n\nHotspot中方法区的变化：\n\nJDK1.6及以前   有永久代，静态变量存储在永久代上\nJDK1.7      有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中\nJDK1.8      无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。\n\n\n# JDK6]\n\n\n\n\n# JDK7\n\n\n\n\n# JDK8\n\n\n\n\n# 为什么永久代要被元空间替代？\n\nOPENJDK: http://openjdk.java.net/jeps/122\n\nJRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代\n\n 1. 随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。\n\n 2. 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间.\n\n 3. 这项改动是很有必要的，原因有：\n    \n    * 为永久代设置空间大小是很难确定的。\n    \n    在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。\n    \n    “Exception in thread‘dubbo client x.x connector\'java.lang.OutOfMemoryError:PermGen space”\n    \n    而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。\n    \n    * 对永久代进行调优是很困难的。\n      * 主要是为了降低Full GC\n\n有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏\n\n方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型\n\n\n# StringTable为什么要调整位置\n\n * jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。\n\n * 这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。\n\n\n# 静态变量存放在那里？\n\n静态引用对应的对象实体始终都存在堆空间\n\n可以使用 jhsdb.ext，需要在jdk9的时候才引入的\n\nstaticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。\n\n\n\n测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。\n\n接着，找到了一个引用该staticobj对象的地方，是在一个java.1ang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：\n\n\n\n从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点\n\n\n# 7. 方法区的垃圾回收\n\n 1. 有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。\n\n 2. 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。\n\n 3. 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。\n\n 4. 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：\n    \n    * 类和接口的全限定名\n    * 字段的名称和描述符\n    * 方法的名称和描述符\n\n 5. HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。\n\n 6. 回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）\n\n 7. 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：\n    \n    * 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。\n    * 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。\n    * 该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n 8. Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息\n\n 9. 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。\n\n\n# 8. 总结\n\n',normalizedContent:'# jvm-方法区\n\n\n# 1. 栈、堆、方法区的交互关系\n\n\n\n> 运行时数据区的最后一部分\n\n\n# 1.1 从线程共享与否的角度来看\n\n\n\n> 上面为：jdk1.7 （1.8有所不同）\n> \n> 堆，元空间：既有异常（oom）\n\n\n# 1.2 栈、堆、方法区的交互关系\n\n\n\n * person：存放在元空间，也可以说方法区\n * person：存放在java栈的局部变量表中\n * new person()：存放在java堆中\n\n\n# 2. 方法区的理解\n\n《java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于hotspotjvm而言，方法区还有一个别名叫做non-heap（非堆），目的就是要和堆分开。\n\n所以，方法区看作是一块独立于java堆的内存空间\n\n\n\n> 堆：目的存放“new”的对象 “new person()“【主要存放的是 实例化的对象】\n> \n> 方法区：存放类的class\n\n 1. 方法区（method area）与java堆一样，是各个线程共享的内存区域。\n\n 2. 方法区在jvm启动的时候被创建，并且它的实际的物理内存空间中和java堆区一样都可以是不连续的。\n\n 3. 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。\n\n 4. 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.outofmemoryerror：permgen space 或者java.lang.outofmemoryerror:metaspace\n    \n    * 加载大量的第三方的jar包\n    \n    * tomcat部署的工程过多（30~50个）\n    \n    * 大量动态的生成反射类\n\n 5. 关闭jvm就会释放这个区域的内存。\n\n\n# hotspot中方法区的演进\n\n 1. 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。\n 2. 本质上，方法区和永久代并不等价。仅是对hotspot而言的。《java虚拟机规范》对如何实现方法区，不做统一要求。例如：bea jrockit / ibm j9 中不存在永久代的概念\n\n * 现在来看，当年使用永久代，不是好的idea。导致java程序更容易oom（超过-xx:maxpermsize上限）\n\n 3. 而到了jdk8,终于完全废弃了永久代概念，改用与jrockit、j9一样在本地内存中实现的元空间（metaspace）来替代。\n    \n    \n\n 4. 元空间的本质和永久代类似，都是jvm规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存.\n\n 5. 永久代、元空间二者并不是只是名字变了，内部结果也调整了。\n\n 6. 根据《java虚拟机规范》的规定，如果方法区无法妈祖新的内存分配需求时，将抛出oom异常。\n\n\n# 3. 设置方法区大小与oom\n\n方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。\n\n\n# jdk7及以前\n\n * 通过-xx:permsize来设置永久代初始分配空间。默认值是20.75m\n * -xx:maxpermsize来设定永久代最大可分配空间。32位机器默认是64m，64位机器模式是82m\n * 当jvm加载的类信息容量超过了这个值，会报异常outofmemoryerror:permgen space。\n\n\n\n\n# jdk8以后\n\n 1. 元数据区大小可以使用参数 -xx:metaspacesize 和 -xx:maxmetaspacesize指定\n\n-xx:metaspacesize=100m -xx:maxmetaspacesize=100m\n\n\n1\n\n\n\n\n 2. 默认值依赖于平台。windows下，-xx:metaspacesize是21m，-xx:maxmetaspacesize的值是-1，即没有限制。\n\n\n\n> 元空间使用本地内存\n\n 3. 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常outofmemoryerror:metaspace\n\n 4. -xx:metaspacesize：设置初始的元空间大小。对于一个64位的服务器端jvm来说，其默认的-xx:metaspacesize值为21mb。这就是初始的高水位线，一旦触及这个水位线，ful1gc将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于gc后释放了多少元空间。如果释放的空间不足，那么在不超过maxmetaspacesize时，适当提高该值。如果释放空间过多，则适当降低该值。\n\n 5. 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到ful1gc多次调用。为了避免频繁地gc，建议将-xx:metaspacesize设置为一个相对较高的值。\n\npublic class methodareademo {\n\n    public static void main(string[] args) {\n        system.out.println("start...");\n        try {\n            thread.sleep(10000000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println("end...");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# oom: permgen和 oom：metaspace（处理结果oom）\n\n 1. 要解决oom异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如ec1ipse memory analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（memory leak）还是内存溢出（memory overflow）\n    \n    * 内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和gc root有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题\n\n 2. 如果是内存泄漏，可进一步通过工具查看泄漏对象到gc roots的引用链。于是就能找到泄漏对象是通过怎样的路径与gcroots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及gcroots引用链的信息，就可以比较准确地定位出泄漏代码的位置。\n\n 3. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-xmx与-xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。\n\n\n# 4. 方法区的内部结构\n\n\n\n《深入理解java虚拟机》书中对方法区（method area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。\n\n\n\n\n# 类型信息\n\n对每个加载的类型（类class、接口interface、枚举enum、注解annotation），jvm必须在方法区中存储以下类型信息：\n\n * 这个类型的完整有效名称（全名=包名.类名）\n * 这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）\n * 这个类型的修饰符（public，abstract，final的某个子集）\n * 这个类型直接接口的一个有序列表\n\n\n# 域信息\n\njvm必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。\n\n域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）\n\n\n# 方法（method）信息\n\njvm必须保存所有方法的以下信息，同域信息一样包括声明顺序：\n\n * 方法名称\n * 方法的返回类型（或void）\n * 方法参数的数量和类型（按顺序）\n * 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）\n * 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）\n * 异常表（abstract和native方法除外）\n\n> 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引\n\n\n# non-final的类变量\n\n静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分\n\n类变量被类的所有实例共享，即使没有类实例时，你也可以访问它\n\n/**\n * non-final的类变量\n *\n * @author: chggx\n * @create: 2020-07-08-16:54\n */\npublic class methodareatest {\n    public static void main(string[] args) {\n        order order = new order();\n        order.hello();\n        system.out.println(order.count);\n    }\n}\nclass order {\n    public static int count = 1;\n    public static final int number = 2;\n    public static void hello() {\n        system.out.println("hello!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如上代码所示，即使我们把order设置为null，也不会出现空指针异常\n\n\n# 全局常量\n\n全局常量就是使用 static final 进行修饰\n\n被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。\n\n\n# 运行时常量池 vs 常量池\n\n运行时常量池，就是运行时常量池\n\n\n\n * 方法区，内部包含了运行时常量池\n * 字节码文件，内部包含了常量池\n * 要弄清楚方法区，需要理解清楚c1assfile，因为加载类的信息都在方法区。\n * 要弄清楚方法区的运行时常量池，需要理解清楚classfile中的常量池。\n\n# 常量池 (constant pool)\n\n\n\n一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（constant pool table），包括各种字面量和对类型、域和方法的符号引用\n\n# 为什么需要常量池？\n\n一个java源文件中的类、接口，编译后产生一个字节码文件。而java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。\n\n比如：如下的代码：\n\npublic class simpleclass {\n    public void sayhello() {\n        system.out.println("hello");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n虽然上述代码只有194字节，但是里面却使用了string、system、printstream及object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。\n\n# jclasslib查看具体类的常量池\n\n\n\n#1: 代表使用的是 常量池里的\n\n\n\n# 常量池中有什么\n\n * 数量值\n * 字符串值\n * 类引用\n * 字段引用\n * 方法引用\n\n# 小结\n\n常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型\n\n# 运行时常量池\n\n * 运行时常量池（runtime constant pool）是方法区的一部分。\n\n * 常量池表（constant pool table）是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\n * 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。\n\n * jvm为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。\n\n * 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。\n   \n   * 运行时常量池，相对于class文件常量池的另一重要特征是：具备动态性。 string.intern()\n\n * 运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包- 含的数据却比符号表要更加丰富一些。\n\n * 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则jvm会抛outofmemoryerror异常。\n\n\n# 5. 方法区使用举例\n\n如下代码\n\npublic class methodareademo {\n    public static void main(string args[]) {\n        int x = 500;\n        int y = 100;\n        int a = x / y;\n        int b = 50;\n        system.out.println(a+b);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n字节码执行过程展示\n\n\n\n首先现将操作数500放入到操作数栈中\n\n\n\n然后存储到局部变量表中\n\n\n\n然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作\n\n\n\n将500 和 100 进行一个除法运算，在把结果入栈\n\n\n\n在最后就是输出流，需要调用运行时常量池的常量\n\n\n\n最后调用invokevirtual（虚方法调用），然后返回\n\n\n\n返回时\n\n\n\n程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了cpu切换后，也能回来到原来的代码进行执行。\n\n\n# 6. 方法区的演进细节\n\n首先明确：只有hotspot才有永久代。bea jrockit、ibmj9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《java虚拟机规范》管束，并不要求统一\n\nhotspot中方法区的变化：\n\njdk1.6及以前   有永久代，静态变量存储在永久代上\njdk1.7      有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中\njdk1.8      无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。\n\n\n# jdk6]\n\n\n\n\n# jdk7\n\n\n\n\n# jdk8\n\n\n\n\n# 为什么永久代要被元空间替代？\n\nopenjdk: http://openjdk.java.net/jeps/122\n\njrockit是和hotspot融合后的结果，因为jrockit没有永久代，所以他们不需要配置永久代\n\n 1. 随着java8的到来，hotspot vm中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（metaspace）。\n\n 2. 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间.\n\n 3. 这项改动是很有必要的，原因有：\n    \n    * 为永久代设置空间大小是很难确定的。\n    \n    在某些场景下，如果动态加载类过多，容易产生perm区的oom。比如某个实际web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。\n    \n    “exception in thread‘dubbo client x.x connector\'java.lang.outofmemoryerror:permgen space”\n    \n    而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。\n    \n    * 对永久代进行调优是很困难的。\n      * 主要是为了降低full gc\n\n有些人认为方法区（如hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如jdk11时期的zgc收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的bug列表中，曾出现过的若干个严重的bug就是由于低版本的hotspot虚拟机对此区域未完全回收而导致内存泄漏\n\n方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型\n\n\n# stringtable为什么要调整位置\n\n * jdk7中将stringtable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。\n\n * 这就导致stringtable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。\n\n\n# 静态变量存放在那里？\n\n静态引用对应的对象实体始终都存在堆空间\n\n可以使用 jhsdb.ext，需要在jdk9的时候才引入的\n\nstaticobj随着test的类型信息存放在方法区，instanceobj随着test的对象实例存放在java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。\n\n\n\n测试发现：三个对象的数据在内存中的地址都落在eden区范围内，所以结论：只要是对象实例必然会在java堆中分配。\n\n接着，找到了一个引用该staticobj对象的地方，是在一个java.1ang.class的实例里，并且给出了这个实例的地址，通过inspector查看该对象实例，可以清楚看到这确实是一个java.lang.class类型的对象实例，里面有一个名为staticobj的实例字段：\n\n\n\n从《java虚拟机规范》所定义的概念模型来看，所有class相关的信息都应该存放在方法区之中，但方法区该如何实现，《java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。jdk7及其以后版本的hotspot虚拟机选择把静态变量与类型在java语言一端的映射class对象存放在一起，存储于java堆之中，从我们的实验中也明确验证了这一点\n\n\n# 7. 方法区的垃圾回收\n\n 1. 有些人认为方法区（如hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如jdk11时期的zgc收集器就不支持类卸载）。\n\n 2. 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的bug列表中，曾出现过的若干个严重的bug就是由于低版本的hotspot虚拟机对此区域未完全回收而导致内存泄漏。\n\n 3. 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。\n\n 4. 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：\n    \n    * 类和接口的全限定名\n    * 字段的名称和描述符\n    * 方法的名称和描述符\n\n 5. hotspot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。\n\n 6. 回收废弃常量与回收java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）\n\n 7. 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：\n    \n    * 该类所有的实例都已经被回收，也就是java堆中不存在该类及其任何派生子类的实例。\n    * 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osgi、jsp的重加载等，否则通常是很难达成的。\n    * 该类对应的java.lang.c1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n 8. java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，hotspot虚拟机提供了-xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -xx：+traceclass-loading、-xx：+traceclassunloading查看类加载和卸载信息\n\n 9. 在大量使用反射、动态代理、cglib等字节码框架，动态生成jsp以及osgi这类频繁自定义类加载器的场景中，通常都需要java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。\n\n\n# 8. 总结\n\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"数据库概述",frontmatter:{title:"数据库概述",date:"2023-02-27T11:50:25.000Z",permalink:"/pages/29740f/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/04.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL%E5%9F%BA%E7%A1%80/01.MySQL%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0.html",relativePath:"01.语言/04.数据库/01.MySQL基础/01.MySQL基础-数据库概述.md",key:"v-412cb168",path:"/pages/29740f/",headers:[{level:2,title:"1. 为什么要使用数据库",slug:"_1-为什么要使用数据库",normalizedTitle:"1. 为什么要使用数据库",charIndex:12},{level:2,title:"2. 数据库与数据库管理系统",slug:"_2-数据库与数据库管理系统",normalizedTitle:"2. 数据库与数据库管理系统",charIndex:336},{level:3,title:"2.1 数据库的相关概念",slug:"_2-1-数据库的相关概念",normalizedTitle:"2.1 数据库的相关概念",charIndex:355},{level:3,title:"2.2 数据库与数据库管理系统的关系",slug:"_2-2-数据库与数据库管理系统的关系",normalizedTitle:"2.2 数据库与数据库管理系统的关系",charIndex:840},{level:3,title:"2.3 常见的数据库管理系统排名(DBMS)",slug:"_2-3-常见的数据库管理系统排名-dbms",normalizedTitle:"2.3 常见的数据库管理系统排名(dbms)",charIndex:972},{level:3,title:"2.4 常见的数据库介绍",slug:"_2-4-常见的数据库介绍",normalizedTitle:"2.4 常见的数据库介绍",charIndex:1133},{level:2,title:"3. MySQL介绍",slug:"_3-mysql介绍",normalizedTitle:"3. mysql介绍",charIndex:1952},{level:3,title:"3.1 概述",slug:"_3-1-概述",normalizedTitle:"3.1 概述",charIndex:1967},{level:3,title:"3.2 MySQL发展史重大事件",slug:"_3-2-mysql发展史重大事件",normalizedTitle:"3.2 mysql发展史重大事件",charIndex:2583},{level:3,title:"3.3 关于MySQL 8.0",slug:"_3-3-关于mysql-8-0",normalizedTitle:"3.3 关于mysql 8.0",charIndex:2723},{level:3,title:"3.4 Why choose MySQL?",slug:"_3-4-why-choose-mysql",normalizedTitle:"3.4 why choose mysql?",charIndex:2893},{level:3,title:"3.5 Oracle vs MySQL",slug:"_3-5-oracle-vs-mysql",normalizedTitle:"3.5 oracle vs mysql",charIndex:3066},{level:2,title:"4. RDBMS 与 非RDBMS 😄",slug:"_4-rdbms-与-非rdbms",normalizedTitle:"4. rdbms 与 非rdbms 😄",charIndex:3276},{level:3,title:"4.1 关系型数据库(RDBMS)",slug:"_4-1-关系型数据库-rdbms",normalizedTitle:"4.1 关系型数据库(rdbms)",charIndex:3394},{level:4,title:"实质",slug:"实质",normalizedTitle:"实质",charIndex:3415},{level:4,title:"优势",slug:"优势",normalizedTitle:"优势",charIndex:3679},{level:3,title:"4.2 非关系型数据库(非RDBMS)",slug:"_4-2-非关系型数据库-非rdbms",normalizedTitle:"4.2 非关系型数据库(非rdbms)",charIndex:3761},{level:4,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:1143},{level:4,title:"有哪些非关系型数据库",slug:"有哪些非关系型数据库",normalizedTitle:"有哪些非关系型数据库",charIndex:3899},{level:5,title:"NoSQL的演变",slug:"nosql的演变",normalizedTitle:"nosql的演变",charIndex:4926},{level:4,title:"3. 小结",slug:"_3-小结",normalizedTitle:"3. 小结",charIndex:5356},{level:2,title:"5. 关系型数据库设计规则",slug:"_5-关系型数据库设计规则",normalizedTitle:"5. 关系型数据库设计规则",charIndex:5469},{level:3,title:"5.1 表、记录、字段",slug:"_5-1-表、记录、字段",normalizedTitle:"5.1 表、记录、字段",charIndex:5653},{level:3,title:"5.2 表的关联关系 😄",slug:"_5-2-表的关联关系",normalizedTitle:"5.2 表的关联关系 😄",charIndex:6008},{level:4,title:"一对一关联（one-to-one）",slug:"一对一关联-one-to-one",normalizedTitle:"一对一关联（one-to-one）",charIndex:6113},{level:4,title:"一对多关系（one-to-many）",slug:"一对多关系-one-to-many",normalizedTitle:"一对多关系（one-to-many）",charIndex:6392},{level:4,title:"多对多（many-to-many）",slug:"多对多-many-to-many",normalizedTitle:"多对多（many-to-many）",charIndex:6542},{level:4,title:"自我引用(Self reference)",slug:"自我引用-self-reference",normalizedTitle:"自我引用(self reference)",charIndex:6629}],headersStr:"1. 为什么要使用数据库 2. 数据库与数据库管理系统 2.1 数据库的相关概念 2.2 数据库与数据库管理系统的关系 2.3 常见的数据库管理系统排名(DBMS) 2.4 常见的数据库介绍 3. MySQL介绍 3.1 概述 3.2 MySQL发展史重大事件 3.3 关于MySQL 8.0 3.4 Why choose MySQL? 3.5 Oracle vs MySQL 4. RDBMS 与 非RDBMS 😄 4.1 关系型数据库(RDBMS) 实质 优势 4.2 非关系型数据库(非RDBMS) 介绍 有哪些非关系型数据库 NoSQL的演变 3. 小结 5. 关系型数据库设计规则 5.1 表、记录、字段 5.2 表的关联关系 😄 一对一关联（one-to-one） 一对多关系（one-to-many） 多对多（many-to-many） 自我引用(Self reference)",content:"# 数据库概述\n\n\n# 1. 为什么要使用数据库\n\n * 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。\n\n * 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。\n\n数据库存储特点：\n\n * 数据量大，单表可以存上亿条数据。\n * （横向）存储的数据结构复杂，比如：一些数据存入文件（excel...），不便于打开查找（大于巨量）。存入数据库可以实现统一管理。\n * （纵向）存入数据库中数据类型多样。比如：字符串、日期、数字、json....\n\n\n# 2. 数据库与数据库管理系统\n\n\n# 2.1 数据库的相关概念\n\n相关概念                                       说明                                                                     示例\nDB：数据库（Database）                           即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。                                   MySQL\nDBMS：数据库管理系统（Database Management System）   是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。   \nSQL：结构化查询语言（Structured Query Language）     专门用来与数据库通信的语言。                                                         \n\n\n# 2.2 数据库与数据库管理系统的关系\n\n数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。\n\n数据库管理系统、数据库和表的关系如图所示：\n\n\n# 2.3 常见的数据库管理系统排名(DBMS)\n\n目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、Sybase、Informix这几种。（查看数据库最新排名: https://db-engines.com/en/ranking）。\n\n\n# 2.4 常见的数据库介绍\n\nOracle\n\n1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。\n\n2007年，总计85亿美金收购BEA Systems。\n\n2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。\n\n2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。\n\n如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。\n\nSQL Server\n\nSQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft BackOffice产品集成。\n\nDB2\n\nIBM公司的数据库产品,收费的。常应用在银行系统中。\n\nPostgreSQL\n\nPostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。\n\nSyBase\n\n已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。\n\nSQLite\n\n嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。\n\ninformix\n\nIBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。\n\n\n# 3. MySQL介绍\n\n\n# 3.1 概述\n\n * MySQL是一个开放源代码的关系型数据库管理系统，由瑞典MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的 No.1。\n\n * 2008被 Sun 收购（10亿美金），2009年Sun被Oracle收购。 MariaDB应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB）\n\n * MySQL6.x 版本之后分为社区版和商业版。\n\n * MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n * MySQL是开源的，所以你不需要支付额外的费用。\n\n * MySQL是可以定制的，采用了GPL（GNU General Public License）协议，你可以修改源码来开发自己的MySQL系统。\n\n * MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。\n\n * MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持 4GB ，64位系统支持最大的表文件为8TB 。\n\n * MySQL使用标准的SQL数据语言形式。\n\n * MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。\n\n\n# 3.2 MySQL发展史重大事件\n\nMySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。\n\n\n# 3.3 关于MySQL 8.0\n\nMySQL从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。\n\n\n# 3.4 Why choose MySQL?\n\n\n\n为什么如此多的厂商要选用MySQL？大概总结的原因主要有以下几点：\n\n 1. 开放源代码，使用成本低。\n 2. 性能卓越，服务稳定。\n 3. 软件体积小，使用简单，并且易于维护。\n 4. 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。\n 5. 许多互联网公司在用，经过了时间的验证。\n\n\n# 3.5 Oracle vs MySQL\n\nOracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。\n\nMySQL 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。\n\n\n# 4. RDBMS 与 非RDBMS 😄\n\n从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。\n\n\n# 4.1 关系型数据库(RDBMS)\n\n# 实质\n\n * 这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。\n\n * 关系型数据库以行(row) 和列(column)的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table) ，一组表组成了一个库(database)。\n\n * 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。\n\n * SQL 就是关系型数据库的查询语言。\n\n# 优势\n\n * 复杂查询 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。\n\n * 事务支持 使得对于安全性能很高的数据访问要求得以实现。\n\n\n# 4.2 非关系型数据库(非RDBMS)\n\n# 介绍\n\n非关系型数据库，可看成传统关系型数据库的功能阉割版本 ，基于键值对存储数据，不需要经过SQL层的解析， 性能非常高 。同时，通过减少不常用的功能，进一步提高性能。\n\n目前基本上大部分主流的非关系型数据库都是免费的。\n\n# 有哪些非关系型数据库\n\n相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。\n\n键值型数据库\n\n键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。\n\n键值型数据库典型的使用场景是作为内存缓存 。 Redis 是最流行的键值型数据库。\n\n文档型数据库\n\n此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB是最流行的文档型数据库。此外，还有CouchDB等。\n\n搜索引擎数据库\n\n虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。\n\n典型产品：Solr、Elasticsearch、Splunk 等。\n\n列式数据库\n\n列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。\n\n图形数据库\n\n图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。\n\n图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。\n\n# NoSQL的演变\n\n由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出NoSQL 功能的演变：\n\n1970：NoSQL = We have no SQL\n\n1980：NoSQL = Know SQL\n\n2000：NoSQL = No SQL!\n\n2005：NoSQL = Not only SQL\n\n2013：NoSQL = No, SQL!\n\nNoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用 性能更高 、 成本更低 的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。\n\n# 3. 小结\n\nNoSQL 的分类很多，即便如此，在 DBMS 排名中，还是 SQL 阵营的比重更大，影响力前 5 的 DBMS 中有4 个是关系型数据库，而排名前 20 的 DBMS 中也有 12 个是关系型数据库。\n\n\n# 5. 关系型数据库设计规则\n\n * 关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（Structured）。\n\n * 将数据放到表中，表再放到库中。\n\n * 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。\n\n * 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。\n\n\n# 5.1 表、记录、字段\n\n * E-R（entity-relationship，实体-联系）模型中有三个主要概念是： 实体集、 属性 、 联系集 。\n\n * 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。\n\n\n\nORM思想 (Object Relational Mapping)体现：\n数据库中的一个表 <---\x3e Java或Python中的一个类\n表中的一条数据 <---\x3e 类中的一个对象（或实体）\n表中的一个列 <----\x3e 类中的一个字段、属性(field)\n\n\n1\n2\n3\n4\n\n\n\n# 5.2 表的关联关系 😄\n\n表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。\n\n四种：一对一关联、一对多关联、多对多关联、自我引用\n\n# 一对一关联（one-to-one）\n\n * 在实际的开发中应用不多，因为一对一可以创建成一张表。\n\n * 举例：设计 学生表 ：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、...\n\n拆为两个表：两个表的记录是一一对应关系。\n\n基础信息表 （常用信息）：学号、姓名、手机号码、班级、系别\n\n档案信息表 （不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、...\n\n * 两种建表原则：\n\n外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。\n\n外键是主键：主表的主键和从表的主键，形成主外键关系。\n\n# 一对多关系（one-to-many）\n\n * 常见实例场景： 客户表和订单表 ， 分类表和商品表 ， 部门表和员工表 。\n\n * 举例：\n\n员工表：编号、姓名、...、所属部门\n\n部门表：编号、名称、简介\n\n * 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键\n\n# 多对多（many-to-many）\n\n要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。\n\n# 自我引用(Self reference)",normalizedContent:"# 数据库概述\n\n\n# 1. 为什么要使用数据库\n\n * 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。\n\n * 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、xml数据文件中。\n\n数据库存储特点：\n\n * 数据量大，单表可以存上亿条数据。\n * （横向）存储的数据结构复杂，比如：一些数据存入文件（excel...），不便于打开查找（大于巨量）。存入数据库可以实现统一管理。\n * （纵向）存入数据库中数据类型多样。比如：字符串、日期、数字、json....\n\n\n# 2. 数据库与数据库管理系统\n\n\n# 2.1 数据库的相关概念\n\n相关概念                                       说明                                                                     示例\ndb：数据库（database）                           即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。                                   mysql\ndbms：数据库管理系统（database management system）   是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。   \nsql：结构化查询语言（structured query language）     专门用来与数据库通信的语言。                                                         \n\n\n# 2.2 数据库与数据库管理系统的关系\n\n数据库管理系统(dbms)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。\n\n数据库管理系统、数据库和表的关系如图所示：\n\n\n# 2.3 常见的数据库管理系统排名(dbms)\n\n目前互联网上常见的数据库管理软件有oracle、mysql、ms sql server、db2、postgresql、access、sybase、informix这几种。（查看数据库最新排名: https://db-engines.com/en/ranking）。\n\n\n# 2.4 常见的数据库介绍\n\noracle\n\n1979 年，oracle 2 诞生，它是第一个商用的 rdbms（关系型数据库管理系统）。随着 oracle 软件的名气越来越大，公司也改名叫 oracle 公司。\n\n2007年，总计85亿美金收购bea systems。\n\n2009年，总计74亿美金收购sun。此前的2008年，sun以10亿美金收购mysql。意味着oracle 同时拥有了mysql 的管理权，至此 oracle 在数据库领域中成为绝对的领导者。\n\n2013年，甲骨文超越ibm，成为继microsoft后全球第二大软件公司。\n\n如今 oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。\n\nsql server\n\nsql server 是微软开发的大型商业数据库，诞生于 1989 年。c#、.net等语言常使用，与winnt完全集成，也可以很好地与microsoft backoffice产品集成。\n\ndb2\n\nibm公司的数据库产品,收费的。常应用在银行系统中。\n\npostgresql\n\npostgresql 的稳定性极强，最符合sql标准，开放源码，具备商业级dbms质量。pg对数据量大的文本以及sql处理较快。\n\nsybase\n\n已经淡出历史舞台。提供了一个非常专业数据建模的工具powerdesigner。\n\nsqlite\n\n嵌入式的小型数据库，应用在手机端。 零配置，sqlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。\n\ninformix\n\nibm公司出品，取自information 和unix的结合，它是第一个被移植到linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。\n\n\n# 3. mysql介绍\n\n\n# 3.1 概述\n\n * mysql是一个开放源代码的关系型数据库管理系统，由瑞典mysql ab（创始人michael widenius）公司1995年开发，迅速成为开源数据库的 no.1。\n\n * 2008被 sun 收购（10亿美金），2009年sun被oracle收购。 mariadb应运而生。（mysql 的创造者担心 mysql 有闭源的风险，因此创建了 mysql 的分支项目 mariadb）\n\n * mysql6.x 版本之后分为社区版和商业版。\n\n * mysql是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n * mysql是开源的，所以你不需要支付额外的费用。\n\n * mysql是可以定制的，采用了gpl（gnu general public license）协议，你可以修改源码来开发自己的mysql系统。\n\n * mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。\n\n * mysql支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持 4gb ，64位系统支持最大的表文件为8tb 。\n\n * mysql使用标准的sql数据语言形式。\n\n * mysql可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括c、c++、python、java、perl、php和ruby等。\n\n\n# 3.2 mysql发展史重大事件\n\nmysql的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了mysql的长足发展。\n\n\n# 3.3 关于mysql 8.0\n\nmysql从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。mysql 8版本在功能上做了显著的改进与增强，开发者对mysql的源代码进行了重构，最突出的一点是多mysql optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。\n\n\n# 3.4 why choose mysql?\n\n\n\n为什么如此多的厂商要选用mysql？大概总结的原因主要有以下几点：\n\n 1. 开放源代码，使用成本低。\n 2. 性能卓越，服务稳定。\n 3. 软件体积小，使用简单，并且易于维护。\n 4. 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。\n 5. 许多互联网公司在用，经过了时间的验证。\n\n\n# 3.5 oracle vs mysql\n\noracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。\n\nmysql 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了mysql作为网站数据库（facebook，twitter，youtube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。\n\n\n# 4. rdbms 与 非rdbms 😄\n\n从排名中我们能看出来，关系型数据库绝对是 dbms 的主流，其中使用最多的 dbms 分别是 oracle、mysql 和 sql server。这些都是关系型数据库（rdbms）。\n\n\n# 4.1 关系型数据库(rdbms)\n\n# 实质\n\n * 这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。\n\n * 关系型数据库以行(row) 和列(column)的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table) ，一组表组成了一个库(database)。\n\n * 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。\n\n * sql 就是关系型数据库的查询语言。\n\n# 优势\n\n * 复杂查询 可以用sql语句方便的在一个表以及多个表之间做非常复杂的数据查询。\n\n * 事务支持 使得对于安全性能很高的数据访问要求得以实现。\n\n\n# 4.2 非关系型数据库(非rdbms)\n\n# 介绍\n\n非关系型数据库，可看成传统关系型数据库的功能阉割版本 ，基于键值对存储数据，不需要经过sql层的解析， 性能非常高 。同时，通过减少不常用的功能，进一步提高性能。\n\n目前基本上大部分主流的非关系型数据库都是免费的。\n\n# 有哪些非关系型数据库\n\n相比于 sql，nosql 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 nosql 一词才能将这些技术囊括进来。\n\n键值型数据库\n\n键值型数据库通过 key-value 键值的方式来存储数据，其中 key 和 value 可以是简单的对象，也可以是复杂的对象。key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 where），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。\n\n键值型数据库典型的使用场景是作为内存缓存 。 redis 是最流行的键值型数据库。\n\n文档型数据库\n\n此类数据库可存放并获取文档，可以是xml、json等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。mongodb是最流行的文档型数据库。此外，还有couchdb等。\n\n搜索引擎数据库\n\n虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。\n\n典型产品：solr、elasticsearch、splunk 等。\n\n列式数据库\n\n列式数据库是相对于行式存储的数据库，oracle、mysql、sql server 等数据库都是采用的行式存储（row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的i/o，适合于分布式文件系统，不足在于功能相对有限。典型产品：hbase等。\n\n图形数据库\n\n图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。\n\n图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：neo4j、infogrid等。\n\n# nosql的演变\n\n由于 sql 一直称霸 dbms，因此许多人在思考是否有一种数据库技术能远离 sql，于是 nosql 诞生了，但是随着发展却发现越来越离不开 sql。到目前为止 nosql 阵营中的 dbms 都会有实现类似 sql 的功能。下面是“nosql”这个名词在不同时期的诠释，从这些释义的变化中可以看出nosql 功能的演变：\n\n1970：nosql = we have no sql\n\n1980：nosql = know sql\n\n2000：nosql = no sql!\n\n2005：nosql = not only sql\n\n2013：nosql = no, sql!\n\nnosql 对 sql 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用 性能更高 、 成本更低 的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。\n\n# 3. 小结\n\nnosql 的分类很多，即便如此，在 dbms 排名中，还是 sql 阵营的比重更大，影响力前 5 的 dbms 中有4 个是关系型数据库，而排名前 20 的 dbms 中也有 12 个是关系型数据库。\n\n\n# 5. 关系型数据库设计规则\n\n * 关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（structured）。\n\n * 将数据放到表中，表再放到库中。\n\n * 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。\n\n * 表具有一些特性，这些特性定义了数据在表中如何存储，类似java和python中 “类”的设计。\n\n\n# 5.1 表、记录、字段\n\n * e-r（entity-relationship，实体-联系）模型中有三个主要概念是： 实体集、 属性 、 联系集 。\n\n * 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。\n\n\n\norm思想 (object relational mapping)体现：\n数据库中的一个表 <---\x3e java或python中的一个类\n表中的一条数据 <---\x3e 类中的一个对象（或实体）\n表中的一个列 <----\x3e 类中的一个字段、属性(field)\n\n\n1\n2\n3\n4\n\n\n\n# 5.2 表的关联关系 😄\n\n表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。\n\n四种：一对一关联、一对多关联、多对多关联、自我引用\n\n# 一对一关联（one-to-one）\n\n * 在实际的开发中应用不多，因为一对一可以创建成一张表。\n\n * 举例：设计 学生表 ：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、...\n\n拆为两个表：两个表的记录是一一对应关系。\n\n基础信息表 （常用信息）：学号、姓名、手机号码、班级、系别\n\n档案信息表 （不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、...\n\n * 两种建表原则：\n\n外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。\n\n外键是主键：主表的主键和从表的主键，形成主外键关系。\n\n# 一对多关系（one-to-many）\n\n * 常见实例场景： 客户表和订单表 ， 分类表和商品表 ， 部门表和员工表 。\n\n * 举例：\n\n员工表：编号、姓名、...、所属部门\n\n部门表：编号、名称、简介\n\n * 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键\n\n# 多对多（many-to-many）\n\n要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。\n\n# 自我引用(self reference)",charsets:{cjk:!0},lastUpdated:"2023/03/10, 07:35:07",lastUpdatedTimestamp:1678404907e3},{title:"MySQL环境搭建(windows版)",frontmatter:{title:"MySQL环境搭建(windows版)",date:"2023-02-28T18:04:01.000Z",permalink:"/pages/274d31/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/04.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL%E5%9F%BA%E7%A1%80/02.MySQL%E5%9F%BA%E7%A1%80-MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(windows%E7%89%88).html",relativePath:"01.语言/04.数据库/01.MySQL基础/02.MySQL基础-MySQL环境搭建(windows版).md",key:"v-0cff2ea9",path:"/pages/274d31/",headers:[{level:2,title:"1 MySQL的下载、安装、配置",slug:"_1-mysql的下载、安装、配置",normalizedTitle:"1 mysql的下载、安装、配置",charIndex:60},{level:3,title:"1.1 MySQL的4大版本",slug:"_1-1-mysql的4大版本",normalizedTitle:"1.1 mysql的4大版本",charIndex:81},{level:3,title:"1.2 软件的下载",slug:"_1-2-软件的下载",normalizedTitle:"1.2 软件的下载",charIndex:529},{level:2,title:"2. MySQL8.0安装配置",slug:"_2-mysql8-0安装配置",normalizedTitle:"2. mysql8.0安装配置",charIndex:1192},{level:3,title:"安装MySQL8.0",slug:"安装mysql8-0",normalizedTitle:"安装mysql8.0",charIndex:1242},{level:3,title:"配置MySQL8.0",slug:"配置mysql8-0",normalizedTitle:"配置mysql8.0",charIndex:2172},{level:3,title:"确认安装目录",slug:"确认安装目录",normalizedTitle:"确认安装目录",charIndex:3573},{level:3,title:"配置环境变量",slug:"配置环境变量",normalizedTitle:"配置环境变量",charIndex:3682},{level:3,title:"验证是否安装成功",slug:"验证是否安装成功",normalizedTitle:"验证是否安装成功",charIndex:3844},{level:2,title:"3. MySQL5.7安装配置",slug:"_3-mysql5-7安装配置",normalizedTitle:"3. mysql5.7安装配置",charIndex:3999},{level:3,title:"安装MySQL5.7",slug:"安装mysql5-7",normalizedTitle:"安装mysql5.7",charIndex:1119},{level:3,title:"配置MySQL5.7",slug:"配置mysql5-7",normalizedTitle:"配置mysql5.7",charIndex:4499},{level:3,title:"确认安装目录",slug:"确认安装目录-2",normalizedTitle:"确认安装目录",charIndex:3573},{level:3,title:"验证是否安装成功",slug:"验证是否安装成功-2",normalizedTitle:"验证是否安装成功",charIndex:3844},{level:2,title:"4. MySQL的卸载",slug:"_4-mysql的卸载",normalizedTitle:"4. mysql的卸载",charIndex:5765},{level:3,title:"1. 停止MySQL服务",slug:"_1-停止mysql服务",normalizedTitle:"1. 停止mysql服务",charIndex:5781},{level:3,title:"2. 软件的卸载",slug:"_2-软件的卸载",normalizedTitle:"2. 软件的卸载",charIndex:5931},{level:4,title:"通过控制面板方式",slug:"通过控制面板方式",normalizedTitle:"通过控制面板方式",charIndex:5943},{level:4,title:"通过安装包提供的卸载功能卸载",slug:"通过安装包提供的卸载功能卸载",normalizedTitle:"通过安装包提供的卸载功能卸载",charIndex:6060},{level:3,title:"3. 残余文件的清理",slug:"_3-残余文件的清理",normalizedTitle:"3. 残余文件的清理",charIndex:6465},{level:3,title:"4. 清理注册表",slug:"_4-清理注册表",normalizedTitle:"4. 清理注册表",charIndex:6662},{level:2,title:"5. MySQL的登录",slug:"_5-mysql的登录",normalizedTitle:"5. mysql的登录",charIndex:7260},{level:3,title:"5.1 服务的启动与停止",slug:"_5-1-服务的启动与停止",normalizedTitle:"5.1 服务的启动与停止",charIndex:7276},{level:4,title:"使用图形界面工具",slug:"使用图形界面工具",normalizedTitle:"使用图形界面工具",charIndex:7393},{level:4,title:"使用命令行工具",slug:"使用命令行工具",normalizedTitle:"使用命令行工具",charIndex:7727},{level:3,title:"5.2 自带客户端的登录与退出",slug:"_5-2-自带客户端的登录与退出",normalizedTitle:"5.2 自带客户端的登录与退出",charIndex:7917},{level:4,title:"MySQL自带客户端",slug:"mysql自带客户端",normalizedTitle:"mysql自带客户端",charIndex:7984},{level:4,title:"windows命令行",slug:"windows命令行",normalizedTitle:"windows命令行",charIndex:8066},{level:4,title:"退出登录",slug:"退出登录",normalizedTitle:"退出登录",charIndex:8738},{level:2,title:"6. MySQL目录结构与源码",slug:"_6-mysql目录结构与源码",normalizedTitle:"6. mysql目录结构与源码",charIndex:8769},{level:3,title:"6.1 主要目录结构",slug:"_6-1-主要目录结构",normalizedTitle:"6.1 主要目录结构",charIndex:8789},{level:3,title:"6.2  MySQL源代码获取",slug:"_6-2-mysql源代码获取",normalizedTitle:"6.2  mysql源代码获取",charIndex:null},{level:2,title:"7. 常见问题的解决",slug:"_7-常见问题的解决",normalizedTitle:"7. 常见问题的解决",charIndex:9673},{level:3,title:"1. root用户密码忘记，重置的操作",slug:"_1-root用户密码忘记-重置的操作",normalizedTitle:"1. root用户密码忘记，重置的操作",charIndex:9688},{level:3,title:'2. mysql命令报"不是内部或外部命令"',slug:"_2-mysql命令报-不是内部或外部命令",normalizedTitle:"2. mysql命令报&quot;不是内部或外部命令&quot;",charIndex:null},{level:3,title:"3. 错误ERROR ：没有选择数据库就操作表格和数据",slug:"_3-错误error-没有选择数据库就操作表格和数据",normalizedTitle:"3. 错误error ：没有选择数据库就操作表格和数据",charIndex:10248},{level:3,title:"4. 命令行客户端的字符集问题",slug:"_4-命令行客户端的字符集问题",normalizedTitle:"4. 命令行客户端的字符集问题",charIndex:10397},{level:3,title:"5. 修改数据库和表的字符编码",slug:"_5-修改数据库和表的字符编码",normalizedTitle:"5. 修改数据库和表的字符编码",charIndex:10697}],headersStr:'1 MySQL的下载、安装、配置 1.1 MySQL的4大版本 1.2 软件的下载 2. MySQL8.0安装配置 安装MySQL8.0 配置MySQL8.0 确认安装目录 配置环境变量 验证是否安装成功 3. MySQL5.7安装配置 安装MySQL5.7 配置MySQL5.7 确认安装目录 验证是否安装成功 4. MySQL的卸载 1. 停止MySQL服务 2. 软件的卸载 通过控制面板方式 通过安装包提供的卸载功能卸载 3. 残余文件的清理 4. 清理注册表 5. MySQL的登录 5.1 服务的启动与停止 使用图形界面工具 使用命令行工具 5.2 自带客户端的登录与退出 MySQL自带客户端 windows命令行 退出登录 6. MySQL目录结构与源码 6.1 主要目录结构 6.2  MySQL源代码获取 7. 常见问题的解决 1. root用户密码忘记，重置的操作 2. mysql命令报"不是内部或外部命令" 3. 错误ERROR ：没有选择数据库就操作表格和数据 4. 命令行客户端的字符集问题 5. 修改数据库和表的字符编码',content:"# MySQL环境搭建(windows版)\n\n> 提示本次使用安装环境：windows server 2022\n\n\n# 1 MySQL的下载、安装、配置\n\n\n# 1.1 MySQL的4大版本\n\n>  * MySQL Community Server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。\n> \n>  * MySQL Enterprise Edition 企业版本，需付费，不能在线下载，可以试用30天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。\n> \n>  * MySQL Cluster 集群版，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用。\n> \n>  * MySQL Cluster CGE 高级集群版，需付费。\n\n此外，官方还提供了 MySQL Workbench （GUITOOL）一款专为MySQL设计的 图形界面管理工具 。MySQLWorkbench又分为两个版本，分别是 社区版 （MySQL Workbench OSS）、 商用版 （MySQL WorkbenchSE）。\n\n\n# 1.2 软件的下载\n\n 1. 下载地址：官网\n\n 2. 打开官网，点击DOWNLOADS\n\n 3. 然后，点击 MySQL Community(GPL) Downloads\n\n 4. 点击MySQL Community Server\n    \n    \n\n 5. 在General Availability(GA) Releases中选择适合的版本\n    \n    Windows平台下提供两种安装文件：MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版使用起来要简单，不再需要其他工具启动就可以运行MySQL。\n    \n    * 这里在Windows 系统下推荐下载MSI安装程序；点击Go to Download Page进行下载即可。\n    \n    * Windows下的MySQL8.0安装有两种安装程序\n      \n      mysql-installer-web-community-8.0.32.0.msi 下载程序大小：2.4M；安装时需要联网安装组件。\n      \n      mysql-installer-community-8.0.32.0.msi 下载程序大小：437.3M；安装时离线安装即可。推荐。\n    \n    * 如果安装MySQL5.7版本的话，选择Archives，接着选择MySQL5.7的相应版本即可。这里下载最近期的MySQL5.7.34版本。\n\n\n# 2. MySQL8.0安装配置\n\n> 端口号：3306 账号：root 密码：123456\n\n\n# 安装MySQL8.0\n\nMySQL下载完成后，找到下载文件，双击进行安装，具体操作步骤如下。\n\n\n\n 1. 双击下载的mysql-installer-community-8.0.32.0.msi文件，打开安装向导。\n    \n    \n\n 2. 打开Choosing a Setup Type（选择安装类型）窗口，在其中列出了5种安装类型，分别是Developer Default（默认安装类型）、Server only（仅作为服务器）、Client only（仅作为客户端）、Full（完全安装）、Custom（自定义安装）。这里选择Custom（自定义安装）类型按钮，单击“Next(下一步)”按钮。\n    \n    \n    \n    3. 打开Select Products（选择产品）窗口，可以定制需要安装的产品清单。例如，选择MySQL Server 8.0.26-X64后，单击→添加按钮，即可选择安装MySQL服务器，如图所示。采用通用的方法，可以添加其他你需要安装的产品。\n       \n       \n       \n       此时如果直接Next（下一步），则产品的安装路径是默认的。如果想要自定义安装目录，则可以选中对应的产品，然后在下面会出现“Advanced Options”（高级选项）的超链接。\n       \n       \n       \n       单击Advanced Options（高级选项）则会弹出安装目录的选择窗口，如图所示，此时你可以分别设置MySQL的服务程序安装目录和数据存储目录。如果不设置，默认分别在C盘的Program Files目录和ProgramData目录（这是一个隐藏目录）。如果自定义安装目录，请避免“中文”目录。另外，建议服务目录和数据目录分开存放。\n       \n       \n\n 3. 在上一步选择好要安装的产品之后，单击Next（下一步）进入确认窗口，如图所示。单击Execute（执行）按钮开始安装。\n    \n    \n\n 4. 安装完成后在Status（状态）列表下将显示Complete（安装完成），如图所示。\n    \n    \n    \n    \n\n\n# 配置MySQL8.0\n\nMySQL安装之后，需要对服务器进行配置。具体的配置步骤如下。\n\n 1.  在安装MySQL8.0最后一步，单击Next（下一步）按钮，就可以进入产品配置窗口。\n     \n     \n\n 2.  单击Next（下一步）按钮，进入MySQL服务器类型配置窗口，如图所示。端口号一般选择默认端口号3306。\n     \n     \n     \n     其中，Config Type选项用于设置服务器的类型。单击该选项右侧的下三角按钮，即可查看3个选项，如图所示。\n     \n     \n     \n     * Development Machine（开发机器） ：该选项代表典型个人用桌面工作站。此时机器上需要运行多个应用程序，那么MySQL服务器将占用最少的系统资源。\n     \n     * Server Machine（服务器） ：该选项代表服务器，MySQL服务器可以同其他服务器应用程序一起运行，例如Web服务器等。MySQL服务器配置成适当比例的系统资源。\n     \n     * Dedicated Machine（专用服务器） ：该选项代表只运行MySQL服务的服务器。MySQL服务器配置成使用所有可用系统资源。\n\n 3.  单击Next（下一步）按钮，打开设置授权方式窗口。其中，上面的选项是MySQL8.0提供的新的授权方式，采用SHA256基础的密码加密方法；下面的选项是传统授权方法（保留5.x版本兼容性）。\n     \n     \n\n 4.  单击Next（下一步）按钮，打开设置服务器root超级管理员的密码窗口，如图所示，需要输入两次同样的登录密码。也可以通过“Add User”添加其他用户，添加其他用户时，需要指定用户名、允许该用户名在哪台/哪些主机上登录，还可以指定用户角色等。此处暂不添加用户，用户管理在MySQL高级特性篇中讲解。\n     \n     \n\n 5.  单击Next（下一步）按钮，打开设置服务器名称窗口，如图所示。该服务名会出现在Windows服务列表中，也可以在命令行窗口中使用该服务名进行启动和停止服务。本书将服务名设置为“MySQL80”。如果希望开机自启动服务，也可以勾选Start the MySQL Server at System Startup选项（推荐）。\n     \n     下面是选择以什么方式运行服务？可以选择Standard System Account(标准系统用户)或者Custom User(自定义用户)中的一个。这里推荐前者。\n     \n     \n\n 6.  单击Next（下一步）按钮，配置文件权限\n     \n     \n     \n     > 注意：低版本没有这步。8.0.26\n\n 7.  单击Next（下一步）按钮，打开确认设置服务器窗口，单击Execute（执行）按钮。\n     \n     \n\n 8.  完成配置，如图所示。单击Finish（完成）按钮，即可完成服务器的配置。\n     \n     \n\n 9.  如果还有其他产品需要配置，可以选择其他产品，然后继续配置。如果没有，直接选择Next（下一步），直接完成整个安装和配置过程。\n     \n     \n\n 10. 单击Next（下一步）按钮，结束安装和配置。\n     \n     \n\n\n# 确认安装目录\n\n 1. 安装目录 C:\\Program Files\\MySQL\\MySQL Server 8.0\n\n 2. 数据目录 C:\\ProgramData\\MySQL\\MySQL Server 8.0\n\n\n# 配置环境变量\n\n 1. 进入到安装目录. 复制C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin 根据自己实际安装的目录。\n\n 2. 进入环境变量中，添加配置。\n\n 3. 命令号查看版本\n    \n    mysql --version\n    \n    \n    1\n    \n\n\n# 验证是否安装成功\n\n环境变量只能配置一个数据库，此处使用命令行进入数据库\n\n方式一：命令行进入数据库\n\nmysql -uroot -p123456 -hlocalhost -P3306\n\n\n1\n\n\n\n\n方式二：进入数据库后，执行致命查询版本号语句。\n\nselect version();\n\n\n1\n\n\n\n\n\n# 3. MySQL5.7安装配置\n\n> 端口号：13306 账号：root 密码：123456\n\n\n# 安装MySQL5.7\n\n此版本的安装过程与上述过程除了版本号不同之外，其它环节都是相同的。下面为MySQL5.7.34版本的安装截图。\n\n 1. 双击进入安装向导\n\n\n\n 2. 之前已经安装8.0.32时候，安装mysql直接进入下面时候。选择add\n    \n    \n\n 3. 之前已经安装8.0.32时候，进入下面页面操作\n    \n    * 去掉勾选，不进行升级\n    * 点击cancle, 进入下图，点击yes,取消升级\n    \n    \n    \n    * 进入安装页面，点击add进入安装5.7.34\n\n 4. 选择安装产品、配置安装路径\n    \n    \n\n 5. 单击Next（下一步）按钮，配置安装环境\n    \n    \n    \n    \n\n 6. 单击Next（下一步）按钮，执行安装\n    \n    \n    \n    \n\n 7. 完成配置，如图所示。单击Finish（完成）按钮，即可完成服务器的配置。\n    \n    \n\n 8. \n 9. \n\n\n# 配置MySQL5.7\n\n配置环节与MySQL8.0版本确有细微不同。大部分情况下直接选择“Next”即可，不影响整理使用。\n\n这里配置MySQL5.7时，重点强调：与前面安装好的MySQL8.0不能使用相同的端口号。\n\n 1.  在安装MySQL5.7最后一步，单击Next（下一步）按钮，就可以进入产品配置窗口。\n     \n     \n\n 2.  单击Next（下一步）按钮，进入MySQL服务器类型配置窗口，如图所示。端口号一般选择默认端口号13306。\n     \n     \n\n 3.  单击Next（下一步）按钮，打开设置服务器root超级管理员的密码窗口，如图所示，需要输入两次同样的登录密码。也可以通过“Add User”添加其他用户，添加其他用户时，需要指定用户名、允许该用户名在哪台/哪些主机上登录，还可以指定用户角色等。此处暂不添加用户，用户管理在MySQL高级特性篇中讲解。\n     \n     \n\n 4.  单击Next（下一步）按钮，打开设置服务器名称窗口，如图所示。该服务名会出现在Windows服务列表中，也可以在命令行窗口中使用该服务名进行启动和停止服务。本书将服务名设置为“MySQL80”。如果希望开机自启动服务，也可以勾选Start the MySQL Server at System Startup选项（推荐）。\n     \n     下面是选择以什么方式运行服务？可以选择Standard System Account(标准系统用户)或者Custom User(自定义用户)中的一个。这里推荐前者。\n     \n     \n\n 5.  单击Next（下一步）按钮，配置文件权限\n     \n     \n\n 6.  单击Next（下一步）按钮，打开确认设置服务器窗口，单击Execute（执行）按钮。\n     \n     \n\n 7.  完成配置，如图所示。单击Finish（完成）按钮，即可完成服务器的配置。\n     \n     \n\n 8.  点击如果还有其他产品需要配置，可以选择其他产品，然后继续配置。如果没有，直接选择Next（下一步），直接完成整个安装和配置过程。\n     \n     \n\n 9.  单击Next（下一步）按钮，结束安装和配置。\n     \n     \n\n 10. 返回mysql添加页面\n     \n     \n\n\n# 确认安装目录\n\n 1. 安装目录 C:\\Program Files\\MySQL\\MySQL Server 5.7\n\n 2. 数据目录 C:\\ProgramData\\MySQL\\MySQL Server 5.7\n\n\n# 验证是否安装成功\n\n环境变量只能配置一个数据库，此处使用命令行进入数据库\n\n方式一：通过命令行进入数据库\n\nmysql -uroot -p123456 -hlocalhost -P13306\n\n\n1\n\n\n\n\n方式二：进入数据库后，执行致命查询版本号语句。\n\nselect version();\n\n\n1\n\n\n\n\n\n# 4. MySQL的卸载\n\n\n# 1. 停止MySQL服务\n\n在卸载之前，先停止MySQL8.0的服务。按键盘上的Ctrl + Alt + Delete组合键，打开任务管理器”对话框，可以在“服务”列表找到“MySQL8.0”的服务，如果现在正在运行状态，可以右键单击服务，选择停止选项停止MySQL8.0的服务，如图所示。\n\n\n# 2. 软件的卸载\n\n# 通过控制面板方式\n\n卸载MySQL8.0的程序可以和其他桌面应用程序一样直接在“控制面板”选择“卸载程序”，并在程序列表中找到MySQL8.0服务器程序，直接双击卸载即可，如图所示。这种方式删除，数据目录下的数据不会跟着删除。\n\n# 通过安装包提供的卸载功能卸载\n\n你也可以通过安装向导程序进行MySQL8.0服务器程序的卸载。\n\n 1. 再次双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。安装向导会自动检测已安装的MySQL服务器程序。\n\n 2. 选择要卸载的MySQL服务器程序，单击“Remove”（移除），即可进行卸载。\n\n 3. 单击Next（下一步）按钮，确认卸载。\n\n 4. 弹出是否同时移除数据目录选择窗口。如果想要同时删除MySQL服务器中的数据，则勾选Removethe datadirectory，如图所示。\n\n 5. 执行卸载。单击“Execute”（执行）按钮进行卸载。\n\n 6. 完成卸载。单击Finish（完成）按钮即可。如果想要同时卸载MySQL8.0的安装向导程序，勾选Yes，UninstallMySQLInstaller即可，如图所示。\n\n\n# 3. 残余文件的清理\n\n如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。\n\n 1. 服务的安装目录。\n\n 2. 数据目录：默认在·C:\\ProgramData\\MySQL·。\n\n如果自己单独指定过数据目录，就找到自己的数据目录进行删除即可。\n\n> 注意：请在卸载前做好数据备份.\n> \n> 在操作完以后，需要重启计算机，然后进行安装即可。如果仍然安装失败，需要继续操作如下步\n\n\n# 4. 清理注册表\n\n如果前几步做了，再次安装还是失败，那么可以清理注册表。\n\n如何打开注册表编辑器：在系统的搜索框中输入regedit\n\nHKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\MySQL服务 目录删除\nHKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\MySQL服务 目录删除\nHKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\MySQL服务 目录删除\nHKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\MySQL服务 目录删除\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\MySQL服务目录删除\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\MySQL服务删除\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注册表中的ControlSet001,ControlSet002,不一定是001和002,可能是ControlSet005、006之类\n\n\n# 5. MySQL的登录\n\n\n# 5.1 服务的启动与停止\n\nMySQL安装完毕之后，需要启动服务器进程，不然客户端无法连接数据库。在前面的配置过程中，已经将MySQL安装为Windows服务，并且勾选当Windows启动、停止时，MySQL也自动启动、停止。\n\n# 使用图形界面工具\n\n 1. 打开windows服务\n    \n    * 方式1：计算机（点击鼠标右键）→ 管理（点击）→ 服务和应用程序（点击）→ 服务（点击）。\n    \n    * 方式2：控制面板（点击）→ 系统和安全（点击）→ 管理工具（点击）→ 服务（点击）。\n    \n    * 方式3：任务栏（点击鼠标右键）→ 启动任务管理器（点击）→ 服务（点击）。\n    \n    * 方式4：单击【开始】菜单，在搜索框中输入services.msc 或者服务，按Enter键确认。\n    \n    * 方式5：win+R, 输入services.msc，按Enter键确认。\n\n 2. 找到MySQL80/57（点击鼠标右键）→ 启动或停止（点击）\n\n# 使用命令行工具\n\n# 启动 MySQL 服务命令：\nnet start MySQL服务名\n\n# 停止 MySQL 服务命令：\nnet stop MySQL服务名\n\n\n1\n2\n3\n4\n5\n\n\n说明：\n\n 1. start和stop后面的服务名应与之前配置时指定的服务名一致。\n 2. 如果当你输入命令后，提示“拒绝服务”，请以 系统管理员身份 打开命令提示符界面重新尝试。\n\n\n# 5.2 自带客户端的登录与退出\n\n当MySQL服务启动完成后，便可以通过客户端来登录MySQL数据库。注意：确认服务是开启的。\n\n# MySQL自带客户端\n\n开始菜单 -》 所有程序 -》 MySQL -》 MySQL 8.0 Command Line Client\n\n> 仅限root用户\n\n# windows命令行\n\n 1. 格式：\n\nmysql -h 主机名 -P 端口号 -u 用户名 -p密码\n\nmysql -hlocalhost -P3306 -uroot -p123456 # 这里我设置的root用户的密码是123456\n\n\n1\n2\n3\n\n\n\n\n 2. 登录注意点\n\n（1）-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格。如：\nmysql -hlocalhost -P3306 -uroot -p123456\n\n（2）密码建议在下一行输入，保证安全\nmysql -hlocalhost -P3306 -u root -p\nEnter password:****\n\n（3）客户端和服务器在同一台机器上，所以输入localhost或者IP地址127.0.0.1。同时，因为是连接本\n机： -hlocalhost就可以省略，如果端口号没有修改：-P3306也可以省略\n简写成：\nmysql -uroot -p\nEnter password:****\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n连接成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识。\n\n 3. 查看数据库版本信息\n    \n    * 未登录，配置过环境变量：\n    \n    mysql --version\n    \n    \n    1\n    \n    * 登录后，\n    \n    mysql> select version();\n    \n    \n    1\n    \n\n# 退出登录\n\nexit\n或\nquit\n\n\n1\n2\n3\n\n\n\n# 6. MySQL目录结构与源码\n\n\n# 6.1 主要目录结构\n\nMYSQL的目录结构                                    说明\nbin目录                                         所有MySQL的可执行文件。如：mysql.exe\nMySQLInstanceConfig.exe                       数据库的配置向导，在安装时出现的内容\ndata目录                                        系统数据库所在的目录\nmy.ini文件                                      MySQL的主要配置文件\nc:\\ProgramData\\MySQL\\MySQL Server 8.0\\data\\   用户创建的数据库所在的目录\n\n\n# 6.2 MySQL源代码获取\n\n首先，你要进入 MySQL下载界面。 这里你不要选择用默认的“Microsoft Windows”，而是要通过下拉栏，找到“Source Code”，在下面的操作系统版本里面， 选择 Windows（Architecture Independent），然后点击下载。\n\n接下来，把下载下来的压缩文件解压，我们就得到了 MySQL 的源代码。MySQL 是用 C++ 开发而成的，这里简单介绍一下源代码的组成。\n\nmysql-8.0.22 目录下的各个子目录，包含了 MySQL 各部分组件的源代码：\n\n * sql 子目录是 MySQL 核心代码；\n\n * libmysql 子目录是客户端程序 API；\n\n * mysql-test 子目录是测试工具；\n\n * mysys 子目录是操作系统相关函数和辅助函数；\n\n源代码可以用记事本打开查看，如果你有 C++ 的开发环境，也可以在开发环境中打开查看。\n\n如上图所示，源代码并不神秘，就是普通的 C++ 代码，跟你熟悉的一样，而且有很多注释，可以帮助你理解。阅读源代码就像在跟 MySQL 的开发人员对话一样，十分有趣。\n\n\n# 7. 常见问题的解决\n\n\n# 1. root用户密码忘记，重置的操作\n\n 1. 通过任务管理器或者服务管理，关掉mysqld(服务进程)\n\n 2. 通过命令行+特殊参数开启\n\nmysqld mysqld --defaults-file=\"D:\\ProgramFiles\\mysql\\MySQLServer5.7Data\\my.ini\" --skip-grant-tables\n\n\n1\n\n 3. 此时，mysqld服务进程已经打开。并且不需要权限检查\n 4. mysql -uroot 无密码登陆服务器。另启动一个客户端进行\n 5. 修改权限表 （\n\n1. use mysql; \n2. update user set authentication_string=password('新密码') where user='root' and Host='localhost';\n3. flush privileges; \n\n\n1\n2\n3\n\n 6. 通过任务管理器，关掉mysqld服务进程。\n 7. 再次通过服务管理，打开mysql服务。\n 8. 即可用修改后的新密码登陆。\n\n\n# 2. mysql命令报\"不是内部或外部命令\"\n\n如果输入mysql命令报“不是内部或外部命令”，把mysql安装目录的bin目录配置到环境变量path中。如下：\n\n\n# 3. 错误ERROR ：没有选择数据库就操作表格和数据\n\nERROR 1046 (3D000): No database selected\n\n解决方案一：就是使用“USE 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作\n\n解决方案二：就是所有的表对象前面都加上“数据库.”\n\n\n# 4. 命令行客户端的字符集问题\n\nmysql> INSERT INTO t_stu VALUES(1,'张三','男');\nERROR 1366 (HY000): Incorrect string value: '\\xD5\\xC5\\xC8\\xFD' for column 'sname' at row 1\n\n\n1\n2\n\n\n原因：服务器端认为你的客户端的字符集是utf-8，而实际上你的客户端的字符集是GBK。\n\n 1. 查看所有字符集：SHOW VARIABLES LIKE 'character_set_%';\n\n\n\n解决方案，设置当前连接的客户端字符集 SET NAMES GBK;\n\n\n\n\n# 5. 修改数据库和表的字符编码\n\n修改编码：\n\n 1. 先停止服务\n\n 2. 修改my.ini文件\n\n 3. 重新启动服务\n\n说明：\n\n如果是在修改my.ini之前建的库和表，那么库和表的编码还是原来的Latin1，要么删了重建，要么使用alter语句修改编码。\n\nmysql> create database 0728db charset Latin1;\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> use 0728db;\nDatabase changed\n\n\nmysql> create table student (id int , name varchar(20)) charset Latin1;\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql> show create table student\\G\n*************************** 1. row ***************************\nTable: student\nCreate Table: CREATE TABLE `student` (\n`id` int(11) NOT NULL,\n`name` varchar(20) DEFAULT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n1 row in set (0.00 sec)\n\n\nmysql> alter table student charset utf8; #修改表字符编码为UTF8\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0 Duplicates: 0 Warnings: 0\nmysql> show create table student\\G\n*************************** 1. row ***************************\nTable: student\nCreate Table: CREATE TABLE `student` (\n`id` int(11) NOT NULL,\n`name` varchar(20) CHARACTER SET latin1 DEFAULT NULL, #字段仍然是latin1编码\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n1 row in set (0.00 sec)\nmysql> alter table student modify name varchar(20) charset utf8; #修改字段字符编码为UTF8\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0 Duplicates: 0 Warnings: 0\nmysql> show create table student\\G\n*************************** 1. row ***************************\nTable: student\nCreate Table: CREATE TABLE `student` (\n`id` int(11) NOT NULL,\n`name` varchar(20) DEFAULT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n1 row in set (0.00 sec)\n\nmysql> show create database 0728db;;\n+--------+-----------------------------------------------------------------+\n|Database| Create Database |\n+------+-------------------------------------------------------------------+\n|0728db| CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET latin1 */ |\n+------+-------------------------------------------------------------------+\n1 row in set (0.00 sec)\nmysql> alter database 0728db charset utf8; #修改数据库的字符编码为utf8\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> show create database 0728db;\n+--------+-----------------------------------------------------------------+\n|Database| Create Database |\n+--------+-----------------------------------------------------------------+\n| 0728db | CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET utf8 */ |\n+--------+-----------------------------------------------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n",normalizedContent:"# mysql环境搭建(windows版)\n\n> 提示本次使用安装环境：windows server 2022\n\n\n# 1 mysql的下载、安装、配置\n\n\n# 1.1 mysql的4大版本\n\n>  * mysql community server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。\n> \n>  * mysql enterprise edition 企业版本，需付费，不能在线下载，可以试用30天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。\n> \n>  * mysql cluster 集群版，开源免费。用于架设集群服务器，可将几个mysql server封装成一个server。需要在社区版或企业版的基础上使用。\n> \n>  * mysql cluster cge 高级集群版，需付费。\n\n此外，官方还提供了 mysql workbench （guitool）一款专为mysql设计的 图形界面管理工具 。mysqlworkbench又分为两个版本，分别是 社区版 （mysql workbench oss）、 商用版 （mysql workbenchse）。\n\n\n# 1.2 软件的下载\n\n 1. 下载地址：官网\n\n 2. 打开官网，点击downloads\n\n 3. 然后，点击 mysql community(gpl) downloads\n\n 4. 点击mysql community server\n    \n    \n\n 5. 在general availability(ga) releases中选择适合的版本\n    \n    windows平台下提供两种安装文件：mysql二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版使用起来要简单，不再需要其他工具启动就可以运行mysql。\n    \n    * 这里在windows 系统下推荐下载msi安装程序；点击go to download page进行下载即可。\n    \n    * windows下的mysql8.0安装有两种安装程序\n      \n      mysql-installer-web-community-8.0.32.0.msi 下载程序大小：2.4m；安装时需要联网安装组件。\n      \n      mysql-installer-community-8.0.32.0.msi 下载程序大小：437.3m；安装时离线安装即可。推荐。\n    \n    * 如果安装mysql5.7版本的话，选择archives，接着选择mysql5.7的相应版本即可。这里下载最近期的mysql5.7.34版本。\n\n\n# 2. mysql8.0安装配置\n\n> 端口号：3306 账号：root 密码：123456\n\n\n# 安装mysql8.0\n\nmysql下载完成后，找到下载文件，双击进行安装，具体操作步骤如下。\n\n\n\n 1. 双击下载的mysql-installer-community-8.0.32.0.msi文件，打开安装向导。\n    \n    \n\n 2. 打开choosing a setup type（选择安装类型）窗口，在其中列出了5种安装类型，分别是developer default（默认安装类型）、server only（仅作为服务器）、client only（仅作为客户端）、full（完全安装）、custom（自定义安装）。这里选择custom（自定义安装）类型按钮，单击“next(下一步)”按钮。\n    \n    \n    \n    3. 打开select products（选择产品）窗口，可以定制需要安装的产品清单。例如，选择mysql server 8.0.26-x64后，单击→添加按钮，即可选择安装mysql服务器，如图所示。采用通用的方法，可以添加其他你需要安装的产品。\n       \n       \n       \n       此时如果直接next（下一步），则产品的安装路径是默认的。如果想要自定义安装目录，则可以选中对应的产品，然后在下面会出现“advanced options”（高级选项）的超链接。\n       \n       \n       \n       单击advanced options（高级选项）则会弹出安装目录的选择窗口，如图所示，此时你可以分别设置mysql的服务程序安装目录和数据存储目录。如果不设置，默认分别在c盘的program files目录和programdata目录（这是一个隐藏目录）。如果自定义安装目录，请避免“中文”目录。另外，建议服务目录和数据目录分开存放。\n       \n       \n\n 3. 在上一步选择好要安装的产品之后，单击next（下一步）进入确认窗口，如图所示。单击execute（执行）按钮开始安装。\n    \n    \n\n 4. 安装完成后在status（状态）列表下将显示complete（安装完成），如图所示。\n    \n    \n    \n    \n\n\n# 配置mysql8.0\n\nmysql安装之后，需要对服务器进行配置。具体的配置步骤如下。\n\n 1.  在安装mysql8.0最后一步，单击next（下一步）按钮，就可以进入产品配置窗口。\n     \n     \n\n 2.  单击next（下一步）按钮，进入mysql服务器类型配置窗口，如图所示。端口号一般选择默认端口号3306。\n     \n     \n     \n     其中，config type选项用于设置服务器的类型。单击该选项右侧的下三角按钮，即可查看3个选项，如图所示。\n     \n     \n     \n     * development machine（开发机器） ：该选项代表典型个人用桌面工作站。此时机器上需要运行多个应用程序，那么mysql服务器将占用最少的系统资源。\n     \n     * server machine（服务器） ：该选项代表服务器，mysql服务器可以同其他服务器应用程序一起运行，例如web服务器等。mysql服务器配置成适当比例的系统资源。\n     \n     * dedicated machine（专用服务器） ：该选项代表只运行mysql服务的服务器。mysql服务器配置成使用所有可用系统资源。\n\n 3.  单击next（下一步）按钮，打开设置授权方式窗口。其中，上面的选项是mysql8.0提供的新的授权方式，采用sha256基础的密码加密方法；下面的选项是传统授权方法（保留5.x版本兼容性）。\n     \n     \n\n 4.  单击next（下一步）按钮，打开设置服务器root超级管理员的密码窗口，如图所示，需要输入两次同样的登录密码。也可以通过“add user”添加其他用户，添加其他用户时，需要指定用户名、允许该用户名在哪台/哪些主机上登录，还可以指定用户角色等。此处暂不添加用户，用户管理在mysql高级特性篇中讲解。\n     \n     \n\n 5.  单击next（下一步）按钮，打开设置服务器名称窗口，如图所示。该服务名会出现在windows服务列表中，也可以在命令行窗口中使用该服务名进行启动和停止服务。本书将服务名设置为“mysql80”。如果希望开机自启动服务，也可以勾选start the mysql server at system startup选项（推荐）。\n     \n     下面是选择以什么方式运行服务？可以选择standard system account(标准系统用户)或者custom user(自定义用户)中的一个。这里推荐前者。\n     \n     \n\n 6.  单击next（下一步）按钮，配置文件权限\n     \n     \n     \n     > 注意：低版本没有这步。8.0.26\n\n 7.  单击next（下一步）按钮，打开确认设置服务器窗口，单击execute（执行）按钮。\n     \n     \n\n 8.  完成配置，如图所示。单击finish（完成）按钮，即可完成服务器的配置。\n     \n     \n\n 9.  如果还有其他产品需要配置，可以选择其他产品，然后继续配置。如果没有，直接选择next（下一步），直接完成整个安装和配置过程。\n     \n     \n\n 10. 单击next（下一步）按钮，结束安装和配置。\n     \n     \n\n\n# 确认安装目录\n\n 1. 安装目录 c:\\program files\\mysql\\mysql server 8.0\n\n 2. 数据目录 c:\\programdata\\mysql\\mysql server 8.0\n\n\n# 配置环境变量\n\n 1. 进入到安装目录. 复制c:\\program files\\mysql\\mysql server 8.0\\bin 根据自己实际安装的目录。\n\n 2. 进入环境变量中，添加配置。\n\n 3. 命令号查看版本\n    \n    mysql --version\n    \n    \n    1\n    \n\n\n# 验证是否安装成功\n\n环境变量只能配置一个数据库，此处使用命令行进入数据库\n\n方式一：命令行进入数据库\n\nmysql -uroot -p123456 -hlocalhost -p3306\n\n\n1\n\n\n\n\n方式二：进入数据库后，执行致命查询版本号语句。\n\nselect version();\n\n\n1\n\n\n\n\n\n# 3. mysql5.7安装配置\n\n> 端口号：13306 账号：root 密码：123456\n\n\n# 安装mysql5.7\n\n此版本的安装过程与上述过程除了版本号不同之外，其它环节都是相同的。下面为mysql5.7.34版本的安装截图。\n\n 1. 双击进入安装向导\n\n\n\n 2. 之前已经安装8.0.32时候，安装mysql直接进入下面时候。选择add\n    \n    \n\n 3. 之前已经安装8.0.32时候，进入下面页面操作\n    \n    * 去掉勾选，不进行升级\n    * 点击cancle, 进入下图，点击yes,取消升级\n    \n    \n    \n    * 进入安装页面，点击add进入安装5.7.34\n\n 4. 选择安装产品、配置安装路径\n    \n    \n\n 5. 单击next（下一步）按钮，配置安装环境\n    \n    \n    \n    \n\n 6. 单击next（下一步）按钮，执行安装\n    \n    \n    \n    \n\n 7. 完成配置，如图所示。单击finish（完成）按钮，即可完成服务器的配置。\n    \n    \n\n 8. \n 9. \n\n\n# 配置mysql5.7\n\n配置环节与mysql8.0版本确有细微不同。大部分情况下直接选择“next”即可，不影响整理使用。\n\n这里配置mysql5.7时，重点强调：与前面安装好的mysql8.0不能使用相同的端口号。\n\n 1.  在安装mysql5.7最后一步，单击next（下一步）按钮，就可以进入产品配置窗口。\n     \n     \n\n 2.  单击next（下一步）按钮，进入mysql服务器类型配置窗口，如图所示。端口号一般选择默认端口号13306。\n     \n     \n\n 3.  单击next（下一步）按钮，打开设置服务器root超级管理员的密码窗口，如图所示，需要输入两次同样的登录密码。也可以通过“add user”添加其他用户，添加其他用户时，需要指定用户名、允许该用户名在哪台/哪些主机上登录，还可以指定用户角色等。此处暂不添加用户，用户管理在mysql高级特性篇中讲解。\n     \n     \n\n 4.  单击next（下一步）按钮，打开设置服务器名称窗口，如图所示。该服务名会出现在windows服务列表中，也可以在命令行窗口中使用该服务名进行启动和停止服务。本书将服务名设置为“mysql80”。如果希望开机自启动服务，也可以勾选start the mysql server at system startup选项（推荐）。\n     \n     下面是选择以什么方式运行服务？可以选择standard system account(标准系统用户)或者custom user(自定义用户)中的一个。这里推荐前者。\n     \n     \n\n 5.  单击next（下一步）按钮，配置文件权限\n     \n     \n\n 6.  单击next（下一步）按钮，打开确认设置服务器窗口，单击execute（执行）按钮。\n     \n     \n\n 7.  完成配置，如图所示。单击finish（完成）按钮，即可完成服务器的配置。\n     \n     \n\n 8.  点击如果还有其他产品需要配置，可以选择其他产品，然后继续配置。如果没有，直接选择next（下一步），直接完成整个安装和配置过程。\n     \n     \n\n 9.  单击next（下一步）按钮，结束安装和配置。\n     \n     \n\n 10. 返回mysql添加页面\n     \n     \n\n\n# 确认安装目录\n\n 1. 安装目录 c:\\program files\\mysql\\mysql server 5.7\n\n 2. 数据目录 c:\\programdata\\mysql\\mysql server 5.7\n\n\n# 验证是否安装成功\n\n环境变量只能配置一个数据库，此处使用命令行进入数据库\n\n方式一：通过命令行进入数据库\n\nmysql -uroot -p123456 -hlocalhost -p13306\n\n\n1\n\n\n\n\n方式二：进入数据库后，执行致命查询版本号语句。\n\nselect version();\n\n\n1\n\n\n\n\n\n# 4. mysql的卸载\n\n\n# 1. 停止mysql服务\n\n在卸载之前，先停止mysql8.0的服务。按键盘上的ctrl + alt + delete组合键，打开任务管理器”对话框，可以在“服务”列表找到“mysql8.0”的服务，如果现在正在运行状态，可以右键单击服务，选择停止选项停止mysql8.0的服务，如图所示。\n\n\n# 2. 软件的卸载\n\n# 通过控制面板方式\n\n卸载mysql8.0的程序可以和其他桌面应用程序一样直接在“控制面板”选择“卸载程序”，并在程序列表中找到mysql8.0服务器程序，直接双击卸载即可，如图所示。这种方式删除，数据目录下的数据不会跟着删除。\n\n# 通过安装包提供的卸载功能卸载\n\n你也可以通过安装向导程序进行mysql8.0服务器程序的卸载。\n\n 1. 再次双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。安装向导会自动检测已安装的mysql服务器程序。\n\n 2. 选择要卸载的mysql服务器程序，单击“remove”（移除），即可进行卸载。\n\n 3. 单击next（下一步）按钮，确认卸载。\n\n 4. 弹出是否同时移除数据目录选择窗口。如果想要同时删除mysql服务器中的数据，则勾选removethe datadirectory，如图所示。\n\n 5. 执行卸载。单击“execute”（执行）按钮进行卸载。\n\n 6. 完成卸载。单击finish（完成）按钮即可。如果想要同时卸载mysql8.0的安装向导程序，勾选yes，uninstallmysqlinstaller即可，如图所示。\n\n\n# 3. 残余文件的清理\n\n如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。\n\n 1. 服务的安装目录。\n\n 2. 数据目录：默认在·c:\\programdata\\mysql·。\n\n如果自己单独指定过数据目录，就找到自己的数据目录进行删除即可。\n\n> 注意：请在卸载前做好数据备份.\n> \n> 在操作完以后，需要重启计算机，然后进行安装即可。如果仍然安装失败，需要继续操作如下步\n\n\n# 4. 清理注册表\n\n如果前几步做了，再次安装还是失败，那么可以清理注册表。\n\n如何打开注册表编辑器：在系统的搜索框中输入regedit\n\nhkey_local_machine\\system\\controlset001\\services\\eventlog\\application\\mysql服务 目录删除\nhkey_local_machine\\system\\controlset001\\services\\mysql服务 目录删除\nhkey_local_machine\\system\\controlset002\\services\\eventlog\\application\\mysql服务 目录删除\nhkey_local_machine\\system\\controlset002\\services\\mysql服务 目录删除\nhkey_local_machine\\system\\currentcontrolset\\services\\eventlog\\application\\mysql服务目录删除\nhkey_local_machine\\system\\currentcontrolset\\services\\mysql服务删除\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注册表中的controlset001,controlset002,不一定是001和002,可能是controlset005、006之类\n\n\n# 5. mysql的登录\n\n\n# 5.1 服务的启动与停止\n\nmysql安装完毕之后，需要启动服务器进程，不然客户端无法连接数据库。在前面的配置过程中，已经将mysql安装为windows服务，并且勾选当windows启动、停止时，mysql也自动启动、停止。\n\n# 使用图形界面工具\n\n 1. 打开windows服务\n    \n    * 方式1：计算机（点击鼠标右键）→ 管理（点击）→ 服务和应用程序（点击）→ 服务（点击）。\n    \n    * 方式2：控制面板（点击）→ 系统和安全（点击）→ 管理工具（点击）→ 服务（点击）。\n    \n    * 方式3：任务栏（点击鼠标右键）→ 启动任务管理器（点击）→ 服务（点击）。\n    \n    * 方式4：单击【开始】菜单，在搜索框中输入services.msc 或者服务，按enter键确认。\n    \n    * 方式5：win+r, 输入services.msc，按enter键确认。\n\n 2. 找到mysql80/57（点击鼠标右键）→ 启动或停止（点击）\n\n# 使用命令行工具\n\n# 启动 mysql 服务命令：\nnet start mysql服务名\n\n# 停止 mysql 服务命令：\nnet stop mysql服务名\n\n\n1\n2\n3\n4\n5\n\n\n说明：\n\n 1. start和stop后面的服务名应与之前配置时指定的服务名一致。\n 2. 如果当你输入命令后，提示“拒绝服务”，请以 系统管理员身份 打开命令提示符界面重新尝试。\n\n\n# 5.2 自带客户端的登录与退出\n\n当mysql服务启动完成后，便可以通过客户端来登录mysql数据库。注意：确认服务是开启的。\n\n# mysql自带客户端\n\n开始菜单 -》 所有程序 -》 mysql -》 mysql 8.0 command line client\n\n> 仅限root用户\n\n# windows命令行\n\n 1. 格式：\n\nmysql -h 主机名 -p 端口号 -u 用户名 -p密码\n\nmysql -hlocalhost -p3306 -uroot -p123456 # 这里我设置的root用户的密码是123456\n\n\n1\n2\n3\n\n\n\n\n 2. 登录注意点\n\n（1）-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格。如：\nmysql -hlocalhost -p3306 -uroot -p123456\n\n（2）密码建议在下一行输入，保证安全\nmysql -hlocalhost -p3306 -u root -p\nenter password:****\n\n（3）客户端和服务器在同一台机器上，所以输入localhost或者ip地址127.0.0.1。同时，因为是连接本\n机： -hlocalhost就可以省略，如果端口号没有修改：-p3306也可以省略\n简写成：\nmysql -uroot -p\nenter password:****\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n连接成功后，有关于mysql server服务版本的信息，还有第几次连接的id标识。\n\n 3. 查看数据库版本信息\n    \n    * 未登录，配置过环境变量：\n    \n    mysql --version\n    \n    \n    1\n    \n    * 登录后，\n    \n    mysql> select version();\n    \n    \n    1\n    \n\n# 退出登录\n\nexit\n或\nquit\n\n\n1\n2\n3\n\n\n\n# 6. mysql目录结构与源码\n\n\n# 6.1 主要目录结构\n\nmysql的目录结构                                    说明\nbin目录                                         所有mysql的可执行文件。如：mysql.exe\nmysqlinstanceconfig.exe                       数据库的配置向导，在安装时出现的内容\ndata目录                                        系统数据库所在的目录\nmy.ini文件                                      mysql的主要配置文件\nc:\\programdata\\mysql\\mysql server 8.0\\data\\   用户创建的数据库所在的目录\n\n\n# 6.2 mysql源代码获取\n\n首先，你要进入 mysql下载界面。 这里你不要选择用默认的“microsoft windows”，而是要通过下拉栏，找到“source code”，在下面的操作系统版本里面， 选择 windows（architecture independent），然后点击下载。\n\n接下来，把下载下来的压缩文件解压，我们就得到了 mysql 的源代码。mysql 是用 c++ 开发而成的，这里简单介绍一下源代码的组成。\n\nmysql-8.0.22 目录下的各个子目录，包含了 mysql 各部分组件的源代码：\n\n * sql 子目录是 mysql 核心代码；\n\n * libmysql 子目录是客户端程序 api；\n\n * mysql-test 子目录是测试工具；\n\n * mysys 子目录是操作系统相关函数和辅助函数；\n\n源代码可以用记事本打开查看，如果你有 c++ 的开发环境，也可以在开发环境中打开查看。\n\n如上图所示，源代码并不神秘，就是普通的 c++ 代码，跟你熟悉的一样，而且有很多注释，可以帮助你理解。阅读源代码就像在跟 mysql 的开发人员对话一样，十分有趣。\n\n\n# 7. 常见问题的解决\n\n\n# 1. root用户密码忘记，重置的操作\n\n 1. 通过任务管理器或者服务管理，关掉mysqld(服务进程)\n\n 2. 通过命令行+特殊参数开启\n\nmysqld mysqld --defaults-file=\"d:\\programfiles\\mysql\\mysqlserver5.7data\\my.ini\" --skip-grant-tables\n\n\n1\n\n 3. 此时，mysqld服务进程已经打开。并且不需要权限检查\n 4. mysql -uroot 无密码登陆服务器。另启动一个客户端进行\n 5. 修改权限表 （\n\n1. use mysql; \n2. update user set authentication_string=password('新密码') where user='root' and host='localhost';\n3. flush privileges; \n\n\n1\n2\n3\n\n 6. 通过任务管理器，关掉mysqld服务进程。\n 7. 再次通过服务管理，打开mysql服务。\n 8. 即可用修改后的新密码登陆。\n\n\n# 2. mysql命令报\"不是内部或外部命令\"\n\n如果输入mysql命令报“不是内部或外部命令”，把mysql安装目录的bin目录配置到环境变量path中。如下：\n\n\n# 3. 错误error ：没有选择数据库就操作表格和数据\n\nerror 1046 (3d000): no database selected\n\n解决方案一：就是使用“use 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作\n\n解决方案二：就是所有的表对象前面都加上“数据库.”\n\n\n# 4. 命令行客户端的字符集问题\n\nmysql> insert into t_stu values(1,'张三','男');\nerror 1366 (hy000): incorrect string value: '\\xd5\\xc5\\xc8\\xfd' for column 'sname' at row 1\n\n\n1\n2\n\n\n原因：服务器端认为你的客户端的字符集是utf-8，而实际上你的客户端的字符集是gbk。\n\n 1. 查看所有字符集：show variables like 'character_set_%';\n\n\n\n解决方案，设置当前连接的客户端字符集 set names gbk;\n\n\n\n\n# 5. 修改数据库和表的字符编码\n\n修改编码：\n\n 1. 先停止服务\n\n 2. 修改my.ini文件\n\n 3. 重新启动服务\n\n说明：\n\n如果是在修改my.ini之前建的库和表，那么库和表的编码还是原来的latin1，要么删了重建，要么使用alter语句修改编码。\n\nmysql> create database 0728db charset latin1;\nquery ok, 1 row affected (0.00 sec)\n\nmysql> use 0728db;\ndatabase changed\n\n\nmysql> create table student (id int , name varchar(20)) charset latin1;\nquery ok, 0 rows affected (0.02 sec)\n\nmysql> show create table student\\g\n*************************** 1. row ***************************\ntable: student\ncreate table: create table `student` (\n`id` int(11) not null,\n`name` varchar(20) default null,\nprimary key (`id`)\n) engine=innodb default charset=latin1\n1 row in set (0.00 sec)\n\n\nmysql> alter table student charset utf8; #修改表字符编码为utf8\nquery ok, 0 rows affected (0.01 sec)\nrecords: 0 duplicates: 0 warnings: 0\nmysql> show create table student\\g\n*************************** 1. row ***************************\ntable: student\ncreate table: create table `student` (\n`id` int(11) not null,\n`name` varchar(20) character set latin1 default null, #字段仍然是latin1编码\nprimary key (`id`)\n) engine=innodb default charset=utf8\n1 row in set (0.00 sec)\nmysql> alter table student modify name varchar(20) charset utf8; #修改字段字符编码为utf8\nquery ok, 0 rows affected (0.05 sec)\nrecords: 0 duplicates: 0 warnings: 0\nmysql> show create table student\\g\n*************************** 1. row ***************************\ntable: student\ncreate table: create table `student` (\n`id` int(11) not null,\n`name` varchar(20) default null,\nprimary key (`id`)\n) engine=innodb default charset=utf8\n1 row in set (0.00 sec)\n\nmysql> show create database 0728db;;\n+--------+-----------------------------------------------------------------+\n|database| create database |\n+------+-------------------------------------------------------------------+\n|0728db| create database `0728db` /*!40100 default character set latin1 */ |\n+------+-------------------------------------------------------------------+\n1 row in set (0.00 sec)\nmysql> alter database 0728db charset utf8; #修改数据库的字符编码为utf8\nquery ok, 1 row affected (0.00 sec)\n\nmysql> show create database 0728db;\n+--------+-----------------------------------------------------------------+\n|database| create database |\n+--------+-----------------------------------------------------------------+\n| 0728db | create database `0728db` /*!40100 default character set utf8 */ |\n+--------+-----------------------------------------------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n",charsets:{cjk:!0},lastUpdated:"2023/03/10, 07:35:07",lastUpdatedTimestamp:1678404907e3},{title:"SQL语句",frontmatter:{title:"SQL语句",date:"2023-03-03T09:03:35.000Z",permalink:"/pages/10beff/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/04.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL%E5%9F%BA%E7%A1%80/03.MySQL%E5%9F%BA%E7%A1%80-SQL%E8%AF%AD%E5%8F%A5.html",relativePath:"01.语言/04.数据库/01.MySQL基础/03.MySQL基础-SQL语句.md",key:"v-25ae2882",path:"/pages/10beff/",headers:[{level:2,title:"1. SQL概述",slug:"_1-sql概述",normalizedTitle:"1. sql概述",charIndex:12},{level:3,title:"1.1 SQL背景知识",slug:"_1-1-sql背景知识",normalizedTitle:"1.1 sql背景知识",charIndex:25},{level:3,title:"1.2 TIOBE 编程语言排行榜",slug:"_1-2-tiobe-编程语言排行榜",normalizedTitle:"1.2 tiobe 编程语言排行榜",charIndex:723},{level:3,title:"1.3 SQL分类",slug:"_1-3-sql分类",normalizedTitle:"1.3 sql分类",charIndex:766},{level:2,title:"2. SQL语言的规则与规范",slug:"_2-sql语言的规则与规范",normalizedTitle:"2. sql语言的规则与规范",charIndex:1351},{level:3,title:"2.1 基本规则",slug:"_2-1-基本规则",normalizedTitle:"2.1 基本规则",charIndex:1370},{level:3,title:"2.2 SQL大小写规范",slug:"_2-2-sql大小写规范",normalizedTitle:"2.2 sql大小写规范",charIndex:1612},{level:3,title:"2.3 注释",slug:"_2-3-注释",normalizedTitle:"2.3 注释",charIndex:1851},{level:3,title:"2.4 命名规则",slug:"_2-4-命名规则",normalizedTitle:"2.4 命名规则",charIndex:1939},{level:3,title:"2.5 数据导入",slug:"_2-5-数据导入",normalizedTitle:"2.5 数据导入",charIndex:2662},{level:4,title:"通过命令行指令",slug:"通过命令行指令",normalizedTitle:"通过命令行指令",charIndex:2674},{level:4,title:"基于具体的图形化界面的工具导入",slug:"基于具体的图形化界面的工具导入",normalizedTitle:"基于具体的图形化界面的工具导入",charIndex:4948},{level:3,title:"2.6 显示表结构",slug:"_2-6-显示表结构",normalizedTitle:"2.6 显示表结构",charIndex:5043}],headersStr:"1. SQL概述 1.1 SQL背景知识 1.2 TIOBE 编程语言排行榜 1.3 SQL分类 2. SQL语言的规则与规范 2.1 基本规则 2.2 SQL大小写规范 2.3 注释 2.4 命名规则 2.5 数据导入 通过命令行指令 基于具体的图形化界面的工具导入 2.6 显示表结构",content:'# SQL语句\n\n\n# 1. SQL概述\n\n\n# 1.1 SQL背景知识\n\n * 1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。\n   \n   * 45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言， SQL 的半衰期可以说是非常长了。\n\n * 不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。\n   \n   * 数据结构和算发是在内存级别进行数据存储运算。\n   * 数据持久化层面存储，需要用到数据库。\n\n * SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言， 与数据直接打交道 ，由 IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有 SQL-86 ， SQL-89 ， SQL-92 ， SQL-99 等标准。\n   \n   * SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。\n\n * 不同的数据库生产厂商都支持SQL语句，但都有特有内容。\n\n\n# 1.2 TIOBE 编程语言排行榜\n\nTIOBE Index - TIOBE\n\n\n# 1.3 SQL分类\n\nSQL语言在功能上主要分为如下3大类：\n\n * DDL（Data Definition Languages、数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。\n   \n   * 主要的语句关键字包括 CREATE 、 DROP 、 ALTER 等。\n\n * DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。\n   \n   * 主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等。-\n   * SELECT是SQL语言的基础，最为重要。\n\n * DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。\n   \n   * 主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、SAVEPOINT 等。\n\n> 因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。还有单独将 COMMIT 、 ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语言）。\n\n\n# 2. SQL语言的规则与规范\n\n\n# 2.1 基本规则\n\n> 必须遵守\n\n * SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进。\n\n * 每条命令以 ; 或 \\g 或 \\G 结束。\n\n * 关键字不能被缩写也不能分行。\n\n * 关于标点符号\n   \n   * 必须保证所有的()、单引号、双引号是成对结束的\n   * 必须使用英文状态下的半角输入方式\n   * 字符串型和日期时间类型的数据可以使用单引号（\' \'）表示\n   * 列的别名，尽量使用双引号（" "），而且不建议省略as\n\n\n# 2.2 SQL大小写规范\n\n> 建议遵守\n\n * MySQL 在Windows环境下是大小写不敏感的\n\n * MySQL 在 Linux 环境下是大小写敏感的\n   \n   * 数据库名、表名、表的别名、变量名是严格区分大小写的\n   * 关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。\n\n * 推荐采用统一的书写规范：\n   \n   * 数据库名、表名、表别名、字段名、字段别名等都小写\n   * SQL 关键字、函数名、绑定变量等都大写\n\n\n# 2.3 注释\n\n单行注释：#注释文字(MySQL特有的方式)\n单行注释：-- 注释文字(--后面必须包含一个空格。)\n多行注释：/* 注释文字 */\n\n\n1\n2\n3\n\n\n\n# 2.4 命名规则\n\n * 数据库、表名不得超过30个字符，变量名限制为29个。\n\n * 必须只能包含 A–Z, a–z, 0–9, _共63个字符。\n\n * 数据库名、表名、字段名等对象名中间不要包含空格。\n\n * 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名。\n\n * 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来。\n\n * 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了。\n\n#以下两句是一样的，不区分大小写\nshow databases;\nSHOW DATABASES;\n\n#创建表格\n#create table student info(...); #表名错误，因为表名有空格\ncreate table student_info(...);\n#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了\nCREATE TABLE `order`(\n\nselect id as "编号", `name` as "姓名" from t_stu; #起别名时，as都可以省略\nselect id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略""\nselect id as 编 号, `name` as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.5 数据导入\n\n# 通过命令行指令\n\n在命令行客户端登录mysql，使用source指令导入\n\nsource d:\\test.sql # 全路径\n\n\n1\n\n\n示例\n\nmysql> show databases; # 查询数据库\n+--------------------+\n| Database           |\n+--------------------+\n| dbtest2            |\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n5 rows in set (0.00 sec)\n\nmysql> source D:\\Project\\learn\\MySQL\\SQL\\test.sql # 数据导入\n\nmysql> show databases; # 查询数据库\n+--------------------+\n| Database           |\n+--------------------+\n| dbtest             |\n| dbtest2            |\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n6 rows in set (0.00 sec)\n\nmysql> use dbtest; # 使用数据库\nDatabase changed\nmysql> show tables; # 展示数据库所有表\n+------------------+\n| Tables_in_dbtest |\n+------------------+\n| countries        |\n| departments      |\n| emp_details_view |\n| employees        |\n| job_grades       |\n| job_history      |\n| jobs             |\n| locations        |\n| order            |\n| regions          |\n+------------------+\n10 rows in set (0.00 sec)\n\nmysql> desc employees; \n+----------------+-------------+------+-----+---------+-------+\n| Field          | Type        | Null | Key | Default | Extra |\n+----------------+-------------+------+-----+---------+-------+\n| employee_id    | int         | NO   | PRI | 0       |       |\n| first_name     | varchar(20) | YES  |     | NULL    |       |\n| last_name      | varchar(25) | NO   |     | NULL    |       |\n| email          | varchar(25) | NO   | UNI | NULL    |       |\n| phone_number   | varchar(20) | YES  |     | NULL    |       |\n| hire_date      | date        | NO   |     | NULL    |       |\n| job_id         | varchar(10) | NO   | MUL | NULL    |       |\n| salary         | double(8,2) | YES  |     | NULL    |       |\n| commission_pct | double(2,2) | YES  |     | NULL    |       |\n| manager_id     | int         | YES  | MUL | NULL    |       |\n| department_id  | int         | YES  | MUL | NULL    |       |\n+----------------+-------------+------+-----+---------+-------+\n11 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n# 基于具体的图形化界面的工具导入\n\n * navicat： 选中数据库右键--点击运行SQL文件--选择执行的SQL文件，点击确认按钮。\n\n * SQLyog：选择工具--执行的脚本\n\n\n# 2.6 显示表结构\n\n使用DESCRIBE 或 DESC 命令，表示表结构。\n\nDESCRIBE employees;\n或\nDESC employees;\n\n\nmysql> desc employees;\n+----------------+-------------+------+-----+---------+-------+\n| Field | Type | Null | Key | Default | Extra |\n+----------------+-------------+------+-----+---------+-------+\n| employee_id | int(6) | NO | PRI | 0 | |\n| first_name | varchar(20) | YES | | NULL | |\n| last_name | varchar(25) | NO | | NULL | |\n| email | varchar(25) | NO | UNI | NULL | |\n| phone_number | varchar(20) | YES | | NULL | |\n| hire_date | date | NO | | NULL | |\n| job_id | varchar(10) | NO | MUL | NULL | |\n| salary | double(8,2) | YES | | NULL | |\n| commission_pct | double(2,2) | YES | | NULL | |\n| manager_id | int(6) | YES | MUL | NULL | |\n| department_id | int(4) | YES | MUL | NULL | |\n+----------------+-------------+------+-----+---------+-------+\n11 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n其中，各个字段的含义分别解释如下：\n\n * Field：表示字段名称。\n\n * Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。\n\n * Null：表示该列是否可以存储NULL值。\n\n * Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。\n\n * Default：表示该列是否有默认值，如果有，那么值是多少。\n\n * Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。',normalizedContent:'# sql语句\n\n\n# 1. sql概述\n\n\n# 1.1 sql背景知识\n\n * 1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 sql。\n   \n   * 45 年前，也就是 1974 年，ibm 研究员发布了一篇揭开数据库技术的论文《sequel：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言， sql 的半衰期可以说是非常长了。\n\n * 不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。\n   \n   * 数据结构和算发是在内存级别进行数据存储运算。\n   * 数据持久化层面存储，需要用到数据库。\n\n * sql（structured query language，结构化查询语言）是使用关系模型的数据库应用语言， 与数据直接打交道 ，由 ibm 上世纪70年代开发出来。后由美国国家标准局（ansi）开始着手制定sql标准，先后有 sql-86 ， sql-89 ， sql-92 ， sql-99 等标准。\n   \n   * sql 有两个重要的标准，分别是 sql92 和 sql99，它们分别代表了 92 年和 99 年颁布的 sql 标准，我们今天使用的 sql 语言依然遵循这些标准。\n\n * 不同的数据库生产厂商都支持sql语句，但都有特有内容。\n\n\n# 1.2 tiobe 编程语言排行榜\n\ntiobe index - tiobe\n\n\n# 1.3 sql分类\n\nsql语言在功能上主要分为如下3大类：\n\n * ddl（data definition languages、数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。\n   \n   * 主要的语句关键字包括 create 、 drop 、 alter 等。\n\n * dml（data manipulation language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。\n   \n   * 主要的语句关键字包括 insert 、 delete 、 update 、 select 等。-\n   * select是sql语言的基础，最为重要。\n\n * dcl（data control language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。\n   \n   * 主要的语句关键字包括 grant 、 revoke 、 commit 、 rollback 、savepoint 等。\n\n> 因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：dql（数据查询语言）。还有单独将 commit 、 rollback 取出来称为tcl （transaction control language，事务控制语言）。\n\n\n# 2. sql语言的规则与规范\n\n\n# 2.1 基本规则\n\n> 必须遵守\n\n * sql 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进。\n\n * 每条命令以 ; 或 \\g 或 \\g 结束。\n\n * 关键字不能被缩写也不能分行。\n\n * 关于标点符号\n   \n   * 必须保证所有的()、单引号、双引号是成对结束的\n   * 必须使用英文状态下的半角输入方式\n   * 字符串型和日期时间类型的数据可以使用单引号（\' \'）表示\n   * 列的别名，尽量使用双引号（" "），而且不建议省略as\n\n\n# 2.2 sql大小写规范\n\n> 建议遵守\n\n * mysql 在windows环境下是大小写不敏感的\n\n * mysql 在 linux 环境下是大小写敏感的\n   \n   * 数据库名、表名、表的别名、变量名是严格区分大小写的\n   * 关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。\n\n * 推荐采用统一的书写规范：\n   \n   * 数据库名、表名、表别名、字段名、字段别名等都小写\n   * sql 关键字、函数名、绑定变量等都大写\n\n\n# 2.3 注释\n\n单行注释：#注释文字(mysql特有的方式)\n单行注释：-- 注释文字(--后面必须包含一个空格。)\n多行注释：/* 注释文字 */\n\n\n1\n2\n3\n\n\n\n# 2.4 命名规则\n\n * 数据库、表名不得超过30个字符，变量名限制为29个。\n\n * 必须只能包含 a–z, a–z, 0–9, _共63个字符。\n\n * 数据库名、表名、字段名等对象名中间不要包含空格。\n\n * 同一个mysql软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名。\n\n * 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在sql语句中使用`（着重号）引起来。\n\n * 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了。\n\n#以下两句是一样的，不区分大小写\nshow databases;\nshow databases;\n\n#创建表格\n#create table student info(...); #表名错误，因为表名有空格\ncreate table student_info(...);\n#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了\ncreate table `order`(\n\nselect id as "编号", `name` as "姓名" from t_stu; #起别名时，as都可以省略\nselect id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略""\nselect id as 编 号, `name` as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.5 数据导入\n\n# 通过命令行指令\n\n在命令行客户端登录mysql，使用source指令导入\n\nsource d:\\test.sql # 全路径\n\n\n1\n\n\n示例\n\nmysql> show databases; # 查询数据库\n+--------------------+\n| database           |\n+--------------------+\n| dbtest2            |\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n5 rows in set (0.00 sec)\n\nmysql> source d:\\project\\learn\\mysql\\sql\\test.sql # 数据导入\n\nmysql> show databases; # 查询数据库\n+--------------------+\n| database           |\n+--------------------+\n| dbtest             |\n| dbtest2            |\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n6 rows in set (0.00 sec)\n\nmysql> use dbtest; # 使用数据库\ndatabase changed\nmysql> show tables; # 展示数据库所有表\n+------------------+\n| tables_in_dbtest |\n+------------------+\n| countries        |\n| departments      |\n| emp_details_view |\n| employees        |\n| job_grades       |\n| job_history      |\n| jobs             |\n| locations        |\n| order            |\n| regions          |\n+------------------+\n10 rows in set (0.00 sec)\n\nmysql> desc employees; \n+----------------+-------------+------+-----+---------+-------+\n| field          | type        | null | key | default | extra |\n+----------------+-------------+------+-----+---------+-------+\n| employee_id    | int         | no   | pri | 0       |       |\n| first_name     | varchar(20) | yes  |     | null    |       |\n| last_name      | varchar(25) | no   |     | null    |       |\n| email          | varchar(25) | no   | uni | null    |       |\n| phone_number   | varchar(20) | yes  |     | null    |       |\n| hire_date      | date        | no   |     | null    |       |\n| job_id         | varchar(10) | no   | mul | null    |       |\n| salary         | double(8,2) | yes  |     | null    |       |\n| commission_pct | double(2,2) | yes  |     | null    |       |\n| manager_id     | int         | yes  | mul | null    |       |\n| department_id  | int         | yes  | mul | null    |       |\n+----------------+-------------+------+-----+---------+-------+\n11 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n# 基于具体的图形化界面的工具导入\n\n * navicat： 选中数据库右键--点击运行sql文件--选择执行的sql文件，点击确认按钮。\n\n * sqlyog：选择工具--执行的脚本\n\n\n# 2.6 显示表结构\n\n使用describe 或 desc 命令，表示表结构。\n\ndescribe employees;\n或\ndesc employees;\n\n\nmysql> desc employees;\n+----------------+-------------+------+-----+---------+-------+\n| field | type | null | key | default | extra |\n+----------------+-------------+------+-----+---------+-------+\n| employee_id | int(6) | no | pri | 0 | |\n| first_name | varchar(20) | yes | | null | |\n| last_name | varchar(25) | no | | null | |\n| email | varchar(25) | no | uni | null | |\n| phone_number | varchar(20) | yes | | null | |\n| hire_date | date | no | | null | |\n| job_id | varchar(10) | no | mul | null | |\n| salary | double(8,2) | yes | | null | |\n| commission_pct | double(2,2) | yes | | null | |\n| manager_id | int(6) | yes | mul | null | |\n| department_id | int(4) | yes | mul | null | |\n+----------------+-------------+------+-----+---------+-------+\n11 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n其中，各个字段的含义分别解释如下：\n\n * field：表示字段名称。\n\n * type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。\n\n * null：表示该列是否可以存储null值。\n\n * key：表示该列是否已编制索引。pri表示该列是表主键的一部分；uni表示该列是unique索引的一部分；mul表示在列中某个给定值允许出现多次。\n\n * default：表示该列是否有默认值，如果有，那么值是多少。\n\n * extra：表示可以获取的与给定列有关的附加信息，例如auto_increment等。',charsets:{cjk:!0},lastUpdated:"2023/03/10, 07:35:07",lastUpdatedTimestamp:1678404907e3},{title:"基础语句",frontmatter:{title:"基础语句",date:"2023-03-08T20:20:03.000Z",permalink:"/pages/a5b5c4/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/04.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL%E5%9F%BA%E7%A1%80/04.MySQL%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5.html",relativePath:"01.语言/04.数据库/01.MySQL基础/04.MySQL基础-基础语句.md",key:"v-5b433015",path:"/pages/a5b5c4/",headers:[{level:2,title:"1. 基础的SELECT语句",slug:"_1-基础的select语句",normalizedTitle:"1. 基础的select语句",charIndex:11},{level:3,title:"1. SELECT...",slug:"_1-select",normalizedTitle:"1. select...",charIndex:30},{level:3,title:"2. SELECT ... FROM",slug:"_2-select-from",normalizedTitle:"2. select ... from",charIndex:93},{level:4,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:115},{level:4,title:"选择全部列",slug:"选择全部列",normalizedTitle:"选择全部列",charIndex:153},{level:4,title:"选择特定的列",slug:"选择特定的列",normalizedTitle:"选择特定的列",charIndex:353},{level:3,title:"3. 列的别名",slug:"_3-列的别名",normalizedTitle:"3. 列的别名",charIndex:531},{level:3,title:"4. 去除重复行(DISTINCT)",slug:"_4-去除重复行-distinct",normalizedTitle:"4. 去除重复行(distinct)",charIndex:792},{level:3,title:"5. 空值参与运算🚗",slug:"_5-空值参与运算",normalizedTitle:"5. 空值参与运算🚗",charIndex:1289},{level:3,title:"6. 着重号🚗",slug:"_6-着重号",normalizedTitle:"6. 着重号🚗",charIndex:1530},{level:3,title:"7. 查询常数🚗",slug:"_7-查询常数",normalizedTitle:"7. 查询常数🚗",charIndex:2301},{level:3,title:"8. 过滤数据",slug:"_8-过滤数据",normalizedTitle:"8. 过滤数据",charIndex:2651},{level:2,title:"2. 排序",slug:"_2-排序",normalizedTitle:"2. 排序",charIndex:2866},{level:3,title:"2.1 排序规则",slug:"_2-1-排序规则",normalizedTitle:"2.1 排序规则",charIndex:2876},{level:3,title:"2.2 单列排序",slug:"_2-2-单列排序",normalizedTitle:"2.2 单列排序",charIndex:2984},{level:3,title:"2.3 多列排序",slug:"_2-3-多列排序",normalizedTitle:"2.3 多列排序",charIndex:3315},{level:2,title:"3. 分页",slug:"_3-分页",normalizedTitle:"3. 分页",charIndex:3531},{level:3,title:"3.1 背景",slug:"_3-1-背景",normalizedTitle:"3.1 背景",charIndex:3541},{level:3,title:"3.2 实现规则",slug:"_3-2-实现规则",normalizedTitle:"3.2 实现规则",charIndex:3628},{level:3,title:"3.3 扩展",slug:"_3-3-扩展",normalizedTitle:"3.3 扩展",charIndex:4456}],headersStr:"1. 基础的SELECT语句 1. SELECT... 2. SELECT ... FROM 语法 选择全部列 选择特定的列 3. 列的别名 4. 去除重复行(DISTINCT) 5. 空值参与运算🚗 6. 着重号🚗 7. 查询常数🚗 8. 过滤数据 2. 排序 2.1 排序规则 2.2 单列排序 2.3 多列排序 3. 分页 3.1 背景 3.2 实现规则 3.3 扩展",content:'# 基础语句\n\n\n# 1. 基础的SELECT语句\n\n\n# 1. SELECT...\n\nSELECT 1; #没有任何子句\nSELECT 9/2; #没有任何子句\n\n\n1\n2\n\n\n\n# 2. SELECT ... FROM\n\n# 语法\n\nSELECT 标识选择哪些列\n\nFROM 标识从哪个表中选择\n\n# 选择全部列\n\nSELECT * FROM departments;\n\n\n1\n\n\n> 一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。\n> \n> 在生产环境下，不推荐你直接使用 SELECT *进行查询。\n\n# 选择特定的列\n\nSELECT department_id, location_id FROM departments;\n\n\n1\n\n\n> MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。\n\n\n# 3. 列的别名\n\n * 重命名一个列\n\n * 便于计算\n\n * 紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写。\n\n * AS 可以省略\n\n * 建议别名简短，见名知意\n\nSELECT last_name AS name, commission_pct comm FROM employees;\n\n\n1\n\n\nSELECT last_name "Name", salary*12 "Annual Salary" FROM employees;\n\n\n1\n\n\n\n# 4. 去除重复行(DISTINCT)\n\n默认情况下，查询会返回全部行，包括重复行。\n\nSELECT department_id FROM employees;\n\n\n1\n\n\n\n\n在SELECT语句中使用关键字DISTINCT去除重复行\n\nSELECT DISTINCT department_id FROM employees;\n\n\n1\n\n\n\n\n针对于：\n\nSELECT DISTINCT department_id,salary FROM employees;\n\n\n1\n\n\n这里有两点需要注意：\n\n 1. DISTINCT 需要放到所有列名的前面，如果写成 SELECT salary, DISTINCT department_id FROM employees 会报错。\n\n 2. DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写 DISTINCT department_id 即可，后面不需要再加其他的列名了。\n\n\n# 5. 空值参与运算🚗\n\n所有运算符或列值遇到null值，运算的结果都为null\n\nSELECT employee_id,salary,commission_pct,\n12 * salary * (1 + commission_pct) "annual_sal"\nFROM employees;\n\n\n1\n2\n3\n\n\n这里你一定要注意，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。\n\n\n# 6. 着重号🚗\n\n * 错误的\n\nmysql> SELECT * FROM ORDER;\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that\ncorresponds to your MySQL server version for the right syntax to use near \'ORDER\' at\nline 1\n\n\n1\n2\n3\n4\n\n * 正确的\n\nmysql> SELECT * FROM `ORDER`;\n+----------+------------+\n| order_id | order_name |\n+----------+------------+\n| 1 | shkstart |\n| 2 | tomcat |\n| 3 | dubbo |\n+----------+------------+\n3 rows in set (0.00 sec)\nmysql> SELECT * FROM `order`;\n+----------+------------+\n| order_id | order_name |\n+----------+------------+\n| 1 | shkstart |\n| 2 | tomcat |\n| 3 | dubbo |\n+----------+------------+\n3 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 结论\n\n我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对``（着重号）引起来\n\n\n# 7. 查询常数🚗\n\nSELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。\n\n你可能会问为什么我们还要对常数进行查询呢？\n\nSQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。\n\n比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段 corporation ，这个字段固定值为“晨光向”，可以这样写：\n\nSELECT \'晨光向\' as corporation, last_name FROM employees;\n\n\n1\n\n\n\n# 8. 过滤数据\n\n * 语法\n\nSELECT 字段1,字段2\nFROM 表名\nWHERE 过滤条件\n\n\n1\n2\n3\n\n * 使用WHERE 子句，将不满足条件的行过滤掉\n * WHERE子句紧随FROM子句\n\nSELECT employee_id, last_name, job_id, department_id\nFROM employees\nWHERE department_id = 90 ;\n\n\n1\n2\n3\n\n\n\n\n\n# 2. 排序\n\n\n# 2.1 排序规则\n\n * 使用 ORDER BY子句排序\n   \n   * ASC（ascend）：升序\n   * DESC（descend）：降序\n\n * ORDER BY 子句在SELECT语句的结尾。\n\n\n# 2.2 单列排序\n\n> 默认排序为升序ASC,ASC可以不写。\n\nSELECT last_name, job_id, department_id, hire_date\nFROM employees\nORDER BY hire_date ;\n\n\n1\n2\n3\n\n\n\n\nSELECT last_name, job_id, department_id, hire_date\nFROM employees\nORDER BY hire_date DESC ;\n\n\n1\n2\n3\n\n\n\n\nSELECT employee_id, last_name, salary*12 annsal\nFROM employees\nORDER BY annsal;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.3 多列排序\n\nSELECT last_name, department_id, salary\nFROM employees\nORDER BY department_id, salary DESC;\n\n\n1\n2\n3\n\n\n\n\n * 可以使用不在SELECT列表中的列排序。\n\n * 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。\n\n\n# 3. 分页\n\n\n# 3.1 背景\n\n背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？\n\n背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？\n\n\n# 3.2 实现规则\n\n * 分页原理\n   \n   所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。\n\n * MySQL中使用LIMIT实现分页\n\n * 格式：\n   \n   LIMIT [位置偏移量,] 行数\n   \n   \n   1\n   \n   \n   第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。\n\n * 示例\n\n--前10条记录：\nSELECT * FROM 表名 LIMIT 0,10;\n或者\nSELECT * FROM 表名 LIMIT 10;\n--第11至20条记录：\nSELECT * FROM 表名 LIMIT 10,10;\n--第21至30条记录：\nSELECT * FROM 表名 LIMIT 20,10;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT4,3;”返回的结果相同。\n\n * 分页显式公式：（当前页数-1）每页条数，每页条数\n   \n   SELECT * FROM table\n   LIMIT(PageNo - 1)*PageSize,PageSize;\n   \n   \n   1\n   2\n   \n\n * 注意：LIMIT 子句必须放在整个SELECT语句的最后！\n\n * 使用 LIMIT 的好处\n   \n   约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有1 条，就可以使用LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。\n\n\n# 3.3 扩展\n\n在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。\n\n * 如果是 SQL Server 和 Access，需要使用TOP关键字，比如：\n\nSELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC\n\n\n1\n\n * 如果是 DB2，使用FETCH FIRST 5 ROWS ONLY这样的关键字：\n\nSELECT name, hp_max FROM heros ORDER BY hp_max DESC FETCH FIRST 5 ROWS ONLY\n\n\n1\n\n * 如果是 Oracle，你需要基于 ROWNUM 来统计行数：\n\nSELECT rownum,last_name,salary FROM employees WHERE rownum < 5 ORDER BY salary DESC;\n\n\n1\n\n\n需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。我会在后面讲到子查询，你可以使用\n\nSELECT rownum, last_name,salary\nFROM (\nSELECT last_name,salary\nFROM employees\nORDER BY salary DESC)\nWHERE rownum < 10;\n\n\n1\n2\n3\n4\n5\n6\n\n\n得到与上述方法一致的结果。',normalizedContent:'# 基础语句\n\n\n# 1. 基础的select语句\n\n\n# 1. select...\n\nselect 1; #没有任何子句\nselect 9/2; #没有任何子句\n\n\n1\n2\n\n\n\n# 2. select ... from\n\n# 语法\n\nselect 标识选择哪些列\n\nfrom 标识从哪个表中选择\n\n# 选择全部列\n\nselect * from departments;\n\n\n1\n\n\n> 一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。\n> \n> 在生产环境下，不推荐你直接使用 select *进行查询。\n\n# 选择特定的列\n\nselect department_id, location_id from departments;\n\n\n1\n\n\n> mysql中的sql语句是不区分大小写的，因此select和select的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。\n\n\n# 3. 列的别名\n\n * 重命名一个列\n\n * 便于计算\n\n * 紧跟列名，也可以在列名和别名之间加入关键字as，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写。\n\n * as 可以省略\n\n * 建议别名简短，见名知意\n\nselect last_name as name, commission_pct comm from employees;\n\n\n1\n\n\nselect last_name "name", salary*12 "annual salary" from employees;\n\n\n1\n\n\n\n# 4. 去除重复行(distinct)\n\n默认情况下，查询会返回全部行，包括重复行。\n\nselect department_id from employees;\n\n\n1\n\n\n\n\n在select语句中使用关键字distinct去除重复行\n\nselect distinct department_id from employees;\n\n\n1\n\n\n\n\n针对于：\n\nselect distinct department_id,salary from employees;\n\n\n1\n\n\n这里有两点需要注意：\n\n 1. distinct 需要放到所有列名的前面，如果写成 select salary, distinct department_id from employees 会报错。\n\n 2. distinct 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写 distinct department_id 即可，后面不需要再加其他的列名了。\n\n\n# 5. 空值参与运算🚗\n\n所有运算符或列值遇到null值，运算的结果都为null\n\nselect employee_id,salary,commission_pct,\n12 * salary * (1 + commission_pct) "annual_sal"\nfrom employees;\n\n\n1\n2\n3\n\n\n这里你一定要注意，在 mysql 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 mysql 里面，空值是占用空间的。\n\n\n# 6. 着重号🚗\n\n * 错误的\n\nmysql> select * from order;\nerror 1064 (42000): you have an error in your sql syntax; check the manual that\ncorresponds to your mysql server version for the right syntax to use near \'order\' at\nline 1\n\n\n1\n2\n3\n4\n\n * 正确的\n\nmysql> select * from `order`;\n+----------+------------+\n| order_id | order_name |\n+----------+------------+\n| 1 | shkstart |\n| 2 | tomcat |\n| 3 | dubbo |\n+----------+------------+\n3 rows in set (0.00 sec)\nmysql> select * from `order`;\n+----------+------------+\n| order_id | order_name |\n+----------+------------+\n| 1 | shkstart |\n| 2 | tomcat |\n| 3 | dubbo |\n+----------+------------+\n3 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 结论\n\n我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在sql语句中使用一对``（着重号）引起来\n\n\n# 7. 查询常数🚗\n\nselect 查询还可以对常数进行查询。对的，就是在 select 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。\n\n你可能会问为什么我们还要对常数进行查询呢？\n\nsql 中的 select 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。\n\n比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段 corporation ，这个字段固定值为“晨光向”，可以这样写：\n\nselect \'晨光向\' as corporation, last_name from employees;\n\n\n1\n\n\n\n# 8. 过滤数据\n\n * 语法\n\nselect 字段1,字段2\nfrom 表名\nwhere 过滤条件\n\n\n1\n2\n3\n\n * 使用where 子句，将不满足条件的行过滤掉\n * where子句紧随from子句\n\nselect employee_id, last_name, job_id, department_id\nfrom employees\nwhere department_id = 90 ;\n\n\n1\n2\n3\n\n\n\n\n\n# 2. 排序\n\n\n# 2.1 排序规则\n\n * 使用 order by子句排序\n   \n   * asc（ascend）：升序\n   * desc（descend）：降序\n\n * order by 子句在select语句的结尾。\n\n\n# 2.2 单列排序\n\n> 默认排序为升序asc,asc可以不写。\n\nselect last_name, job_id, department_id, hire_date\nfrom employees\norder by hire_date ;\n\n\n1\n2\n3\n\n\n\n\nselect last_name, job_id, department_id, hire_date\nfrom employees\norder by hire_date desc ;\n\n\n1\n2\n3\n\n\n\n\nselect employee_id, last_name, salary*12 annsal\nfrom employees\norder by annsal;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.3 多列排序\n\nselect last_name, department_id, salary\nfrom employees\norder by department_id, salary desc;\n\n\n1\n2\n3\n\n\n\n\n * 可以使用不在select列表中的列排序。\n\n * 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。\n\n\n# 3. 分页\n\n\n# 3.1 背景\n\n背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？\n\n背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？\n\n\n# 3.2 实现规则\n\n * 分页原理\n   \n   所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。\n\n * mysql中使用limit实现分页\n\n * 格式：\n   \n   limit [位置偏移量,] 行数\n   \n   \n   1\n   \n   \n   第一个“位置偏移量”参数指示mysql从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。\n\n * 示例\n\n--前10条记录：\nselect * from 表名 limit 0,10;\n或者\nselect * from 表名 limit 10;\n--第11至20条记录：\nselect * from 表名 limit 10,10;\n--第21至30条记录：\nselect * from 表名 limit 20,10;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> mysql 8.0中可以使用“limit 3 offset 4”，意思是获取从第5条记录开始后面的3条记录，和“limit4,3;”返回的结果相同。\n\n * 分页显式公式：（当前页数-1）每页条数，每页条数\n   \n   select * from table\n   limit(pageno - 1)*pagesize,pagesize;\n   \n   \n   1\n   2\n   \n\n * 注意：limit 子句必须放在整个select语句的最后！\n\n * 使用 limit 的好处\n   \n   约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有1 条，就可以使用limit 1 ，告诉 select 语句只需要返回一条记录即可。这样的好处就是 select 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。\n\n\n# 3.3 扩展\n\n在不同的 dbms 中使用的关键字可能不同。在 mysql、postgresql、mariadb 和 sqlite 中使用 limit 关键字，而且需要放到 select 语句的最后面。\n\n * 如果是 sql server 和 access，需要使用top关键字，比如：\n\nselect top 5 name, hp_max from heros order by hp_max desc\n\n\n1\n\n * 如果是 db2，使用fetch first 5 rows only这样的关键字：\n\nselect name, hp_max from heros order by hp_max desc fetch first 5 rows only\n\n\n1\n\n * 如果是 oracle，你需要基于 rownum 来统计行数：\n\nselect rownum,last_name,salary from employees where rownum < 5 order by salary desc;\n\n\n1\n\n\n需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。我会在后面讲到子查询，你可以使用\n\nselect rownum, last_name,salary\nfrom (\nselect last_name,salary\nfrom employees\norder by salary desc)\nwhere rownum < 10;\n\n\n1\n2\n3\n4\n5\n6\n\n\n得到与上述方法一致的结果。',charsets:{cjk:!0},lastUpdated:"2023/03/10, 07:35:07",lastUpdatedTimestamp:1678404907e3},{title:"运算符",frontmatter:{title:"运算符",date:"2023-03-08T20:45:39.000Z",permalink:"/pages/d5d2c6/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/04.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL%E5%9F%BA%E7%A1%80/05.MySQL%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6.html",relativePath:"01.语言/04.数据库/01.MySQL基础/05.MySQL基础-运算符.md",key:"v-178980de",path:"/pages/d5d2c6/",headers:[{level:2,title:"1. 算术运算符",slug:"_1-算术运算符",normalizedTitle:"1. 算术运算符",charIndex:10},{level:3,title:"1.1 加法和减法运算符",slug:"_1-1-加法和减法运算符",normalizedTitle:"1.1 加法和减法运算符",charIndex:98},{level:3,title:"1.2 乘法与除法运算符 😄",slug:"_1-2-乘法与除法运算符",normalizedTitle:"1.2 乘法与除法运算符 😄",charIndex:866},{level:3,title:"1.3 求模（求余）运算符 将t22表中的字段i对3和5进行求模（求余）运算。",slug:"_1-3-求模-求余-运算符-将t22表中的字段i对3和5进行求模-求余-运算。",normalizedTitle:"1.3 求模（求余）运算符 将t22表中的字段i对3和5进行求模（求余）运算。",charIndex:1815},{level:2,title:"2. 比较运算符",slug:"_2-比较运算符",normalizedTitle:"2. 比较运算符",charIndex:2159},{level:3,title:"2.1 等号运算符",slug:"_2-1-等号运算符",normalizedTitle:"2.1 等号运算符",charIndex:2284},{level:3,title:"2.2 安全等于运算符",slug:"_2-2-安全等于运算符",normalizedTitle:"2.2 安全等于运算符",charIndex:3480},{level:3,title:"2.3 不等于运算符",slug:"_2-3-不等于运算符",normalizedTitle:"2.3 不等于运算符",charIndex:4429},{level:3,title:"2.4 空运算符",slug:"_2-4-空运算符",normalizedTitle:"2.4 空运算符",charIndex:5062},{level:3,title:"2.5  非空运算符",slug:"_2-5-非空运算符",normalizedTitle:"2.5  非空运算符",charIndex:null},{level:3,title:"2.6 最小值运算符",slug:"_2-6-最小值运算符",normalizedTitle:"2.6 最小值运算符",charIndex:6659},{level:3,title:"2.7 最大值运算符",slug:"_2-7-最大值运算符",normalizedTitle:"2.7 最大值运算符",charIndex:7186},{level:3,title:"2.8 BETWEEN AND运算符",slug:"_2-8-between-and运算符",normalizedTitle:"2.8 between and运算符",charIndex:7792},{level:3,title:"2.9 IN运算符",slug:"_2-9-in运算符",normalizedTitle:"2.9 in运算符",charIndex:8421},{level:3,title:"2.10 NOT IN运算符",slug:"_2-10-not-in运算符",normalizedTitle:"2.10 not in运算符",charIndex:9091},{level:3,title:"2.11 LIKE运算符",slug:"_2-11-like运算符",normalizedTitle:"2.11 like运算符",charIndex:9460},{level:4,title:"LIKE",slug:"like",normalizedTitle:"like",charIndex:9465},{level:4,title:"ESCAPE 😄🚗🐶🐱",slug:"escape",normalizedTitle:"escape 😄🚗🐶🐱",charIndex:10029},{level:3,title:"2.12 REGEXP运算符",slug:"_2-12-regexp运算符",normalizedTitle:"2.12 regexp运算符",charIndex:10283},{level:2,title:"3. 逻辑运算符",slug:"_3-逻辑运算符",normalizedTitle:"3. 逻辑运算符",charIndex:11498},{level:3,title:"3.1 逻辑非运算符",slug:"_3-1-逻辑非运算符",normalizedTitle:"3.1 逻辑非运算符",charIndex:11580},{level:3,title:"3.2 逻辑与运算符",slug:"_3-2-逻辑与运算符",normalizedTitle:"3.2 逻辑与运算符",charIndex:12093},{level:3,title:"3.3 逻辑或运算符",slug:"_3-3-逻辑或运算符",normalizedTitle:"3.3 逻辑或运算符",charIndex:12619},{level:3,title:"3.4 逻辑异或运算符",slug:"_3-4-逻辑异或运算符",normalizedTitle:"3.4 逻辑异或运算符",charIndex:13648},{level:2,title:"4. 位运算符",slug:"_4-位运算符",normalizedTitle:"4. 位运算符",charIndex:14340},{level:3,title:"4.1 按位与运算符🚗",slug:"_4-1-按位与运算符",normalizedTitle:"4.1 按位与运算符🚗",charIndex:14436},{level:3,title:"4.2 按位或运算符",slug:"_4-2-按位或运算符",normalizedTitle:"4.2 按位或运算符",charIndex:14797},{level:3,title:"4.3 按位异或运算符",slug:"_4-3-按位异或运算符",normalizedTitle:"4.3 按位异或运算符",charIndex:15164},{level:3,title:"4.4 按位取反运算符",slug:"_4-4-按位取反运算符",normalizedTitle:"4.4 按位取反运算符",charIndex:15754},{level:3,title:"4.5 按位右移运算符",slug:"_4-5-按位右移运算符",normalizedTitle:"4.5 按位右移运算符",charIndex:16030},{level:3,title:"4.6 按位左移运算符",slug:"_4-6-按位左移运算符",normalizedTitle:"4.6 按位左移运算符",charIndex:16371},{level:2,title:"5. 运算符的优先级",slug:"_5-运算符的优先级",normalizedTitle:"5. 运算符的优先级",charIndex:16714},{level:2,title:"6. 扩展：使用正则表达式",slug:"_6-扩展-使用正则表达式",normalizedTitle:"6. 扩展：使用正则表达式",charIndex:16797}],headersStr:"1. 算术运算符 1.1 加法和减法运算符 1.2 乘法与除法运算符 😄 1.3 求模（求余）运算符 将t22表中的字段i对3和5进行求模（求余）运算。 2. 比较运算符 2.1 等号运算符 2.2 安全等于运算符 2.3 不等于运算符 2.4 空运算符 2.5  非空运算符 2.6 最小值运算符 2.7 最大值运算符 2.8 BETWEEN AND运算符 2.9 IN运算符 2.10 NOT IN运算符 2.11 LIKE运算符 LIKE ESCAPE 😄🚗🐶🐱 2.12 REGEXP运算符 3. 逻辑运算符 3.1 逻辑非运算符 3.2 逻辑与运算符 3.3 逻辑或运算符 3.4 逻辑异或运算符 4. 位运算符 4.1 按位与运算符🚗 4.2 按位或运算符 4.3 按位异或运算符 4.4 按位取反运算符 4.5 按位右移运算符 4.6 按位左移运算符 5. 运算符的优先级 6. 扩展：使用正则表达式",content:"# 运算符\n\n\n# 1. 算术运算符\n\n算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。\n\n\n\n\n# 1.1 加法和减法运算符\n\nmysql> SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5\nFROM dual;\n+-----+---------+---------+----------+--------------+------------+------------+\n| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |\n+-----+---------+---------+----------+--------------+------------+------------+\n| 100 | 100 | 100 | 150 | 120 | 135.5 | 64.5 |\n+-----+---------+---------+----------+--------------+------------+------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n>  * 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；\n> \n>  * 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；\n> \n>  * 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；\n> \n>  * 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）\n\n\n# 1.2 乘法与除法运算符 😄\n\nmysql> SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100\nDIV 0 FROM dual;\n+-----+---------+-----------+-----------+---------+-----------------+---------+-------\n----+\n| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3 | 100\nDIV 0 |\n+-----+---------+-----------+-----------+---------+-----------------+---------+-------\n----+\n| 100 | 100 | 100.0 | 100.0000 | 50.0000 | 105.0000 | 33.3333 |\nNULL |\n+-----+---------+-----------+-----------+---------+-----------------+---------+-------\n----+\n1 row in set (0.00 sec)\n\n#计算出员工的年基本工资\nSELECT employee_id,salary,salary * 12 annual_sal\nFROM employees;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n>  * 一个数乘以整数1和除以整数1后仍得原数；\n> \n>  * 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；\n> \n>  * 一个数除以整数后，不管是否能除尽，结果都为一个浮点数；\n> \n>  * 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；\n> \n>  * 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。\n> \n>  * 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。\n\n\n# 1.3 求模（求余）运算符 将t22表中的字段i对3和5进行求模（求余）运算。\n\nmysql> SELECT 12 % 3, 12 MOD 5 FROM dual;\n+--------+----------+\n| 12 % 3 | 12 MOD 5 |\n+--------+----------+\n| 0 | 2 |\n+--------+----------+\n1 row in set (0.00 sec)\n\n#筛选出employee_id是偶数的员工\nSELECT * FROM employees\nWHERE employee_id MOD 2 = 0;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看到，100对3求模后的结果为3，对5求模后的结果为0。\n\n\n# 2. 比较运算符\n\n比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。\n\n比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。\n\n\n\n\n# 2.1 等号运算符\n\n * 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。\n\n * 在使用等号运算符时，遵循如下规则：\n   \n   * 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。\n   * 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。\n   * 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。\n   * 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。\n\n * 对比：SQL中赋值符号使用 :=\n\nmysql> SELECT 1 = 1, 1 = '1', 1 = 0, 'a' = 'a', (5 + 3) = (2 + 6), '' = NULL , NULL =\nNULL;\n+-------+---------+-------+-----------+-------------------+-----------+-------------+\n| 1 = 1 | 1 = '1' | 1 = 0 | 'a' = 'a' | (5 + 3) = (2 + 6) | '' = NULL | NULL = NULL |\n+-------+---------+-------+-----------+-------------------+-----------+-------------+\n| 1 | 1 | 0 | 1 | 1 | NULL | NULL |\n+-------+---------+-------+-----------+-------------------+-----------+-------------+\n1 row in set (0.00 sec)\n\nmysql> SELECT 1 = 2, 0 = 'abc', 1 = 'abc' FROM dual;\n+-------+-----------+-----------+\n| 1 = 2 | 0 = 'abc' | 1 = 'abc' |\n+-------+-----------+-----------+\n| 0 | 1 | 0 |\n+-------+-----------+-----------+\n1 row in set, 2 warnings (0.00 sec)\n\n#查询salary=10000，注意在Java中比较是==\nSELECT employee_id,salary FROM employees WHERE salary = 10000;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.2 安全等于运算符\n\n安全等于运算符（<=>）与等于运算符（=）的作用是相似的， 唯一的区别 是‘<=>’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。\n\n\n1\n\n\nmysql> SELECT 1 <=> '1', 1 <=> 0, 'a' <=> 'a', (5 + 3) <=> (2 + 6), '' <=> NULL,NULL\n<=> NULL FROM dual;\n+-----------+---------+-------------+---------------------+-------------+---------------+\n| 1 <=> '1' | 1 <=> 0 | 'a' <=> 'a' | (5 + 3) <=> (2 + 6) | '' <=> NULL | NULL <=> NULL |\n+-----------+---------+-------------+---------------------+-------------+---------------+\n| 1 | 0 | 1 | 1 | 0 |1 |\n+-----------+---------+-------------+---------------------+-------------+---------------+\n1 row in set (0.00 sec)\n\n#查询commission_pct等于0.40\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct = 0.40;\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> 0.40;\n#如果把0.40改成 NULL 呢？\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他返回结果与等于运算符相同\n\n\n# 2.3 不等于运算符\n\n不等于运算符（<>和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。 SQL语句示例如下：\n\n\n1\n\n\nmysql> SELECT 1 <> 1, 1 != 2, 'a' != 'b', (3+4) <> (2+6), 'a' != NULL, NULL <> NULL;\n+--------+--------+------------+----------------+-------------+--------------+\n| 1 <> 1 | 1 != 2 | 'a' != 'b' | (3+4) <> (2+6) | 'a' != NULL | NULL <> NULL |\n+--------+--------+------------+----------------+-------------+--------------+\n| 0 | 1 | 1 | 1 | NULL | NULL |\n+--------+--------+------------+----------------+-------------+--------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n此外，还有非符号类型的运算符:\n\n\n# 2.4 空运算符\n\n空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。 SQL语句示例如下：\n\nmysql> SELECT NULL IS NULL, ISNULL(NULL), ISNULL('a'), 1 IS NULL;\n+--------------+--------------+-------------+-----------+\n| NULL IS NULL | ISNULL(NULL) | ISNULL('a') | 1 IS NULL |\n+--------------+--------------+-------------+-----------+\n| 1 | 1 | 0 | 0 |\n+--------------+--------------+-------------+-----------+\n1 row in set (0.00 sec)\n\n#查询commission_pct等于NULL。比较如下的四种写法\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> NULL;\nSELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;\n\n\nSELECT last_name, manager_id\nFROM employees\nWHERE manager_id IS NULL;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2.5 非空运算符\n\n非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。 SQL语句示例如下：\n\nmysql> SELECT NULL IS NOT NULL, 'a' IS NOT NULL, 1 IS NOT NULL;\n+------------------+-----------------+---------------+\n| NULL IS NOT NULL | 'a' IS NOT NULL | 1 IS NOT NULL |\n+------------------+-----------------+---------------+\n| 0 | 1 | 1 |\n+------------------+-----------------+---------------+\n1 row in set (0.01 sec)\n\n#查询commission_pct不等于NULL\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL;\nSELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct <=> NULL;\nSELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.6 最小值运算符\n\n语法格式为：LEAST(值1，值2，...，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。\n\nmysql> SELECT LEAST (1,0,2), LEAST('b','a','c'), LEAST(1,NULL,2);\n+---------------+--------------------+-----------------+\n| LEAST (1,0,2) | LEAST('b','a','c') | LEAST(1,NULL,2) |\n+---------------+--------------------+-----------------+\n| 0 | a | NULL |\n+---------------+--------------------+-----------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。\n\n\n# 2.7 最大值运算符\n\n语法格式为：GREATEST(值1，值2，...，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。\n\nmysql> SELECT GREATEST(1,0,2), GREATEST('b','a','c'), GREATEST(1,NULL,2);\n+-----------------+-----------------------+--------------------+\n| GREATEST(1,0,2) | GREATEST('b','a','c') | GREATEST(1,NULL,2) |\n+-----------------+-----------------------+--------------------+\n| 2 | c | NULL |\n+-----------------+-----------------------+--------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。\n\n\n# 2.8 BETWEEN AND运算符\n\nBETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。\n\nmysql> SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, 'b' BETWEEN 'a' AND 'c';\n+-------------------+----------------------+-------------------------+\n| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | 'b' BETWEEN 'a' AND 'c' |\n+-------------------+----------------------+-------------------------+\n| 1 | 0 | 1 |\n+-------------------+----------------------+-------------------------+\n1 row in set (0.00 sec)\n\nSELECT last_name, salary\nFROM employees\nWHERE salary BETWEEN 2500 AND 3500;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2.9 IN运算符\n\nIN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。\n\nmysql> SELECT 'a' IN ('a','b','c'), 1 IN (2,3), NULL IN ('a','b'), 'a' IN ('a', NULL);\n+----------------------+------------+-------------------+--------------------+\n| 'a' IN ('a','b','c') | 1 IN (2,3) | NULL IN ('a','b') | 'a' IN ('a', NULL) |\n+----------------------+------------+-------------------+--------------------+\n| 1 | 0 | NULL | 1 |\n+----------------------+------------+-------------------+--------------------+\n1 row in set (0.00 sec)\n\nSELECT employee_id, last_name, salary, manager_id\nFROM employees\nWHERE manager_id IN (100, 101, 201);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2.10 NOT IN运算符\n\nNOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。\n\nmysql> SELECT 'a' NOT IN ('a','b','c'), 1 NOT IN (2,3);\n+--------------------------+----------------+\n| 'a' NOT IN ('a','b','c') | 1 NOT IN (2,3) |\n+--------------------------+----------------+\n| 0 | 1 |\n+--------------------------+----------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.11 LIKE运算符\n\n# LIKE\n\nLIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。\n\nLIKE运算符通常使用如下通配符：\n\n“%”：匹配0个或多个字符。\n“_”：只能匹配一个字符。\n\n\n1\n2\n\n\nSQL语句示例如下：\n\nmysql> SELECT NULL LIKE 'abc', 'abc' LIKE NULL;\n+-----------------+-----------------+\n| NULL LIKE 'abc' | 'abc' LIKE NULL |\n+-----------------+-----------------+\n| NULL | NULL |\n+-----------------+-----------------+\n1 row in set (0.00 sec)\n\nSELECT first_name\nFROM employees\nWHERE first_name LIKE 'S%';\n\nSELECT last_name\nFROM employees\nWHERE last_name LIKE '_o%';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# ESCAPE 😄🚗🐶🐱\n\n * 回避特殊符号的：使用转义符。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。\n\nSELECT job_id\nFROM jobs\nWHERE job_id LIKE ‘IT\\_%‘;\n\n\n1\n2\n3\n\n * 如果使用\\表示转义，要省略ESCAPE。如果不是\\，则要加上ESCAPE。\n\nSELECT job_id\nFROM jobs\nWHERE job_id LIKE ‘IT$_%‘ escape ‘$‘;\n\n\n1\n2\n3\n\n\n\n# 2.12 REGEXP运算符\n\nREGEXP运算符用来匹配字符串，语法格式为： expr REGEXP 匹配条件 。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。\n\nREGEXP运算符在进行匹配时，常用的有下面几种通配符：\n\n（1）‘^’匹配以该字符后面的字符开头的字符串。\n（2）‘$’匹配以该字符前面的字符结尾的字符串。\n（3）‘.’匹配任何一个单字符。\n（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一\n个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。\n（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，\n而“*”匹配任何数量的任何字符。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nSQL语句示例如下：\n\nmysql> SELECT 'shkstart' REGEXP '^s', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk';\n+------------------------+------------------------+-------------------------+\n| 'shkstart' REGEXP '^s' | 'shkstart' REGEXP 't$' | 'shkstart' REGEXP 'hk' |\n+------------------------+------------------------+-------------------------+\n| 1 | 1 | 1 |\n+------------------------+------------------------+-------------------------+\n1 row in set (0.01 sec)\n\nmysql> SELECT 'atguigu' REGEXP 'gu.gu', 'atguigu' REGEXP '[ab]';\n+--------------------------+-------------------------+\n| 'atguigu' REGEXP 'gu.gu' | 'atguigu' REGEXP '[ab]' |\n+--------------------------+-------------------------+\n| 1 | 1 |\n+--------------------------+-------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3. 逻辑运算符\n\n逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。MySQL中支持4种逻辑运算符如下：\n\n\n\n\n# 3.1 逻辑非运算符\n\n逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。\n\nmysql> SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;\n+-------+-------+----------+--------+----------+\n| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL |\n+-------+-------+----------+--------+----------+\n| 0 | 1 | 0 | 1 | NULL |\n+-------+-------+----------+--------+----------+\n1 row in set, 1 warning (0.00 sec)\n\nSELECT last_name, job_id\nFROM employees\nWHERE job_id NOT IN ('IT_PROG', 'ST_CLERK', 'SA_REP');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.2 逻辑与运算符\n\n逻辑与（AND或&&）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。\n\nmysql> SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;\n+----------+---------+------------+------------+\n| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |\n+----------+---------+------------+------------+\n| 1 | 0 | 0 | NULL |\n+----------+---------+------------+------------+\n1 row in set (0.00 sec)\n\nSELECT employee_id, last_name, job_id, salary\nFROM employees\nWHERE salary >=10000\nAND job_id LIKE '%MAN%';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.3 逻辑或运算符\n\n逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。\n\nmysql> SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;\n+---------+--------+-----------+-----------+--------------+\n| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |\n+---------+--------+-----------+-----------+--------------+\n| 1 | 1 | 1 | NULL | NULL |\n+---------+--------+-----------+-----------+--------------+\n1 row in set, 2 warnings (0.00 sec)\n\n#查询基本薪资不在9000-12000之间的员工编号和基本薪资\nSELECT employee_id,salary FROM employees\nWHERE NOT (salary >= 9000 AND salary <= 12000);\nSELECT employee_id,salary FROM employees\nWHERE salary <9000 OR salary > 12000;\nSELECT employee_id,salary FROM employees\nWHERE salary NOT BETWEEN 9000 AND 12000;\n\n\nSELECT employee_id, last_name, job_id, salary\nFROM employees\nWHERE salary >= 10000\nOR job_id LIKE '%MAN%';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n> 注意：\n> \n> OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。\n\n\n# 3.4 逻辑异或运算符\n\n逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。\n\nmysql> SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;\n+----------+---------+---------+------------+---------------+---------------+\n| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |\n+----------+---------+---------+------------+---------------+---------------+\n| 0 | 1 | 0 | NULL | 1 | 0 |\n+----------+---------+---------+------------+---------------+---------------+\n1 row in set (0.00 sec)\n\n\nselect last_name,department_id,salary\nfrom employees\nwhere department_id in (10,20) XOR salary > 8000;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4. 位运算符\n\n位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。\n\nMySQL支持的位运算符如下：\n\n\n\n\n# 4.1 按位与运算符🚗\n\n按位与（&）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。\n\nmysql> SELECT 1 & 10, 20 & 30;\n+--------+---------+\n| 1 & 10 | 20 & 30 |\n+--------+---------+\n| 0 | 20 |\n+--------+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0001，10的二进制数为1010，所以1 & 10的结果为0000，对应的十进制数为0。20的二进制数为10100，30的二进制数为11110，所以20 & 30的结果为10100，对应的十进制数为20。\n\n\n# 4.2 按位或运算符\n\n按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。\n\nmysql> SELECT 1 | 10, 20 | 30;\n+--------+---------+\n| 1 | 10 | 20 | 30 |\n+--------+---------+\n| 11 | 30 |\n+--------+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。\n\n\n# 4.3 按位异或运算符\n\n按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0。\n\nmysql> SELECT 1 ^ 10, 20 ^ 30;\n+--------+---------+\n| 1 ^ 10 | 20 ^ 30 |\n+--------+---------+\n| 11 | 10 |\n+--------+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。\n\n再举例：\n\nmysql> SELECT 12 & 5, 12 | 5,12 ^ 5 FROM DUAL;\n+--------+--------+--------+\n| 12 & 5 | 12 | 5 | 12 ^ 5 |\n+--------+--------+--------+\n| 4 | 13 | 9 |\n+--------+--------+--------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.4 按位取反运算符\n\n按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。\n\nmysql> SELECT 10 & ~1;\n+---------+\n| 10 & ~1 |\n+---------+\n| 10 |\n+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于按位取反（~）运算符的优先级高于按位与（&）运算符的优先级，所以10 & ~1，首先，对数字1进行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。\n\n\n# 4.5 按位右移运算符\n\n按位右移（>>）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。\n\n\n1\n\n\nmysql> SELECT 1 >> 2, 4 >> 2;\n+--------+--------+\n| 1 >> 2 | 4 >> 2 |\n+--------+--------+\n| 0 | 1 |\n+--------+--------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2位为0000 0001，对应的十进制数为1。\n\n\n# 4.6 按位左移运算符\n\n按位左移（<<）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。\n\n\n1\n\n\nmysql> SELECT 1 << 2, 4 << 2;\n+--------+--------+\n| 1 << 2 | 4 << 2 |\n+--------+--------+\n| 4 | 16 |\n+--------+--------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移两位为0001 0000，对应的十进制数为16。\n\n\n# 5. 运算符的优先级\n\n\n\n数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。\n\n\n# 6. 扩展：使用正则表达式\n\n正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。\n\nMySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。\n\n\n\n1. 查询以特定字符或字符串开头的记录 字符‘^’匹配以特定字符或者字符串开头的文本。\n\n在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP '^b';\n\n\n1\n\n\n2. 查询以特定字符或字符串结尾的记录 字符‘$’匹配以特定字符或者字符串结尾的文本。\n\n在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'y$';\n\n\n1\n\n\n3. 用符号\".\"来替代字符串中的任意一个字符 字符‘.’匹配任意一个字符。\n\n在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'a.g';\n\n\n1\n\n\n4. 使用\"*\"和\"+\"来匹配多个字符 星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。\n\n在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP '^ba*';\n\n\n1\n\n\n在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP '^ba+';\n\n\n1\n\n\n5. 匹配指定字符串 正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。\n\n在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'on';\n\n\n1\n\n\n在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'on|ap';\n\n\n1\n\n\n之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。\n\n在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name like 'on';\n\nEmpty set(0.00 sec)\n\n\n1\n2\n3\n\n\n6. 匹配指定字符中的任意一个 方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。\n\n在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP '[ot]';\n\n\n1\n\n\n在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE s_id REGEXP '[456]';\n\n\n1\n\n\n7. 匹配指定字符以外的字符\n\n“[^字符集合]”  匹配不在指定集合中的任何字符。\n\n\n1\n\n\n在fruits表中，查询f_id字段中包含字母a-e和数字1-2以外字符的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_id REGEXP '[^a-e1-2]';\n\n\n1\n\n\n8. 使用{n,}或者{n,m}来指定字符串连续出现的次数 “字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。\n\n在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'x{2,}';\\\n\n\n1\n\n\n在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下：\n\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'ba{1,3}';\n\n\n1\n",normalizedContent:"# 运算符\n\n\n# 1. 算术运算符\n\n算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。\n\n\n\n\n# 1.1 加法和减法运算符\n\nmysql> select 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5\nfrom dual;\n+-----+---------+---------+----------+--------------+------------+------------+\n| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |\n+-----+---------+---------+----------+--------------+------------+------------+\n| 100 | 100 | 100 | 150 | 120 | 135.5 | 64.5 |\n+-----+---------+---------+----------+--------------+------------+------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n>  * 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；\n> \n>  * 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；\n> \n>  * 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；\n> \n>  * 在java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在mysql中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：mysql中字符串拼接要使用字符串函数concat()实现）\n\n\n# 1.2 乘法与除法运算符 😄\n\nmysql> select 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100\ndiv 0 from dual;\n+-----+---------+-----------+-----------+---------+-----------------+---------+-------\n----+\n| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3 | 100\ndiv 0 |\n+-----+---------+-----------+-----------+---------+-----------------+---------+-------\n----+\n| 100 | 100 | 100.0 | 100.0000 | 50.0000 | 105.0000 | 33.3333 |\nnull |\n+-----+---------+-----------+-----------+---------+-----------------+---------+-------\n----+\n1 row in set (0.00 sec)\n\n#计算出员工的年基本工资\nselect employee_id,salary,salary * 12 annual_sal\nfrom employees;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n>  * 一个数乘以整数1和除以整数1后仍得原数；\n> \n>  * 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；\n> \n>  * 一个数除以整数后，不管是否能除尽，结果都为一个浮点数；\n> \n>  * 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；\n> \n>  * 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。\n> \n>  * 在数学运算中，0不能用作除数，在mysql中，一个数除以0为null。\n\n\n# 1.3 求模（求余）运算符 将t22表中的字段i对3和5进行求模（求余）运算。\n\nmysql> select 12 % 3, 12 mod 5 from dual;\n+--------+----------+\n| 12 % 3 | 12 mod 5 |\n+--------+----------+\n| 0 | 2 |\n+--------+----------+\n1 row in set (0.00 sec)\n\n#筛选出employee_id是偶数的员工\nselect * from employees\nwhere employee_id mod 2 = 0;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看到，100对3求模后的结果为3，对5求模后的结果为0。\n\n\n# 2. 比较运算符\n\n比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回null。\n\n比较运算符经常被用来作为select查询语句的条件来使用，返回符合条件的结果记录。\n\n\n\n\n# 2.1 等号运算符\n\n * 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。\n\n * 在使用等号运算符时，遵循如下规则：\n   \n   * 如果等号两边的值、字符串或表达式都为字符串，则mysql会按照字符串进行比较，其比较的是每个字符串中字符的ansi编码是否相等。\n   * 如果等号两边的值都是整数，则mysql会按照整数来比较两个值的大小。\n   * 如果等号两边的值一个是整数，另一个是字符串，则mysql会将字符串转化为数字进行比较。\n   * 如果等号两边的值、字符串或表达式中有一个为null，则比较结果为null。\n\n * 对比：sql中赋值符号使用 :=\n\nmysql> select 1 = 1, 1 = '1', 1 = 0, 'a' = 'a', (5 + 3) = (2 + 6), '' = null , null =\nnull;\n+-------+---------+-------+-----------+-------------------+-----------+-------------+\n| 1 = 1 | 1 = '1' | 1 = 0 | 'a' = 'a' | (5 + 3) = (2 + 6) | '' = null | null = null |\n+-------+---------+-------+-----------+-------------------+-----------+-------------+\n| 1 | 1 | 0 | 1 | 1 | null | null |\n+-------+---------+-------+-----------+-------------------+-----------+-------------+\n1 row in set (0.00 sec)\n\nmysql> select 1 = 2, 0 = 'abc', 1 = 'abc' from dual;\n+-------+-----------+-----------+\n| 1 = 2 | 0 = 'abc' | 1 = 'abc' |\n+-------+-----------+-----------+\n| 0 | 1 | 0 |\n+-------+-----------+-----------+\n1 row in set, 2 warnings (0.00 sec)\n\n#查询salary=10000，注意在java中比较是==\nselect employee_id,salary from employees where salary = 10000;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.2 安全等于运算符\n\n安全等于运算符（<=>）与等于运算符（=）的作用是相似的， 唯一的区别 是‘<=>’可以用来对null进行判断。在两个操作数均为null时，其返回值为1，而不为null；当一个操作数为null时，其返回值为0，而不为null。\n\n\n1\n\n\nmysql> select 1 <=> '1', 1 <=> 0, 'a' <=> 'a', (5 + 3) <=> (2 + 6), '' <=> null,null\n<=> null from dual;\n+-----------+---------+-------------+---------------------+-------------+---------------+\n| 1 <=> '1' | 1 <=> 0 | 'a' <=> 'a' | (5 + 3) <=> (2 + 6) | '' <=> null | null <=> null |\n+-----------+---------+-------------+---------------------+-------------+---------------+\n| 1 | 0 | 1 | 1 | 0 |1 |\n+-----------+---------+-------------+---------------------+-------------+---------------+\n1 row in set (0.00 sec)\n\n#查询commission_pct等于0.40\nselect employee_id,commission_pct from employees where commission_pct = 0.40;\nselect employee_id,commission_pct from employees where commission_pct <=> 0.40;\n#如果把0.40改成 null 呢？\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可以看到，使用安全等于运算符时，两边的操作数的值都为null时，返回的结果为1而不是null，其他返回结果与等于运算符相同\n\n\n# 2.3 不等于运算符\n\n不等于运算符（<>和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断null值。如果两边的值有任意一个为null，或两边都为null，则结果为null。 sql语句示例如下：\n\n\n1\n\n\nmysql> select 1 <> 1, 1 != 2, 'a' != 'b', (3+4) <> (2+6), 'a' != null, null <> null;\n+--------+--------+------------+----------------+-------------+--------------+\n| 1 <> 1 | 1 != 2 | 'a' != 'b' | (3+4) <> (2+6) | 'a' != null | null <> null |\n+--------+--------+------------+----------------+-------------+--------------+\n| 0 | 1 | 1 | 1 | null | null |\n+--------+--------+------------+----------------+-------------+--------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n此外，还有非符号类型的运算符:\n\n\n# 2.4 空运算符\n\n空运算符（is null或者isnull）判断一个值是否为null，如果为null则返回1，否则返回0。 sql语句示例如下：\n\nmysql> select null is null, isnull(null), isnull('a'), 1 is null;\n+--------------+--------------+-------------+-----------+\n| null is null | isnull(null) | isnull('a') | 1 is null |\n+--------------+--------------+-------------+-----------+\n| 1 | 1 | 0 | 0 |\n+--------------+--------------+-------------+-----------+\n1 row in set (0.00 sec)\n\n#查询commission_pct等于null。比较如下的四种写法\nselect employee_id,commission_pct from employees where commission_pct is null;\nselect employee_id,commission_pct from employees where commission_pct <=> null;\nselect employee_id,commission_pct from employees where isnull(commission_pct);\nselect employee_id,commission_pct from employees where commission_pct = null;\n\n\nselect last_name, manager_id\nfrom employees\nwhere manager_id is null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 2.5 非空运算符\n\n非空运算符（is not null）判断一个值是否不为null，如果不为null则返回1，否则返回0。 sql语句示例如下：\n\nmysql> select null is not null, 'a' is not null, 1 is not null;\n+------------------+-----------------+---------------+\n| null is not null | 'a' is not null | 1 is not null |\n+------------------+-----------------+---------------+\n| 0 | 1 | 1 |\n+------------------+-----------------+---------------+\n1 row in set (0.01 sec)\n\n#查询commission_pct不等于null\nselect employee_id,commission_pct from employees where commission_pct is not null;\nselect employee_id,commission_pct from employees where not commission_pct <=> null;\nselect employee_id,commission_pct from employees where not isnull(commission_pct);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.6 最小值运算符\n\n语法格式为：least(值1，值2，...，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。\n\nmysql> select least (1,0,2), least('b','a','c'), least(1,null,2);\n+---------------+--------------------+-----------------+\n| least (1,0,2) | least('b','a','c') | least(1,null,2) |\n+---------------+--------------------+-----------------+\n| 0 | a | null |\n+---------------+--------------------+-----------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由结果可以看到，当参数是整数或者浮点数时，least将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有null时，不能判断大小，返回值为null。\n\n\n# 2.7 最大值运算符\n\n语法格式为：greatest(值1，值2，...，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为null，则greatest()的返回值为null。\n\nmysql> select greatest(1,0,2), greatest('b','a','c'), greatest(1,null,2);\n+-----------------+-----------------------+--------------------+\n| greatest(1,0,2) | greatest('b','a','c') | greatest(1,null,2) |\n+-----------------+-----------------------+--------------------+\n| 2 | c | null |\n+-----------------+-----------------------+--------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由结果可以看到，当参数中是整数或者浮点数时，greatest将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有null时，不能判断大小，返回值为null。\n\n\n# 2.8 between and运算符\n\nbetween运算符使用的格式通常为select d from table where c between a and b，此时，当c大于或等于a，并且c小于或等于b时，结果为1，否则结果为0。\n\nmysql> select 1 between 0 and 1, 10 between 11 and 12, 'b' between 'a' and 'c';\n+-------------------+----------------------+-------------------------+\n| 1 between 0 and 1 | 10 between 11 and 12 | 'b' between 'a' and 'c' |\n+-------------------+----------------------+-------------------------+\n| 1 | 0 | 1 |\n+-------------------+----------------------+-------------------------+\n1 row in set (0.00 sec)\n\nselect last_name, salary\nfrom employees\nwhere salary between 2500 and 3500;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2.9 in运算符\n\nin运算符用于判断给定的值是否是in列表中的一个值，如果是则返回1，否则返回0。如果给定的值为null，或者in列表中存在null，则结果为null。\n\nmysql> select 'a' in ('a','b','c'), 1 in (2,3), null in ('a','b'), 'a' in ('a', null);\n+----------------------+------------+-------------------+--------------------+\n| 'a' in ('a','b','c') | 1 in (2,3) | null in ('a','b') | 'a' in ('a', null) |\n+----------------------+------------+-------------------+--------------------+\n| 1 | 0 | null | 1 |\n+----------------------+------------+-------------------+--------------------+\n1 row in set (0.00 sec)\n\nselect employee_id, last_name, salary, manager_id\nfrom employees\nwhere manager_id in (100, 101, 201);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2.10 not in运算符\n\nnot in运算符用于判断给定的值是否不是in列表中的一个值，如果不是in列表中的一个值，则返回1，否则返回0。\n\nmysql> select 'a' not in ('a','b','c'), 1 not in (2,3);\n+--------------------------+----------------+\n| 'a' not in ('a','b','c') | 1 not in (2,3) |\n+--------------------------+----------------+\n| 0 | 1 |\n+--------------------------+----------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.11 like运算符\n\n# like\n\nlike运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为null，则返回结果为null。\n\nlike运算符通常使用如下通配符：\n\n“%”：匹配0个或多个字符。\n“_”：只能匹配一个字符。\n\n\n1\n2\n\n\nsql语句示例如下：\n\nmysql> select null like 'abc', 'abc' like null;\n+-----------------+-----------------+\n| null like 'abc' | 'abc' like null |\n+-----------------+-----------------+\n| null | null |\n+-----------------+-----------------+\n1 row in set (0.00 sec)\n\nselect first_name\nfrom employees\nwhere first_name like 's%';\n\nselect last_name\nfrom employees\nwhere last_name like '_o%';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# escape 😄🚗🐶🐱\n\n * 回避特殊符号的：使用转义符。例如：将[%]转为[$%]、[]转为[$]，然后再加上[escape‘$’]即可。\n\nselect job_id\nfrom jobs\nwhere job_id like ‘it\\_%‘;\n\n\n1\n2\n3\n\n * 如果使用\\表示转义，要省略escape。如果不是\\，则要加上escape。\n\nselect job_id\nfrom jobs\nwhere job_id like ‘it$_%‘ escape ‘$‘;\n\n\n1\n2\n3\n\n\n\n# 2.12 regexp运算符\n\nregexp运算符用来匹配字符串，语法格式为： expr regexp 匹配条件 。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为null，则结果为null。\n\nregexp运算符在进行匹配时，常用的有下面几种通配符：\n\n（1）‘^’匹配以该字符后面的字符开头的字符串。\n（2）‘$’匹配以该字符前面的字符结尾的字符串。\n（3）‘.’匹配任何一个单字符。\n（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一\n个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。\n（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，\n而“*”匹配任何数量的任何字符。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nsql语句示例如下：\n\nmysql> select 'shkstart' regexp '^s', 'shkstart' regexp 't$', 'shkstart' regexp 'hk';\n+------------------------+------------------------+-------------------------+\n| 'shkstart' regexp '^s' | 'shkstart' regexp 't$' | 'shkstart' regexp 'hk' |\n+------------------------+------------------------+-------------------------+\n| 1 | 1 | 1 |\n+------------------------+------------------------+-------------------------+\n1 row in set (0.01 sec)\n\nmysql> select 'atguigu' regexp 'gu.gu', 'atguigu' regexp '[ab]';\n+--------------------------+-------------------------+\n| 'atguigu' regexp 'gu.gu' | 'atguigu' regexp '[ab]' |\n+--------------------------+-------------------------+\n| 1 | 1 |\n+--------------------------+-------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3. 逻辑运算符\n\n逻辑运算符主要用来判断表达式的真假，在mysql中，逻辑运算符的返回结果为1、0或者null。mysql中支持4种逻辑运算符如下：\n\n\n\n\n# 3.1 逻辑非运算符\n\n逻辑非（not或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为null时，返回null。\n\nmysql> select not 1, not 0, not(1+1), not !1, not null;\n+-------+-------+----------+--------+----------+\n| not 1 | not 0 | not(1+1) | not !1 | not null |\n+-------+-------+----------+--------+----------+\n| 0 | 1 | 0 | 1 | null |\n+-------+-------+----------+--------+----------+\n1 row in set, 1 warning (0.00 sec)\n\nselect last_name, job_id\nfrom employees\nwhere job_id not in ('it_prog', 'st_clerk', 'sa_rep');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.2 逻辑与运算符\n\n逻辑与（and或&&）运算符是当给定的所有值均为非0值，并且都不为null时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回null。\n\nmysql> select 1 and -1, 0 and 1, 0 and null, 1 and null;\n+----------+---------+------------+------------+\n| 1 and -1 | 0 and 1 | 0 and null | 1 and null |\n+----------+---------+------------+------------+\n| 1 | 0 | 0 | null |\n+----------+---------+------------+------------+\n1 row in set (0.00 sec)\n\nselect employee_id, last_name, job_id, salary\nfrom employees\nwhere salary >=10000\nand job_id like '%man%';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.3 逻辑或运算符\n\n逻辑或（or或||）运算符是当给定的值都不为null，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为null，并且另一个值为非0值时，返回1，否则返回null；当两个值都为null时，返回null。\n\nmysql> select 1 or -1, 1 or 0, 1 or null, 0 || null, null || null;\n+---------+--------+-----------+-----------+--------------+\n| 1 or -1 | 1 or 0 | 1 or null | 0 || null | null || null |\n+---------+--------+-----------+-----------+--------------+\n| 1 | 1 | 1 | null | null |\n+---------+--------+-----------+-----------+--------------+\n1 row in set, 2 warnings (0.00 sec)\n\n#查询基本薪资不在9000-12000之间的员工编号和基本薪资\nselect employee_id,salary from employees\nwhere not (salary >= 9000 and salary <= 12000);\nselect employee_id,salary from employees\nwhere salary <9000 or salary > 12000;\nselect employee_id,salary from employees\nwhere salary not between 9000 and 12000;\n\n\nselect employee_id, last_name, job_id, salary\nfrom employees\nwhere salary >= 10000\nor job_id like '%man%';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n> 注意：\n> \n> or可以和and一起使用，但是在使用时要注意两者的优先级，由于and的优先级高于or，因此先对and两边的操作数进行操作，再与or中的操作数结合。\n\n\n# 3.4 逻辑异或运算符\n\n逻辑异或（xor）运算符是当给定的值中任意一个值为null时，则返回null；如果两个非null的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。\n\nmysql> select 1 xor -1, 1 xor 0, 0 xor 0, 1 xor null, 1 xor 1 xor 1, 0 xor 0 xor 0;\n+----------+---------+---------+------------+---------------+---------------+\n| 1 xor -1 | 1 xor 0 | 0 xor 0 | 1 xor null | 1 xor 1 xor 1 | 0 xor 0 xor 0 |\n+----------+---------+---------+------------+---------------+---------------+\n| 0 | 1 | 0 | null | 1 | 0 |\n+----------+---------+---------+------------+---------------+---------------+\n1 row in set (0.00 sec)\n\n\nselect last_name,department_id,salary\nfrom employees\nwhere department_id in (10,20) xor salary > 8000;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4. 位运算符\n\n位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。\n\nmysql支持的位运算符如下：\n\n\n\n\n# 4.1 按位与运算符🚗\n\n按位与（&）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。\n\nmysql> select 1 & 10, 20 & 30;\n+--------+---------+\n| 1 & 10 | 20 & 30 |\n+--------+---------+\n| 0 | 20 |\n+--------+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0001，10的二进制数为1010，所以1 & 10的结果为0000，对应的十进制数为0。20的二进制数为10100，30的二进制数为11110，所以20 & 30的结果为10100，对应的十进制数为20。\n\n\n# 4.2 按位或运算符\n\n按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。\n\nmysql> select 1 | 10, 20 | 30;\n+--------+---------+\n| 1 | 10 | 20 | 30 |\n+--------+---------+\n| 11 | 30 |\n+--------+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。\n\n\n# 4.3 按位异或运算符\n\n按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0。\n\nmysql> select 1 ^ 10, 20 ^ 30;\n+--------+---------+\n| 1 ^ 10 | 20 ^ 30 |\n+--------+---------+\n| 11 | 10 |\n+--------+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。\n\n再举例：\n\nmysql> select 12 & 5, 12 | 5,12 ^ 5 from dual;\n+--------+--------+--------+\n| 12 & 5 | 12 | 5 | 12 ^ 5 |\n+--------+--------+--------+\n| 4 | 13 | 9 |\n+--------+--------+--------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.4 按位取反运算符\n\n按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。\n\nmysql> select 10 & ~1;\n+---------+\n| 10 & ~1 |\n+---------+\n| 10 |\n+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于按位取反（~）运算符的优先级高于按位与（&）运算符的优先级，所以10 & ~1，首先，对数字1进行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。\n\n\n# 4.5 按位右移运算符\n\n按位右移（>>）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。\n\n\n1\n\n\nmysql> select 1 >> 2, 4 >> 2;\n+--------+--------+\n| 1 >> 2 | 4 >> 2 |\n+--------+--------+\n| 0 | 1 |\n+--------+--------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2位为0000 0001，对应的十进制数为1。\n\n\n# 4.6 按位左移运算符\n\n按位左移（<<）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。\n\n\n1\n\n\nmysql> select 1 << 2, 4 << 2;\n+--------+--------+\n| 1 << 2 | 4 << 2 |\n+--------+--------+\n| 4 | 16 |\n+--------+--------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移两位为0001 0000，对应的十进制数为16。\n\n\n# 5. 运算符的优先级\n\n\n\n数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。\n\n\n# 6. 扩展：使用正则表达式\n\n正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。\n\nmysql中使用regexp关键字指定正则表达式的字符匹配模式。下表列出了regexp操作符中常用字符匹配列表。\n\n\n\n1. 查询以特定字符或字符串开头的记录 字符‘^’匹配以特定字符或者字符串开头的文本。\n\n在fruits表中，查询f_name字段以字母‘b’开头的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp '^b';\n\n\n1\n\n\n2. 查询以特定字符或字符串结尾的记录 字符‘$’匹配以特定字符或者字符串结尾的文本。\n\n在fruits表中，查询f_name字段以字母‘y’结尾的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp 'y$';\n\n\n1\n\n\n3. 用符号\".\"来替代字符串中的任意一个字符 字符‘.’匹配任意一个字符。\n\n在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp 'a.g';\n\n\n1\n\n\n4. 使用\"*\"和\"+\"来匹配多个字符 星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。\n\n在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp '^ba*';\n\n\n1\n\n\n在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp '^ba+';\n\n\n1\n\n\n5. 匹配指定字符串 正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。\n\n在fruits表中，查询f_name字段值包含字符串“on”的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp 'on';\n\n\n1\n\n\n在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp 'on|ap';\n\n\n1\n\n\n之前介绍过，like运算符也可以匹配指定的字符串，但与regexp不同，like匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。regexp在文本内进行匹配，如果被匹配的字符串在文本中出现，regexp将会找到它，相应的行也会被返回。对比结果如下所示。\n\n在fruits表中，使用like运算符查询f_name字段值为“on”的记录，sql语句如下：\n\nmysql> select * from fruits where f_name like 'on';\n\nempty set(0.00 sec)\n\n\n1\n2\n3\n\n\n6. 匹配指定字符中的任意一个 方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。\n\n在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp '[ot]';\n\n\n1\n\n\n在fruits表中，查询s_id字段中包含4、5或者6的记录，sql语句如下：\n\nmysql> select * from fruits where s_id regexp '[456]';\n\n\n1\n\n\n7. 匹配指定字符以外的字符\n\n“[^字符集合]”  匹配不在指定集合中的任何字符。\n\n\n1\n\n\n在fruits表中，查询f_id字段中包含字母a-e和数字1-2以外字符的记录，sql语句如下：\n\nmysql> select * from fruits where f_id regexp '[^a-e1-2]';\n\n\n1\n\n\n8. 使用{n,}或者{n,m}来指定字符串连续出现的次数 “字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。\n\n在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp 'x{2,}';\\\n\n\n1\n\n\n在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，sql语句如下：\n\nmysql> select * from fruits where f_name regexp 'ba{1,3}';\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/03/10, 07:35:07",lastUpdatedTimestamp:1678404907e3},{title:"多表查询",frontmatter:{title:"多表查询",date:"2023-03-09T21:51:35.000Z",permalink:"/pages/9ed39a/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/04.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL%E5%9F%BA%E7%A1%80/06.MySQL%E5%9F%BA%E7%A1%80-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2.html",relativePath:"01.语言/04.数据库/01.MySQL基础/06.MySQL基础-多表查询.md",key:"v-7d6ccb43",path:"/pages/9ed39a/",headers:[{level:2,title:"1. 一个案例引发的多表连接",slug:"_1-一个案例引发的多表连接",normalizedTitle:"1. 一个案例引发的多表连接",charIndex:11},{level:3,title:"1.1 案例",slug:"_1-1-案例",normalizedTitle:"1.1 案例",charIndex:30},{level:3,title:"1.2 笛卡尔积（或交叉连接）的理解",slug:"_1-2-笛卡尔积-或交叉连接-的理解",normalizedTitle:"1.2 笛卡尔积（或交叉连接）的理解",charIndex:1003},{level:3,title:"1.3 案例分析与问题解决",slug:"_1-3-案例分析与问题解决",normalizedTitle:"1.3 案例分析与问题解决",charIndex:1551},{level:2,title:"2. 多表查询",slug:"_2-多表查询",normalizedTitle:"2. 多表查询",charIndex:2092},{level:3,title:"2.1 等值连接 vs 非等值连接",slug:"_2-1-等值连接-vs-非等值连接",normalizedTitle:"2.1 等值连接 vs 非等值连接",charIndex:2104},{level:4,title:"等值连接",slug:"等值连接",normalizedTitle:"等值连接",charIndex:2108},{level:4,title:"非等值连接",slug:"非等值连接",normalizedTitle:"非等值连接",charIndex:2116},{level:3,title:"2.2 自连接 vs 非自连接",slug:"_2-2-自连接-vs-非自连接",normalizedTitle:"2.2 自连接 vs 非自连接",charIndex:3730},{level:3,title:"2.3 内连接 vs 外连接",slug:"_2-3-内连接-vs-外连接",normalizedTitle:"2.3 内连接 vs 外连接",charIndex:4026},{level:4,title:"SQL92：使用(+)创建连接",slug:"sql92-使用-创建连接",normalizedTitle:"sql92：使用(+)创建连接",charIndex:4308},{level:2,title:"3. SQL99语法实现多表查询",slug:"_3-sql99语法实现多表查询",normalizedTitle:"3. sql99语法实现多表查询",charIndex:4805},{level:3,title:"3.1 基本语法",slug:"_3-1-基本语法",normalizedTitle:"3.1 基本语法",charIndex:4826},{level:3,title:"3.2 内连接(INNER JOIN)的实现 😄",slug:"_3-2-内连接-inner-join-的实现",normalizedTitle:"3.2 内连接(inner join)的实现 😄",charIndex:5475},{level:4,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:1698},{level:4,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:5578},{level:3,title:"3.3 外连接(OUTER JOIN)的实现",slug:"_3-3-外连接-outer-join-的实现",normalizedTitle:"3.3 外连接(outer join)的实现",charIndex:5957},{level:4,title:"左外连接(LEFT OUTER JOIN)",slug:"左外连接-left-outer-join",normalizedTitle:"左外连接(left outer join)",charIndex:5983},{level:4,title:"右外连接(RIGHT OUTER JOIN)",slug:"右外连接-right-outer-join",normalizedTitle:"右外连接(right outer join)",charIndex:6335},{level:4,title:"满外连接(FULL OUTER JOIN)",slug:"满外连接-full-outer-join",normalizedTitle:"满外连接(full outer join)",charIndex:6767},{level:2,title:"4. UNION的使用",slug:"_4-union的使用",normalizedTitle:"4. union的使用",charIndex:6960},{level:3,title:"4.1 语法格式：",slug:"_4-1-语法格式",normalizedTitle:"4.1 语法格式：",charIndex:7091},{level:3,title:"4.2 UNION操作符",slug:"_4-2-union操作符",normalizedTitle:"4.2 union操作符",charIndex:7187},{level:3,title:"4.3 UNION ALL操作符",slug:"_4-3-union-all操作符",normalizedTitle:"4.3 union all操作符",charIndex:7238},{level:3,title:"4.3 示例",slug:"_4-3-示例",normalizedTitle:"4.3 示例",charIndex:7408},{level:2,title:"5. 7种SQL JOINS的实现 😄",slug:"_5-7种sql-joins的实现",normalizedTitle:"5. 7种sql joins的实现 😄",charIndex:7884},{level:3,title:"5.1 代码实现",slug:"_5-1-代码实现",normalizedTitle:"5.1 代码实现",charIndex:7911},{level:3,title:"5.2 语法格式小结",slug:"_5-2-语法格式小结",normalizedTitle:"5.2 语法格式小结",charIndex:9560},{level:2,title:"6. SQL99语法新特性",slug:"_6-sql99语法新特性",normalizedTitle:"6. sql99语法新特性",charIndex:10473},{level:3,title:"6.1 自然连接",slug:"_6-1-自然连接",normalizedTitle:"6.1 自然连接",charIndex:10491},{level:3,title:"6.2 USING连接",slug:"_6-2-using连接",normalizedTitle:"6.2 using连接",charIndex:10917},{level:2,title:"7. 章节小结",slug:"_7-章节小结",normalizedTitle:"7. 章节小结",charIndex:11379},{level:2,title:"附录：常用的SQL标准有哪些",slug:"附录-常用的sql标准有哪些",normalizedTitle:"附录：常用的sql标准有哪些",charIndex:12972}],headersStr:"1. 一个案例引发的多表连接 1.1 案例 1.2 笛卡尔积（或交叉连接）的理解 1.3 案例分析与问题解决 2. 多表查询 2.1 等值连接 vs 非等值连接 等值连接 非等值连接 2.2 自连接 vs 非自连接 2.3 内连接 vs 外连接 SQL92：使用(+)创建连接 3. SQL99语法实现多表查询 3.1 基本语法 3.2 内连接(INNER JOIN)的实现 😄 语法 示例 3.3 外连接(OUTER JOIN)的实现 左外连接(LEFT OUTER JOIN) 右外连接(RIGHT OUTER JOIN) 满外连接(FULL OUTER JOIN) 4. UNION的使用 4.1 语法格式： 4.2 UNION操作符 4.3 UNION ALL操作符 4.3 示例 5. 7种SQL JOINS的实现 😄 5.1 代码实现 5.2 语法格式小结 6. SQL99语法新特性 6.1 自然连接 6.2 USING连接 7. 章节小结 附录：常用的SQL标准有哪些",content:"# 多表查询\n\n\n# 1. 一个案例引发的多表连接\n\n\n# 1.1 案例\n\n\n\n从多个表中获取数据：\n\n\n\n#案例：查询员工的姓名及其部门名称\nSELECT last_name, department_name\nFROM employees, departments;\n\n\n1\n2\n3\n\n\n\n\n+-----------+----------------------+\n| last_name | department_name |\n+-----------+----------------------+\n| King | Administration |\n| King | Marketing |\n| King | Purchasing |\n| King | Human Resources |\n| King | Shipping |\n| King | IT |\n| King | Public Relations |\n| King | Sales |\n| King | Executive |\n| King | Finance |\n| King | Accounting |\n| King | Treasury |\n...\n| Gietz | IT Support |\n| Gietz | NOC |\n| Gietz | IT Helpdesk |\n| Gietz | Government Sales |\n| Gietz | Retail Sales |\n...\n| Gietz | Recruiting |\n| Gietz | Payroll |\n+-----------+----------------------+\n2889 rows in set (0.01 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n分析错误情况：\n\nSELECT COUNT(employee_id) FROM employees;\n#输出107行\n\nSELECT COUNT(department_id)FROM departments;\n#输出27行\n\nSELECT 107*27 FROM dual;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们把上述多表查询中出现的问题称为：笛卡尔积的错误。\n\n\n# 1.2 笛卡尔积（或交叉连接）的理解\n\n笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。\n\nSQL92中，笛卡尔积也称为交叉连接，英文是CROSS JOIN。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：\n\n#查询员工姓名和所在部门名称\nSELECT last_name,department_name FROM employees,departments;\nSELECT last_name,department_name FROM employees CROSS JOIN departments;\nSELECT last_name,department_name FROM employees INNER JOIN departments;\nSELECT last_name,department_name FROM employees JOIN departments;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1.3 案例分析与问题解决\n\n * 笛卡尔积的错误会在下面条件下产生：\n   \n   * 省略多个表的连接条件（或关联条件）\n   * 连接条件（或关联条件）无效\n   * 所有表中的所有行互相连接\n\n * 为了避免笛卡尔积， 可以在WHERE加入有效的连接条件。\n\n * 加入连接条件后，查询语法：\n   \n   SELECT table1.column, table2.column\n   FROM table1, table2\n   WHERE table1.column1 = table2.column2; #连接条件\n   \n   \n   1\n   2\n   3\n   \n   * 在WHERE子句中写入连接条件。\n\n * 正确写法：\n   \n   #案例：查询员工的姓名及其部门名称\n   SELECT last_name, department_name\n   FROM employees, departments\n   WHERE employees.department_id = departments.department_id;\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 在表中有相同列时，在列名之前加上表名前缀。\n\n\n# 2. 多表查询\n\n\n# 2.1 等值连接 vs 非等值连接\n\n# 等值连接\n\nSELECT employees.employee_id, employees.last_name,\n\t   employees.department_id, departments.department_id,\n\t   departments.location_id\nFROM employees, departments\nWHERE employees.department_id = departments.department_id;\n\n\n1\n2\n3\n4\n5\n\n\n\n\n拓展1：多个连接条件与 AND 操作符\n\n\n\n拓展2：区分重复的列名\n\n * 多个表中有相同列时，必须在列名之前加上表名前缀。\n\n * 在不同表中具有相同列名的列可以用 表名 加以区分。\n\nSELECT employees.last_name, departments.department_name,employees.department_id\nFROM employees, departments\nWHERE employees.department_id = departments.department_id;\n\n\n1\n2\n3\n\n\n拓展3：表的别名\n\n * 使用别名可以简化查询。\n\n * 列名前使用表名前缀可以提高查询效率。\n\nSELECT e.employee_id, e.last_name, e.department_id,\n       d.department_id, d.location_id\nFROM employees e, departments d\nWHERE e.department_id = d.department_id;\n\n\n1\n2\n3\n4\n\n\n> 需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。\n> \n> 阿里开发规范 ：\n> \n> 【 强制】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。\n> \n> 说明 ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。\n> \n> 正例 ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;\n> \n> 反例 ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出1052 异常：Column 'name' in field list is ambiguous。\n\n拓展4：连接多个表\n\n\n\n总结：连接n个表,至少需要n-1个连接条件。比如，连接三个表，至少需要两个连接条件。\n\n练习：查询出公司员工的 last_name,department_name, city\n\nSELECT a.last_name, b.department_name, c.city\nFROM employees a, departments b, locations c\nWHERE a.department_id = b.department_id AND b.location_id = c.location_id\n\n\n1\n2\n3\n\n\n# 非等值连接\n\n\n\nSELECT e.last_name, e.salary, j.grade_level\nFROM employees e, job_grades j\nWHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.2 自连接 vs 非自连接\n\n\n\n当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。\n\n题目：查询employees表，返回“Xxx works for Xxx”\n\nSELECT CONCAT(worker.last_name ,' works for ', manager.last_name)\nFROM employees worker, employees manager\nWHERE worker.manager_id = manager.employee_id ;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.3 内连接 vs 外连接\n\n除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。\n\n\n\n * 内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行\n\n * 外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。\n\n * 如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。\n\n * 如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。\n\n# SQL92：使用(+)创建连接\n\n * 在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。\n\n * Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接。\n   \n   #左外连接\n   SELECT last_name,department_name\n   FROM employees ,departments\n   WHERE employees.department_id = departments.department_id(+);\n   #右外连接\n   SELECT last_name,department_name\n   FROM employees ,departments\n   WHERE employees.department_id(+) = departments.department_id;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。\n\n\n# 3. SQL99语法实现多表查询\n\n\n# 3.1 基本语法\n\n * 使用JOIN...ON子句创建连接的语法结构：\n   \n   SELECT table1.column, table2.column,table3.column\n   FROM table1\n   JOIN table2 ON table1 和 table2 的连接条件\n   JOIN table3 ON table2 和 table3 的连接条件\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   它的嵌套逻辑类似我们使用的 FOR 循环：\n   \n   for t1 in table1:\n   \tfor t2 in table2:\n   \t\tif condition1:\n   \t\t\tfor t3 in table3:\n   \t\t\t\tif condition2:\n   \t\t\t\t\toutput t1 + t2 + t3\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。\n\n * 语法说明：\n   \n   * 可以使用ON子句指定额外的连接条件。\n   * 这个连接条件是与其它条件分开的。\n   * ON子句使语句具有更高的易读性。\n   * 关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接\n\n\n# 3.2 内连接(INNER JOIN)的实现 😄\n\n# 语法\n\nSELECT 字段列表\nFROM A表 \nINNER JOIN B表 ON 关联条件\nWHERE 等其他子句;\n\n\n1\n2\n3\n4\n\n\n# 示例\n\n题目1：\n\nSELECT e.employee_id, e.last_name, e.department_id,d.department_id, d.location_id\nFROM employees e \nJOIN departments d ON (e.department_id = d.department_id);\n\n\n1\n2\n3\n\n\n\n\n题目2：拓展4：连接多个表\n\nSELECT employee_id, city, department_name\nFROM employees e\nJOIN departments d ON d.department_id = e.department_id\nJOIN locations l ON d.location_id = l.location_id;\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 3.3 外连接(OUTER JOIN)的实现\n\n# 左外连接(LEFT OUTER JOIN)\n\n * 语法：\n   \n   #实现查询结果是A\n   SELECT 字段列表\n   FROM A表 \n   LEFT JOIN B表 ON 关联条件\n   WHERE 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 举例：\n   \n   SELECT e.last_name, e.department_id, d.department_name\n   FROM employees e\n   LEFT OUTER JOIN departments d ON (e.department_id = d.department_id);\n   \n   \n   1\n   2\n   3\n   \n   \n   \n\n# 右外连接(RIGHT OUTER JOIN)\n\n * 语法：\n   \n   #实现查询结果是B\n   SELECT 字段列表\n   FROM A表 \n   RIGHT JOIN B表 ON 关联条件\n   WHERE 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 举例：\n   \n   SELECT e.last_name, e.department_id, d.department_name\n   FROM employees e\n   RIGHT OUTER JOIN departments d ON (e.department_id = d.department_id);\n   \n   \n   1\n   2\n   3\n   \n   \n   \n\n> 需要注意的是，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在，只能用 (+) 表示。\n\n# 满外连接(FULL OUTER JOIN)\n\n * 满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。\n\n * SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。\n\n * 需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替。\n\n\n# 4. UNION的使用\n\n合并查询结果 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。\n\n\n# 4.1 语法格式：\n\nSELECT column,... FROM table1\nUNION [ALL]\nSELECT column,... FROM table2\n\n\n1\n2\n3\n\n\n\n# 4.2 UNION操作符\n\nUNION 操作符返回两个查询的结果集的并集，去除重复记录。\n\n\n\n\n# 4.3 UNION ALL操作符\n\nUNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。\n\n\n\n> 注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。\n\n\n# 4.3 示例\n\n * 举例：查询部门编号>90或邮箱包含a的员工信息\n   \n   #方式1\n   SELECT * FROM employees WHERE email LIKE '%a%' OR department_id>90;\n   \n   #方式2\n   SELECT * FROM employees WHERE email LIKE '%a%'\n   UNION\n   SELECT * FROM employees WHERE department_id>90;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息\n   \n   SELECT id,cname FROM t_chinamale WHERE csex='男'\n   UNION ALL\n   SELECT id,tname FROM t_usmale WHERE tGender='male';\n   \n   \n   1\n   2\n   3\n   \n\n\n# 5. 7种SQL JOINS的实现 😄\n\n\n\n\n# 5.1 代码实现\n\n#中图：内连接 A∩B\nSELECT employee_id,last_name,department_name\nFROM employees e \nJOIN departments d ON e.`department_id` = d.`department_id`;\n\n#左上图：左外连接\nSELECT employee_id,last_name,department_name\nFROM employees e \nLEFT JOIN departments d ON e.`department_id` = d.`department_id`;\n\n#右上图：右外连接\nSELECT employee_id,last_name,department_name\nFROM employees e \nRIGHT JOIN departments d ON e.`department_id` = d.`department_id`;\n\n#左中图：A - A∩B\nSELECT employee_id,last_name,department_name\nFROM employees e \nLEFT JOIN departments d ON e.`department_id` = d.`department_id`\nWHERE d.`department_id` IS NULL\n\n#右中图：B-A∩B\nSELECT employee_id,last_name,department_name\nFROM employees e \nRIGHT JOIN departments d ON e.`department_id` = d.`department_id`\nWHERE e.`department_id` IS NULL\n\n\n#左下图：满外连接\n# 左中图 + 右上图 A∪B\nSELECT employee_id,last_name,department_name\nFROM employees e \nLEFT JOIN departments d ON e.`department_id` = d.`department_id`\nWHERE d.`department_id` IS NULL\nUNION ALL #没有去重操作，效率高\nSELECT employee_id,last_name,department_name\nFROM employees e \nRIGHT JOIN departments d ON e.`department_id` = d.`department_id`;\n\n\n#右下图\n#左中图 + 右中图 A ∪B- A∩B 或者 (A - A∩B) ∪ （B - A∩B）\nSELECT employee_id,last_name,department_name\nFROM employees e \nLEFT JOIN departments d ON e.`department_id` = d.`department_id`\nWHERE d.`department_id` IS NULL\nUNION ALL\nSELECT employee_id,last_name,department_name\nFROM employees e \nRIGHT JOIN departments d ON e.`department_id` = d.`department_id`\nWHERE e.`department_id` IS NULL\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 5.2 语法格式小结\n\n * 左中图\n   \n   #实现A - A∩B\n   select 字段列表\n   from A表 \n   left join B表 on 关联条件\n   where 从表关联字段 is null and 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 右中图\n   \n   #实现B - A∩B\n   select 字段列表\n   from A表 \n   right join B表on 关联条件\n   where 从表关联字段 is null and 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 左下图\n   \n   #实现查询结果是A∪B\n   #用左外的A，union 右外的B\n   select 字段列表\n   from A表 \n   left join B表 on 关联条件\n   where 等其他子句\n   union\n   select 字段列表\n   from A表 \n   right join B表 on 关联条件\n   where 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * 右下图\n   \n   #实现A∪B - A∩B 或 (A - A∩B) ∪ （B - A∩B）\n   #使用左外的 (A - A∩B) union 右外的（B - A∩B）\n   select 字段列表\n   from A表 \n   left join B表 on 关联条件\n   where 从表关联字段 is null and 等其他子句\n   union\n   select 字段列表\n   from A表 \n   right join B表 on 关联条件\n   where 从表关联字段 is null and 等其他子句\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n\n# 6. SQL99语法新特性\n\n\n# 6.1 自然连接\n\nSQL99 在 SQL92 的基础上提供了一些特殊语法，比如 NATURAL JOIN 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 所有相同的字段 ，然后进行等值连接 。\n\n在SQL92标准中：\n\nSELECT employee_id,last_name,department_name\nFROM employees e \nJOIN departments d ON e.`department_id` = d.`department_id` AND e.`manager_id` = d.`manager_id`;\n\n\n1\n2\n3\n\n\n在SQL99中你可以写成：\n\nSELECT employee_id,last_name,department_name\nFROM employees e \nNATURAL JOIN departments d;\n\n\n1\n2\n3\n\n\n\n# 6.2 USING连接\n\n当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配合JOIN一起使用。比如：\n\nSELECT employee_id,last_name,department_name\nFROM employees e \nJOIN departments d\nUSING (department_id);\n\n\n1\n2\n3\n4\n\n\n你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING的括号 () 中填入要指定的同名字段。同时使用JOIN...USING可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：\n\nSELECT employee_id,last_name,department_name\nFROM employees e ,departments d\nWHERE e.department_id = d.department_id;\n\n\n1\n2\n3\n\n\n\n# 7. 章节小结\n\n表连接的约束条件可以有三种方式：WHERE, ON, USING\n\n * WHERE：适用于所有关联查询\n\n * ON ：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。\n\n * USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等\n\n#关联条件\n#把关联条件写在where后面\nSELECT last_name,department_name\nFROM employees,departments\nWHERE employees.department_id = departments.department_id;\n\n#把关联条件写在on后面，只能和JOIN一起使用\nSELECT last_name,department_name\nFROM employees INNER JOIN departments\nON employees.department_id = departments.department_id;\n\nSELECT last_name,department_name\nFROM employees CROSS JOIN departments\nON employees.department_id = departments.department_id;\n\nSELECT last_name,department_name\nFROM employees JOIN departments\nON employees.department_id = departments.department_id;\n\n#把关联字段写在using()中，只能和JOIN一起使用\n#而且两个表中的关联字段必须名称相同，而且只能表示=\n#查询员工姓名与基本工资\nSELECT last_name,job_title\nFROM employees INNER JOIN jobs USING(job_id);\n\n#n张表关联，需要n-1个关联条件\n#查询员工姓名，基本工资，部门名称\nSELECT last_name,job_title,department_name FROM employees,departments,jobs\nWHERE employees.department_id = departments.department_id\nAND employees.job_id = jobs.job_id;\n\nSELECT last_name,job_title,department_name\nFROM employees INNER JOIN departments INNER JOIN jobs\nON employees.department_id = departments.department_id\nAND employees.job_id = jobs.job_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n注意：\n\n我们要控制连接表的数量 。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。\n\n> 【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。\n> \n> 说明：即使双表 join 也要注意表索引、SQL 性能。\n> \n> 来源：阿里巴巴《Java开发手册》\n\n\n# 附录：常用的SQL标准有哪些\n\n在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。\n\nSQL 有两个主要的标准，分别是 SQL92 和 SQL99 。92 和 99 代表了标准提出的时间，SQL92 就是 92 年提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、SQL:2011 和 SQL:2016 等其他的标准。\n\n这么多标准，到底该学习哪个呢？实际上最重要的 SQL 标准就是 SQL92 和 SQL99。一般来说 SQL92 的形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂，但可读性更强。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满足日常工作的需求即可。\n\nSQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 **标准。**也正是在这两个标准发布之后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言，还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使用。",normalizedContent:"# 多表查询\n\n\n# 1. 一个案例引发的多表连接\n\n\n# 1.1 案例\n\n\n\n从多个表中获取数据：\n\n\n\n#案例：查询员工的姓名及其部门名称\nselect last_name, department_name\nfrom employees, departments;\n\n\n1\n2\n3\n\n\n\n\n+-----------+----------------------+\n| last_name | department_name |\n+-----------+----------------------+\n| king | administration |\n| king | marketing |\n| king | purchasing |\n| king | human resources |\n| king | shipping |\n| king | it |\n| king | public relations |\n| king | sales |\n| king | executive |\n| king | finance |\n| king | accounting |\n| king | treasury |\n...\n| gietz | it support |\n| gietz | noc |\n| gietz | it helpdesk |\n| gietz | government sales |\n| gietz | retail sales |\n...\n| gietz | recruiting |\n| gietz | payroll |\n+-----------+----------------------+\n2889 rows in set (0.01 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n分析错误情况：\n\nselect count(employee_id) from employees;\n#输出107行\n\nselect count(department_id)from departments;\n#输出27行\n\nselect 107*27 from dual;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们把上述多表查询中出现的问题称为：笛卡尔积的错误。\n\n\n# 1.2 笛卡尔积（或交叉连接）的理解\n\n笛卡尔乘积是一个数学运算。假设我有两个集合 x 和 y，那么 x 和 y 的笛卡尔积就是 x 和 y 的所有可能组合，也就是第一个对象来自于 x，第二个对象来自于 y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。\n\nsql92中，笛卡尔积也称为交叉连接，英文是cross join。在 sql99 中也是使用 cross join表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在mysql中如下情况会出现笛卡尔积：\n\n#查询员工姓名和所在部门名称\nselect last_name,department_name from employees,departments;\nselect last_name,department_name from employees cross join departments;\nselect last_name,department_name from employees inner join departments;\nselect last_name,department_name from employees join departments;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1.3 案例分析与问题解决\n\n * 笛卡尔积的错误会在下面条件下产生：\n   \n   * 省略多个表的连接条件（或关联条件）\n   * 连接条件（或关联条件）无效\n   * 所有表中的所有行互相连接\n\n * 为了避免笛卡尔积， 可以在where加入有效的连接条件。\n\n * 加入连接条件后，查询语法：\n   \n   select table1.column, table2.column\n   from table1, table2\n   where table1.column1 = table2.column2; #连接条件\n   \n   \n   1\n   2\n   3\n   \n   * 在where子句中写入连接条件。\n\n * 正确写法：\n   \n   #案例：查询员工的姓名及其部门名称\n   select last_name, department_name\n   from employees, departments\n   where employees.department_id = departments.department_id;\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 在表中有相同列时，在列名之前加上表名前缀。\n\n\n# 2. 多表查询\n\n\n# 2.1 等值连接 vs 非等值连接\n\n# 等值连接\n\nselect employees.employee_id, employees.last_name,\n\t   employees.department_id, departments.department_id,\n\t   departments.location_id\nfrom employees, departments\nwhere employees.department_id = departments.department_id;\n\n\n1\n2\n3\n4\n5\n\n\n\n\n拓展1：多个连接条件与 and 操作符\n\n\n\n拓展2：区分重复的列名\n\n * 多个表中有相同列时，必须在列名之前加上表名前缀。\n\n * 在不同表中具有相同列名的列可以用 表名 加以区分。\n\nselect employees.last_name, departments.department_name,employees.department_id\nfrom employees, departments\nwhere employees.department_id = departments.department_id;\n\n\n1\n2\n3\n\n\n拓展3：表的别名\n\n * 使用别名可以简化查询。\n\n * 列名前使用表名前缀可以提高查询效率。\n\nselect e.employee_id, e.last_name, e.department_id,\n       d.department_id, d.location_id\nfrom employees e, departments d\nwhere e.department_id = d.department_id;\n\n\n1\n2\n3\n4\n\n\n> 需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。\n> \n> 阿里开发规范 ：\n> \n> 【 强制】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。\n> \n> 说明 ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。\n> \n> 正例 ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;\n> \n> 反例 ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出1052 异常：column 'name' in field list is ambiguous。\n\n拓展4：连接多个表\n\n\n\n总结：连接n个表,至少需要n-1个连接条件。比如，连接三个表，至少需要两个连接条件。\n\n练习：查询出公司员工的 last_name,department_name, city\n\nselect a.last_name, b.department_name, c.city\nfrom employees a, departments b, locations c\nwhere a.department_id = b.department_id and b.location_id = c.location_id\n\n\n1\n2\n3\n\n\n# 非等值连接\n\n\n\nselect e.last_name, e.salary, j.grade_level\nfrom employees e, job_grades j\nwhere e.salary between j.lowest_sal and j.highest_sal;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.2 自连接 vs 非自连接\n\n\n\n当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。\n\n题目：查询employees表，返回“xxx works for xxx”\n\nselect concat(worker.last_name ,' works for ', manager.last_name)\nfrom employees worker, employees manager\nwhere worker.manager_id = manager.employee_id ;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.3 内连接 vs 外连接\n\n除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。\n\n\n\n * 内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行\n\n * 外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(null)。\n\n * 如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。\n\n * 如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。\n\n# sql92：使用(+)创建连接\n\n * 在 sql92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。\n\n * oracle 对 sql92 支持较好，而 mysql 则不支持 sql92 的外连接。\n   \n   #左外连接\n   select last_name,department_name\n   from employees ,departments\n   where employees.department_id = departments.department_id(+);\n   #右外连接\n   select last_name,department_name\n   from employees ,departments\n   where employees.department_id(+) = departments.department_id;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 而且在 sql92 中，只有左外连接和右外连接，没有满（或全）外连接。\n\n\n# 3. sql99语法实现多表查询\n\n\n# 3.1 基本语法\n\n * 使用join...on子句创建连接的语法结构：\n   \n   select table1.column, table2.column,table3.column\n   from table1\n   join table2 on table1 和 table2 的连接条件\n   join table3 on table2 和 table3 的连接条件\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   它的嵌套逻辑类似我们使用的 for 循环：\n   \n   for t1 in table1:\n   \tfor t2 in table2:\n   \t\tif condition1:\n   \t\t\tfor t3 in table3:\n   \t\t\t\tif condition2:\n   \t\t\t\t\toutput t1 + t2 + t3\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   sql99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 sql92，可读性就会大打折扣。\n\n * 语法说明：\n   \n   * 可以使用on子句指定额外的连接条件。\n   * 这个连接条件是与其它条件分开的。\n   * on子句使语句具有更高的易读性。\n   * 关键字 join、inner join、cross join 的含义是一样的，都表示内连接\n\n\n# 3.2 内连接(inner join)的实现 😄\n\n# 语法\n\nselect 字段列表\nfrom a表 \ninner join b表 on 关联条件\nwhere 等其他子句;\n\n\n1\n2\n3\n4\n\n\n# 示例\n\n题目1：\n\nselect e.employee_id, e.last_name, e.department_id,d.department_id, d.location_id\nfrom employees e \njoin departments d on (e.department_id = d.department_id);\n\n\n1\n2\n3\n\n\n\n\n题目2：拓展4：连接多个表\n\nselect employee_id, city, department_name\nfrom employees e\njoin departments d on d.department_id = e.department_id\njoin locations l on d.location_id = l.location_id;\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 3.3 外连接(outer join)的实现\n\n# 左外连接(left outer join)\n\n * 语法：\n   \n   #实现查询结果是a\n   select 字段列表\n   from a表 \n   left join b表 on 关联条件\n   where 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 举例：\n   \n   select e.last_name, e.department_id, d.department_name\n   from employees e\n   left outer join departments d on (e.department_id = d.department_id);\n   \n   \n   1\n   2\n   3\n   \n   \n   \n\n# 右外连接(right outer join)\n\n * 语法：\n   \n   #实现查询结果是b\n   select 字段列表\n   from a表 \n   right join b表 on 关联条件\n   where 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 举例：\n   \n   select e.last_name, e.department_id, d.department_name\n   from employees e\n   right outer join departments d on (e.department_id = d.department_id);\n   \n   \n   1\n   2\n   3\n   \n   \n   \n\n> 需要注意的是，left join 和 right join 只存在于 sql99 及以后的标准中，在 sql92 中不存在，只能用 (+) 表示。\n\n# 满外连接(full outer join)\n\n * 满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。\n\n * sql99是支持满外连接的。使用full join 或 full outer join来实现。\n\n * 需要注意的是，mysql不支持full join，但是可以用 left join union right join代替。\n\n\n# 4. union的使用\n\n合并查询结果 利用union关键字，可以给出多条select语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个select语句之间使用union或union all关键字分隔。\n\n\n# 4.1 语法格式：\n\nselect column,... from table1\nunion [all]\nselect column,... from table2\n\n\n1\n2\n3\n\n\n\n# 4.2 union操作符\n\nunion 操作符返回两个查询的结果集的并集，去除重复记录。\n\n\n\n\n# 4.3 union all操作符\n\nunion all操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。\n\n\n\n> 注意：执行union all语句时所需要的资源比union语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用union all语句，以提高数据查询的效率。\n\n\n# 4.3 示例\n\n * 举例：查询部门编号>90或邮箱包含a的员工信息\n   \n   #方式1\n   select * from employees where email like '%a%' or department_id>90;\n   \n   #方式2\n   select * from employees where email like '%a%'\n   union\n   select * from employees where department_id>90;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息\n   \n   select id,cname from t_chinamale where csex='男'\n   union all\n   select id,tname from t_usmale where tgender='male';\n   \n   \n   1\n   2\n   3\n   \n\n\n# 5. 7种sql joins的实现 😄\n\n\n\n\n# 5.1 代码实现\n\n#中图：内连接 a∩b\nselect employee_id,last_name,department_name\nfrom employees e \njoin departments d on e.`department_id` = d.`department_id`;\n\n#左上图：左外连接\nselect employee_id,last_name,department_name\nfrom employees e \nleft join departments d on e.`department_id` = d.`department_id`;\n\n#右上图：右外连接\nselect employee_id,last_name,department_name\nfrom employees e \nright join departments d on e.`department_id` = d.`department_id`;\n\n#左中图：a - a∩b\nselect employee_id,last_name,department_name\nfrom employees e \nleft join departments d on e.`department_id` = d.`department_id`\nwhere d.`department_id` is null\n\n#右中图：b-a∩b\nselect employee_id,last_name,department_name\nfrom employees e \nright join departments d on e.`department_id` = d.`department_id`\nwhere e.`department_id` is null\n\n\n#左下图：满外连接\n# 左中图 + 右上图 a∪b\nselect employee_id,last_name,department_name\nfrom employees e \nleft join departments d on e.`department_id` = d.`department_id`\nwhere d.`department_id` is null\nunion all #没有去重操作，效率高\nselect employee_id,last_name,department_name\nfrom employees e \nright join departments d on e.`department_id` = d.`department_id`;\n\n\n#右下图\n#左中图 + 右中图 a ∪b- a∩b 或者 (a - a∩b) ∪ （b - a∩b）\nselect employee_id,last_name,department_name\nfrom employees e \nleft join departments d on e.`department_id` = d.`department_id`\nwhere d.`department_id` is null\nunion all\nselect employee_id,last_name,department_name\nfrom employees e \nright join departments d on e.`department_id` = d.`department_id`\nwhere e.`department_id` is null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 5.2 语法格式小结\n\n * 左中图\n   \n   #实现a - a∩b\n   select 字段列表\n   from a表 \n   left join b表 on 关联条件\n   where 从表关联字段 is null and 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 右中图\n   \n   #实现b - a∩b\n   select 字段列表\n   from a表 \n   right join b表on 关联条件\n   where 从表关联字段 is null and 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 左下图\n   \n   #实现查询结果是a∪b\n   #用左外的a，union 右外的b\n   select 字段列表\n   from a表 \n   left join b表 on 关联条件\n   where 等其他子句\n   union\n   select 字段列表\n   from a表 \n   right join b表 on 关联条件\n   where 等其他子句;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * 右下图\n   \n   #实现a∪b - a∩b 或 (a - a∩b) ∪ （b - a∩b）\n   #使用左外的 (a - a∩b) union 右外的（b - a∩b）\n   select 字段列表\n   from a表 \n   left join b表 on 关联条件\n   where 从表关联字段 is null and 等其他子句\n   union\n   select 字段列表\n   from a表 \n   right join b表 on 关联条件\n   where 从表关联字段 is null and 等其他子句\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n\n# 6. sql99语法新特性\n\n\n# 6.1 自然连接\n\nsql99 在 sql92 的基础上提供了一些特殊语法，比如 natural join 用来表示自然连接。我们可以把自然连接理解为 sql92 中的等值连接。它会帮你自动查询两张连接表中 所有相同的字段 ，然后进行等值连接 。\n\n在sql92标准中：\n\nselect employee_id,last_name,department_name\nfrom employees e \njoin departments d on e.`department_id` = d.`department_id` and e.`manager_id` = d.`manager_id`;\n\n\n1\n2\n3\n\n\n在sql99中你可以写成：\n\nselect employee_id,last_name,department_name\nfrom employees e \nnatural join departments d;\n\n\n1\n2\n3\n\n\n\n# 6.2 using连接\n\n当我们进行连接的时候，sql99还支持使用 using 指定数据表里的 同名字段 进行等值连接。但是只能配合join一起使用。比如：\n\nselect employee_id,last_name,department_name\nfrom employees e \njoin departments d\nusing (department_id);\n\n\n1\n2\n3\n4\n\n\n你能看出与自然连接 natural join 不同的是，using 指定了具体的相同的字段名称，你需要在 using的括号 () 中填入要指定的同名字段。同时使用join...using可以简化 join on 的等值连接。它与下面的 sql 查询结果是相同的：\n\nselect employee_id,last_name,department_name\nfrom employees e ,departments d\nwhere e.department_id = d.department_id;\n\n\n1\n2\n3\n\n\n\n# 7. 章节小结\n\n表连接的约束条件可以有三种方式：where, on, using\n\n * where：适用于所有关联查询\n\n * on ：只能和join一起使用，只能写关联条件。虽然关联条件可以并到where中和其他条件一起写，但分开写可读性更好。\n\n * using：只能和join一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等\n\n#关联条件\n#把关联条件写在where后面\nselect last_name,department_name\nfrom employees,departments\nwhere employees.department_id = departments.department_id;\n\n#把关联条件写在on后面，只能和join一起使用\nselect last_name,department_name\nfrom employees inner join departments\non employees.department_id = departments.department_id;\n\nselect last_name,department_name\nfrom employees cross join departments\non employees.department_id = departments.department_id;\n\nselect last_name,department_name\nfrom employees join departments\non employees.department_id = departments.department_id;\n\n#把关联字段写在using()中，只能和join一起使用\n#而且两个表中的关联字段必须名称相同，而且只能表示=\n#查询员工姓名与基本工资\nselect last_name,job_title\nfrom employees inner join jobs using(job_id);\n\n#n张表关联，需要n-1个关联条件\n#查询员工姓名，基本工资，部门名称\nselect last_name,job_title,department_name from employees,departments,jobs\nwhere employees.department_id = departments.department_id\nand employees.job_id = jobs.job_id;\n\nselect last_name,job_title,department_name\nfrom employees inner join departments inner join jobs\non employees.department_id = departments.department_id\nand employees.job_id = jobs.job_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n注意：\n\n我们要控制连接表的数量 。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 sql 查询性能下降得很严重，因此不要连接不必要的表。在许多 dbms 中，也都会有最大连接表的限制。\n\n> 【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。\n> \n> 说明：即使双表 join 也要注意表索引、sql 性能。\n> \n> 来源：阿里巴巴《java开发手册》\n\n\n# 附录：常用的sql标准有哪些\n\n在正式开始讲连接表的种类时，我们首先需要知道 sql 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。\n\nsql 有两个主要的标准，分别是 sql92 和 sql99 。92 和 99 代表了标准提出的时间，sql92 就是 92 年提出的标准规范。当然除了 sql92 和 sql99 以外，还存在 sql-86、sql-89、sql:2003、sql:2008、sql:2011 和 sql:2016 等其他的标准。\n\n这么多标准，到底该学习哪个呢？实际上最重要的 sql 标准就是 sql92 和 sql99。一般来说 sql92 的形式更简单，但是写的 sql 语句会比较长，可读性较差。而 sql99 相比于 sql92 来说，语法更加复杂，但可读性更强。我们从这两个标准发布的页数也能看出，sql92 的标准有 500 页，而 sql99 标准超过了1000 页。实际上从 sql99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用windows、linux 和 office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满足日常工作的需求即可。\n\nsql92 和 sql99 是经典的 sql 标准，也分别叫做 sql-2 和 sql-3 **标准。**也正是在这两个标准发布之后，sql 影响力越来越大，甚至超越了数据库领域。现如今 sql 已经不仅仅是数据库领域的主流语言，还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 sql 语言的使用。",charsets:{cjk:!0},lastUpdated:"2023/03/10, 00:03:40",lastUpdatedTimestamp:167837782e4},{title:"单行",frontmatter:{title:"单行",date:"2023-03-10T06:53:16.000Z",permalink:"/pages/333675/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/04.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL%E5%9F%BA%E7%A1%80/07.MySQL%E5%9F%BA%E7%A1%80-%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0.html",relativePath:"01.语言/04.数据库/01.MySQL基础/07.MySQL基础-单行函数.md",key:"v-5fb0e4a0",path:"/pages/333675/",headers:[{level:2,title:"1. 函数的理解",slug:"_1-函数的理解",normalizedTitle:"1. 函数的理解",charIndex:11},{level:3,title:"1.1 什么是函数",slug:"_1-1-什么是函数",normalizedTitle:"1.1 什么是函数",charIndex:24},{level:3,title:"1.2 不同DBMS函数的差异",slug:"_1-2-不同dbms函数的差异",normalizedTitle:"1.2 不同dbms函数的差异",charIndex:273},{level:3,title:"1.3 MySQL的内置函数及分类",slug:"_1-3-mysql的内置函数及分类",normalizedTitle:"1.3 mysql的内置函数及分类",charIndex:520},{level:2,title:"2. 数值函数",slug:"_2-数值函数",normalizedTitle:"2. 数值函数",charIndex:836},{level:3,title:"2.1 基本函数",slug:"_2-1-基本函数",normalizedTitle:"2.1 基本函数",charIndex:848},{level:3,title:"2.2 角度与弧度互换函数",slug:"_2-2-角度与弧度互换函数",normalizedTitle:"2.2 角度与弧度互换函数",charIndex:1777},{level:3,title:"2.3 三角函数",slug:"_2-3-三角函数",normalizedTitle:"2.3 三角函数",charIndex:1979},{level:3,title:"2.4 指数与对数",slug:"_2-4-指数与对数",normalizedTitle:"2.4 指数与对数",charIndex:2669},{level:3,title:"2.5 进制间的转换",slug:"_2-5-进制间的转换",normalizedTitle:"2.5 进制间的转换",charIndex:3038},{level:2,title:"3. 字符串函数",slug:"_3-字符串函数",normalizedTitle:"3. 字符串函数",charIndex:3248}],headersStr:"1. 函数的理解 1.1 什么是函数 1.2 不同DBMS函数的差异 1.3 MySQL的内置函数及分类 2. 数值函数 2.1 基本函数 2.2 角度与弧度互换函数 2.3 三角函数 2.4 指数与对数 2.5 进制间的转换 3. 字符串函数",content:"# 单行函数\n\n\n# 1. 函数的理解\n\n\n# 1.1 什么是函数\n\n函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既 提高了代码效率，又提高了可维护性 。在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地提高用户对数据库的管理效率。\n\n\n\n从函数定义的角度出发，我们可以将函数分成内置函数和自定义函数。在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的。\n\n\n# 1.2 不同DBMS函数的差异\n\n我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即DBMS。DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异。实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为concat()。大部分 DBMS 会有自己特定的函数，这就意味着采用SQL函数的代码可移植性是很差的，因此在使用函数的时候需要特别注意。\n\n\n# 1.3 MySQL的内置函数及分类\n\nMySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。\n\nMySQL提供的内置函数从实现的功能角度可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类： 单行函数 、 聚合函数（或分组函数） 。\n\n两种SQL函数\n\n\n\n单行函数\n\n * 操作数据对象\n\n * 接受参数返回一个结果\n\n * 只对一行进行变换\n\n * 每行返回一个结果\n\n * 可以嵌套\n\n * 参数可以是一列或一个值\n\n\n# 2. 数值函数\n\n\n# 2.1 基本函数\n\n函数                    用法\nABS(x)                返回x的绝对值\nSIGN(X)               返回X的符号。正数返回1，负数返回-1，0返回0\nPI()                  返回圆周率的值\nCEIL(x)，CEILING(x)    返回大于或等于某个值的最小整数\nFLOOR(x)              返回小于或等于某个值的最大整数\nLEAST(e1,e2,e3…)      返回列表中的最小值\nGREATEST(e1,e2,e3…)   返回列表中的最大值\nMOD(x,y)              返回X除以Y后的余数\nRAND()                返回0~1的随机值\nRAND(x)               返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数\nROUND(x)              返回一个对x的值进行四舍五入后，最接近于X的整数\nROUND(x,y)            返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位\nTRUNCATE(x,y)         返回数字x截断为y位小数的结果\nSQRT(x)               返回x的平方根。当X的值为负数时，返回NULL\n\n举例：\n\nSELECT\nABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32),FLOOR(-43.23),MOD(12,5)\nFROM DUAL;\n\n\n1\n2\n3\n\n\n\n\nSELECT RAND(),RAND(),RAND(10),RAND(10),RAND(-1),RAND(-1)\nFROM DUAL;\n\n\n1\n2\n\n\n\n\nSELECT\nROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1)\nFROM DUAL;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.2 角度与弧度互换函数\n\n函数           用法\nRADIANS(x)   将角度转化为弧度，其中，参数x为角度值\nDEGREES(x)   将弧度转化为角度，其中，参数x为弧度值\n\nSELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90))\nFROM DUAL;\n\n\n1\n2\n\n\n\n\n\n# 2.3 三角函数\n\n函数           用法\nSIN(x)       返回x的正弦值，其中，参数x为弧度值\nASIN(x)      返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL\nCOS(x)       返回x的余弦值，其中，参数x为弧度值\nACOS(x)      返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL\nTAN(x)       返回x的正切值，其中，参数x为弧度值\nATAN(x)      返回x的反正切值，即返回正切值为x的值\nATAN2(m,n)   返回两个参数的反正切值\nCOT(x)       返回x的余切值，其中，X为弧度值\n\n举例：\n\nATAN2(M,N)函数返回两个参数的反正切值。 与ATAN(X)函数相比，ATAN2(M,N)需要两个参数，例如有两个点point(x1,y1)和point(x2,y2)，使用ATAN(X)函数计算反正切值为ATAN((y2-y1)/(x2-x1))，使用ATAN2(M,N)计算反正切值则为ATAN2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，ATAN(X)函数会报错，而ATAN2(M,N)函数则仍然可以计算。\n\nATAN2(M,N)函数的使用示例如下：\n\nSELECT\nSIN(RADIANS(30)),DEGREES(ASIN(1)),TAN(RADIANS(45)),DEGREES(ATAN(1)),DEGREES(ATAN2(1,1))\nFROM DUAL;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.4 指数与对数\n\n函数                    用法\nPOW(x,y)，POWER(X,Y)   返回x的y次方\nEXP(X)                返回e的X次方，其中e是一个常数，2.718281828459045\nLN(X)，LOG(X)          返回以e为底的X的对数，当X <= 0 时，返回的结果为NULL\nLOG10(X)              返回以10为底的X的对数，当X <= 0 时，返回的结果为NULL\nLOG2(X)               返回以2为底的X的对数，当X <= 0 时，返回NULL\n\nSELECT POW(2,5),POWER(2,4),EXP(2),LN(10),LOG10(10),LOG2(4)\nFROM DUAL;\n\n\n1\n2\n\n\n\n\n\n# 2.5 进制间的转换\n\n函数              用法\nBIN(x)          返回x的二进制编码\nHEX(x)          返回x的十六进制编码\nOCT(x)          返回x的八进制编码\nCONV(x,f1,f2)   返回f1进制数变成f2进制数\n\nSELECT BIN(10),HEX(10),OCT(10),CONV(10,2,8)\nFROM DUAL;\n\n\n1\n2\n\n\n\n\n\n# 3. 字符串函数\n\n函数                                 用法\nASCII(S)                           返回字符串S中的第一个字符的ASCII码值\nCHAR_LENGTH(s)                     返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同\nLENGTH(s)                          返回字符串s的字节数，和字符集有关\nCONCAT(s1,s2,......,sn)            连接s1,s2,......,sn为一个字符串\nCONCAT_WS(x,s1,s2,......,sn)       同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x\nINSERT(str, idx, len,replacestr)   将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr\nREPLACE(str, a, b)                 用字符串b替换字符串str中所有出现的字符串a\nUPPER(s) 或 UCASE(s)                将字符串s的所有字母转成大写字母\nLOWER(s) 或LCASE(s)                 将字符串s的所有字母转成小写字母\nLEFT(str,n)                        返回字符串str最左边的n个字符\nRIGHT(str,n)                       返回字符串str最右边的n个字符\nLPAD(str, len, pad)                用字符串pad对str最左边进行填充，直到str的长度为len个字符\nRPAD(str ,len, pad)                用字符串pad对str最右边进行填充，直到str的长度为len个字符\nLTRIM(s)                           去掉字符串s左侧的空格\nRTRIM(s)                           去掉字符串s右侧的空格\nTRIM(s)                            去掉字符串s开始与结尾的空格\nTRIM(s1 FROM s)                    去掉字符串s开始与结尾的s1\nTRIM(LEADING s1 FROM s)            去掉字符串s开始处的s1\nTRIM(TRAILING s1 FROM s)           去掉字符串s结尾处的s1\nREPEAT(str, n)                     返回str重复n次的结果\nSPACE(n)                           返回n个空格\nSTRCMP(s1,s2)                      比较字符串s1,s2的ASCII码值的大小\nSUBSTR(s,index,len)                返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同\nLOCATE(substr,str)                 返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN\n                                   str)、INSTR(str,substr)相同。未找到，返回0\nELT(m,s1,s2,…,sn)                  返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn\nFIELD(s,s1,s2,…,sn)                返回字符串s在字符串列表中第一次出现的位置\nFIND_IN_SET(s1,s2)                 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串\nREVERSE(s)                         返回s反转后的字符串\nNULLIF(value1,value2)              比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1\n\n> 注意：MySQL中，字符串的位置是从1开始的。\n> \n> 参考：\n> \n> Mysql中concat()、concat_ws()和 group_concat()的用法 - 南方的墙 - 博客园 (cnblogs.com)",normalizedContent:"# 单行函数\n\n\n# 1. 函数的理解\n\n\n# 1.1 什么是函数\n\n函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既 提高了代码效率，又提高了可维护性 。在 sql 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地提高用户对数据库的管理效率。\n\n\n\n从函数定义的角度出发，我们可以将函数分成内置函数和自定义函数。在 sql 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的。\n\n\n# 1.2 不同dbms函数的差异\n\n我们在使用 sql 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即dbms。dbms 之间的差异性很大，远大于同一个语言不同版本之间的差异。实际上，只有很少的函数是被 dbms 同时支持的。比如，大多数 dbms 使用（||）或者（+）来做拼接符，而在 mysql 中的字符串拼接函数为concat()。大部分 dbms 会有自己特定的函数，这就意味着采用sql函数的代码可移植性是很差的，因此在使用函数的时候需要特别注意。\n\n\n# 1.3 mysql的内置函数及分类\n\nmysql提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。\n\nmysql提供的内置函数从实现的功能角度可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取mysql信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类： 单行函数 、 聚合函数（或分组函数） 。\n\n两种sql函数\n\n\n\n单行函数\n\n * 操作数据对象\n\n * 接受参数返回一个结果\n\n * 只对一行进行变换\n\n * 每行返回一个结果\n\n * 可以嵌套\n\n * 参数可以是一列或一个值\n\n\n# 2. 数值函数\n\n\n# 2.1 基本函数\n\n函数                    用法\nabs(x)                返回x的绝对值\nsign(x)               返回x的符号。正数返回1，负数返回-1，0返回0\npi()                  返回圆周率的值\nceil(x)，ceiling(x)    返回大于或等于某个值的最小整数\nfloor(x)              返回小于或等于某个值的最大整数\nleast(e1,e2,e3…)      返回列表中的最小值\ngreatest(e1,e2,e3…)   返回列表中的最大值\nmod(x,y)              返回x除以y后的余数\nrand()                返回0~1的随机值\nrand(x)               返回0~1的随机值，其中x的值用作种子值，相同的x值会产生相同的随机数\nround(x)              返回一个对x的值进行四舍五入后，最接近于x的整数\nround(x,y)            返回一个对x的值进行四舍五入后最接近x的值，并保留到小数点后面y位\ntruncate(x,y)         返回数字x截断为y位小数的结果\nsqrt(x)               返回x的平方根。当x的值为负数时，返回null\n\n举例：\n\nselect\nabs(-123),abs(32),sign(-23),sign(43),pi(),ceil(32.32),ceiling(-43.23),floor(32.32),floor(-43.23),mod(12,5)\nfrom dual;\n\n\n1\n2\n3\n\n\n\n\nselect rand(),rand(),rand(10),rand(10),rand(-1),rand(-1)\nfrom dual;\n\n\n1\n2\n\n\n\n\nselect\nround(12.33),round(12.343,2),round(12.324,-1),truncate(12.66,1),truncate(12.66,-1)\nfrom dual;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.2 角度与弧度互换函数\n\n函数           用法\nradians(x)   将角度转化为弧度，其中，参数x为角度值\ndegrees(x)   将弧度转化为角度，其中，参数x为弧度值\n\nselect radians(30),radians(60),radians(90),degrees(2*pi()),degrees(radians(90))\nfrom dual;\n\n\n1\n2\n\n\n\n\n\n# 2.3 三角函数\n\n函数           用法\nsin(x)       返回x的正弦值，其中，参数x为弧度值\nasin(x)      返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回null\ncos(x)       返回x的余弦值，其中，参数x为弧度值\nacos(x)      返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回null\ntan(x)       返回x的正切值，其中，参数x为弧度值\natan(x)      返回x的反正切值，即返回正切值为x的值\natan2(m,n)   返回两个参数的反正切值\ncot(x)       返回x的余切值，其中，x为弧度值\n\n举例：\n\natan2(m,n)函数返回两个参数的反正切值。 与atan(x)函数相比，atan2(m,n)需要两个参数，例如有两个点point(x1,y1)和point(x2,y2)，使用atan(x)函数计算反正切值为atan((y2-y1)/(x2-x1))，使用atan2(m,n)计算反正切值则为atan2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，atan(x)函数会报错，而atan2(m,n)函数则仍然可以计算。\n\natan2(m,n)函数的使用示例如下：\n\nselect\nsin(radians(30)),degrees(asin(1)),tan(radians(45)),degrees(atan(1)),degrees(atan2(1,1))\nfrom dual;\n\n\n1\n2\n3\n\n\n\n\n\n# 2.4 指数与对数\n\n函数                    用法\npow(x,y)，power(x,y)   返回x的y次方\nexp(x)                返回e的x次方，其中e是一个常数，2.718281828459045\nln(x)，log(x)          返回以e为底的x的对数，当x <= 0 时，返回的结果为null\nlog10(x)              返回以10为底的x的对数，当x <= 0 时，返回的结果为null\nlog2(x)               返回以2为底的x的对数，当x <= 0 时，返回null\n\nselect pow(2,5),power(2,4),exp(2),ln(10),log10(10),log2(4)\nfrom dual;\n\n\n1\n2\n\n\n\n\n\n# 2.5 进制间的转换\n\n函数              用法\nbin(x)          返回x的二进制编码\nhex(x)          返回x的十六进制编码\noct(x)          返回x的八进制编码\nconv(x,f1,f2)   返回f1进制数变成f2进制数\n\nselect bin(10),hex(10),oct(10),conv(10,2,8)\nfrom dual;\n\n\n1\n2\n\n\n\n\n\n# 3. 字符串函数\n\n函数                                 用法\nascii(s)                           返回字符串s中的第一个字符的ascii码值\nchar_length(s)                     返回字符串s的字符数。作用与character_length(s)相同\nlength(s)                          返回字符串s的字节数，和字符集有关\nconcat(s1,s2,......,sn)            连接s1,s2,......,sn为一个字符串\nconcat_ws(x,s1,s2,......,sn)       同concat(s1,s2,...)函数，但是每个字符串之间要加上x\ninsert(str, idx, len,replacestr)   将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr\nreplace(str, a, b)                 用字符串b替换字符串str中所有出现的字符串a\nupper(s) 或 ucase(s)                将字符串s的所有字母转成大写字母\nlower(s) 或lcase(s)                 将字符串s的所有字母转成小写字母\nleft(str,n)                        返回字符串str最左边的n个字符\nright(str,n)                       返回字符串str最右边的n个字符\nlpad(str, len, pad)                用字符串pad对str最左边进行填充，直到str的长度为len个字符\nrpad(str ,len, pad)                用字符串pad对str最右边进行填充，直到str的长度为len个字符\nltrim(s)                           去掉字符串s左侧的空格\nrtrim(s)                           去掉字符串s右侧的空格\ntrim(s)                            去掉字符串s开始与结尾的空格\ntrim(s1 from s)                    去掉字符串s开始与结尾的s1\ntrim(leading s1 from s)            去掉字符串s开始处的s1\ntrim(trailing s1 from s)           去掉字符串s结尾处的s1\nrepeat(str, n)                     返回str重复n次的结果\nspace(n)                           返回n个空格\nstrcmp(s1,s2)                      比较字符串s1,s2的ascii码值的大小\nsubstr(s,index,len)                返回从字符串s的index位置其len个字符，作用与substring(s,n,len)、mid(s,n,len)相同\nlocate(substr,str)                 返回字符串substr在字符串str中首次出现的位置，作用于position(substr in\n                                   str)、instr(str,substr)相同。未找到，返回0\nelt(m,s1,s2,…,sn)                  返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn\nfield(s,s1,s2,…,sn)                返回字符串s在字符串列表中第一次出现的位置\nfind_in_set(s1,s2)                 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串\nreverse(s)                         返回s反转后的字符串\nnullif(value1,value2)              比较两个字符串，如果value1与value2相等，则返回null，否则返回value1\n\n> 注意：mysql中，字符串的位置是从1开始的。\n> \n> 参考：\n> \n> mysql中concat()、concat_ws()和 group_concat()的用法 - 南方的墙 - 博客园 (cnblogs.com)",charsets:{cjk:!0},lastUpdated:"2023/03/10, 07:35:07",lastUpdatedTimestamp:1678404907e3},{title:"数据结构",frontmatter:{title:"数据结构",date:"2023-02-27T11:06:47.000Z",permalink:"/pages/febdf1/"},regularPath:"/02.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"02.编程基础/01.数据结构和算法/01.数据结构/01.数据结构.md",key:"v-322162e0",path:"/pages/febdf1/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"时序数据库-influxdb",frontmatter:{title:"时序数据库-influxdb",date:"2023-02-27T11:48:17.000Z",permalink:"/pages/ff9a50/"},regularPath:"/01.%E8%AF%AD%E8%A8%80/04.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Influxdb/21.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93-influxdb.html",relativePath:"01.语言/04.数据库/03.Influxdb/21.时序数据库-influxdb.md",key:"v-6aaaa430",path:"/pages/ff9a50/",headers:[{level:2,title:"1. Influxdb1.x 快速入门",slug:"_1-influxdb1-x-快速入门",normalizedTitle:"1. influxdb1.x 快速入门",charIndex:21},{level:3,title:"1. InfluxDB1.x Docker安装",slug:"_1-influxdb1-x-docker安装",normalizedTitle:"1. influxdb1.x docker安装",charIndex:45},{level:4,title:"1. 安装",slug:"_1-安装",normalizedTitle:"1. 安装",charIndex:111},{level:4,title:"2. 查看",slug:"_2-查看",normalizedTitle:"2. 查看",charIndex:222},{level:4,title:"3. 进入容器",slug:"_3-进入容器",normalizedTitle:"3. 进入容器",charIndex:252},{level:4,title:"4. 直接输入influx启动",slug:"_4-直接输入influx启动",normalizedTitle:"4. 直接输入influx启动",charIndex:356},{level:4,title:"5. 修改账户信息",slug:"_5-修改账户信息",normalizedTitle:"5. 修改账户信息",charIndex:423},{level:4,title:"6. 在配置文件启用认证",slug:"_6-在配置文件启用认证",normalizedTitle:"6. 在配置文件启用认证",charIndex:876},{level:2,title:"2. Influxdb2.x 快速入门",slug:"_2-influxdb2-x-快速入门",normalizedTitle:"2. influxdb2.x 快速入门",charIndex:1126},{level:3,title:"1. influxdb2.x介绍",slug:"_1-influxdb2-x介绍",normalizedTitle:"1. influxdb2.x介绍",charIndex:1150},{level:4,title:"1. 介绍",slug:"_1-介绍",normalizedTitle:"1. 介绍",charIndex:1235},{level:4,title:"2. InfluxDB有三大特性：",slug:"_2-influxdb有三大特性",normalizedTitle:"2. influxdb有三大特性：",charIndex:1858},{level:4,title:"3. 特点",slug:"_3-特点",normalizedTitle:"3. 特点",charIndex:1986},{level:4,title:"4. 核心概念",slug:"_4-核心概念",normalizedTitle:"4. 核心概念",charIndex:2392},{level:3,title:"2. 安装",slug:"_2-安装",normalizedTitle:"2. 安装",charIndex:3777},{level:4,title:"1. 官网:",slug:"_1-官网",normalizedTitle:"1. 官网:",charIndex:3786},{level:4,title:"2. 文档2.3：",slug:"_2-文档2-3",normalizedTitle:"2. 文档2.3：",charIndex:3827},{level:4,title:"3. 下载地址:",slug:"_3-下载地址",normalizedTitle:"3. 下载地址:",charIndex:3884},{level:5,title:"1. centos",slug:"_1-centos",normalizedTitle:"1. centos",charIndex:4328},{level:5,title:"2. ubuntu",slug:"_2-ubuntu",normalizedTitle:"2. ubuntu",charIndex:4763},{level:5,title:"3. docker",slug:"_3-docker",normalizedTitle:"3. docker",charIndex:4918},{level:5,title:"配置文件目录：",slug:"配置文件目录",normalizedTitle:"配置文件目录：",charIndex:5785},{level:5,title:"默认配置如下",slug:"默认配置如下",normalizedTitle:"默认配置如下",charIndex:5831},{level:4,title:"3. 启动 InfluxDB",slug:"_3-启动-influxdb",normalizedTitle:"3. 启动 influxdb",charIndex:5865},{level:4,title:"4. 验证",slug:"_4-验证",normalizedTitle:"4. 验证",charIndex:6208},{level:5,title:"1. 访问",slug:"_1-访问",normalizedTitle:"1. 访问",charIndex:6217},{level:5,title:"2. 初始化用户设置",slug:"_2-初始化用户设置",normalizedTitle:"2. 初始化用户设置",charIndex:6289},{level:5,title:"3. 首页",slug:"_3-首页",normalizedTitle:"3. 首页",charIndex:6435},{level:5,title:"4. 关于about",slug:"_4-关于about",normalizedTitle:"4. 关于about",charIndex:6446},{level:5,title:"5. token令牌",slug:"_5-token令牌",normalizedTitle:"5. token令牌",charIndex:6462},{level:5,title:"6. 初始化创建的Bucket",slug:"_6-初始化创建的bucket",normalizedTitle:"6. 初始化创建的bucket",charIndex:6480},{level:5,title:"7. 设置Bucket的保存策略",slug:"_7-设置bucket的保存策略",normalizedTitle:"7. 设置bucket的保存策略",charIndex:6501},{level:4,title:"5. 安装Windows CLI",slug:"_5-安装windows-cli",normalizedTitle:"5. 安装windows cli",charIndex:6523},{level:5,title:"1. 下载地址",slug:"_1-下载地址",normalizedTitle:"1. 下载地址",charIndex:6650},{level:5,title:"2. 解压",slug:"_2-解压",normalizedTitle:"2. 解压",charIndex:6728},{level:5,title:"3. 授予对influxCLI 的网络访问权限。",slug:"_3-授予对influxcli-的网络访问权限。",normalizedTitle:"3. 授予对influxcli 的网络访问权限。",charIndex:6761},{level:3,title:"3. influxdb2.2与springboot集成",slug:"_3-influxdb2-2与springboot集成",normalizedTitle:"3. influxdb2.2与springboot集成",charIndex:7283},{level:4,title:"1. 依赖",slug:"_1-依赖",normalizedTitle:"1. 依赖",charIndex:7433},{level:4,title:"2. yml配置文件",slug:"_2-yml配置文件",normalizedTitle:"2. yml配置文件",charIndex:8008},{level:4,title:"3. Influx实例化类",slug:"_3-influx实例化类",normalizedTitle:"3. influx实例化类",charIndex:8219},{level:4,title:"4、Influx配置类: 启动Spring工程时实例化InfluxBean",slug:"_4、influx配置类-启动spring工程时实例化influxbean",normalizedTitle:"4、influx配置类: 启动spring工程时实例化influxbean",charIndex:9600},{level:5,title:"1. 配置类",slug:"_1-配置类",normalizedTitle:"1. 配置类",charIndex:9641},{level:5,title:"2. 配置类（写法二）",slug:"_2-配置类-写法二",normalizedTitle:"2. 配置类（写法二）",charIndex:10207},{level:4,title:"5. 数据库桶(表)实体类",slug:"_5-数据库桶-表-实体类",normalizedTitle:"5. 数据库桶(表)实体类",charIndex:10879},{level:4,title:"6. 实现类",slug:"_6-实现类",normalizedTitle:"6. 实现类",charIndex:11230},{level:4,title:"7. 接口",slug:"_7-接口",normalizedTitle:"7. 接口",charIndex:14355},{level:4,title:"8. 使用 aplfox 测试",slug:"_8-使用-aplfox-测试",normalizedTitle:"8. 使用 aplfox 测试",charIndex:14971},{level:4,title:"1. 新增",slug:"_1-新增",normalizedTitle:"1. 新增",charIndex:14990},{level:4,title:"2. 查询",slug:"_2-查询",normalizedTitle:"2. 查询",charIndex:15001},{level:3,title:"4. Influxdb文档",slug:"_4-influxdb文档",normalizedTitle:"4. influxdb文档",charIndex:15013}],headersStr:"1. Influxdb1.x 快速入门 1. InfluxDB1.x Docker安装 1. 安装 2. 查看 3. 进入容器 4. 直接输入influx启动 5. 修改账户信息 6. 在配置文件启用认证 2. Influxdb2.x 快速入门 1. influxdb2.x介绍 1. 介绍 2. InfluxDB有三大特性： 3. 特点 4. 核心概念 2. 安装 1. 官网: 2. 文档2.3： 3. 下载地址: 1. centos 2. ubuntu 3. docker 配置文件目录： 默认配置如下 3. 启动 InfluxDB 4. 验证 1. 访问 2. 初始化用户设置 3. 首页 4. 关于about 5. token令牌 6. 初始化创建的Bucket 7. 设置Bucket的保存策略 5. 安装Windows CLI 1. 下载地址 2. 解压 3. 授予对influxCLI 的网络访问权限。 3. influxdb2.2与springboot集成 1. 依赖 2. yml配置文件 3. Influx实例化类 4、Influx配置类: 启动Spring工程时实例化InfluxBean 1. 配置类 2. 配置类（写法二） 5. 数据库桶(表)实体类 6. 实现类 7. 接口 8. 使用 aplfox 测试 1. 新增 2. 查询 4. Influxdb文档",content:'# 时序数据库-influxdb\n\n\n# 1. Influxdb1.x 快速入门\n\n\n# 1. InfluxDB1.x Docker安装\n\n> docker安装InfluxDB1.x （influxdb1.8.4）\n\n# 1. 安装\n\ndocker run -d  --name influxdb -p 8087:8086 influxdb:1.8.4 \n\n\n1\n\n\n> 注意：这里端口使用8087。（端口8086安装2.x版本已使用）\n\n# 2. 查看\n\ndocker ps -a\n\n\n1\n\n\n\n\n# 3. 进入容器\n\ndocker exec -it 容器名称/容器ID bin/bash\n\n-- 如：容器名称\ndocker exec -it influxdb /bin/bash\n\n\n1\n2\n3\n4\n\n\n# 4. 直接输入influx启动\n\n# 启动influxdb\ninflux \n\n# 退出\nexit\n\n\n1\n2\n3\n4\n5\n\n\n\n\n# 5. 修改账户信息\n\n> 【需进入influxdb中操作】\n\n# 显示用户\nSHOW USERS\n\n# 创建用户\nCREATE USER "username" WITH PASSWORD \'password\'\n\n# 赋予用户管理员权限\nGRANT ALL PRIVILEGES TO username\n\n# 创建管理员权限的用户\nCREATE USER <username> WITH PASSWORD \'<password>\' WITH ALL PRIVILEGES\n\n# 修改用户密码\nSET PASSWORD FOR username = \'password\'\n\n# 撤消权限\nREVOKE ALL ON mydb FROM username\n\n# 查看权限\nSHOW GRANTS FOR username\n\n# 删除用户\nDROP USER "username"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 6. 在配置文件启用认证\n\n默认情况下，influxdb的配置文件是禁用认证策略的，所以需要修改设置一下。 编辑配置文件vim /etc/influxdb/influxdb.conf，把 [http] 下的 auth-enabled 选项设置为 true\n\n# 进入influxdb容器\ndocker exec -it influxdb /bin/bash\n\n# 编辑数据\nvim /etc/influxdb/influxdb.conf\n\n\n1\n2\n3\n4\n5\n\n\n未完待续。。。。。。。。\n\n\n# 2. Influxdb2.x 快速入门\n\n\n# 1. influxdb2.x介绍\n\nhttps://www.jianshu.com/p/268fca65f10e\n\n> 本文使用的是influxdb 2.2版本。\n\n# 1. 介绍\n\nInfluxDB是一个由InfluxData开发的开源时序型数据。它由Go写成，着力于高性能地查询与存储时序型数据。InfluxDB被广泛应用于存储系统的监控数据，IoT行业的实时数据等场景。\n\n> 2021年6月份，发布influxdb2.x，与前面版本结构有所差异\n\n * 1.x 版本使用 influxQL 查询语言，2.x 和 1.8+（beta） 使用 flux 查询语法；相比V1 移除了database 和 RP，增加了bucket。\n * V2具有以下几个概念： timestamp、field key、field value、field set、tag key、tag value、tag set、measurement、series、point、bucket、bucket schema、organization\n * 新增的概念：\n   1. bucket：所有 InfluxDB 数据都存储在一个存储桶中。一个桶结合了数据库的概念和存储周期（时间每个数据点仍然存在持续时间）。一个桶属于一个组织\n   2. bucket schema：具有明确的schema-type的存储桶需要为每个度量指定显式架构。测量包含标签、字段和时间戳。显式模式限制了可以写入该度量的数据的形状。\n   3. organization：InfluxDB组织是一组用户的工作区。所有仪表板、任务、存储桶和用户都属于一个组织。\n\n# 2. InfluxDB有三大特性：\n\n * Time Series （时间序列）：你可以使用与时间有关的相关函数（如最大，最小，求和等）\n * Metrics（度量）：你可以实时对大量数据进行计算\n * Eevents（事件）：它支持任意的事件数据\n\n# 3. 特点\n\n * 为时间序列数据专门编写的自定义高性能数据存储。 TSM引擎具有高性能的写入和数据压缩\n * Golang编写，没有其它的依赖\n * 提供简单、高性能的写入、查询 http api，Native HTTP API, 内置http支持，使用http读写\n * 插件支持其它数据写入协议，例如 graphite、collectd、OpenTSDB\n * 支持类sql查询语句\n * tags可以索引序列化，提供快速有效的查询\n * Retention policies自动处理过期数据\n * Continuous queries自动聚合，提高查询效率\n * schemaless(无结构)，可以是任意数量的列\n * Scalable可拓展\n * min, max, sum, count, mean,median 一系列函数，方便统计\n * Built-in Explorer 自带管理工具\n\n# 4. 核心概念\n\n示例数据（解释某些概念用）\n\n_TIME                  _MEASUREMENT   LOCATION   SCIENTIST   _FIELD   _VALUE\n2019-08-18T00:00:00Z   census         klamath    anderson    bees     23\n2019-08-18T00:00:00Z   census         portland   mullen      ants     30\n\n 1.  Organization organization 是一组用户的工作空间，一个组下用户可以创建多个bucket\n\n 2.  bucket 所有的 influxdb数据都存储在bucket中，bucket结合了数据库和保存期限（每条数据会被保留的时间）的概念，类似于RDMS的database的概念。bucket属于一个organization\n\n 3.  Measurement measurement是所有 tags fields 和时间的容器和RDMS的table的概念类似,是一个数据集的容器\n\n 4.  Fields 数据属性包括field key 和 field value 分别存储在 _field和 _value当中, 并且一个measurement中必须包含至少一个filed\n\n 5.  Field key field key 是一个代表属性名称的字段，在示例数据中bees和ants就是field key\n\n 6.  Field value field value 是对应 field key 的值,在示例数据中在2019-08-18T00:00:00Z该时间点 bees的值为23，而ants的值为30\n\n 7.  Field set field set 表示在同一时间内 所有fields的集合\n\n 8.  Tags 和Fields类似，Tags也有 key value。但与Fields不同的是，field key存储在_field列中 而tag key则是本省就是列\n\n 9.  tag key 和 tag value 即tag 的 key 和 value 在Line Protocl中有更为直观的体现\n\n 10. timestamp 所有存储在influxdb中的数据都有一个_time列用来记录时间，在磁盘中以纳秒之间戳存储，但客户端查询时返回的是格式化的更易读的 RFC3339 UTC时间格式\n\n>  1. 对于Fields 和 Tags 简单来说他们都是一组键值对的集合。在存储形式上，field 的key 被存储在一个名为_field的列中,而tag 的key则是以列头的形式存在的,该列的内容即为tag value。可以从示例数据中直观的看出其区别。\n>  2. 另外值得注意的是，field 和 tag 都可以用来存储数据，但tag只能存储字符串类型数据，而filed既可以存储字符串类型又可以存储数值类型数据。\n>  3. 那么我是否可以在tag中存储字符串形式的数据呢？ 当然可以但其不可以参与flux查询中的mean() max() 等聚合函数的计算。所以field 和 tag 还是有着本质上的区别的。\n\n\n# 2. 安装\n\n# 1. 官网:\n\nhttps://www.influxdata.com/\n\n\n\n# 2. 文档2.3：\n\nhttps://docs.influxdata.com/influxdb/v2.3/\n\n# 3. 下载地址:\n\n 1. 地址： https://www.influxdata.com/get-influxdb/\n\n 2. 下载页\n\n 3. 点击release-notes， 进入: https://docs.influxdata.com/influxdb/v2.3/install/?t=Linux\n\n\n\n\n\n> 此处有官方文档的详细安装说明（包含mac、linux、windows）。下面有自己安装过程的记录。\n\n 4. 安装服务端\n\n> influxdb2-2.2.0.x86_64.rpm\n\n参考：https://blog.csdn.net/l_15156024189/article/details/124726892\n\n 1. 下载安装包\n\n清华镜像： Index of /influxdata/yum/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n\n> 本文选择: influxdb2-2.2.0.x86_64.rpm\n\n# 1. centos\n\n# 官网\nwget https://dl.influxdata.com/influxdb/releases/influxdb2-2.2.0-amd64.rpm\n\n# 清华源\nwget https://mirrors.tuna.tsinghua.edu.cn/influxdata/yum/el7-x86_64/influxdb2-2.2.0.x86_64.rpm\n\n\n1\n2\n3\n4\n5\n\n\n\n\n> 注意：wget下载https出现：--no-check-certificate 使用 wget --no-check-certificate https://mirrors.tuna.tsinghua.edu.cn/influxdata/yum/el7-x86_64/influxdb2-2.2.0.x86_64.rpm\n\nsudo yum localinstall -y influxdb2-2.2.0.x86_64.rpm\n\n\n1\n\n\n\n\n# 2. ubuntu\n\n# Ubuntu/Debian\nwget https://dl.influxdata.com/influxdb/releases/influxdb2-2.2.0.x86_64.deb\nsudo dpkg -i influxdb2-2.2.0.x86_64.deb\n\n\n1\n2\n3\n\n\n# 3. docker\n\nInfluxDB 2.x 初始化凭证 自动 InfluxDB 升级过程引导InfluxDB 2.x 所需的初始管理员用户、 组织和 存储桶。在 Docker 容器中设置以下环境变量 以提供设置凭据：\n\n * DOCKER_INFLUXDB_INIT_USERNAME：为管理员用户设置的用户名（必需）。\n * DOCKER_INFLUXDB_INIT_PASSWORD：为管理员用户设置的密码（必需）。\n * DOCKER_INFLUXDB_INIT_ORG：为初始组织设置的名称（必需）。\n * DOCKER_INFLUXDB_INIT_BUCKET：为初始存储桶设置的名称（必需）。\n * DOCKER_INFLUXDB_INIT_RETENTION：初始存储桶保留期的持续时间。如果未设置，初始存储桶将永久保留数据。\n * DOCKER_INFLUXDB_INIT_ADMIN_TOKEN：与管理员用户关联的 API 令牌。如果没有设置，InfluxDB 会自动生成一个令牌。\n\n# 拉取镜像\ndoker pull influxdb:2.3\n\n# 安装\ndocker run -d -p 8086:8086 \\\n  -v influxdb:/var/lib/influxdb \\\n  -v influxdb2:/var/lib/influxdb2 \\\n  -e DOCKER_INFLUXDB_INIT_MODE=upgrade \\\n  -e DOCKER_INFLUXDB_INIT_USERNAME=my-user \\\n  -e DOCKER_INFLUXDB_INIT_PASSWORD=my-password \\\n  -e DOCKER_INFLUXDB_INIT_ORG=my-org \\\n  -e DOCKER_INFLUXDB_INIT_BUCKET=my-bucket \\\n  influxdb:2.3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. 配置\n\n# 配置文件目录：\n\n# 进入目录\ncd /etc/influxdb/\n\n\n1\n2\n\n\n\n\n# 默认配置如下\n\ncat config.toml\n\n\n1\n\n\n\n\n# 3. 启动 InfluxDB\n\n> 执行如下命令开机启动：\n\n# 开机自启：\nsystemctl enable influxdb\n\n# 启动：\nsystemctl start influxdb\n\n# 重启：\nsystemctl restart influxdb\n\n# 停止\nsystemctl stop influxdb\n\n# 查看状态\nsystemctl status influxdb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 启动方式\n\n# 第一种\nsystemctl start influxdb\n\n# 第二种\nservice influxdb start\n\n# 第三种\ninfluxdb run\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 4. 验证\n\n# 1. 访问\n\n访问：ip:8086 http://localhost:8086 http://192.168.47.129:8086\n\n\n\n# 2. 初始化用户设置\n\n\n\n> 初始化时用户名：influxdb，密码：influxdb\n\n从上到下为：账号（zhouhong）、密码(66668888)、确认密码(66668888)、组织(my_influxdb)、Buucket(Tom)；完了之后点击 Quick Start\n\n\n\n# 3. 首页\n\n\n\n# 4. 关于about\n\n\n\n# 5. token令牌\n\n\n\n\n\n# 6. 初始化创建的Bucket\n\n\n\n# 7. 设置Bucket的保存策略\n\n\n\n# 5. 安装Windows CLI\n\n文档地址：https://docs.influxdata.com/influxdb/v2.3/install/?t=Windows\n\n> influxdb2-client-2.3.0-windows-amd64\n\n# 1. 下载地址\n\n地址: https://docs.influxdata.com/influxdb/v2.3/tools/influx-cli/\n\n\n\n# 2. 解压\n\n * 解压后的目录\n\n\n\n * 文件内容\n\n\n\n# 3. 授予对influxCLI 的网络访问权限。\n\n 1. influx首次使用CLI 时， Windows Defender显示以下消息：\n\nWindows Defender 防火墙已阻止此应用程序的某些功能。\n要授予influxCLI 所需的访问权限，请执行以下操作：\n1. 选择专用网络，例如我的家庭或工作网络。\n2. 单击允许访问。\n\n\n1\n2\n3\n4\n\n 2. 为了后面执行influx命令不需要每次都连接和验证token，可以执行如下命令创建一个配置：\n\ninflux config create --config-name influxdb2.conf \\\n--host-url http://192.168.47.129:8086 \\\n--org chggx \\\n--token ExGUyaInMuPVpp6vZa9RuuyGBhcywlOzT_fYkYdwiLT5FSJdENA1-PQ-EKWp2RFdZNl8r6yDQcLR8KH0Hw8KuQ== \\\n--active\n\n\n1\n2\n3\n4\n5\n\n * --host-url: 服务端地址：http://192.168.47.129:8086\n * --org\n\n\n# 3. influxdb2.2与springboot集成\n\n参考： https://www.cnblogs.com/Tom-shushu/p/15830776.html https://blog.csdn.net/Calm_D/article/details/120646931[另外一种写法]\n\n# 1. 依赖\n\n <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>com.influxdb</groupId>\n    <artifactId>influxdb-client-java</artifactId>\n    <version>4.0.0</version>\n</dependency>\n<dependency>\n    <groupId>org.influxdb</groupId>\n    <artifactId>influxdb-java</artifactId>\n    <version>2.20</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 2. yml配置文件\n\ninflux:\n  influxUrl: \'http://192.168.47.129:8086\'\n  bucket: \'chggx\'\n  org: \'chggx\'\n  token: \'ExGUyaInMuPVpp6vZa9RuuyGBhcywlOzT_fYkYdwiLT5FSJdENA1-PQ-EKWp2RFdZNl8r6yDQcLR8KH0Hw8KuQ==\'\n\n\n1\n2\n3\n4\n5\n\n\n# 3. Influx实例化类\n\n@Setter\n@Getter\npublic class InfluxBean{\n    /**\n     * 数据库url地址\n     */\n    private String influxUrl;\n    /**\n     * 桶(表)\n     */\n    private String bucket;\n    /**\n     * 组织\n     */\n    private String org;\n    /**\n     * token\n     */\n    private String token;\n    /**\n     * 数据库连接\n     */\n    private InfluxDBClient client;\n    /**\n     * 构造方法\n     */\n    public InfluxBean(String influxUrl, String bucket, String org, String token) {\n        this.influxUrl = influxUrl;\n        this.bucket = bucket;\n        this.org = org;\n        this.token = token;\n        this.client = getClient();\n    }\n    /**\n     * 获取连接\n     */\n    private InfluxDBClient getClient() {\n        if (client == null) {\n            client  = InfluxDBClientFactory.create(influxUrl, token.toCharArray());\n        }\n        return client;\n    }\n    /**\n     * 写入数据(以秒为时间单位)\n     */\n    public void write(Object object){\n        try (WriteApi writeApi = client.getWriteApi()) {\n            writeApi.writeMeasurement(bucket, org, WritePrecision.NS, object);\n        }\n    }\n    /**\n     * 读取数据\n     */\n    public List<FluxTable> queryTable(String fluxQuery){\n        return client.getQueryApi().query(fluxQuery, org);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n# 4、Influx配置类: 启动Spring工程时实例化InfluxBean\n\n# 1. 配置类\n\n@Data\n@Configuration\n@ConfigurationProperties(prefix = "influx")\npublic class InfluxConfig {\n    /**\n     * url地址\n     */\n    private String influxUrl;\n    /**\n     * 桶(表)\n     */\n    private String bucket;\n    /**\n     * 组织\n     */\n    private String org;\n    /**\n     * token\n     */\n    private String token;\n    /**\n     * 初始化bean\n     */\n    @Bean(name = "influx")\n    public InfluxBean InfluxBean() {\n        return new InfluxBean(influxUrl, bucket, org, token);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 2. 配置类（写法二）\n\n@Configuration\npublic class InfluxConfig {\n    /**\n     * url地址\n     */\n    @Value("${spring.influx.url}")\n    private String influxUrl;\n    /**\n     * 桶(表)\n     */\n    @Value("${spring.influx.bucket}")\n    private String bucket;\n    /**\n     * 组织\n     */\n    @Value("${spring.influx.org}")\n    private String org;\n    /**\n     * token\n     */\n    @Value("${spring.influx.token}")\n    private String token;\n    /**\n     * 初始化bean\n     */\n    @Bean(name = "influx")\n    public InfluxBean InfluxBean() {\n        return new InfluxBean(influxUrl, bucket, org, token);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 5. 数据库桶(表)实体类\n\n@Measurement(name = "influxEntity")\n@Getter\n@Setter\npublic class InfluxEntity{\n    /**\n     * 值\n     */\n    @Column\n    Integer value;\n    /**\n     * 标签字段\n     */\n    @Column(tag = true)\n    String tag;\n    /**\n     * 时间\n     */\n    @Column(timestamp = true)\n    Instant time;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 6. 实现类\n\npackage com.chggx.influxdb2x.servie.impl;\n\nimport com.chggx.influxdb2x.config.InfluxBean;\nimport com.chggx.influxdb2x.model.param.InsertParams;\nimport com.chggx.influxdb2x.model.restlt.InfluxResult;\nimport com.chggx.influxdb2x.servie.InfluxService;\nimport com.influxdb.query.FluxTable;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.Resource;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Service\n@Slf4j\npublic class InfluxServiceImpl implements InfluxService {\n    @Resource\n    private InfluxBean influxBean;\n\n    @Override\n    public void insert(InsertParams insertParams) {\n        insertParams.setTime(Instant.now());\n        influxBean.write(insertParams);\n    }\n\n    @Override\n    public List<InfluxResult> queue(){\n        // 下面两个 private 方法 赋值给 list 查询对应的数据\n        List<FluxTable> list = queryInfluxAll();\n        List<InfluxResult> results = new ArrayList<>();\n        for (int i = 0; i < list.size(); i++) {\n            for (int j = 0; j < list.get(i).getRecords().size(); j++) {\n                InfluxResult influxResult = new InfluxResult();\n                influxResult.setCurrent(list.get(i).getRecords().get(j).getValues().get("current").toString());\n                influxResult.setEnergyUsed(list.get(i).getRecords().get(j).getValues().get("energyUsed").toString());\n                influxResult.setPower(list.get(i).getRecords().get(j).getValues().get("power").toString());\n                influxResult.setVoltage(list.get(i).getRecords().get(j).getValues().get("voltage").toString());\n                influxResult.setTime(list.get(i).getRecords().get(j).getValues().get("_time").toString());\n                System.err.println(list.get(i).getRecords().get(j).getValues().toString());\n                results.add(influxResult);\n            }\n        }\n        return results;\n    }\n\n    /**\n     * 查询一小时内的InsertParams所有数据\n     * @return\n     */\n    private List<FluxTable> queryInfluxAll(){\n        String query = " from(bucket: \\"chggx\\")" +\n                "  |> range(start: -60m, stop: now())" +\n                "  |> filter(fn: (r) => r[\\"_measurement\\"] == \\"influx_test\\")" +\n                "  |> pivot( rowKey:[\\"_time\\"], columnKey: [\\"_field\\"], valueColumn: \\"_value\\" )";\n        return influxBean.queryTable(query);\n    }\n\n    /**\n     * 根据某一个字段的值过滤(查询 用电量 energyUsed 为 322 的那条记录)\n     * @return\n     */\n    public List<FluxTable> queryFilterByEnergyUsed(){\n        String query = " from(bucket: \\"chggx\\")" +\n                "  |> range(start: -60m, stop: now())" +\n                "  |> filter(fn: (r) => r[\\"_measurement\\"] == \\"influx_test\\")" +\n                "  |> filter(fn: (r) => r[\\"energyUsed\\"] == \\"322\\")" +\n                "  |> pivot( rowKey:[\\"_time\\"], columnKey: [\\"_field\\"], valueColumn: \\"_value\\" )";\n        return influxBean.queryTable(query);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n# 7. 接口\n\n@RestController\npublic class InfluxDbController {\n\n    @Autowired\n    private InfluxService influxService;\n\n    /**\n      * 时许数据库插入测试\n      * @return\n      */\n    @PostMapping("/inlfuxdb/insert")\n    public ResponseData insert(@RequestBody InsertParams insertParams) {\n        influxService.insert(insertParams);\n        return new SuccessResponseData();\n    }\n\n\n    @PostMapping("/inlfuxdb/queue")\n    public ResponseData queue(@RequestBody InsertParams insertParams) {\n        return new SuccessResponseData(influxService.queue());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 8. 使用 aplfox 测试\n\n# 1. 新增\n\n\n\n# 2. 查询\n\n\n\n\n# 4. Influxdb文档\n\n> 2.3 官网：https://docs.influxdata.com/influxdb/v2.3/',normalizedContent:'# 时序数据库-influxdb\n\n\n# 1. influxdb1.x 快速入门\n\n\n# 1. influxdb1.x docker安装\n\n> docker安装influxdb1.x （influxdb1.8.4）\n\n# 1. 安装\n\ndocker run -d  --name influxdb -p 8087:8086 influxdb:1.8.4 \n\n\n1\n\n\n> 注意：这里端口使用8087。（端口8086安装2.x版本已使用）\n\n# 2. 查看\n\ndocker ps -a\n\n\n1\n\n\n\n\n# 3. 进入容器\n\ndocker exec -it 容器名称/容器id bin/bash\n\n-- 如：容器名称\ndocker exec -it influxdb /bin/bash\n\n\n1\n2\n3\n4\n\n\n# 4. 直接输入influx启动\n\n# 启动influxdb\ninflux \n\n# 退出\nexit\n\n\n1\n2\n3\n4\n5\n\n\n\n\n# 5. 修改账户信息\n\n> 【需进入influxdb中操作】\n\n# 显示用户\nshow users\n\n# 创建用户\ncreate user "username" with password \'password\'\n\n# 赋予用户管理员权限\ngrant all privileges to username\n\n# 创建管理员权限的用户\ncreate user <username> with password \'<password>\' with all privileges\n\n# 修改用户密码\nset password for username = \'password\'\n\n# 撤消权限\nrevoke all on mydb from username\n\n# 查看权限\nshow grants for username\n\n# 删除用户\ndrop user "username"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 6. 在配置文件启用认证\n\n默认情况下，influxdb的配置文件是禁用认证策略的，所以需要修改设置一下。 编辑配置文件vim /etc/influxdb/influxdb.conf，把 [http] 下的 auth-enabled 选项设置为 true\n\n# 进入influxdb容器\ndocker exec -it influxdb /bin/bash\n\n# 编辑数据\nvim /etc/influxdb/influxdb.conf\n\n\n1\n2\n3\n4\n5\n\n\n未完待续。。。。。。。。\n\n\n# 2. influxdb2.x 快速入门\n\n\n# 1. influxdb2.x介绍\n\nhttps://www.jianshu.com/p/268fca65f10e\n\n> 本文使用的是influxdb 2.2版本。\n\n# 1. 介绍\n\ninfluxdb是一个由influxdata开发的开源时序型数据。它由go写成，着力于高性能地查询与存储时序型数据。influxdb被广泛应用于存储系统的监控数据，iot行业的实时数据等场景。\n\n> 2021年6月份，发布influxdb2.x，与前面版本结构有所差异\n\n * 1.x 版本使用 influxql 查询语言，2.x 和 1.8+（beta） 使用 flux 查询语法；相比v1 移除了database 和 rp，增加了bucket。\n * v2具有以下几个概念： timestamp、field key、field value、field set、tag key、tag value、tag set、measurement、series、point、bucket、bucket schema、organization\n * 新增的概念：\n   1. bucket：所有 influxdb 数据都存储在一个存储桶中。一个桶结合了数据库的概念和存储周期（时间每个数据点仍然存在持续时间）。一个桶属于一个组织\n   2. bucket schema：具有明确的schema-type的存储桶需要为每个度量指定显式架构。测量包含标签、字段和时间戳。显式模式限制了可以写入该度量的数据的形状。\n   3. organization：influxdb组织是一组用户的工作区。所有仪表板、任务、存储桶和用户都属于一个组织。\n\n# 2. influxdb有三大特性：\n\n * time series （时间序列）：你可以使用与时间有关的相关函数（如最大，最小，求和等）\n * metrics（度量）：你可以实时对大量数据进行计算\n * eevents（事件）：它支持任意的事件数据\n\n# 3. 特点\n\n * 为时间序列数据专门编写的自定义高性能数据存储。 tsm引擎具有高性能的写入和数据压缩\n * golang编写，没有其它的依赖\n * 提供简单、高性能的写入、查询 http api，native http api, 内置http支持，使用http读写\n * 插件支持其它数据写入协议，例如 graphite、collectd、opentsdb\n * 支持类sql查询语句\n * tags可以索引序列化，提供快速有效的查询\n * retention policies自动处理过期数据\n * continuous queries自动聚合，提高查询效率\n * schemaless(无结构)，可以是任意数量的列\n * scalable可拓展\n * min, max, sum, count, mean,median 一系列函数，方便统计\n * built-in explorer 自带管理工具\n\n# 4. 核心概念\n\n示例数据（解释某些概念用）\n\n_time                  _measurement   location   scientist   _field   _value\n2019-08-18t00:00:00z   census         klamath    anderson    bees     23\n2019-08-18t00:00:00z   census         portland   mullen      ants     30\n\n 1.  organization organization 是一组用户的工作空间，一个组下用户可以创建多个bucket\n\n 2.  bucket 所有的 influxdb数据都存储在bucket中，bucket结合了数据库和保存期限（每条数据会被保留的时间）的概念，类似于rdms的database的概念。bucket属于一个organization\n\n 3.  measurement measurement是所有 tags fields 和时间的容器和rdms的table的概念类似,是一个数据集的容器\n\n 4.  fields 数据属性包括field key 和 field value 分别存储在 _field和 _value当中, 并且一个measurement中必须包含至少一个filed\n\n 5.  field key field key 是一个代表属性名称的字段，在示例数据中bees和ants就是field key\n\n 6.  field value field value 是对应 field key 的值,在示例数据中在2019-08-18t00:00:00z该时间点 bees的值为23，而ants的值为30\n\n 7.  field set field set 表示在同一时间内 所有fields的集合\n\n 8.  tags 和fields类似，tags也有 key value。但与fields不同的是，field key存储在_field列中 而tag key则是本省就是列\n\n 9.  tag key 和 tag value 即tag 的 key 和 value 在line protocl中有更为直观的体现\n\n 10. timestamp 所有存储在influxdb中的数据都有一个_time列用来记录时间，在磁盘中以纳秒之间戳存储，但客户端查询时返回的是格式化的更易读的 rfc3339 utc时间格式\n\n>  1. 对于fields 和 tags 简单来说他们都是一组键值对的集合。在存储形式上，field 的key 被存储在一个名为_field的列中,而tag 的key则是以列头的形式存在的,该列的内容即为tag value。可以从示例数据中直观的看出其区别。\n>  2. 另外值得注意的是，field 和 tag 都可以用来存储数据，但tag只能存储字符串类型数据，而filed既可以存储字符串类型又可以存储数值类型数据。\n>  3. 那么我是否可以在tag中存储字符串形式的数据呢？ 当然可以但其不可以参与flux查询中的mean() max() 等聚合函数的计算。所以field 和 tag 还是有着本质上的区别的。\n\n\n# 2. 安装\n\n# 1. 官网:\n\nhttps://www.influxdata.com/\n\n\n\n# 2. 文档2.3：\n\nhttps://docs.influxdata.com/influxdb/v2.3/\n\n# 3. 下载地址:\n\n 1. 地址： https://www.influxdata.com/get-influxdb/\n\n 2. 下载页\n\n 3. 点击release-notes， 进入: https://docs.influxdata.com/influxdb/v2.3/install/?t=linux\n\n\n\n\n\n> 此处有官方文档的详细安装说明（包含mac、linux、windows）。下面有自己安装过程的记录。\n\n 4. 安装服务端\n\n> influxdb2-2.2.0.x86_64.rpm\n\n参考：https://blog.csdn.net/l_15156024189/article/details/124726892\n\n 1. 下载安装包\n\n清华镜像： index of /influxdata/yum/ | 清华大学开源软件镜像站 | tsinghua open source mirror\n\n> 本文选择: influxdb2-2.2.0.x86_64.rpm\n\n# 1. centos\n\n# 官网\nwget https://dl.influxdata.com/influxdb/releases/influxdb2-2.2.0-amd64.rpm\n\n# 清华源\nwget https://mirrors.tuna.tsinghua.edu.cn/influxdata/yum/el7-x86_64/influxdb2-2.2.0.x86_64.rpm\n\n\n1\n2\n3\n4\n5\n\n\n\n\n> 注意：wget下载https出现：--no-check-certificate 使用 wget --no-check-certificate https://mirrors.tuna.tsinghua.edu.cn/influxdata/yum/el7-x86_64/influxdb2-2.2.0.x86_64.rpm\n\nsudo yum localinstall -y influxdb2-2.2.0.x86_64.rpm\n\n\n1\n\n\n\n\n# 2. ubuntu\n\n# ubuntu/debian\nwget https://dl.influxdata.com/influxdb/releases/influxdb2-2.2.0.x86_64.deb\nsudo dpkg -i influxdb2-2.2.0.x86_64.deb\n\n\n1\n2\n3\n\n\n# 3. docker\n\ninfluxdb 2.x 初始化凭证 自动 influxdb 升级过程引导influxdb 2.x 所需的初始管理员用户、 组织和 存储桶。在 docker 容器中设置以下环境变量 以提供设置凭据：\n\n * docker_influxdb_init_username：为管理员用户设置的用户名（必需）。\n * docker_influxdb_init_password：为管理员用户设置的密码（必需）。\n * docker_influxdb_init_org：为初始组织设置的名称（必需）。\n * docker_influxdb_init_bucket：为初始存储桶设置的名称（必需）。\n * docker_influxdb_init_retention：初始存储桶保留期的持续时间。如果未设置，初始存储桶将永久保留数据。\n * docker_influxdb_init_admin_token：与管理员用户关联的 api 令牌。如果没有设置，influxdb 会自动生成一个令牌。\n\n# 拉取镜像\ndoker pull influxdb:2.3\n\n# 安装\ndocker run -d -p 8086:8086 \\\n  -v influxdb:/var/lib/influxdb \\\n  -v influxdb2:/var/lib/influxdb2 \\\n  -e docker_influxdb_init_mode=upgrade \\\n  -e docker_influxdb_init_username=my-user \\\n  -e docker_influxdb_init_password=my-password \\\n  -e docker_influxdb_init_org=my-org \\\n  -e docker_influxdb_init_bucket=my-bucket \\\n  influxdb:2.3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. 配置\n\n# 配置文件目录：\n\n# 进入目录\ncd /etc/influxdb/\n\n\n1\n2\n\n\n\n\n# 默认配置如下\n\ncat config.toml\n\n\n1\n\n\n\n\n# 3. 启动 influxdb\n\n> 执行如下命令开机启动：\n\n# 开机自启：\nsystemctl enable influxdb\n\n# 启动：\nsystemctl start influxdb\n\n# 重启：\nsystemctl restart influxdb\n\n# 停止\nsystemctl stop influxdb\n\n# 查看状态\nsystemctl status influxdb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 启动方式\n\n# 第一种\nsystemctl start influxdb\n\n# 第二种\nservice influxdb start\n\n# 第三种\ninfluxdb run\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 4. 验证\n\n# 1. 访问\n\n访问：ip:8086 http://localhost:8086 http://192.168.47.129:8086\n\n\n\n# 2. 初始化用户设置\n\n\n\n> 初始化时用户名：influxdb，密码：influxdb\n\n从上到下为：账号（zhouhong）、密码(66668888)、确认密码(66668888)、组织(my_influxdb)、buucket(tom)；完了之后点击 quick start\n\n\n\n# 3. 首页\n\n\n\n# 4. 关于about\n\n\n\n# 5. token令牌\n\n\n\n\n\n# 6. 初始化创建的bucket\n\n\n\n# 7. 设置bucket的保存策略\n\n\n\n# 5. 安装windows cli\n\n文档地址：https://docs.influxdata.com/influxdb/v2.3/install/?t=windows\n\n> influxdb2-client-2.3.0-windows-amd64\n\n# 1. 下载地址\n\n地址: https://docs.influxdata.com/influxdb/v2.3/tools/influx-cli/\n\n\n\n# 2. 解压\n\n * 解压后的目录\n\n\n\n * 文件内容\n\n\n\n# 3. 授予对influxcli 的网络访问权限。\n\n 1. influx首次使用cli 时， windows defender显示以下消息：\n\nwindows defender 防火墙已阻止此应用程序的某些功能。\n要授予influxcli 所需的访问权限，请执行以下操作：\n1. 选择专用网络，例如我的家庭或工作网络。\n2. 单击允许访问。\n\n\n1\n2\n3\n4\n\n 2. 为了后面执行influx命令不需要每次都连接和验证token，可以执行如下命令创建一个配置：\n\ninflux config create --config-name influxdb2.conf \\\n--host-url http://192.168.47.129:8086 \\\n--org chggx \\\n--token exguyainmupvpp6vza9ruuygbhcywlozt_fykydwilt5fsjdena1-pq-ekwp2rfdznl8r6ydqclr8kh0hw8kuq== \\\n--active\n\n\n1\n2\n3\n4\n5\n\n * --host-url: 服务端地址：http://192.168.47.129:8086\n * --org\n\n\n# 3. influxdb2.2与springboot集成\n\n参考： https://www.cnblogs.com/tom-shushu/p/15830776.html https://blog.csdn.net/calm_d/article/details/120646931[另外一种写法]\n\n# 1. 依赖\n\n <dependency>\n    <groupid>org.projectlombok</groupid>\n    <artifactid>lombok</artifactid>\n</dependency>\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n<dependency>\n    <groupid>com.influxdb</groupid>\n    <artifactid>influxdb-client-java</artifactid>\n    <version>4.0.0</version>\n</dependency>\n<dependency>\n    <groupid>org.influxdb</groupid>\n    <artifactid>influxdb-java</artifactid>\n    <version>2.20</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 2. yml配置文件\n\ninflux:\n  influxurl: \'http://192.168.47.129:8086\'\n  bucket: \'chggx\'\n  org: \'chggx\'\n  token: \'exguyainmupvpp6vza9ruuygbhcywlozt_fykydwilt5fsjdena1-pq-ekwp2rfdznl8r6ydqclr8kh0hw8kuq==\'\n\n\n1\n2\n3\n4\n5\n\n\n# 3. influx实例化类\n\n@setter\n@getter\npublic class influxbean{\n    /**\n     * 数据库url地址\n     */\n    private string influxurl;\n    /**\n     * 桶(表)\n     */\n    private string bucket;\n    /**\n     * 组织\n     */\n    private string org;\n    /**\n     * token\n     */\n    private string token;\n    /**\n     * 数据库连接\n     */\n    private influxdbclient client;\n    /**\n     * 构造方法\n     */\n    public influxbean(string influxurl, string bucket, string org, string token) {\n        this.influxurl = influxurl;\n        this.bucket = bucket;\n        this.org = org;\n        this.token = token;\n        this.client = getclient();\n    }\n    /**\n     * 获取连接\n     */\n    private influxdbclient getclient() {\n        if (client == null) {\n            client  = influxdbclientfactory.create(influxurl, token.tochararray());\n        }\n        return client;\n    }\n    /**\n     * 写入数据(以秒为时间单位)\n     */\n    public void write(object object){\n        try (writeapi writeapi = client.getwriteapi()) {\n            writeapi.writemeasurement(bucket, org, writeprecision.ns, object);\n        }\n    }\n    /**\n     * 读取数据\n     */\n    public list<fluxtable> querytable(string fluxquery){\n        return client.getqueryapi().query(fluxquery, org);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n# 4、influx配置类: 启动spring工程时实例化influxbean\n\n# 1. 配置类\n\n@data\n@configuration\n@configurationproperties(prefix = "influx")\npublic class influxconfig {\n    /**\n     * url地址\n     */\n    private string influxurl;\n    /**\n     * 桶(表)\n     */\n    private string bucket;\n    /**\n     * 组织\n     */\n    private string org;\n    /**\n     * token\n     */\n    private string token;\n    /**\n     * 初始化bean\n     */\n    @bean(name = "influx")\n    public influxbean influxbean() {\n        return new influxbean(influxurl, bucket, org, token);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 2. 配置类（写法二）\n\n@configuration\npublic class influxconfig {\n    /**\n     * url地址\n     */\n    @value("${spring.influx.url}")\n    private string influxurl;\n    /**\n     * 桶(表)\n     */\n    @value("${spring.influx.bucket}")\n    private string bucket;\n    /**\n     * 组织\n     */\n    @value("${spring.influx.org}")\n    private string org;\n    /**\n     * token\n     */\n    @value("${spring.influx.token}")\n    private string token;\n    /**\n     * 初始化bean\n     */\n    @bean(name = "influx")\n    public influxbean influxbean() {\n        return new influxbean(influxurl, bucket, org, token);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 5. 数据库桶(表)实体类\n\n@measurement(name = "influxentity")\n@getter\n@setter\npublic class influxentity{\n    /**\n     * 值\n     */\n    @column\n    integer value;\n    /**\n     * 标签字段\n     */\n    @column(tag = true)\n    string tag;\n    /**\n     * 时间\n     */\n    @column(timestamp = true)\n    instant time;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 6. 实现类\n\npackage com.chggx.influxdb2x.servie.impl;\n\nimport com.chggx.influxdb2x.config.influxbean;\nimport com.chggx.influxdb2x.model.param.insertparams;\nimport com.chggx.influxdb2x.model.restlt.influxresult;\nimport com.chggx.influxdb2x.servie.influxservice;\nimport com.influxdb.query.fluxtable;\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.stereotype.service;\n\nimport javax.annotation.resource;\nimport java.time.instant;\nimport java.util.arraylist;\nimport java.util.list;\n\n@service\n@slf4j\npublic class influxserviceimpl implements influxservice {\n    @resource\n    private influxbean influxbean;\n\n    @override\n    public void insert(insertparams insertparams) {\n        insertparams.settime(instant.now());\n        influxbean.write(insertparams);\n    }\n\n    @override\n    public list<influxresult> queue(){\n        // 下面两个 private 方法 赋值给 list 查询对应的数据\n        list<fluxtable> list = queryinfluxall();\n        list<influxresult> results = new arraylist<>();\n        for (int i = 0; i < list.size(); i++) {\n            for (int j = 0; j < list.get(i).getrecords().size(); j++) {\n                influxresult influxresult = new influxresult();\n                influxresult.setcurrent(list.get(i).getrecords().get(j).getvalues().get("current").tostring());\n                influxresult.setenergyused(list.get(i).getrecords().get(j).getvalues().get("energyused").tostring());\n                influxresult.setpower(list.get(i).getrecords().get(j).getvalues().get("power").tostring());\n                influxresult.setvoltage(list.get(i).getrecords().get(j).getvalues().get("voltage").tostring());\n                influxresult.settime(list.get(i).getrecords().get(j).getvalues().get("_time").tostring());\n                system.err.println(list.get(i).getrecords().get(j).getvalues().tostring());\n                results.add(influxresult);\n            }\n        }\n        return results;\n    }\n\n    /**\n     * 查询一小时内的insertparams所有数据\n     * @return\n     */\n    private list<fluxtable> queryinfluxall(){\n        string query = " from(bucket: \\"chggx\\")" +\n                "  |> range(start: -60m, stop: now())" +\n                "  |> filter(fn: (r) => r[\\"_measurement\\"] == \\"influx_test\\")" +\n                "  |> pivot( rowkey:[\\"_time\\"], columnkey: [\\"_field\\"], valuecolumn: \\"_value\\" )";\n        return influxbean.querytable(query);\n    }\n\n    /**\n     * 根据某一个字段的值过滤(查询 用电量 energyused 为 322 的那条记录)\n     * @return\n     */\n    public list<fluxtable> queryfilterbyenergyused(){\n        string query = " from(bucket: \\"chggx\\")" +\n                "  |> range(start: -60m, stop: now())" +\n                "  |> filter(fn: (r) => r[\\"_measurement\\"] == \\"influx_test\\")" +\n                "  |> filter(fn: (r) => r[\\"energyused\\"] == \\"322\\")" +\n                "  |> pivot( rowkey:[\\"_time\\"], columnkey: [\\"_field\\"], valuecolumn: \\"_value\\" )";\n        return influxbean.querytable(query);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n# 7. 接口\n\n@restcontroller\npublic class influxdbcontroller {\n\n    @autowired\n    private influxservice influxservice;\n\n    /**\n      * 时许数据库插入测试\n      * @return\n      */\n    @postmapping("/inlfuxdb/insert")\n    public responsedata insert(@requestbody insertparams insertparams) {\n        influxservice.insert(insertparams);\n        return new successresponsedata();\n    }\n\n\n    @postmapping("/inlfuxdb/queue")\n    public responsedata queue(@requestbody insertparams insertparams) {\n        return new successresponsedata(influxservice.queue());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 8. 使用 aplfox 测试\n\n# 1. 新增\n\n\n\n# 2. 查询\n\n\n\n\n# 4. influxdb文档\n\n> 2.3 官网：https://docs.influxdata.com/influxdb/v2.3/',charsets:{cjk:!0},lastUpdated:"2023/02/28, 18:23:46",lastUpdatedTimestamp:1677579826e3},{title:"Java设计模式-内容介绍",frontmatter:{title:"Java设计模式-内容介绍",date:"2023-02-25T20:46:26.000Z",permalink:"/pages/391852/"},regularPath:"/02.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D.html",relativePath:"02.编程基础/04.设计模式/0.Java设计模式-内容介绍.md",key:"v-ebfbb4aa",path:"/pages/391852/",headers:[{level:2,title:"1. 经典面试图",slug:"_1-经典面试图",normalizedTitle:"1. 经典面试图",charIndex:20},{level:3,title:"1. 试题一",slug:"_1-试题一",normalizedTitle:"1. 试题一",charIndex:33},{level:3,title:"2. 试题二",slug:"_2-试题二",normalizedTitle:"2. 试题二",charIndex:44},{level:3,title:"3. 试题三：状态模式",slug:"_3-试题三-状态模式",normalizedTitle:"3. 试题三：状态模式",charIndex:161},{level:3,title:"4. 示例四：解释器模式",slug:"_4-示例四-解释器模式",normalizedTitle:"4. 示例四：解释器模式",charIndex:179},{level:3,title:"5. 示例四：单例模式",slug:"_5-示例四-单例模式",normalizedTitle:"5. 示例四：单例模式",charIndex:225},{level:2,title:"2. 设计模式的重要性",slug:"_2-设计模式的重要性",normalizedTitle:"2. 设计模式的重要性",charIndex:307}],headersStr:"1. 经典面试图 1. 试题一 2. 试题二 3. 试题三：状态模式 4. 示例四：解释器模式 5. 示例四：单例模式 2. 设计模式的重要性",content:"# Java设计模式-内容介绍\n\n\n# 1. 经典面试图\n\n\n# 1. 试题一\n\n\n# 2. 试题二\n\n> 设计模式常用的七大原则：\n> \n>  * 单一职责原则\n>  * 接口隔离原则\n>  * 依赖倒转原则\n>  * 里氏替换原则\n>  * 开闭原则 OCP原则\n>  * 迪米特法则\n>  * 合成复用原则\n\n\n# 3. 试题三：状态模式\n\n\n\n\n# 4. 示例四：解释器模式\n\n\n\n * spring框架用到的解释器设计模式示例\n\n\n\n\n# 5. 示例四：单例模式\n\n\n\n> 单例设计模式的写法：\n> \n>  * 饿汉式\n>  * 懒汉式\n>  * 双重检查\n>  * 静态内部类\n>  * 枚举\n\n\n# 2. 设计模式的重要性\n\n\n\n\n\n> 设计模式在哪些软件中哪里？\n> \n> 面向对象(oo)=》 功能模块 [设计模式 + 算法(数据结构)] =》框架[使用多种设计模式] =》架构(服务器集群)\n> \n>  * 框架 = 设计模式 + 注解 + 反射",normalizedContent:"# java设计模式-内容介绍\n\n\n# 1. 经典面试图\n\n\n# 1. 试题一\n\n\n# 2. 试题二\n\n> 设计模式常用的七大原则：\n> \n>  * 单一职责原则\n>  * 接口隔离原则\n>  * 依赖倒转原则\n>  * 里氏替换原则\n>  * 开闭原则 ocp原则\n>  * 迪米特法则\n>  * 合成复用原则\n\n\n# 3. 试题三：状态模式\n\n\n\n\n# 4. 示例四：解释器模式\n\n\n\n * spring框架用到的解释器设计模式示例\n\n\n\n\n# 5. 示例四：单例模式\n\n\n\n> 单例设计模式的写法：\n> \n>  * 饿汉式\n>  * 懒汉式\n>  * 双重检查\n>  * 静态内部类\n>  * 枚举\n\n\n# 2. 设计模式的重要性\n\n\n\n\n\n> 设计模式在哪些软件中哪里？\n> \n> 面向对象(oo)=》 功能模块 [设计模式 + 算法(数据结构)] =》框架[使用多种设计模式] =》架构(服务器集群)\n> \n>  * 框架 = 设计模式 + 注解 + 反射",charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Java设计模式-设计模式七大原则",frontmatter:{title:"Java设计模式-设计模式七大原则",date:"2023-02-25T20:46:26.000Z",permalink:"/pages/f21426/"},regularPath:"/02.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99.html",relativePath:"02.编程基础/04.设计模式/1.Java设计模式-设计模式七大原则.md",key:"v-7d4ea15e",path:"/pages/f21426/",headers:[{level:2,title:"1. 设计模式的目的",slug:"_1-设计模式的目的",normalizedTitle:"1. 设计模式的目的",charIndex:25},{level:2,title:"2. 设计模式的七大原则",slug:"_2-设计模式的七大原则",normalizedTitle:"2. 设计模式的七大原则",charIndex:391},{level:2,title:"3. 单一职责原则",slug:"_3-单一职责原则",normalizedTitle:"3. 单一职责原则",charIndex:542},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍",normalizedTitle:"1. 基本介绍",charIndex:556},{level:3,title:"2. 示例",slug:"_2-示例",normalizedTitle:"2. 示例",charIndex:667},{level:4,title:"方式一：",slug:"方式一",normalizedTitle:"方式一：",charIndex:700},{level:4,title:"方式二：",slug:"方式二",normalizedTitle:"方式二：",charIndex:1218},{level:4,title:"方式三",slug:"方式三",normalizedTitle:"方式三",charIndex:1975},{level:3,title:"3. 注意事项和细节",slug:"_3-注意事项和细节",normalizedTitle:"3. 注意事项和细节",charIndex:2796},{level:2,title:"4. 接口隔离原则",slug:"_4-接口隔离原则",normalizedTitle:"4. 接口隔离原则",charIndex:2958},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍-2",normalizedTitle:"1. 基本介绍",charIndex:556},{level:3,title:"2. 示例",slug:"_2-示例-2",normalizedTitle:"2. 示例",charIndex:667},{level:4,title:"1. 原始代码",slug:"_1-原始代码",normalizedTitle:"1. 原始代码",charIndex:3264},{level:4,title:"2. 接口隔离原则改造后代码",slug:"_2-接口隔离原则改造后代码",normalizedTitle:"2. 接口隔离原则改造后代码",charIndex:5255},{level:2,title:"5. 依赖倒转原则",slug:"_5-依赖倒转原则",normalizedTitle:"5. 依赖倒转原则",charIndex:7422},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍-3",normalizedTitle:"1. 基本介绍",charIndex:556},{level:3,title:"2. 示例",slug:"_2-示例-3",normalizedTitle:"2. 示例",charIndex:667},{level:4,title:"1. 方式一：",slug:"_1-方式一",normalizedTitle:"1. 方式一：",charIndex:7758},{level:4,title:"2. 方式二：使用依赖倒转原则",slug:"_2-方式二-使用依赖倒转原则",normalizedTitle:"2. 方式二：使用依赖倒转原则",charIndex:8299},{level:3,title:"3. 依赖关系传递的三种方式",slug:"_3-依赖关系传递的三种方式",normalizedTitle:"3. 依赖关系传递的三种方式",charIndex:9258},{level:4,title:"1. 接口传递",slug:"_1-接口传递",normalizedTitle:"1. 接口传递",charIndex:9276},{level:4,title:"2. 构造方法传递",slug:"_2-构造方法传递",normalizedTitle:"2. 构造方法传递",charIndex:10164},{level:4,title:"3. setter方法传递",slug:"_3-setter方法传递",normalizedTitle:"3. setter方法传递",charIndex:11243},{level:2,title:"6. 里式替换原则",slug:"_6-里式替换原则",normalizedTitle:"6. 里式替换原则",charIndex:12361},{level:3,title:"1. OO 中的继承性的思考和说明",slug:"_1-oo-中的继承性的思考和说明",normalizedTitle:"1. oo 中的继承性的思考和说明",charIndex:12375},{level:3,title:"2. 基本介绍",slug:"_2-基本介绍",normalizedTitle:"2. 基本介绍",charIndex:12661},{level:3,title:"3. 一个程序引出的问题和思考",slug:"_3-一个程序引出的问题和思考",normalizedTitle:"3. 一个程序引出的问题和思考",charIndex:13025},{level:4,title:"1. 问题",slug:"_1-问题",normalizedTitle:"1. 问题",charIndex:13044},{level:4,title:"2. 思考和解决思路",slug:"_2-思考和解决思路",normalizedTitle:"2. 思考和解决思路",charIndex:14202},{level:4,title:"3. 改进方案实现",slug:"_3-改进方案实现",normalizedTitle:"3. 改进方案实现",charIndex:14433},{level:2,title:"7. 开闭原则",slug:"_7-开闭原则",normalizedTitle:"7. 开闭原则",charIndex:16248},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍-4",normalizedTitle:"1. 基本介绍",charIndex:556},{level:3,title:"2. 看一个画图形的功能",slug:"_2-看一个画图形的功能",normalizedTitle:"2. 看一个画图形的功能",charIndex:16471},{level:4,title:"1. 方式一实现",slug:"_1-方式一实现",normalizedTitle:"1. 方式一实现",charIndex:16487},{level:4,title:"2. 方式一的优缺点",slug:"_2-方式一的优缺点",normalizedTitle:"2. 方式一的优缺点",charIndex:18195},{level:4,title:"3. 改进思路分析和实现",slug:"_3-改进思路分析和实现",normalizedTitle:"3. 改进思路分析和实现",charIndex:18356},{level:2,title:"8. 迪米特原则",slug:"_8-迪米特原则",normalizedTitle:"8. 迪米特原则",charIndex:20268},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍-5",normalizedTitle:"1. 基本介绍",charIndex:556},{level:3,title:"2. 应用实例",slug:"_2-应用实例",normalizedTitle:"2. 应用实例",charIndex:20647},{level:4,title:"1. 代码",slug:"_1-代码",normalizedTitle:"1. 代码",charIndex:113},{level:4,title:"2. 改进的思路和代码",slug:"_2-改进的思路和代码",normalizedTitle:"2. 改进的思路和代码",charIndex:23607},{level:3,title:"3. 迪米特法则注意事项和细节",slug:"_3-迪米特法则注意事项和细节",normalizedTitle:"3. 迪米特法则注意事项和细节",charIndex:26298},{level:2,title:"9. 合成复用原则",slug:"_9-合成复用原则",normalizedTitle:"9. 合成复用原则",charIndex:26408},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍-6",normalizedTitle:"1. 基本介绍",charIndex:556},{level:3,title:"2. 核心思想",slug:"_2-核心思想",normalizedTitle:"2. 核心思想",charIndex:26461}],headersStr:"1. 设计模式的目的 2. 设计模式的七大原则 3. 单一职责原则 1. 基本介绍 2. 示例 方式一： 方式二： 方式三 3. 注意事项和细节 4. 接口隔离原则 1. 基本介绍 2. 示例 1. 原始代码 2. 接口隔离原则改造后代码 5. 依赖倒转原则 1. 基本介绍 2. 示例 1. 方式一： 2. 方式二：使用依赖倒转原则 3. 依赖关系传递的三种方式 1. 接口传递 2. 构造方法传递 3. setter方法传递 6. 里式替换原则 1. OO 中的继承性的思考和说明 2. 基本介绍 3. 一个程序引出的问题和思考 1. 问题 2. 思考和解决思路 3. 改进方案实现 7. 开闭原则 1. 基本介绍 2. 看一个画图形的功能 1. 方式一实现 2. 方式一的优缺点 3. 改进思路分析和实现 8. 迪米特原则 1. 基本介绍 2. 应用实例 1. 代码 2. 改进的思路和代码 3. 迪米特法则注意事项和细节 9. 合成复用原则 1. 基本介绍 2. 核心思想",content:'# Java设计模式-设计模式的七大原则\n\n\n# 1. 设计模式的目的\n\n编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的\n\n挑战，设计模式是为了让程序(软件)，具有更好\n\n 1. 代码重用性 ：相同功能的代码，不用多次编写\n\n 2. 可读性：编程规范性, 便于其他程序员的阅读和理解\n\n 3. 可扩展性 ：当需要增加新的功能时，非常的方便，称为可维护\n\n 4. 可靠性 ：当我们增加新的功能后，对原来的功能没有影响\n\n 5. 使程序呈现高内聚，低耦合的特性\n\n> 分享金句：\n\n 1. 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”\n 2. Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤疤\n\n\n# 2. 设计模式的七大原则\n\n设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础。\n\n设计模式常用的七大原则有:\n\n * 单一职责原则\n * 接口隔离原则\n * 依赖倒转(倒置)原则\n * 里氏替换原则\n * 开闭原则 OCP原则\n * 迪米特法则\n * 合成复用原则\n\n\n# 3. 单一职责原则\n\n\n# 1. 基本介绍\n\n对类来说的，即一个类应该只负责一项职责。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2\n\n\n# 2. 示例\n\n> 此处使用交通工具类作为演示单一职责原则。\n\n# 方式一：\n\npublic class SingleResponsibility1 {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      Vehicle vehicle = new Vehicle();\n      vehicle.run("摩托车");\n      vehicle.run("汽车");\n      vehicle.run("飞机");\n   }\n\n}\n\n/**\n * 交通类\n */\nclass Vehicle {\n   public void run(String vehicle) {\n      System.out.println(vehicle + " 在公路上运行....");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 方式一的分析：\n> \n>  1. 在方式1 的run方法中，违反了单一职责原则\n>  2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可\n\n# 方式二：\n\npublic class SingleResponsibility2 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tRoadVehicle roadVehicle = new RoadVehicle();\n\t\troadVehicle.run("摩托车");\n\t\troadVehicle.run("汽车");\n\t\t\n\t\tAirVehicle airVehicle = new AirVehicle();\n\t\t\n\t\tairVehicle.run("飞机");\n\t}\n\n}\n\nclass RoadVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + "公路运行");\n\t}\n}\n\nclass AirVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + "天空运行");\n\t}\n}\n\nclass WaterVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + "水中运行");\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n> 方式二的分析：\n> \n>  1. 遵守单一职责原则\n>  2. 但是这样做的改动很大，即将类分解，同时修改客户端\n\n# 方式三\n\npublic class SingleResponsibility3 {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      Vehicle2 vehicle2  = new Vehicle2();\n      vehicle2.run("汽车");\n      vehicle2.runWater("轮船");\n      vehicle2.runAir("飞机");\n   }\n\n}\n\nclass Vehicle2 {\n   public void run(String vehicle) {\n      //处理\n      System.out.println(vehicle + " 在公路上运行....");  \n   }\n   \n   public void runAir(String vehicle) {\n      System.out.println(vehicle + " 在天空上运行....");\n   }\n   \n   public void runWater(String vehicle) {\n      System.out.println(vehicle + " 在水中行....");\n   }\n   \n   //方法2.\n   //..\n   //..\n   \n   //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n> 方式三的分析：\n> \n>  1. 这种修改方法没有对原来的类做大的修改，只是增加方法\n>  2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责\n\n\n# 3. 注意事项和细节\n\n 1. 降低类的复杂度，一个类只负责一项职责。\n\n 2. 提高类的可读性，可维护性\n\n 3. 降低变更引起的风险\n\n 4. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则(比如代码中的方式三)；只有类中 方法数量足够少，可以在方法级别保持单一职责原则\n\n\n# 4. 接口隔离原则\n\n\n# 1. 基本介绍\n\n 1. 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上\n\n\n# 2. 示例\n\n示例：\n\n * 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。\n\n * 按隔离原则应当这样处理：\n   \n   将接口 Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n\n# 1. 原始代码\n\n> 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，请编写代码完成此应用实例\n\n * 类图\n\n\n\n * 代码\n\npublic class Segregation1 {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n\n   }\n\n}\n\n//接口\ninterface Interface1 {\n   void operation1();\n   void operation2();\n   void operation3();\n   void operation4();\n   void operation5();\n}\n\nclass B implements Interface1 {\n   public void operation1() {\n      System.out.println("B 实现了 operation1");\n   }\n   \n   public void operation2() {\n      System.out.println("B 实现了 operation2");\n   }\n   public void operation3() {\n      System.out.println("B 实现了 operation3");\n   }\n   public void operation4() {\n      System.out.println("B 实现了 operation4");\n   }\n   public void operation5() {\n      System.out.println("B 实现了 operation5");\n   }\n}\n\nclass D implements Interface1 {\n   public void operation1() {\n      System.out.println("D 实现了 operation1");\n   }\n   \n   public void operation2() {\n      System.out.println("D 实现了 operation2");\n   }\n   public void operation3() {\n      System.out.println("D 实现了 operation3");\n   }\n   public void operation4() {\n      System.out.println("D 实现了 operation4");\n   }\n   public void operation5() {\n      System.out.println("D 实现了 operation5");\n   }\n}\n\nclass A { //A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法\n   public void depend1(Interface1 i) {\n      i.operation1();\n   }\n   public void depend2(Interface1 i) {\n      i.operation2();\n   }\n   public void depend3(Interface1 i) {\n      i.operation3();\n   }\n}\n  \nclass C { //C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法\n   public void depend1(Interface1 i) {\n      i.operation1();\n   }\n   public void depend4(Interface1 i) {\n      i.operation4();\n   }\n   public void depend5(Interface1 i) {\n      i.operation5();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n# 2. 接口隔离原则改造后代码\n\n>  1. 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法\n> \n>  2. 将接口 Interface1 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n> \n>  3. 接口 Interface1 中出现的方法，根据实际情况拆分为三个接口\n\n * 类图\n\n\n\n * 代码\n\npublic class Segregation1 {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n\n   }\n\n}\n\n//接口\ninterface Interface1 {\n   void operation1();\n   void operation2();\n   void operation3();\n   void operation4();\n   void operation5();\n}\n\nclass B implements Interface1 {\n   public void operation1() {\n      System.out.println("B 实现了 operation1");\n   }\n   \n   public void operation2() {\n      System.out.println("B 实现了 operation2");\n   }\n   public void operation3() {\n      System.out.println("B 实现了 operation3");\n   }\n   public void operation4() {\n      System.out.println("B 实现了 operation4");\n   }\n   public void operation5() {\n      System.out.println("B 实现了 operation5");\n   }\n}\n\nclass D implements Interface1 {\n   public void operation1() {\n      System.out.println("D 实现了 operation1");\n   }\n   \n   public void operation2() {\n      System.out.println("D 实现了 operation2");\n   }\n   public void operation3() {\n      System.out.println("D 实现了 operation3");\n   }\n   public void operation4() {\n      System.out.println("D 实现了 operation4");\n   }\n   public void operation5() {\n      System.out.println("D 实现了 operation5");\n   }\n}\n\nclass A { //A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法\n   public void depend1(Interface1 i) {\n      i.operation1();\n   }\n   public void depend2(Interface1 i) {\n      i.operation2();\n   }\n   public void depend3(Interface1 i) {\n      i.operation3();\n   }\n}\n  \nclass C { //C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法\n   public void depend1(Interface1 i) {\n      i.operation1();\n   }\n   public void depend4(Interface1 i) {\n      i.operation4();\n   }\n   public void depend5(Interface1 i) {\n      i.operation5();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# 5. 依赖倒转原则\n\n\n# 1. 基本介绍\n\n依赖倒转原则(Dependence Inversion Principle)是指：\n\n 1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象\n\n 2. 抽象不应该依赖细节，细节应该依赖抽象\n\n 3. 依赖倒转(倒置)的中心思想是：面向接口编程\n\n 4. 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java中，抽象指的是接口或抽象类，细节就是具体的实现类\n\n 5. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成\n\n\n# 2. 示例\n\n程完成 Person 接收消息 的功能\n\n# 1. 方式一：\n\npublic class DependecyInversion {\n\n    public static void main(String[] args) {\n        Person person = new Person();\n        person.receive(new Email());\n    }\n\n}\n\n/**\n * 邮件类\n */\nclass Email {\n    public String getInfo() {\n        return "电子邮件信息: hello,world";\n    }\n}\n\n/**\n * Person类\n */\nclass Person {\n    public void receive(Email email) {\n        System.out.println(email.getInfo());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 分析：简单，比较容易想到。如果我们获取的对象是 微信，短信等等，则新增类，同时Person也要增加相应的接收方法\n\n# 2. 方式二：使用依赖倒转原则\n\n解决思路：解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖。因为Email, WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则。\n\npublic class DependecyInversion2 {\n\n    public static void main(String[] args) {\n        Person person = new Person();\n        person.receive(new Email());\n        person.receive(new WeiXin());\n    }\n\n}\n\n/**\n * 定义接口\n */\ninterface IReceiver {\n    public String getInfo();\n}\n\n/**\n * 邮件类\n */\nclass Email implements IReceiver {\n    public String getInfo() {\n        return "电子邮件信息: hello,world";\n    }\n}\n\n/**\n * 微信类\n */\nclass WeiXin implements IReceiver {\n    public String getInfo() {\n        return "微信信息: hello,ok";\n    }\n}\n\n\n/**\n * Person类\n */\nclass Person {\n    // 这里我们是对接口的依赖\n    public void receive(IReceiver receiver ) {\n        System.out.println(receiver.getInfo());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 3. 依赖关系传递的三种方式\n\n# 1. 接口传递\n\npublic class DependencyPass1 {\n\n    public static void main(String[] args) {\n        // 通过接口传递实现依赖\n        ChangHong changHong = new ChangHong();\n        OpenAndClose openAndClose = new OpenAndClose();\n        openAndClose.open(changHong);\n    }\n\n}\n\n/**\n * 开关的接口\n */\ninterface IOpenAndClose {\n\n    /**\n     * 抽象方法,接收接口\n     *\n     * @param tv\n     */\n    public void open(ITV tv);\n}\n\n/**\n * ITV接口\n */\ninterface ITV {\n    public void play();\n}\n\n\n/**\n * 实现ITV接口\n */\nclass ChangHong implements ITV {\n\n    @Override\n    public void play() {\n        System.out.println("长虹电视机，打开");\n    }\n\n}\n\n/**\n * 实现开关接口\n */\nclass OpenAndClose implements IOpenAndClose {\n    @Override\n    public void open(ITV tv) {\n        tv.play();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 2. 构造方法传递\n\npublic class DependencyPass2 {\n\n    public static void main(String[] args) {\n        // 通过构造方法依赖传递\n        ChangHong changHong = new ChangHong();\n        OpenAndClose openAndClose = new OpenAndClose(changHong);\n        openAndClose.open();\n    }\n\n}\n\n/**\n * 开关的接口\n */\ninterface IOpenAndClose {\n\n    /**\n     * 抽象方法,接收接口\n     */\n    public void open();\n}\n\n\n/**\n * ITV接口\n */\ninterface ITV {\n    public void play();\n}\n\n/**\n * 实现ITV接口\n */\nclass ChangHong implements ITV {\n\n    @Override\n    public void play() {\n        System.out.println("长虹电视机，打开");\n    }\n\n}\n\n/**\n * 实现开关接口\n */\nclass OpenAndClose implements IOpenAndClose {\n\n    /**\n     * 成员\n     */\n    public ITV tv;\n\n    /**\n     * 构造器\n     *\n     * @param tv\n     */\n    public OpenAndClose(ITV tv) {\n        this.tv = tv;\n    }\n\n    /**\n     * 开关方法\n     */\n    public void open() {\n        this.tv.play();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n# 3. setter方法传递\n\npublic class DependencyPass3 {\n\n    public static void main(String[] args) {\n        // 通过set方法依赖传递\n        ChangHong changHong = new ChangHong();\n        OpenAndClose openAndClose = new OpenAndClose();\n        openAndClose.setTv(changHong);\n        openAndClose.open();\n    }\n\n}\n\n/**\n * 开关的接口\n */\ninterface IOpenAndClose {\n\n    /**\n     * 抽象方法,接收接口\n     */\n    public void open();\n}\n\n\n/**\n * ITV接口\n */\ninterface ITV {\n    public void play();\n}\n\n/**\n * 实现ITV接口\n */\nclass ChangHong implements ITV {\n\n    @Override\n    public void play() {\n        System.out.println("长虹电视机，打开");\n    }\n\n}\n\n/**\n * 实现开关接口\n */\nclass OpenAndClose implements IOpenAndClose {\n\n    /**\n     * 成员\n     */\n    public ITV tv;\n\n    /**\n     * set方法\n     *\n     * @param tv\n     */\n    public void setTv(ITV tv) {\n        this.tv = tv;\n    }\n\n    /**\n     * 开关方法\n     */\n    public void open() {\n        this.tv.play();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 6. 里式替换原则\n\n\n# 1. OO 中的继承性的思考和说明\n\n 1. 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。\n\n 2. 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障\n\n 3. 问题提出：在编程中，如何正确的使用继承? => 里氏替换原则\n\n\n# 2. 基本介绍\n\n 1. 里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。\n\n 2. 如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。\n\n 3. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法\n\n 4. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。.\n\n> 子类中尽量不要重写父类的方法：是针对普通类。当类为接口、抽象类时候使用重写。\n\n\n# 3. 一个程序引出的问题和思考\n\n# 1. 问题\n\npublic class Liskov {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      A a = new A();\n      System.out.println("11-3=" + a.func1(11, 3));\n      System.out.println("1-8=" + a.func1(1, 8));\n\n      System.out.println("-----------------------");\n      B b = new B();\n      // 这里本意是求出11-3\n      System.out.println("11-3=" + b.func1(11, 3));\n      // 1-8\n      System.out.println("1-8=" + b.func1(1, 8));\n      System.out.println("11+3+9=" + b.func2(11, 3));\n\n   }\n\n}\n\n/**\n *  A类\n */\nclass A {\n   /**\n    * 返回两个数的差\n    * @param num1\n    * @param num2\n    * @return\n    */\n   public int func1(int num1, int num2) {\n      return num1 - num2;\n   }\n}\n\n/**\n * B类继承了A\n *\n *  增加了一个新功能：完成两个数相加,然后和9求和\n */\nclass B extends A {\n   /**\n    * 这里，重写了A类的方法, 可能是无意识\n    * @param a\n    * @param b\n    * @return\n    */\n   @Override\n   public int func1(int a, int b) {\n      return a + b;\n   }\n\n   public int func2(int a, int b) {\n      return func1(a, b) + 9;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n# 2. 思考和解决思路\n\n 1. 我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类方法完成新的功能，这样写起来虽然简单，但整个继承体系的尚硅谷 Java 设计模式 复用性会比较差。特别是运行多态比较频繁的时候\n\n 2. 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替\n\n 3. 改进方案\n    \n    \n\n# 3. 改进方案实现\n\npublic class Liskov {\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        A a = new A();\n        System.out.println("11-3=" + a.func1(11, 3));\n        System.out.println("1-8=" + a.func1(1, 8));\n\n        System.out.println("-----------------------");\n        B b = new B();\n\n        //因为B类不再继承A类，因此调用者，不会再func1是求减法\n        //调用完成的功能就会很明确\n        //这里本意是求出11+3\n        System.out.println("11+3=" + b.func1(11, 3));\n        // 1+8\n        System.out.println("1+8=" + b.func1(1, 8));\n        System.out.println("11+3+9=" + b.func2(11, 3));\n\n\n        //使用组合仍然可以使用到A类相关方法\n        // 这里本意是求出11-3\n        System.out.println("11-3=" + b.func3(11, 3));\n    }\n\n}\n\n/**\n * 创建一个更加基础的基类\n */\nclass Base {\n    //把更加基础的方法和成员写到Base类\n}\n\n/**\n * A类\n */\nclass A extends Base {\n    /**\n     * 返回两个数的差\n     *\n     * @param num1\n     * @param num2\n     * @return\n     */\n    public int func1(int num1, int num2) {\n        return num1 - num2;\n    }\n}\n\n/**\n * B类继承了A\n * <p>\n * 增加了一个新功能：完成两个数相加,然后和9求和\n */\nclass B extends Base {\n    /**\n     * 如果B需要使用A类的方法,使用组合关系\n     */\n    private A a = new A();\n\n    /**\n     * 这里，重写了A类的方法, 可能是无意识\n     *\n     * @param a\n     * @param b\n     * @return\n     */\n    public int func1(int a, int b) {\n        return a + b;\n    }\n\n    public int func2(int a, int b) {\n        return func1(a, b) + 9;\n    }\n\n    /**\n     * 我们仍然想使用A的方法\n     *\n     * @param a\n     * @param b\n     * @return\n     */\n    public int func3(int a, int b) {\n        return this.a.func1(a, b);\n    }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n> B类中的 func3使用组合。\n\n\n# 7. 开闭原则\n\n\n# 1. 基本介绍\n\n 1. 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则\n\n 2. 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。\n\n 3. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。\n\n 4. 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。\n\n\n# 2. 看一个画图形的功能\n\n# 1. 方式一实现\n\npublic class Ocp {\n\n    public static void main(String[] args) {\n        //使用看看存在的问题\n        GraphicEditor graphicEditor = new GraphicEditor();\n        graphicEditor.drawShape(new Rectangle());\n        graphicEditor.drawShape(new Circle());\n        graphicEditor.drawShape(new Triangle());\n    }\n\n}\n\n/**\n * 这是一个用于绘图的类 [使用方]\n */\nclass GraphicEditor {\n    /**\n     * 接收Shape对象，然后根据type，来绘制不同的图形\n     *\n     * @param s\n     */\n    public void drawShape(Shape s) {\n        if (s.m_type == 1) {\n            drawRectangle(s);\n        } else if (s.m_type == 2) {\n            drawCircle(s);\n        } else if (s.m_type == 3) {\n            drawTriangle(s);\n        }\n    }\n\n    /**\n     * 绘制矩形\n     *\n     * @param r\n     */\n    public void drawRectangle(Shape r) {\n        System.out.println(" 绘制矩形 ");\n    }\n\n    /**\n     * 绘制圆形\n     *\n     * @param r\n     */\n    public void drawCircle(Shape r) {\n        System.out.println(" 绘制圆形 ");\n    }\n\n    /**\n     * 绘制三角形\n     *\n     * @param r\n     */\n    public void drawTriangle(Shape r) {\n        System.out.println(" 绘制三角形 ");\n    }\n}\n\n/**\n * Shape形状类，基类\n */\nclass Shape {\n    int m_type;\n}\n\n/**\n * 矩形类\n */\nclass Rectangle extends Shape {\n    Rectangle() {\n        super.m_type = 1;\n    }\n}\n\n/**\n * 圆类\n */\nclass Circle extends Shape {\n    Circle() {\n        super.m_type = 2;\n    }\n}\n\n/**\n * 新增画三角形\n */\nclass Triangle extends Shape {\n    Triangle() {\n        super.m_type = 3;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n# 2. 方式一的优缺点\n\n 1. 优点是比较好理解，简单易操作。\n\n 2. 缺点是违反了设计模式的 ocp 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n 3. 比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多\n\n# 3. 改进思路分析和实现\n\n把创建 Shape 类做成抽象类，并提供一个抽象的 draw 方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修 -> 满足了开闭原则\n\npublic class Ocp {\n\n   public static void main(String[] args) {\n      //使用看看存在的问题\n      GraphicEditor graphicEditor = new GraphicEditor();\n      graphicEditor.drawShape(new Rectangle());\n      graphicEditor.drawShape(new Circle());\n      graphicEditor.drawShape(new Triangle());\n      graphicEditor.drawShape(new OtherGraphic());\n   }\n\n}\n\n/**\n * 这是一个用于绘图的类 [使用方]\n */\nclass GraphicEditor {\n   /**\n    * 接收Shape对象，调用draw方法\n    * @param s\n    */\n   public void drawShape(Shape s) {\n      s.draw();\n   }\n\n   \n}\n\n/**\n * Shape形状类，基类\n */\nabstract class Shape {\n   int m_type;\n\n   /**\n    * 抽象方法\n    */\n   public abstract void draw();\n}\n\n/**\n * 矩形类\n */\nclass Rectangle extends Shape {\n   Rectangle() {\n      super.m_type = 1;\n   }\n\n   @Override\n   public void draw() {\n      // TODO Auto-generated method stub\n      System.out.println(" 绘制矩形 ");\n   }\n}\n\n/**\n * 圆类\n */\nclass Circle extends Shape {\n   Circle() {\n      super.m_type = 2;\n   }\n   @Override\n   public void draw() {\n      // TODO Auto-generated method stub\n      System.out.println(" 绘制圆形 ");\n   }\n}\n\n/**\n * 新增画三角形\n */\nclass Triangle extends Shape {\n   Triangle() {\n      super.m_type = 3;\n   }\n   @Override\n   public void draw() {\n      // TODO Auto-generated method stub\n      System.out.println(" 绘制三角形 ");\n   }\n}\n\n/**\n * 新增一个图形\n */\nclass OtherGraphic extends Shape {\n   OtherGraphic() {\n      super.m_type = 4;\n   }\n\n   @Override\n   public void draw() {\n      // TODO Auto-generated method stub\n      System.out.println(" 绘制其它图形 ");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n\n# 8. 迪米特原则\n\n\n# 1. 基本介绍\n\n 1. 一个对象应该对其他对象保持最少的了解\n\n 2. 类与类关系越密切，耦合度越大\n\n 3. 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息\n\n 4. 迪米特法则还有个更简单的定义：只与直接的朋友通信\n\n 5. 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。\n\n\n# 2. 应用实例\n\n有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id\n\n# 1. 代码\n\npublic class Demeter1 {\n\n    public static void main(String[] args) {\n        // 创建了一个 SchoolManager 对象\n        SchoolManager schoolManager = new SchoolManager();\n        // 输出学院的员工id 和  学校总部的员工信息\n        schoolManager.printAllEmployee(new CollegeManager());\n\n    }\n\n}\n\n\n/**\n * 学校总部员工类\n */\nclass Employee {\n    private String id;\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getId() {\n        return id;\n    }\n}\n\n\n/**\n * 学院的员工类\n */\nclass CollegeEmployee {\n    private String id;\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getId() {\n        return id;\n    }\n}\n\n\n/**\n * 管理学院员工的管理类\n */\nclass CollegeManager {\n    /**\n     * 返回学院的所有员工\n     *\n     * @return\n     */\n    public List<CollegeEmployee> getAllEmployee() {\n        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();\n        // 这里我们增加了10个员工到 list\n        for (int i = 0; i < 10; i++) {\n            CollegeEmployee emp = new CollegeEmployee();\n            emp.setId("学院员工id= " + i);\n            list.add(emp);\n        }\n        return list;\n    }\n}\n\n/**\n * 学校管理类\n * <p>\n * 分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager\n * <p>\n * CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则\n */\nclass SchoolManager {\n    /**\n     * 返回学校总部的员工\n     *\n     * @return\n     */\n    public List<Employee> getAllEmployee() {\n        List<Employee> list = new ArrayList<Employee>();\n        // 这里我们增加了5个员工到 list\n        for (int i = 0; i < 5; i++) {\n            Employee emp = new Employee();\n            emp.setId("学校总部员工id= " + i);\n            list.add(emp);\n        }\n        return list;\n    }\n\n    /**\n     * 该方法完成输出学校总部和学院员工信息(id)\n     *\n     * @param sub\n     */\n    void printAllEmployee(CollegeManager sub) {\n\n        //分析问题\n        //1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友\n        //2. CollegeEmployee 是以局部变量方式出现在 SchoolManager\n        //3. 违反了 迪米特法则 \n\n        // 获取到学院员工\n        List<CollegeEmployee> list1 = sub.getAllEmployee();\n        System.out.println("------------学院员工------------");\n        for (CollegeEmployee e : list1) {\n            System.out.println(e.getId());\n        }\n        // 获取到学校总部员工\n        List<Employee> list2 = this.getAllEmployee();\n        System.out.println("------------学校总部员工------------");\n        for (Employee e : list2) {\n            System.out.println(e.getId());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n> 分析问题:\n> \n>  1. 这里的 CollegeEmployee 不是 SchoolManager的直接朋友。SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager。\n>  2. CollegeEmployee 是以局部变量方式出现在 SchoolManager。\n>  3. 违反了 迪米特法则。\n\n# 2. 改进的思路和代码\n\n按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合\n\npublic class Demeter1 {\n\n    public static void main(String[] args) {\n        System.out.println("~~~使用迪米特法则的改进~~~");\n        // 创建了一个 SchoolManager 对象\n        SchoolManager schoolManager = new SchoolManager();\n        // 输出学院的员工id 和  学校总部的员工信息\n        schoolManager.printAllEmployee(new CollegeManager());\n\n    }\n\n}\n\n\n/**\n * 学校总部员工类\n */\nclass Employee {\n    private String id;\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getId() {\n        return id;\n    }\n}\n\n\n/**\n * 学院的员工类\n */\nclass CollegeEmployee {\n    private String id;\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getId() {\n        return id;\n    }\n}\n\n\n/**\n * 管理学院员工的管理类\n */\nclass CollegeManager {\n    /**\n     * 返回学院的所有员工\n     *\n     * @return\n     */\n    public List<CollegeEmployee> getAllEmployee() {\n        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();\n        // 这里我们增加了10个员工到 list\n        for (int i = 0; i < 10; i++) {\n            CollegeEmployee emp = new CollegeEmployee();\n            emp.setId("学院员工id= " + i);\n            list.add(emp);\n        }\n        return list;\n    }\n\n    /**\n     * 输出学院员工的信息\n     */\n    public void printEmployee() {\n        // 获取到学院员工\n        List<CollegeEmployee> list1 = getAllEmployee();\n        System.out.println("------------学院员工------------");\n        for (CollegeEmployee e : list1) {\n            System.out.println(e.getId());\n        }\n    }\n}\n\n/**\n * 学校管理类\n */\nclass SchoolManager {\n    /**\n     * 返回学校总部的员工\n     *\n     * @return\n     */\n    public List<Employee> getAllEmployee() {\n        List<Employee> list = new ArrayList<Employee>();\n        // 这里我们增加了5个员工到 list\n        for (int i = 0; i < 5; i++) {\n            Employee emp = new Employee();\n            emp.setId("学校总部员工id= " + i);\n            list.add(emp);\n        }\n        return list;\n    }\n\n    /**\n     * 该方法完成输出学校总部和学院员工信息(id)\n     *\n     * @param sub\n     */\n    void printAllEmployee(CollegeManager sub) {\n\n        // 将输出学院的员工方法，封装到CollegeManager\n        sub.printEmployee();\n\n        // 获取到学校总部员工\n        List<Employee> list2 = this.getAllEmployee();\n        System.out.println("------------学校总部员工------------");\n        for (Employee e : list2) {\n            System.out.println(e.getId());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n\n\n\n# 3. 迪米特法则注意事项和细节\n\n 1. 迪米特法则的核心: 降低类之间的耦合\n\n 2. 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系\n\n\n# 9. 合成复用原则\n\n\n# 1. 基本介绍\n\n原则是尽量使用合成/聚合的方式，而不是使用继承\n\n\n\n\n# 2. 核心思想\n\n 1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。\n\n 2. 针对接口编程，而不是针对实现编程。\n\n 3. 为了交互对象之间的松耦合设计而努力',normalizedContent:'# java设计模式-设计模式的七大原则\n\n\n# 1. 设计模式的目的\n\n编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的\n\n挑战，设计模式是为了让程序(软件)，具有更好\n\n 1. 代码重用性 ：相同功能的代码，不用多次编写\n\n 2. 可读性：编程规范性, 便于其他程序员的阅读和理解\n\n 3. 可扩展性 ：当需要增加新的功能时，非常的方便，称为可维护\n\n 4. 可靠性 ：当我们增加新的功能后，对原来的功能没有影响\n\n 5. 使程序呈现高内聚，低耦合的特性\n\n> 分享金句：\n\n 1. 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（ooa/d）的精要”\n 2. scott mayers 在其巨著《effective c++》就曾经说过：c++老手和 c++新手的区别就是前者手背上有很多伤疤\n\n\n# 2. 设计模式的七大原则\n\n设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础。\n\n设计模式常用的七大原则有:\n\n * 单一职责原则\n * 接口隔离原则\n * 依赖倒转(倒置)原则\n * 里氏替换原则\n * 开闭原则 ocp原则\n * 迪米特法则\n * 合成复用原则\n\n\n# 3. 单一职责原则\n\n\n# 1. 基本介绍\n\n对类来说的，即一个类应该只负责一项职责。如类 a 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 a 时，可能造成职责 2 执行错误，所以需要将类 a 的粒度分解为 a1，a2\n\n\n# 2. 示例\n\n> 此处使用交通工具类作为演示单一职责原则。\n\n# 方式一：\n\npublic class singleresponsibility1 {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n      vehicle vehicle = new vehicle();\n      vehicle.run("摩托车");\n      vehicle.run("汽车");\n      vehicle.run("飞机");\n   }\n\n}\n\n/**\n * 交通类\n */\nclass vehicle {\n   public void run(string vehicle) {\n      system.out.println(vehicle + " 在公路上运行....");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 方式一的分析：\n> \n>  1. 在方式1 的run方法中，违反了单一职责原则\n>  2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可\n\n# 方式二：\n\npublic class singleresponsibility2 {\n\n\tpublic static void main(string[] args) {\n\t\t// todo auto-generated method stub\n\t\troadvehicle roadvehicle = new roadvehicle();\n\t\troadvehicle.run("摩托车");\n\t\troadvehicle.run("汽车");\n\t\t\n\t\tairvehicle airvehicle = new airvehicle();\n\t\t\n\t\tairvehicle.run("飞机");\n\t}\n\n}\n\nclass roadvehicle {\n\tpublic void run(string vehicle) {\n\t\tsystem.out.println(vehicle + "公路运行");\n\t}\n}\n\nclass airvehicle {\n\tpublic void run(string vehicle) {\n\t\tsystem.out.println(vehicle + "天空运行");\n\t}\n}\n\nclass watervehicle {\n\tpublic void run(string vehicle) {\n\t\tsystem.out.println(vehicle + "水中运行");\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n> 方式二的分析：\n> \n>  1. 遵守单一职责原则\n>  2. 但是这样做的改动很大，即将类分解，同时修改客户端\n\n# 方式三\n\npublic class singleresponsibility3 {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n      vehicle2 vehicle2  = new vehicle2();\n      vehicle2.run("汽车");\n      vehicle2.runwater("轮船");\n      vehicle2.runair("飞机");\n   }\n\n}\n\nclass vehicle2 {\n   public void run(string vehicle) {\n      //处理\n      system.out.println(vehicle + " 在公路上运行....");  \n   }\n   \n   public void runair(string vehicle) {\n      system.out.println(vehicle + " 在天空上运行....");\n   }\n   \n   public void runwater(string vehicle) {\n      system.out.println(vehicle + " 在水中行....");\n   }\n   \n   //方法2.\n   //..\n   //..\n   \n   //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n> 方式三的分析：\n> \n>  1. 这种修改方法没有对原来的类做大的修改，只是增加方法\n>  2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责\n\n\n# 3. 注意事项和细节\n\n 1. 降低类的复杂度，一个类只负责一项职责。\n\n 2. 提高类的可读性，可维护性\n\n 3. 降低变更引起的风险\n\n 4. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则(比如代码中的方式三)；只有类中 方法数量足够少，可以在方法级别保持单一职责原则\n\n\n# 4. 接口隔离原则\n\n\n# 1. 基本介绍\n\n 1. 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上\n\n\n# 2. 示例\n\n示例：\n\n * 类 a 通过接口 interface1 依赖类 b，类 c 通过接口 interface1 依赖类 d，如果接口 interface1 对于类 a 和类 c 来说不是最小接口，那么类 b 和类 d 必须去实现他们不需要的方法。\n\n * 按隔离原则应当这样处理：\n   \n   将接口 interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 a 和类 c 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n\n# 1. 原始代码\n\n> 类 a 通过接口 interface1 依赖类 b，类 c 通过接口 interface1 依赖类 d，请编写代码完成此应用实例\n\n * 类图\n\n\n\n * 代码\n\npublic class segregation1 {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n\n   }\n\n}\n\n//接口\ninterface interface1 {\n   void operation1();\n   void operation2();\n   void operation3();\n   void operation4();\n   void operation5();\n}\n\nclass b implements interface1 {\n   public void operation1() {\n      system.out.println("b 实现了 operation1");\n   }\n   \n   public void operation2() {\n      system.out.println("b 实现了 operation2");\n   }\n   public void operation3() {\n      system.out.println("b 实现了 operation3");\n   }\n   public void operation4() {\n      system.out.println("b 实现了 operation4");\n   }\n   public void operation5() {\n      system.out.println("b 实现了 operation5");\n   }\n}\n\nclass d implements interface1 {\n   public void operation1() {\n      system.out.println("d 实现了 operation1");\n   }\n   \n   public void operation2() {\n      system.out.println("d 实现了 operation2");\n   }\n   public void operation3() {\n      system.out.println("d 实现了 operation3");\n   }\n   public void operation4() {\n      system.out.println("d 实现了 operation4");\n   }\n   public void operation5() {\n      system.out.println("d 实现了 operation5");\n   }\n}\n\nclass a { //a 类通过接口interface1 依赖(使用) b类，但是只会用到1,2,3方法\n   public void depend1(interface1 i) {\n      i.operation1();\n   }\n   public void depend2(interface1 i) {\n      i.operation2();\n   }\n   public void depend3(interface1 i) {\n      i.operation3();\n   }\n}\n  \nclass c { //c 类通过接口interface1 依赖(使用) d类，但是只会用到1,4,5方法\n   public void depend1(interface1 i) {\n      i.operation1();\n   }\n   public void depend4(interface1 i) {\n      i.operation4();\n   }\n   public void depend5(interface1 i) {\n      i.operation5();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n# 2. 接口隔离原则改造后代码\n\n>  1. 类 a 通过接口 interface1 依赖类 b，类 c 通过接口 interface1 依赖类 d，如果接口 interface1 对于类 a 和类 c来说不是最小接口，那么类 b 和类 d 必须去实现他们不需要的方法\n> \n>  2. 将接口 interface1 拆分为独立的几个接口，类 a 和类 c 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n> \n>  3. 接口 interface1 中出现的方法，根据实际情况拆分为三个接口\n\n * 类图\n\n\n\n * 代码\n\npublic class segregation1 {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n\n   }\n\n}\n\n//接口\ninterface interface1 {\n   void operation1();\n   void operation2();\n   void operation3();\n   void operation4();\n   void operation5();\n}\n\nclass b implements interface1 {\n   public void operation1() {\n      system.out.println("b 实现了 operation1");\n   }\n   \n   public void operation2() {\n      system.out.println("b 实现了 operation2");\n   }\n   public void operation3() {\n      system.out.println("b 实现了 operation3");\n   }\n   public void operation4() {\n      system.out.println("b 实现了 operation4");\n   }\n   public void operation5() {\n      system.out.println("b 实现了 operation5");\n   }\n}\n\nclass d implements interface1 {\n   public void operation1() {\n      system.out.println("d 实现了 operation1");\n   }\n   \n   public void operation2() {\n      system.out.println("d 实现了 operation2");\n   }\n   public void operation3() {\n      system.out.println("d 实现了 operation3");\n   }\n   public void operation4() {\n      system.out.println("d 实现了 operation4");\n   }\n   public void operation5() {\n      system.out.println("d 实现了 operation5");\n   }\n}\n\nclass a { //a 类通过接口interface1 依赖(使用) b类，但是只会用到1,2,3方法\n   public void depend1(interface1 i) {\n      i.operation1();\n   }\n   public void depend2(interface1 i) {\n      i.operation2();\n   }\n   public void depend3(interface1 i) {\n      i.operation3();\n   }\n}\n  \nclass c { //c 类通过接口interface1 依赖(使用) d类，但是只会用到1,4,5方法\n   public void depend1(interface1 i) {\n      i.operation1();\n   }\n   public void depend4(interface1 i) {\n      i.operation4();\n   }\n   public void depend5(interface1 i) {\n      i.operation5();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# 5. 依赖倒转原则\n\n\n# 1. 基本介绍\n\n依赖倒转原则(dependence inversion principle)是指：\n\n 1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象\n\n 2. 抽象不应该依赖细节，细节应该依赖抽象\n\n 3. 依赖倒转(倒置)的中心思想是：面向接口编程\n\n 4. 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java中，抽象指的是接口或抽象类，细节就是具体的实现类\n\n 5. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成\n\n\n# 2. 示例\n\n程完成 person 接收消息 的功能\n\n# 1. 方式一：\n\npublic class dependecyinversion {\n\n    public static void main(string[] args) {\n        person person = new person();\n        person.receive(new email());\n    }\n\n}\n\n/**\n * 邮件类\n */\nclass email {\n    public string getinfo() {\n        return "电子邮件信息: hello,world";\n    }\n}\n\n/**\n * person类\n */\nclass person {\n    public void receive(email email) {\n        system.out.println(email.getinfo());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 分析：简单，比较容易想到。如果我们获取的对象是 微信，短信等等，则新增类，同时person也要增加相应的接收方法\n\n# 2. 方式二：使用依赖倒转原则\n\n解决思路：解决思路：引入一个抽象的接口ireceiver, 表示接收者, 这样person类与接口ireceiver发生依赖。因为email, weixin 等等属于接收的范围，他们各自实现ireceiver 接口就ok, 这样我们就符号依赖倒转原则。\n\npublic class dependecyinversion2 {\n\n    public static void main(string[] args) {\n        person person = new person();\n        person.receive(new email());\n        person.receive(new weixin());\n    }\n\n}\n\n/**\n * 定义接口\n */\ninterface ireceiver {\n    public string getinfo();\n}\n\n/**\n * 邮件类\n */\nclass email implements ireceiver {\n    public string getinfo() {\n        return "电子邮件信息: hello,world";\n    }\n}\n\n/**\n * 微信类\n */\nclass weixin implements ireceiver {\n    public string getinfo() {\n        return "微信信息: hello,ok";\n    }\n}\n\n\n/**\n * person类\n */\nclass person {\n    // 这里我们是对接口的依赖\n    public void receive(ireceiver receiver ) {\n        system.out.println(receiver.getinfo());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 3. 依赖关系传递的三种方式\n\n# 1. 接口传递\n\npublic class dependencypass1 {\n\n    public static void main(string[] args) {\n        // 通过接口传递实现依赖\n        changhong changhong = new changhong();\n        openandclose openandclose = new openandclose();\n        openandclose.open(changhong);\n    }\n\n}\n\n/**\n * 开关的接口\n */\ninterface iopenandclose {\n\n    /**\n     * 抽象方法,接收接口\n     *\n     * @param tv\n     */\n    public void open(itv tv);\n}\n\n/**\n * itv接口\n */\ninterface itv {\n    public void play();\n}\n\n\n/**\n * 实现itv接口\n */\nclass changhong implements itv {\n\n    @override\n    public void play() {\n        system.out.println("长虹电视机，打开");\n    }\n\n}\n\n/**\n * 实现开关接口\n */\nclass openandclose implements iopenandclose {\n    @override\n    public void open(itv tv) {\n        tv.play();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 2. 构造方法传递\n\npublic class dependencypass2 {\n\n    public static void main(string[] args) {\n        // 通过构造方法依赖传递\n        changhong changhong = new changhong();\n        openandclose openandclose = new openandclose(changhong);\n        openandclose.open();\n    }\n\n}\n\n/**\n * 开关的接口\n */\ninterface iopenandclose {\n\n    /**\n     * 抽象方法,接收接口\n     */\n    public void open();\n}\n\n\n/**\n * itv接口\n */\ninterface itv {\n    public void play();\n}\n\n/**\n * 实现itv接口\n */\nclass changhong implements itv {\n\n    @override\n    public void play() {\n        system.out.println("长虹电视机，打开");\n    }\n\n}\n\n/**\n * 实现开关接口\n */\nclass openandclose implements iopenandclose {\n\n    /**\n     * 成员\n     */\n    public itv tv;\n\n    /**\n     * 构造器\n     *\n     * @param tv\n     */\n    public openandclose(itv tv) {\n        this.tv = tv;\n    }\n\n    /**\n     * 开关方法\n     */\n    public void open() {\n        this.tv.play();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n# 3. setter方法传递\n\npublic class dependencypass3 {\n\n    public static void main(string[] args) {\n        // 通过set方法依赖传递\n        changhong changhong = new changhong();\n        openandclose openandclose = new openandclose();\n        openandclose.settv(changhong);\n        openandclose.open();\n    }\n\n}\n\n/**\n * 开关的接口\n */\ninterface iopenandclose {\n\n    /**\n     * 抽象方法,接收接口\n     */\n    public void open();\n}\n\n\n/**\n * itv接口\n */\ninterface itv {\n    public void play();\n}\n\n/**\n * 实现itv接口\n */\nclass changhong implements itv {\n\n    @override\n    public void play() {\n        system.out.println("长虹电视机，打开");\n    }\n\n}\n\n/**\n * 实现开关接口\n */\nclass openandclose implements iopenandclose {\n\n    /**\n     * 成员\n     */\n    public itv tv;\n\n    /**\n     * set方法\n     *\n     * @param tv\n     */\n    public void settv(itv tv) {\n        this.tv = tv;\n    }\n\n    /**\n     * 开关方法\n     */\n    public void open() {\n        this.tv.play();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 6. 里式替换原则\n\n\n# 1. oo 中的继承性的思考和说明\n\n 1. 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。\n\n 2. 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障\n\n 3. 问题提出：在编程中，如何正确的使用继承? => 里氏替换原则\n\n\n# 2. 基本介绍\n\n 1. 里氏替换原则(liskov substitution principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。\n\n 2. 如果对每个类型为 t1 的对象 o1，都有类型为 t2 的对象 o2，使得以 t1 定义的所有程序 p 在所有的对象 o1 都代换成 o2 时，程序 p 的行为没有发生变化，那么类型 t2 是类型 t1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。\n\n 3. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法\n\n 4. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。.\n\n> 子类中尽量不要重写父类的方法：是针对普通类。当类为接口、抽象类时候使用重写。\n\n\n# 3. 一个程序引出的问题和思考\n\n# 1. 问题\n\npublic class liskov {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n      a a = new a();\n      system.out.println("11-3=" + a.func1(11, 3));\n      system.out.println("1-8=" + a.func1(1, 8));\n\n      system.out.println("-----------------------");\n      b b = new b();\n      // 这里本意是求出11-3\n      system.out.println("11-3=" + b.func1(11, 3));\n      // 1-8\n      system.out.println("1-8=" + b.func1(1, 8));\n      system.out.println("11+3+9=" + b.func2(11, 3));\n\n   }\n\n}\n\n/**\n *  a类\n */\nclass a {\n   /**\n    * 返回两个数的差\n    * @param num1\n    * @param num2\n    * @return\n    */\n   public int func1(int num1, int num2) {\n      return num1 - num2;\n   }\n}\n\n/**\n * b类继承了a\n *\n *  增加了一个新功能：完成两个数相加,然后和9求和\n */\nclass b extends a {\n   /**\n    * 这里，重写了a类的方法, 可能是无意识\n    * @param a\n    * @param b\n    * @return\n    */\n   @override\n   public int func1(int a, int b) {\n      return a + b;\n   }\n\n   public int func2(int a, int b) {\n      return func1(a, b) + 9;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n# 2. 思考和解决思路\n\n 1. 我们发现原来运行正常的相减功能发生了错误。原因就是类 b 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类方法完成新的功能，这样写起来虽然简单，但整个继承体系的尚硅谷 java 设计模式 复用性会比较差。特别是运行多态比较频繁的时候\n\n 2. 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替\n\n 3. 改进方案\n    \n    \n\n# 3. 改进方案实现\n\npublic class liskov {\n\n    public static void main(string[] args) {\n        // todo auto-generated method stub\n        a a = new a();\n        system.out.println("11-3=" + a.func1(11, 3));\n        system.out.println("1-8=" + a.func1(1, 8));\n\n        system.out.println("-----------------------");\n        b b = new b();\n\n        //因为b类不再继承a类，因此调用者，不会再func1是求减法\n        //调用完成的功能就会很明确\n        //这里本意是求出11+3\n        system.out.println("11+3=" + b.func1(11, 3));\n        // 1+8\n        system.out.println("1+8=" + b.func1(1, 8));\n        system.out.println("11+3+9=" + b.func2(11, 3));\n\n\n        //使用组合仍然可以使用到a类相关方法\n        // 这里本意是求出11-3\n        system.out.println("11-3=" + b.func3(11, 3));\n    }\n\n}\n\n/**\n * 创建一个更加基础的基类\n */\nclass base {\n    //把更加基础的方法和成员写到base类\n}\n\n/**\n * a类\n */\nclass a extends base {\n    /**\n     * 返回两个数的差\n     *\n     * @param num1\n     * @param num2\n     * @return\n     */\n    public int func1(int num1, int num2) {\n        return num1 - num2;\n    }\n}\n\n/**\n * b类继承了a\n * <p>\n * 增加了一个新功能：完成两个数相加,然后和9求和\n */\nclass b extends base {\n    /**\n     * 如果b需要使用a类的方法,使用组合关系\n     */\n    private a a = new a();\n\n    /**\n     * 这里，重写了a类的方法, 可能是无意识\n     *\n     * @param a\n     * @param b\n     * @return\n     */\n    public int func1(int a, int b) {\n        return a + b;\n    }\n\n    public int func2(int a, int b) {\n        return func1(a, b) + 9;\n    }\n\n    /**\n     * 我们仍然想使用a的方法\n     *\n     * @param a\n     * @param b\n     * @return\n     */\n    public int func3(int a, int b) {\n        return this.a.func1(a, b);\n    }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n> b类中的 func3使用组合。\n\n\n# 7. 开闭原则\n\n\n# 1. 基本介绍\n\n 1. 开闭原则（open closed principle）是编程中最基础、最重要的设计原则\n\n 2. 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。\n\n 3. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。\n\n 4. 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。\n\n\n# 2. 看一个画图形的功能\n\n# 1. 方式一实现\n\npublic class ocp {\n\n    public static void main(string[] args) {\n        //使用看看存在的问题\n        graphiceditor graphiceditor = new graphiceditor();\n        graphiceditor.drawshape(new rectangle());\n        graphiceditor.drawshape(new circle());\n        graphiceditor.drawshape(new triangle());\n    }\n\n}\n\n/**\n * 这是一个用于绘图的类 [使用方]\n */\nclass graphiceditor {\n    /**\n     * 接收shape对象，然后根据type，来绘制不同的图形\n     *\n     * @param s\n     */\n    public void drawshape(shape s) {\n        if (s.m_type == 1) {\n            drawrectangle(s);\n        } else if (s.m_type == 2) {\n            drawcircle(s);\n        } else if (s.m_type == 3) {\n            drawtriangle(s);\n        }\n    }\n\n    /**\n     * 绘制矩形\n     *\n     * @param r\n     */\n    public void drawrectangle(shape r) {\n        system.out.println(" 绘制矩形 ");\n    }\n\n    /**\n     * 绘制圆形\n     *\n     * @param r\n     */\n    public void drawcircle(shape r) {\n        system.out.println(" 绘制圆形 ");\n    }\n\n    /**\n     * 绘制三角形\n     *\n     * @param r\n     */\n    public void drawtriangle(shape r) {\n        system.out.println(" 绘制三角形 ");\n    }\n}\n\n/**\n * shape形状类，基类\n */\nclass shape {\n    int m_type;\n}\n\n/**\n * 矩形类\n */\nclass rectangle extends shape {\n    rectangle() {\n        super.m_type = 1;\n    }\n}\n\n/**\n * 圆类\n */\nclass circle extends shape {\n    circle() {\n        super.m_type = 2;\n    }\n}\n\n/**\n * 新增画三角形\n */\nclass triangle extends shape {\n    triangle() {\n        super.m_type = 3;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n# 2. 方式一的优缺点\n\n 1. 优点是比较好理解，简单易操作。\n\n 2. 缺点是违反了设计模式的 ocp 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n 3. 比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多\n\n# 3. 改进思路分析和实现\n\n把创建 shape 类做成抽象类，并提供一个抽象的 draw 方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承 shape，并实现 draw 方法即可，使用方的代码就不需要修 -> 满足了开闭原则\n\npublic class ocp {\n\n   public static void main(string[] args) {\n      //使用看看存在的问题\n      graphiceditor graphiceditor = new graphiceditor();\n      graphiceditor.drawshape(new rectangle());\n      graphiceditor.drawshape(new circle());\n      graphiceditor.drawshape(new triangle());\n      graphiceditor.drawshape(new othergraphic());\n   }\n\n}\n\n/**\n * 这是一个用于绘图的类 [使用方]\n */\nclass graphiceditor {\n   /**\n    * 接收shape对象，调用draw方法\n    * @param s\n    */\n   public void drawshape(shape s) {\n      s.draw();\n   }\n\n   \n}\n\n/**\n * shape形状类，基类\n */\nabstract class shape {\n   int m_type;\n\n   /**\n    * 抽象方法\n    */\n   public abstract void draw();\n}\n\n/**\n * 矩形类\n */\nclass rectangle extends shape {\n   rectangle() {\n      super.m_type = 1;\n   }\n\n   @override\n   public void draw() {\n      // todo auto-generated method stub\n      system.out.println(" 绘制矩形 ");\n   }\n}\n\n/**\n * 圆类\n */\nclass circle extends shape {\n   circle() {\n      super.m_type = 2;\n   }\n   @override\n   public void draw() {\n      // todo auto-generated method stub\n      system.out.println(" 绘制圆形 ");\n   }\n}\n\n/**\n * 新增画三角形\n */\nclass triangle extends shape {\n   triangle() {\n      super.m_type = 3;\n   }\n   @override\n   public void draw() {\n      // todo auto-generated method stub\n      system.out.println(" 绘制三角形 ");\n   }\n}\n\n/**\n * 新增一个图形\n */\nclass othergraphic extends shape {\n   othergraphic() {\n      super.m_type = 4;\n   }\n\n   @override\n   public void draw() {\n      // todo auto-generated method stub\n      system.out.println(" 绘制其它图形 ");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n\n# 8. 迪米特原则\n\n\n# 1. 基本介绍\n\n 1. 一个对象应该对其他对象保持最少的了解\n\n 2. 类与类关系越密切，耦合度越大\n\n 3. 迪米特法则(demeter principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息\n\n 4. 迪米特法则还有个更简单的定义：只与直接的朋友通信\n\n 5. 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。\n\n\n# 2. 应用实例\n\n有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 id 和学院员工的 id\n\n# 1. 代码\n\npublic class demeter1 {\n\n    public static void main(string[] args) {\n        // 创建了一个 schoolmanager 对象\n        schoolmanager schoolmanager = new schoolmanager();\n        // 输出学院的员工id 和  学校总部的员工信息\n        schoolmanager.printallemployee(new collegemanager());\n\n    }\n\n}\n\n\n/**\n * 学校总部员工类\n */\nclass employee {\n    private string id;\n\n    public void setid(string id) {\n        this.id = id;\n    }\n\n    public string getid() {\n        return id;\n    }\n}\n\n\n/**\n * 学院的员工类\n */\nclass collegeemployee {\n    private string id;\n\n    public void setid(string id) {\n        this.id = id;\n    }\n\n    public string getid() {\n        return id;\n    }\n}\n\n\n/**\n * 管理学院员工的管理类\n */\nclass collegemanager {\n    /**\n     * 返回学院的所有员工\n     *\n     * @return\n     */\n    public list<collegeemployee> getallemployee() {\n        list<collegeemployee> list = new arraylist<collegeemployee>();\n        // 这里我们增加了10个员工到 list\n        for (int i = 0; i < 10; i++) {\n            collegeemployee emp = new collegeemployee();\n            emp.setid("学院员工id= " + i);\n            list.add(emp);\n        }\n        return list;\n    }\n}\n\n/**\n * 学校管理类\n * <p>\n * 分析 schoolmanager 类的直接朋友类有哪些 employee、collegemanager\n * <p>\n * collegeemployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则\n */\nclass schoolmanager {\n    /**\n     * 返回学校总部的员工\n     *\n     * @return\n     */\n    public list<employee> getallemployee() {\n        list<employee> list = new arraylist<employee>();\n        // 这里我们增加了5个员工到 list\n        for (int i = 0; i < 5; i++) {\n            employee emp = new employee();\n            emp.setid("学校总部员工id= " + i);\n            list.add(emp);\n        }\n        return list;\n    }\n\n    /**\n     * 该方法完成输出学校总部和学院员工信息(id)\n     *\n     * @param sub\n     */\n    void printallemployee(collegemanager sub) {\n\n        //分析问题\n        //1. 这里的 collegeemployee 不是  schoolmanager的直接朋友\n        //2. collegeemployee 是以局部变量方式出现在 schoolmanager\n        //3. 违反了 迪米特法则 \n\n        // 获取到学院员工\n        list<collegeemployee> list1 = sub.getallemployee();\n        system.out.println("------------学院员工------------");\n        for (collegeemployee e : list1) {\n            system.out.println(e.getid());\n        }\n        // 获取到学校总部员工\n        list<employee> list2 = this.getallemployee();\n        system.out.println("------------学校总部员工------------");\n        for (employee e : list2) {\n            system.out.println(e.getid());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n> 分析问题:\n> \n>  1. 这里的 collegeemployee 不是 schoolmanager的直接朋友。schoolmanager 类的直接朋友类有哪些 employee、collegemanager。\n>  2. collegeemployee 是以局部变量方式出现在 schoolmanager。\n>  3. 违反了 迪米特法则。\n\n# 2. 改进的思路和代码\n\n按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合\n\npublic class demeter1 {\n\n    public static void main(string[] args) {\n        system.out.println("~~~使用迪米特法则的改进~~~");\n        // 创建了一个 schoolmanager 对象\n        schoolmanager schoolmanager = new schoolmanager();\n        // 输出学院的员工id 和  学校总部的员工信息\n        schoolmanager.printallemployee(new collegemanager());\n\n    }\n\n}\n\n\n/**\n * 学校总部员工类\n */\nclass employee {\n    private string id;\n\n    public void setid(string id) {\n        this.id = id;\n    }\n\n    public string getid() {\n        return id;\n    }\n}\n\n\n/**\n * 学院的员工类\n */\nclass collegeemployee {\n    private string id;\n\n    public void setid(string id) {\n        this.id = id;\n    }\n\n    public string getid() {\n        return id;\n    }\n}\n\n\n/**\n * 管理学院员工的管理类\n */\nclass collegemanager {\n    /**\n     * 返回学院的所有员工\n     *\n     * @return\n     */\n    public list<collegeemployee> getallemployee() {\n        list<collegeemployee> list = new arraylist<collegeemployee>();\n        // 这里我们增加了10个员工到 list\n        for (int i = 0; i < 10; i++) {\n            collegeemployee emp = new collegeemployee();\n            emp.setid("学院员工id= " + i);\n            list.add(emp);\n        }\n        return list;\n    }\n\n    /**\n     * 输出学院员工的信息\n     */\n    public void printemployee() {\n        // 获取到学院员工\n        list<collegeemployee> list1 = getallemployee();\n        system.out.println("------------学院员工------------");\n        for (collegeemployee e : list1) {\n            system.out.println(e.getid());\n        }\n    }\n}\n\n/**\n * 学校管理类\n */\nclass schoolmanager {\n    /**\n     * 返回学校总部的员工\n     *\n     * @return\n     */\n    public list<employee> getallemployee() {\n        list<employee> list = new arraylist<employee>();\n        // 这里我们增加了5个员工到 list\n        for (int i = 0; i < 5; i++) {\n            employee emp = new employee();\n            emp.setid("学校总部员工id= " + i);\n            list.add(emp);\n        }\n        return list;\n    }\n\n    /**\n     * 该方法完成输出学校总部和学院员工信息(id)\n     *\n     * @param sub\n     */\n    void printallemployee(collegemanager sub) {\n\n        // 将输出学院的员工方法，封装到collegemanager\n        sub.printemployee();\n\n        // 获取到学校总部员工\n        list<employee> list2 = this.getallemployee();\n        system.out.println("------------学校总部员工------------");\n        for (employee e : list2) {\n            system.out.println(e.getid());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n\n\n\n# 3. 迪米特法则注意事项和细节\n\n 1. 迪米特法则的核心: 降低类之间的耦合\n\n 2. 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系\n\n\n# 9. 合成复用原则\n\n\n# 1. 基本介绍\n\n原则是尽量使用合成/聚合的方式，而不是使用继承\n\n\n\n\n# 2. 核心思想\n\n 1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。\n\n 2. 针对接口编程，而不是针对实现编程。\n\n 3. 为了交互对象之间的松耦合设计而努力',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Java设计模式-UML类图",frontmatter:{title:"Java设计模式-UML类图",date:"2023-02-25T20:46:26.000Z",permalink:"/pages/5247a4/"},regularPath:"/02.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML%E7%B1%BB%E5%9B%BE.html",relativePath:"02.编程基础/04.设计模式/2.Java设计模式-UML类图.md",key:"v-611843b4",path:"/pages/5247a4/",headers:[{level:2,title:"1. UML基本介绍",slug:"_1-uml基本介绍",normalizedTitle:"1. uml基本介绍",charIndex:21},{level:2,title:"2. UML 图",slug:"_2-uml-图",normalizedTitle:"2. uml 图",charIndex:296},{level:2,title:"3. UML类图",slug:"_3-uml类图",normalizedTitle:"3. uml类图",charIndex:494},{level:3,title:"1. 基本描述",slug:"_1-基本描述",normalizedTitle:"1. 基本描述",charIndex:507},{level:3,title:"2. 类图-依赖关系（Dependence）",slug:"_2-类图-依赖关系-dependence",normalizedTitle:"2. 类图-依赖关系（dependence）",charIndex:992},{level:4,title:"1. 源码",slug:"_1-源码",normalizedTitle:"1. 源码",charIndex:1062},{level:4,title:"2. 类图",slug:"_2-类图",normalizedTitle:"2. 类图",charIndex:992},{level:4,title:"3. 小结:",slug:"_3-小结",normalizedTitle:"3. 小结:",charIndex:1515},{level:3,title:"3. 类图-泛化关系(generalization）",slug:"_3-类图-泛化关系-generalization",normalizedTitle:"3. 类图-泛化关系(generalization）",charIndex:1598},{level:4,title:"1. 源码",slug:"_1-源码-2",normalizedTitle:"1. 源码",charIndex:1062},{level:4,title:"2. 类图",slug:"_2-类图-2",normalizedTitle:"2. 类图",charIndex:992},{level:4,title:"3. 小结",slug:"_3-小结-2",normalizedTitle:"3. 小结",charIndex:1515},{level:3,title:"4. 类图-关联关系(Association)",slug:"_4-类图-关联关系-association",normalizedTitle:"4. 类图-关联关系(association)",charIndex:1938},{level:3,title:"5. 类图-聚合关系(Aggregation)",slug:"_5-类图-聚合关系-aggregation",normalizedTitle:"5. 类图-聚合关系(aggregation)",charIndex:1968},{level:4,title:"1. 基本介绍",slug:"_1-基本介绍",normalizedTitle:"1. 基本介绍",charIndex:1995},{level:4,title:"2. 应用实例",slug:"_2-应用实例",normalizedTitle:"2. 应用实例",charIndex:2154},{level:3,title:"6. 类图—组合关系（Composition）",slug:"_6-类图-组合关系-composition",normalizedTitle:"6. 类图—组合关系（composition）",charIndex:2168},{level:4,title:"基本信息",slug:"基本信息",normalizedTitle:"基本信息",charIndex:2195}],headersStr:"1. UML基本介绍 2. UML 图 3. UML类图 1. 基本描述 2. 类图-依赖关系（Dependence） 1. 源码 2. 类图 3. 小结: 3. 类图-泛化关系(generalization） 1. 源码 2. 类图 3. 小结 4. 类图-关联关系(Association) 5. 类图-聚合关系(Aggregation) 1. 基本介绍 2. 应用实例 6. 类图—组合关系（Composition） 基本信息",content:"# Java设计模式-UML类图\n\n\n# 1. UML基本介绍\n\n 1. UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果\n\n 2. UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如图:\n\n 3. 使用 UML 来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模 。下图是Eclipse插件介绍。\n    \n    \n\n\n# 2. UML 图\n\n画 UML 图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML 图分类：\n\n 1. 用例图(use case)\n\n 2. 静态结构图：类图、对象图、包图、组件图、部署图\n\n 3. 动态行为图：交互图（时序图与协作图）、状态图、活动图\n\n> 说明： 类图是描述类与类之间的关系的，是 UML 图中最核心的。在讲解设计模式时，我们必然会使用类图。\n\n\n# 3. UML类图\n\n\n# 1. 基本描述\n\n 1. 用于描述系统中的类(对象)本身的组成和类(对)的各种静态关系。\n\n 2. 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。\n\n 3. 类图简单举例\n    \n    * 源码形式\n    \n    public class Person{\n        private Integer id; \n        private String name; \n        \n        public void setName(String name){ \n            this.name=name; \n        }\n        \n        public String getName(){\n            return name; \n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n    * 类图\n    \n    \n\n\n# 2. 类图-依赖关系（Dependence）\n\n只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。\n\n# 1. 源码\n\npublic class PersonServiceBean {\n    private PersonDao personDao;\n\n    public void save(Person person) {\n    }\n\n    public IDCard getIDCard(Integer personid) {\n        return new IDCard();\n    }\n\n    public void modify() {\n        Department department = new Department();\n    }\n}\n\nclass PersonDao {\n}\n\nclass IDCard {\n}\n\nclass Person {\n}\n\nclass Department {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 2. 类图\n\n\n\n# 3. 小结:\n\n 1. 类中用到了对方\n\n 2. 如果是类的成员属性\n\n 3. 如果是方法的返回类型\n\n 4. 是方法接收的参数类型\n\n 5. 方法中使用到\n\n\n# 3. 类图-泛化关系(generalization）\n\n> 泛化关系实际上就是继承关系，他是依赖关系的特例\n\n# 1. 源码\n\npublic abstract class DaoSupport{ \n\tpublic void save(Object entity){\n    }\n    public void delete(Object id){ \n    } \n}\n\npublic class PersonServiceBean extends Daosupport{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 2. 类图\n\n\n\n# 3. 小结\n\n 1. 泛化关系实际上就是继承关系。\n 2. 如果 A 类继承了 B 类，我们就说 A 和 B 存在泛化关系。\n\n\n# 4. 类图-关联关系(Association)\n\n\n\n\n# 5. 类图-聚合关系(Aggregation)\n\n# 1. 基本介绍\n\n聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。\n\n如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：\n\n# 2. 应用实例\n\n\n\n\n# 6. 类图—组合关系（Composition）\n\n# 基本信息\n\n组合关系：也是整体与部分的关系，但是整体与部分不可以分开。",normalizedContent:"# java设计模式-uml类图\n\n\n# 1. uml基本介绍\n\n 1. uml——unified modeling language uml (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果\n\n 2. uml 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如图:\n\n 3. 使用 uml 来建模，常用的工具有 rational rose , 也可以使用一些插件来建模 。下图是eclipse插件介绍。\n    \n    \n\n\n# 2. uml 图\n\n画 uml 图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，uml 图分类：\n\n 1. 用例图(use case)\n\n 2. 静态结构图：类图、对象图、包图、组件图、部署图\n\n 3. 动态行为图：交互图（时序图与协作图）、状态图、活动图\n\n> 说明： 类图是描述类与类之间的关系的，是 uml 图中最核心的。在讲解设计模式时，我们必然会使用类图。\n\n\n# 3. uml类图\n\n\n# 1. 基本描述\n\n 1. 用于描述系统中的类(对象)本身的组成和类(对)的各种静态关系。\n\n 2. 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。\n\n 3. 类图简单举例\n    \n    * 源码形式\n    \n    public class person{\n        private integer id; \n        private string name; \n        \n        public void setname(string name){ \n            this.name=name; \n        }\n        \n        public string getname(){\n            return name; \n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n    * 类图\n    \n    \n\n\n# 2. 类图-依赖关系（dependence）\n\n只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。\n\n# 1. 源码\n\npublic class personservicebean {\n    private persondao persondao;\n\n    public void save(person person) {\n    }\n\n    public idcard getidcard(integer personid) {\n        return new idcard();\n    }\n\n    public void modify() {\n        department department = new department();\n    }\n}\n\nclass persondao {\n}\n\nclass idcard {\n}\n\nclass person {\n}\n\nclass department {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 2. 类图\n\n\n\n# 3. 小结:\n\n 1. 类中用到了对方\n\n 2. 如果是类的成员属性\n\n 3. 如果是方法的返回类型\n\n 4. 是方法接收的参数类型\n\n 5. 方法中使用到\n\n\n# 3. 类图-泛化关系(generalization）\n\n> 泛化关系实际上就是继承关系，他是依赖关系的特例\n\n# 1. 源码\n\npublic abstract class daosupport{ \n\tpublic void save(object entity){\n    }\n    public void delete(object id){ \n    } \n}\n\npublic class personservicebean extends daosupport{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 2. 类图\n\n\n\n# 3. 小结\n\n 1. 泛化关系实际上就是继承关系。\n 2. 如果 a 类继承了 b 类，我们就说 a 和 b 存在泛化关系。\n\n\n# 4. 类图-关联关系(association)\n\n\n\n\n# 5. 类图-聚合关系(aggregation)\n\n# 1. 基本介绍\n\n聚合关系（aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。\n\n如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：\n\n# 2. 应用实例\n\n\n\n\n# 6. 类图—组合关系（composition）\n\n# 基本信息\n\n组合关系：也是整体与部分的关系，但是整体与部分不可以分开。",charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Java设计模式-设计模式概述",frontmatter:{title:"Java设计模式-设计模式概述",date:"2023-02-25T20:46:26.000Z",permalink:"/pages/d2284f/"},regularPath:"/02.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0.html",relativePath:"02.编程基础/04.设计模式/3.Java设计模式-设计模式概述.md",key:"v-5320d5b4",path:"/pages/d2284f/",headers:[{level:2,title:"1. 掌握设计模式的层次",slug:"_1-掌握设计模式的层次",normalizedTitle:"1. 掌握设计模式的层次",charIndex:22},{level:2,title:"2. 设计模式介绍",slug:"_2-设计模式介绍",normalizedTitle:"2. 设计模式介绍",charIndex:270},{level:2,title:"3. 设计模式类型",slug:"_3-设计模式类型",normalizedTitle:"3. 设计模式类型",charIndex:591}],headersStr:"1. 掌握设计模式的层次 2. 设计模式介绍 3. 设计模式类型",content:"# Java设计模式-设计模式概述\n\n\n# 1. 掌握设计模式的层次\n\n 1. 第 1 层：刚开始学编程不久，听说过什么是设计模式\n\n 2. 第 2 层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道\n\n 3. 第 3 层：学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的\n\n 4. 第 4 层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处。\n\n 5. 第 5 层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来\n\n\n# 2. 设计模式介绍\n\n 1. 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n 2. 设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。\n 3. <<设计模式>> 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称 “四人组 GOF”） 。\n 4. 设计模式并不局限于某种语言，java，php，c++ 都有设计模式。\n\n\n# 3. 设计模式类型\n\n设计模式分为三种类型，共 23种\n\n 1. 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式\n 2. 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。\n 3. 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、 解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)。\n\n> 注意：不同的书籍上对分类和名称略有差别",normalizedContent:"# java设计模式-设计模式概述\n\n\n# 1. 掌握设计模式的层次\n\n 1. 第 1 层：刚开始学编程不久，听说过什么是设计模式\n\n 2. 第 2 层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道\n\n 3. 第 3 层：学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的\n\n 4. 第 4 层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处。\n\n 5. 第 5 层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来\n\n\n# 2. 设计模式介绍\n\n 1. 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n 2. 设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。\n 3. <<设计模式>> 是经典的书，作者是 erich gamma、richard helm、ralph johnson 和 john vlissides design（俗称 “四人组 gof”） 。\n 4. 设计模式并不局限于某种语言，java，php，c++ 都有设计模式。\n\n\n# 3. 设计模式类型\n\n设计模式分为三种类型，共 23种\n\n 1. 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式\n 2. 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。\n 3. 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、 解释器模式（interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)。\n\n> 注意：不同的书籍上对分类和名称略有差别",charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Java设计模式-单例模式",frontmatter:{title:"Java设计模式-单例模式",date:"2023-02-25T20:46:26.000Z",permalink:"/pages/4c822c/"},regularPath:"/02.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"02.编程基础/04.设计模式/4.Java设计模式-单例模式.md",key:"v-771f7249",path:"/pages/4c822c/",headers:[{level:2,title:"1. 单例设计模式介绍",slug:"_1-单例设计模式介绍",normalizedTitle:"1. 单例设计模式介绍",charIndex:20},{level:2,title:"2. 单例设计模式八种方式",slug:"_2-单例设计模式八种方式",normalizedTitle:"2. 单例设计模式八种方式",charIndex:243},{level:3,title:"1. 单例模式有八种方式：",slug:"_1-单例模式有八种方式",normalizedTitle:"1. 单例模式有八种方式：",charIndex:261},{level:3,title:"2. 推荐的模式",slug:"_2-推荐的模式",normalizedTitle:"2. 推荐的模式",charIndex:421},{level:2,title:"3. 单例设计模式-示例",slug:"_3-单例设计模式-示例",normalizedTitle:"3. 单例设计模式-示例",charIndex:548},{level:3,title:"1. 饿汉式(静态常量)",slug:"_1-饿汉式-静态常量",normalizedTitle:"1. 饿汉式(静态常量)",charIndex:277},{level:4,title:"1. 代码实现",slug:"_1-代码实现",normalizedTitle:"1. 代码实现",charIndex:581},{level:4,title:"2. 优缺点",slug:"_2-优缺点",normalizedTitle:"2. 优缺点",charIndex:1619},{level:3,title:"2. 饿汉式(静态代码块)",slug:"_2-饿汉式-静态代码块",normalizedTitle:"2. 饿汉式(静态代码块)",charIndex:292},{level:4,title:"1. 代码实现",slug:"_1-代码实现-2",normalizedTitle:"1. 代码实现",charIndex:581},{level:4,title:"2. 优缺点",slug:"_2-优缺点-2",normalizedTitle:"2. 优缺点",charIndex:1619},{level:3,title:"3. 懒汉式(线程不安全)",slug:"_3-懒汉式-线程不安全",normalizedTitle:"3. 懒汉式(线程不安全)",charIndex:308},{level:4,title:"1. 代码实现",slug:"_1-代码实现-3",normalizedTitle:"1. 代码实现",charIndex:581},{level:4,title:"2. 优缺点",slug:"_2-优缺点-3",normalizedTitle:"2. 优缺点",charIndex:1619},{level:3,title:"4. 懒汉式(线程安全：同步方法)",slug:"_4-懒汉式-线程安全-同步方法",normalizedTitle:"4. 懒汉式(线程安全：同步方法)",charIndex:4156},{level:4,title:"1. 代码实现",slug:"_1-代码实现-4",normalizedTitle:"1. 代码实现",charIndex:581},{level:4,title:"2. 优缺点",slug:"_2-优缺点-4",normalizedTitle:"2. 优缺点",charIndex:1619},{level:3,title:"5. 懒汉式(同步代码块)",slug:"_5-懒汉式-同步代码块",normalizedTitle:"5. 懒汉式(同步代码块)",charIndex:5289},{level:4,title:"1. 代码实现",slug:"_1-代码实现-5",normalizedTitle:"1. 代码实现",charIndex:581},{level:4,title:"2. 优缺点",slug:"_2-优缺点-5",normalizedTitle:"2. 优缺点",charIndex:1619},{level:3,title:"6. 双重检查(DoubleCheck) 😄",slug:"_6-双重检查-doublecheck",normalizedTitle:"6. 双重检查(doublecheck) 😄",charIndex:6482},{level:4,title:"1. 代码实现",slug:"_1-代码实现-6",normalizedTitle:"1. 代码实现",charIndex:581},{level:4,title:"2. 优缺点",slug:"_2-优缺点-6",normalizedTitle:"2. 优缺点",charIndex:1619},{level:3,title:"7. 静态内部类 😄",slug:"_7-静态内部类",normalizedTitle:"7. 静态内部类 😄",charIndex:378},{level:4,title:"1. 代码实现",slug:"_1-代码实现-7",normalizedTitle:"1. 代码实现",charIndex:581},{level:4,title:"2. 优缺点",slug:"_2-优缺点-7",normalizedTitle:"2. 优缺点",charIndex:1619},{level:3,title:"8. 枚举方式 😄",slug:"_8-枚举方式",normalizedTitle:"8. 枚举方式 😄",charIndex:9244},{level:4,title:"1. 代码实现",slug:"_1-代码实现-8",normalizedTitle:"1. 代码实现",charIndex:581},{level:4,title:"2. 优缺点",slug:"_2-优缺点-8",normalizedTitle:"2. 优缺点",charIndex:1619},{level:2,title:"4. 单例模式在JDK应用的源码分析",slug:"_4-单例模式在jdk应用的源码分析",normalizedTitle:"4. 单例模式在jdk应用的源码分析",charIndex:9952},{level:2,title:"5. 单例模式注意事项和细节说明",slug:"_5-单例模式注意事项和细节说明",normalizedTitle:"5. 单例模式注意事项和细节说明",charIndex:10697}],headersStr:"1. 单例设计模式介绍 2. 单例设计模式八种方式 1. 单例模式有八种方式： 2. 推荐的模式 3. 单例设计模式-示例 1. 饿汉式(静态常量) 1. 代码实现 2. 优缺点 2. 饿汉式(静态代码块) 1. 代码实现 2. 优缺点 3. 懒汉式(线程不安全) 1. 代码实现 2. 优缺点 4. 懒汉式(线程安全：同步方法) 1. 代码实现 2. 优缺点 5. 懒汉式(同步代码块) 1. 代码实现 2. 优缺点 6. 双重检查(DoubleCheck) 😄 1. 代码实现 2. 优缺点 7. 静态内部类 😄 1. 代码实现 2. 优缺点 8. 枚举方式 😄 1. 代码实现 2. 优缺点 4. 单例模式在JDK应用的源码分析 5. 单例模式注意事项和细节说明",content:'# Java设计模式-单例模式\n\n\n# 1. 单例设计模式介绍\n\n所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。\n\n比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。\n\n\n# 2. 单例设计模式八种方式\n\n\n# 1. 单例模式有八种方式：\n\n 1. 饿汉式(静态常量)\n\n 2. 饿汉式(静态代码块)\n\n 3. 懒汉式(线程不安全)\n\n 4. 懒汉式(线程安全，同步方法)\n\n 5. 懒汉式(线程安全，同步代码块)\n\n 6. 双重检查 😄\n\n 7. 静态内部类 😄\n\n 8. 枚举 😄\n\n> 饿汉式二种；懒汉式三种。\n\n\n# 2. 推荐的模式\n\n单、多线程场景推荐：\n\n 1. 双重检查 😄\n 2. 静态内部类 😄\n 3. 枚举 😄\n\n单线程模式也推荐：\n\n 1. 饿汉式(静态常量)\n 2. 饿汉式(静态代码块)\n\n> 注意饿汉式在使用的时候创建，避免内存浪费。\n\n\n# 3. 单例设计模式-示例\n\n\n# 1. 饿汉式(静态常量)\n\n# 1. 代码实现\n\n 1. 构造器私有化 (防止 new )\n\n 2. 类的内部创建对象\n\n 3. 向外暴露一个静态的公共方法。getInstance()\n\npublic class SingletonTest01 {\n\n    public static void main(String[] args) {\n        // 测试\n        Singleton instance = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        // true\n        System.out.println(instance == instance2);\n        // instance.hashCode=460141958\n        System.out.println("instance.hashCode=" + instance.hashCode());\n        // instance2.hashCode=460141958\n        System.out.println("instance2.hashCode=" + instance2.hashCode());\n    }\n\n}\n\n/**\n * 饿汉式(静态变量)\n */\nclass Singleton {\n\n    /**\n     * 1. 构造器私有化, 外部能new\n     */\n    private Singleton() {\n\n    }\n\n    /**\n     * 2.本类内部创建对象实例\n     */\n    private final static Singleton instance = new Singleton();\n\n    /**\n     * 3. 提供一个公有的静态方法，返回实例对象\n     */\n    public static Singleton getInstance() {\n        return instance;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 2. 优缺点\n\n 1. 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。\n\n 2. 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。\n\n 3. 这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果。\n\n 4. 结论：这种单例模式可用，可能造成内存浪费。\n\n\n# 2. 饿汉式(静态代码块)\n\n# 1. 代码实现\n\npublic class SingletonTest02 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\t// true\n\t\tSystem.out.println(instance == instance2);\n\t\t// instance.hashCode=460141958\n\t\tSystem.out.println("instance.hashCode=" + instance.hashCode());\n\t\t// instance2.hashCode=460141958\n\t\tSystem.out.println("instance2.hashCode=" + instance2.hashCode());\n\t}\n\n}\n\n/**\n * 饿汉式(静态代码块)\n */\nclass Singleton {\n\n\t/**\n\t * 1. 构造器私有化, 外部能new\n\t */\n\tprivate Singleton() {\n\t\t\n\t}\n\n\n\t/**\n\t * 2.本类内部创建对象实例\n\t */\n\tprivate  static Singleton instance;\n\n\t/**\n\t * 在静态代码块中，创建单例对象\n\t */\n\tstatic {\n\t\tinstance = new Singleton();\n\t}\n\n\t/**\n\t * 3. 提供一个公有的静态方法，返回实例对象\n\t * @return\n\t */\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n\t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n# 2. 优缺点\n\n 1. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。\n\n 2. 结论：这种单例模式可用，但是可能造成内存浪费。\n\n\n# 3. 懒汉式(线程不安全)\n\n# 1. 代码实现\n\npublic class SingletonTest03 {\n\n    public static void main(String[] args) {\n        System.out.println("懒汉式1 ， 线程不安全~");\n        Singleton instance = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        // true\n        System.out.println(instance == instance2);\n        System.out.println("instance.hashCode=" + instance.hashCode());\n        System.out.println("instance2.hashCode=" + instance2.hashCode());\n    }\n\n}\n\n/**\n * 懒汉式(线程不安全)\n */\nclass Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n    }\n\n    /**\n     * 提供一个静态的公有方法，当使用到该方法时，才去创建 instance: 即懒汉式\n     *\n     * @return\n     */\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n# 2. 优缺点\n\n 1. 起到了Lazy Loading的效果，但是只能在单线程下使用。\n\n 2. 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。\n\n 3. 结论：在实际开发中，不要使用这种方式。\n\n\n# 4. 懒汉式(线程安全：同步方法)\n\n# 1. 代码实现\n\n加入同步处理的代码(添加 “synchronized” )\n\npublic class SingletonTest04 {\n\n    public static void main(String[] args) {\n        System.out.println("懒汉式2 ， 线程安全~");\n        Singleton instance = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        // true\n        System.out.println(instance == instance2);\n        System.out.println("instance.hashCode=" + instance.hashCode());\n        System.out.println("instance2.hashCode=" + instance2.hashCode());\n    }\n\n}\n\n/**\n * 懒汉式(线程安全：同步方法)\n */\nclass Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n    }\n\n    /**\n     * 提供一个静态的公有方法，加入同步处理的代码(添加 “synchronized” )，解决线程安全问题\n     */\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n# 2. 优缺点\n\n 1. 解决了线程不安全问题。\n\n 2. 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低。\n\n 3. 结论：在实际开发中，不推荐使用这种方式。\n\n\n# 5. 懒汉式(同步代码块)\n\n# 1. 代码实现\n\npublic class SingletonTest04 {\n\n    public static void main(String[] args) {\n        System.out.println("懒汉式2 ， 线程安全~");\n        Singleton instance = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        // true\n        System.out.println(instance == instance2);\n        System.out.println("instance.hashCode=" + instance.hashCode());\n        System.out.println("instance2.hashCode=" + instance2.hashCode());\n    }\n\n}\n\n/**\n * 懒汉式(线程安全：同步方法)\n */\nclass Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n    }\n\n    /**\n     * 提供一个静态的公有方法，加入同步处理的代码(添加 “synchronized” )，解决线程安全问题\n     */\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized(Singleton.class){\n            \tinstance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n# 2. 优缺点\n\n 1. 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块。\n\n 2. 但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例\n\n 3. 结论：在实际开发中，不能使用这种方式\n\n\n# 6. 双重检查(DoubleCheck) 😄\n\n# 1. 代码实现\n\n加入双重检查代码，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题。\n\npublic class SingletonTest06 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("双重检查");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println("instance.hashCode=" + instance.hashCode());\n\t\tSystem.out.println("instance2.hashCode=" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n/**\n * 懒汉式(双重检查)\n */\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\tprivate Singleton() {}\n\n\t/**\n\t * 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题\n\t * 同时保证了效率, 推荐使用\n\t * @return\n\t */\n\tpublic static Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tif(instance == null) {\n\t\t\t\t\tinstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn instance;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 2. 优缺点\n\n 1. Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。\n\n 2. 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步。\n\n 3. 线程安全: 延迟加载；效率较高。\n\n 4. 结论：在实际开发中，推荐使用这种单例设计模式。🐱\n\n\n# 7. 静态内部类 😄\n\n# 1. 代码实现\n\n解决线程安全问题, 同时解决懒加载问题。\n\npublic class SingletonTest07 {\n\n    public static void main(String[] args) {\n        System.out.println("使用静态内部类完成单例模式");\n        Singleton instance = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        // true\n        System.out.println(instance == instance2);\n        System.out.println("instance.hashCode=" + instance.hashCode());\n        System.out.println("instance2.hashCode=" + instance2.hashCode());\n\n    }\n\n}\n\n/**\n * 静态内部类完成\n */\nclass Singleton {\n    private static volatile Singleton instance;\n\n    /**\n     * 构造器私有化\n     */\n    private Singleton() {\n    }\n\n    /**\n     * 写一个静态内部类,该类中有一个静态属性 Singleton\n     *\n     * JVM底层类的装载机制， 保证了 private static final Singleton INSTANCE = new Singleton(); 初始化线程安全\n     */\n    private static class SingletonInstance {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    /**\n     * 提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE\n     *\n     * @return\n     */\n    public static synchronized Singleton getInstance() {\n        return SingletonInstance.INSTANCE;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n# 2. 优缺点\n\n 1. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。\n\n 2. 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。（加载外部类时候，内部类不会立即加载实例化）\n\n 3. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。\n\n 4. 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高。\n\n 5. 结论：推荐使用。\n\n\n# 8. 枚举方式 😄\n\n# 1. 代码实现\n\npublic class SingletonTest08 {\n\tpublic static void main(String[] args) {\n\t\tSingleton instance = Singleton.INSTANCE;\n\t\tSingleton instance2 = Singleton.INSTANCE;\n\t\tSystem.out.println(instance == instance2);\n\t\t\n\t\tSystem.out.println(instance.hashCode());\n\t\tSystem.out.println(instance2.hashCode());\n\t\t\n\t\tinstance.sayOK();\n\t}\n}\n\n/**\n * 使用枚举，可以实现单例\n */\nenum Singleton {\n\n\t/**\n\t * 属性\n\t */\n\tINSTANCE;\n\n\t/**\n\t * 方法\n\t */\n\tpublic void sayOK() {\n\t\tSystem.out.println("ok~");\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 2. 优缺点\n\n 1. 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。\n\n 2. 这种方式是Effective Java作者Josh Bloch 提倡的方式。\n\n 3. 结论：推荐使用。\n\n\n# 4. 单例模式在JDK应用的源码分析\n\n我们JDK中，java.lang.Runtime就是经典的单例模式(饿汉式 静态变量)。\n\n代码分析+Debug源码+代码说明\n\npublic class Runtime {\n    private static Runtime currentRuntime = new Runtime();\n\n    /**\n     * Returns the runtime object associated with the current Java application.\n     * Most of the methods of class <code>Runtime</code> are instance\n     * methods and must be invoked with respect to the current runtime object.\n     *\n     * @return  the <code>Runtime</code> object associated with the current\n     *          Java application.\n     */\n    public static Runtime getRuntime() {\n        return currentRuntime;\n    }\n\n    /** Don\'t let anyone else instantiate this class */\n    private Runtime() {}\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5. 单例模式注意事项和细节说明\n\n单例模式注意事项和细节说明\n\n 1. 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。\n\n 2. 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new。\n\n 3. 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)。',normalizedContent:'# java设计模式-单例模式\n\n\n# 1. 单例设计模式介绍\n\n所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。\n\n比如 hibernate 的 sessionfactory，它充当数据存储源的代理，并负责创建 session 对象。sessionfactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 sessionfactory 就够，这是就会使用到单例模式。\n\n\n# 2. 单例设计模式八种方式\n\n\n# 1. 单例模式有八种方式：\n\n 1. 饿汉式(静态常量)\n\n 2. 饿汉式(静态代码块)\n\n 3. 懒汉式(线程不安全)\n\n 4. 懒汉式(线程安全，同步方法)\n\n 5. 懒汉式(线程安全，同步代码块)\n\n 6. 双重检查 😄\n\n 7. 静态内部类 😄\n\n 8. 枚举 😄\n\n> 饿汉式二种；懒汉式三种。\n\n\n# 2. 推荐的模式\n\n单、多线程场景推荐：\n\n 1. 双重检查 😄\n 2. 静态内部类 😄\n 3. 枚举 😄\n\n单线程模式也推荐：\n\n 1. 饿汉式(静态常量)\n 2. 饿汉式(静态代码块)\n\n> 注意饿汉式在使用的时候创建，避免内存浪费。\n\n\n# 3. 单例设计模式-示例\n\n\n# 1. 饿汉式(静态常量)\n\n# 1. 代码实现\n\n 1. 构造器私有化 (防止 new )\n\n 2. 类的内部创建对象\n\n 3. 向外暴露一个静态的公共方法。getinstance()\n\npublic class singletontest01 {\n\n    public static void main(string[] args) {\n        // 测试\n        singleton instance = singleton.getinstance();\n        singleton instance2 = singleton.getinstance();\n        // true\n        system.out.println(instance == instance2);\n        // instance.hashcode=460141958\n        system.out.println("instance.hashcode=" + instance.hashcode());\n        // instance2.hashcode=460141958\n        system.out.println("instance2.hashcode=" + instance2.hashcode());\n    }\n\n}\n\n/**\n * 饿汉式(静态变量)\n */\nclass singleton {\n\n    /**\n     * 1. 构造器私有化, 外部能new\n     */\n    private singleton() {\n\n    }\n\n    /**\n     * 2.本类内部创建对象实例\n     */\n    private final static singleton instance = new singleton();\n\n    /**\n     * 3. 提供一个公有的静态方法，返回实例对象\n     */\n    public static singleton getinstance() {\n        return instance;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 2. 优缺点\n\n 1. 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。\n\n 2. 缺点：在类装载的时候就完成实例化，没有达到 lazy loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。\n\n 3. 这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getinstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果。\n\n 4. 结论：这种单例模式可用，可能造成内存浪费。\n\n\n# 2. 饿汉式(静态代码块)\n\n# 1. 代码实现\n\npublic class singletontest02 {\n\n\tpublic static void main(string[] args) {\n\t\t//测试\n\t\tsingleton instance = singleton.getinstance();\n\t\tsingleton instance2 = singleton.getinstance();\n\t\t// true\n\t\tsystem.out.println(instance == instance2);\n\t\t// instance.hashcode=460141958\n\t\tsystem.out.println("instance.hashcode=" + instance.hashcode());\n\t\t// instance2.hashcode=460141958\n\t\tsystem.out.println("instance2.hashcode=" + instance2.hashcode());\n\t}\n\n}\n\n/**\n * 饿汉式(静态代码块)\n */\nclass singleton {\n\n\t/**\n\t * 1. 构造器私有化, 外部能new\n\t */\n\tprivate singleton() {\n\t\t\n\t}\n\n\n\t/**\n\t * 2.本类内部创建对象实例\n\t */\n\tprivate  static singleton instance;\n\n\t/**\n\t * 在静态代码块中，创建单例对象\n\t */\n\tstatic {\n\t\tinstance = new singleton();\n\t}\n\n\t/**\n\t * 3. 提供一个公有的静态方法，返回实例对象\n\t * @return\n\t */\n\tpublic static singleton getinstance() {\n\t\treturn instance;\n\t}\n\t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n# 2. 优缺点\n\n 1. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。\n\n 2. 结论：这种单例模式可用，但是可能造成内存浪费。\n\n\n# 3. 懒汉式(线程不安全)\n\n# 1. 代码实现\n\npublic class singletontest03 {\n\n    public static void main(string[] args) {\n        system.out.println("懒汉式1 ， 线程不安全~");\n        singleton instance = singleton.getinstance();\n        singleton instance2 = singleton.getinstance();\n        // true\n        system.out.println(instance == instance2);\n        system.out.println("instance.hashcode=" + instance.hashcode());\n        system.out.println("instance2.hashcode=" + instance2.hashcode());\n    }\n\n}\n\n/**\n * 懒汉式(线程不安全)\n */\nclass singleton {\n    private static singleton instance;\n\n    private singleton() {\n    }\n\n    /**\n     * 提供一个静态的公有方法，当使用到该方法时，才去创建 instance: 即懒汉式\n     *\n     * @return\n     */\n    public static singleton getinstance() {\n        if (instance == null) {\n            instance = new singleton();\n        }\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n# 2. 优缺点\n\n 1. 起到了lazy loading的效果，但是只能在单线程下使用。\n\n 2. 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。\n\n 3. 结论：在实际开发中，不要使用这种方式。\n\n\n# 4. 懒汉式(线程安全：同步方法)\n\n# 1. 代码实现\n\n加入同步处理的代码(添加 “synchronized” )\n\npublic class singletontest04 {\n\n    public static void main(string[] args) {\n        system.out.println("懒汉式2 ， 线程安全~");\n        singleton instance = singleton.getinstance();\n        singleton instance2 = singleton.getinstance();\n        // true\n        system.out.println(instance == instance2);\n        system.out.println("instance.hashcode=" + instance.hashcode());\n        system.out.println("instance2.hashcode=" + instance2.hashcode());\n    }\n\n}\n\n/**\n * 懒汉式(线程安全：同步方法)\n */\nclass singleton {\n    private static singleton instance;\n\n    private singleton() {\n    }\n\n    /**\n     * 提供一个静态的公有方法，加入同步处理的代码(添加 “synchronized” )，解决线程安全问题\n     */\n    public static synchronized singleton getinstance() {\n        if (instance == null) {\n            instance = new singleton();\n        }\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n# 2. 优缺点\n\n 1. 解决了线程不安全问题。\n\n 2. 效率太低了，每个线程在想获得类的实例时候，执行getinstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低。\n\n 3. 结论：在实际开发中，不推荐使用这种方式。\n\n\n# 5. 懒汉式(同步代码块)\n\n# 1. 代码实现\n\npublic class singletontest04 {\n\n    public static void main(string[] args) {\n        system.out.println("懒汉式2 ， 线程安全~");\n        singleton instance = singleton.getinstance();\n        singleton instance2 = singleton.getinstance();\n        // true\n        system.out.println(instance == instance2);\n        system.out.println("instance.hashcode=" + instance.hashcode());\n        system.out.println("instance2.hashcode=" + instance2.hashcode());\n    }\n\n}\n\n/**\n * 懒汉式(线程安全：同步方法)\n */\nclass singleton {\n    private static singleton instance;\n\n    private singleton() {\n    }\n\n    /**\n     * 提供一个静态的公有方法，加入同步处理的代码(添加 “synchronized” )，解决线程安全问题\n     */\n    public static singleton getinstance() {\n        if (instance == null) {\n            synchronized(singleton.class){\n            \tinstance = new singleton();\n            }\n        }\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n# 2. 优缺点\n\n 1. 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块。\n\n 2. 但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例\n\n 3. 结论：在实际开发中，不能使用这种方式\n\n\n# 6. 双重检查(doublecheck) 😄\n\n# 1. 代码实现\n\n加入双重检查代码，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题。\n\npublic class singletontest06 {\n\n\tpublic static void main(string[] args) {\n\t\tsystem.out.println("双重检查");\n\t\tsingleton instance = singleton.getinstance();\n\t\tsingleton instance2 = singleton.getinstance();\n\t\tsystem.out.println(instance == instance2); // true\n\t\tsystem.out.println("instance.hashcode=" + instance.hashcode());\n\t\tsystem.out.println("instance2.hashcode=" + instance2.hashcode());\n\t\t\n\t}\n\n}\n\n/**\n * 懒汉式(双重检查)\n */\nclass singleton {\n\tprivate static volatile singleton instance;\n\t\n\tprivate singleton() {}\n\n\t/**\n\t * 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题\n\t * 同时保证了效率, 推荐使用\n\t * @return\n\t */\n\tpublic static singleton getinstance() {\n\t\tif(instance == null) {\n\t\t\tsynchronized (singleton.class) {\n\t\t\t\tif(instance == null) {\n\t\t\t\t\tinstance = new singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn instance;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n# 2. 优缺点\n\n 1. double-check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。\n\n 2. 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步。\n\n 3. 线程安全: 延迟加载；效率较高。\n\n 4. 结论：在实际开发中，推荐使用这种单例设计模式。🐱\n\n\n# 7. 静态内部类 😄\n\n# 1. 代码实现\n\n解决线程安全问题, 同时解决懒加载问题。\n\npublic class singletontest07 {\n\n    public static void main(string[] args) {\n        system.out.println("使用静态内部类完成单例模式");\n        singleton instance = singleton.getinstance();\n        singleton instance2 = singleton.getinstance();\n        // true\n        system.out.println(instance == instance2);\n        system.out.println("instance.hashcode=" + instance.hashcode());\n        system.out.println("instance2.hashcode=" + instance2.hashcode());\n\n    }\n\n}\n\n/**\n * 静态内部类完成\n */\nclass singleton {\n    private static volatile singleton instance;\n\n    /**\n     * 构造器私有化\n     */\n    private singleton() {\n    }\n\n    /**\n     * 写一个静态内部类,该类中有一个静态属性 singleton\n     *\n     * jvm底层类的装载机制， 保证了 private static final singleton instance = new singleton(); 初始化线程安全\n     */\n    private static class singletoninstance {\n        private static final singleton instance = new singleton();\n    }\n\n    /**\n     * 提供一个静态的公有方法，直接返回singletoninstance.instance\n     *\n     * @return\n     */\n    public static synchronized singleton getinstance() {\n        return singletoninstance.instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n# 2. 优缺点\n\n 1. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。\n\n 2. 静态内部类方式在singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getinstance方法，才会装载singletoninstance类，从而完成singleton的实例化。（加载外部类时候，内部类不会立即加载实例化）\n\n 3. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，jvm帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。\n\n 4. 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高。\n\n 5. 结论：推荐使用。\n\n\n# 8. 枚举方式 😄\n\n# 1. 代码实现\n\npublic class singletontest08 {\n\tpublic static void main(string[] args) {\n\t\tsingleton instance = singleton.instance;\n\t\tsingleton instance2 = singleton.instance;\n\t\tsystem.out.println(instance == instance2);\n\t\t\n\t\tsystem.out.println(instance.hashcode());\n\t\tsystem.out.println(instance2.hashcode());\n\t\t\n\t\tinstance.sayok();\n\t}\n}\n\n/**\n * 使用枚举，可以实现单例\n */\nenum singleton {\n\n\t/**\n\t * 属性\n\t */\n\tinstance;\n\n\t/**\n\t * 方法\n\t */\n\tpublic void sayok() {\n\t\tsystem.out.println("ok~");\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 2. 优缺点\n\n 1. 这借助jdk1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。\n\n 2. 这种方式是effective java作者josh bloch 提倡的方式。\n\n 3. 结论：推荐使用。\n\n\n# 4. 单例模式在jdk应用的源码分析\n\n我们jdk中，java.lang.runtime就是经典的单例模式(饿汉式 静态变量)。\n\n代码分析+debug源码+代码说明\n\npublic class runtime {\n    private static runtime currentruntime = new runtime();\n\n    /**\n     * returns the runtime object associated with the current java application.\n     * most of the methods of class <code>runtime</code> are instance\n     * methods and must be invoked with respect to the current runtime object.\n     *\n     * @return  the <code>runtime</code> object associated with the current\n     *          java application.\n     */\n    public static runtime getruntime() {\n        return currentruntime;\n    }\n\n    /** don\'t let anyone else instantiate this class */\n    private runtime() {}\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5. 单例模式注意事项和细节说明\n\n单例模式注意事项和细节说明\n\n 1. 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。\n\n 2. 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new。\n\n 3. 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Java设计模式-原型模式",frontmatter:{title:"Java设计模式-原型模式",date:"2023-02-25T20:46:26.000Z",permalink:"/pages/9814ac/"},regularPath:"/02.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"02.编程基础/04.设计模式/6.Java设计模式-原型模式.md",key:"v-7e01f4b7",path:"/pages/9814ac/",headers:[{level:2,title:"1. 克隆羊问题",slug:"_1-克隆羊问题",normalizedTitle:"1. 克隆羊问题",charIndex:20},{level:3,title:"1. 传统方式解决克隆羊问题",slug:"_1-传统方式解决克隆羊问题",normalizedTitle:"1. 传统方式解决克隆羊问题",charIndex:93},{level:4,title:"1. 思路分析(UML类图)",slug:"_1-思路分析-uml类图",normalizedTitle:"1. 思路分析(uml类图)",charIndex:111},{level:4,title:"2. 代码",slug:"_2-代码",normalizedTitle:"2. 代码",charIndex:131},{level:3,title:"2. 传统的方式的优缺点",slug:"_2-传统的方式的优缺点",normalizedTitle:"2. 传统的方式的优缺点",charIndex:1750},{level:2,title:"2. 原型模式",slug:"_2-原型模式",normalizedTitle:"2. 原型模式",charIndex:2027},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍",normalizedTitle:"1. 基本介绍",charIndex:2039},{level:3,title:"2. 原理结构图(UML类图)",slug:"_2-原理结构图-uml类图",normalizedTitle:"2. 原理结构图(uml类图)",charIndex:2269},{level:2,title:"3. 原型模式-解决克隆羊问题",slug:"_3-原型模式-解决克隆羊问题",normalizedTitle:"3. 原型模式-解决克隆羊问题",charIndex:2421},{level:2,title:"4. 原型模式-在Spring框架中源码分析",slug:"_4-原型模式-在spring框架中源码分析",normalizedTitle:"4. 原型模式-在spring框架中源码分析",charIndex:4756},{level:2,title:"5. 深入讨论-浅拷贝和深拷贝",slug:"_5-深入讨论-浅拷贝和深拷贝",normalizedTitle:"5. 深入讨论-浅拷贝和深拷贝",charIndex:7671},{level:3,title:"1. 浅拷贝的介绍",slug:"_1-浅拷贝的介绍",normalizedTitle:"1. 浅拷贝的介绍",charIndex:7691},{level:3,title:"2. 深拷贝基本介绍",slug:"_2-深拷贝基本介绍",normalizedTitle:"2. 深拷贝基本介绍",charIndex:7988},{level:2,title:"6. 原型模式的注意事项和细节",slug:"_6-原型模式的注意事项和细节",normalizedTitle:"6. 原型模式的注意事项和细节",charIndex:11701}],headersStr:"1. 克隆羊问题 1. 传统方式解决克隆羊问题 1. 思路分析(UML类图) 2. 代码 2. 传统的方式的优缺点 2. 原型模式 1. 基本介绍 2. 原理结构图(UML类图) 3. 原型模式-解决克隆羊问题 4. 原型模式-在Spring框架中源码分析 5. 深入讨论-浅拷贝和深拷贝 1. 浅拷贝的介绍 2. 深拷贝基本介绍 6. 原型模式的注意事项和细节",content:'# Java设计模式-原型模式\n\n\n# 1. 克隆羊问题\n\n现在有一只羊tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和tom羊 属性完全相同的10只羊。\n\n\n# 1. 传统方式解决克隆羊问题\n\n# 1. 思路分析(UML类图)\n\n\n\n# 2. 代码\n\n羊\n\npublic class Sheep {\n   private String name;\n   private int age;\n   private String color;\n   public Sheep(String name, int age, String color) {\n      super();\n      this.name = name;\n      this.age = age;\n      this.color = color;\n   }\n   public String getName() {\n      return name;\n   }\n   public void setName(String name) {\n      this.name = name;\n   }\n   public int getAge() {\n      return age;\n   }\n   public void setAge(int age) {\n      this.age = age;\n   }\n   public String getColor() {\n      return color;\n   }\n   public void setColor(String color) {\n      this.color = color;\n   }\n   @Override\n   public String toString() {\n      return "Sheep [name=" + name + ", age=" + age + ", color=" + color + "]";\n   }\n   \n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\npublic class Client {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      //传统的方法\n      Sheep sheep = new Sheep("tom", 1, "白色");\n      \n      Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n      Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n      Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n      Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n      //....\n      \n      System.out.println(sheep);\n      System.out.println(sheep2);\n      System.out.println(sheep3);\n      System.out.println(sheep4);\n      System.out.println(sheep5);\n      //...\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2. 传统的方式的优缺点\n\n 1. 优点是比较好理解，简单易操作。\n\n 2. 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低。\n\n 3. 总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活。\n\n 4. 改进的思路分析。\n\n> **思路：**Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 => 原型模式\n\n\n# 2. 原型模式\n\n\n# 1. 基本介绍\n\n 1. 原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。\n\n 2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。\n\n 3. 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()。\n\n 4. 形象的理解：孙大圣拔出猴毛， 变出其它孙大圣。\n\n\n# 2. 原理结构图(UML类图)\n\n原理结构图说明:\n\n 1. Prototype : 原型类，声明一个克隆自己的接口。\n\n 2. ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作。\n\n 3. Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)。\n\n\n# 3. 原型模式-解决克隆羊问题\n\n原型模式解决克隆羊问题的应用实例\n\n使用原型模式改进传统方式，让程序具有更高的效率和扩展性。实现Cloneable\n\npublic class Sheep implements Cloneable {\n   private String name;\n   private int age;\n   private String color;\n   private String address = "蒙古羊";\n   public Sheep friend; //是对象, 克隆是会如何处理\n   public Sheep(String name, int age, String color) {\n      super();\n      this.name = name;\n      this.age = age;\n      this.color = color;\n   }\n   public String getName() {\n      return name;\n   }\n   public void setName(String name) {\n      this.name = name;\n   }\n   public int getAge() {\n      return age;\n   }\n   public void setAge(int age) {\n      this.age = age;\n   }\n   public String getColor() {\n      return color;\n   }\n   public void setColor(String color) {\n      this.color = color;\n   }\n   \n   \n   \n   @Override\n   public String toString() {\n      return "Sheep [name=" + name + ", age=" + age + ", color=" + color + ", address=" + address + "]";\n   }\n   //克隆该实例，使用默认的clone方法来完成\n   @Override\n   protected Object clone()  {\n      \n      Sheep sheep = null;\n      try {\n         sheep = (Sheep)super.clone();\n      } catch (Exception e) {\n         // TODO: handle exception\n         System.out.println(e.getMessage());\n      }\n      // TODO Auto-generated method stub\n      return sheep;\n   }\n   \n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\npublic class Client {\n\n   public static void main(String[] args) {\n      System.out.println("原型模式完成对象的创建");\n      // TODO Auto-generated method stub\n      Sheep sheep = new Sheep("tom", 1, "白色");\n      \n      // sheep.friend = new Sheep("jack", 2, "黑色");\n      \n      Sheep sheep2 = (Sheep)sheep.clone(); //克隆\n      Sheep sheep3 = (Sheep)sheep.clone(); //克隆\n      Sheep sheep4 = (Sheep)sheep.clone(); //克隆\n      Sheep sheep5 = (Sheep)sheep.clone(); //克隆\n      \n      System.out.println("sheep2 =" + sheep2 + "sheep2.friend=" + sheep2.friend.hashCode());\n      System.out.println("sheep3 =" + sheep3 + "sheep3.friend=" + sheep3.friend.hashCode());\n      System.out.println("sheep4 =" + sheep4 + "sheep4.friend=" + sheep4.friend.hashCode());\n      System.out.println("sheep5 =" + sheep5 + "sheep5.friend=" + sheep5.friend.hashCode());\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4. 原型模式-在Spring框架中源码分析\n\n 1. Spring中原型bean的创建，就是原型模式的应用\n    \n    beans.xml\n    \n    \x3c!-- 这里我们的 scope="prototype" 即 原型模式来创建 --\x3e\n     <bean id="id01" class="org.example.spring.bean.Monster"\n       scope="prototype"/>\n     \n     \n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    Monster\n    \n    /**\n     * 注释\n     * @author Administrator\n     *\n     */\n    public class Monster {\n    \n       private Integer id = 10 ;\n       private String nickname = "牛魔王";\n       private String skill = "芭蕉扇";\n       public Monster() {\n          \n          System.out.println("monster 创建..");\n       }\n       public Monster(Integer id, String nickname, String skill) {\n          //System.out.println("Integer id, String nickname, String skill被调用");\n          this.id = id;\n          this.nickname = nickname;\n          this.skill = skill;\n       }\n       \n       public Monster( String nickname, String skill,Integer id) {\n          \n          this.id = id;\n          this.nickname = nickname;\n          this.skill = skill;\n       }\n       public Integer getId() {\n          return id;\n       }\n       public void setId(Integer id) {\n          this.id = id;\n       }\n       public String getNickname() {\n          return nickname;\n       }\n       public void setNickname(String nickname) {\n          this.nickname = nickname;\n       }\n       public String getSkill() {\n          return skill;\n       }\n       public void setSkill(String skill) {\n          this.skill = skill;\n       }\n       @Override\n       public String toString() {\n          return "Monster [id=" + id + ", nickname=" + nickname + ", skill="\n                + skill + "]";\n       }\n       \n       \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    \n    \n    测试类：ProtoType\n    \n    public class ProtoType {\n    \n       public static void main(String[] args) {\n          // TODO Auto-generated method stub\n          ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");\n          // 获取monster[通过id获取monster]\n          Object bean = applicationContext.getBean("id01");\n          System.out.println("bean" + bean); // 输出 "牛魔王" .....\n          \n          Object bean2 = applicationContext.getBean("id01");\n          \n          System.out.println("bean2" + bean2); //输出 "牛魔王" .....\n    \n          System.out.println(bean == bean2); // false\n          \n          // ConfigurableApplicationContext\n       }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 2. 代码分析+Debug源码\n\n\n# 5. 深入讨论-浅拷贝和深拷贝\n\n\n# 1. 浅拷贝的介绍\n\n 1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。\n\n 2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。\n\n 3. 前面我们克隆羊就是浅拷贝。\n\n 4. 浅拷贝是使用默认的 clone()方法来实现sheep = (Sheep) super.clone();\n\n\n# 2. 深拷贝基本介绍\n\n 1. 复制对象的所有基本数据类型的成员变量值。\n\n 2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝。\n\n 3. 深拷贝实现方式1：重写clone方法来实现深拷贝。\n\n 4. 深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)。\n\nDeepCloneableTarget：\n\npublic class DeepCloneableTarget implements Serializable, Cloneable {\n   \n   /**\n    * \n    */\n   private static final long serialVersionUID = 1L;\n\n   private String cloneName;\n\n   private String cloneClass;\n\n   //构造器\n   public DeepCloneableTarget(String cloneName, String cloneClass) {\n      this.cloneName = cloneName;\n      this.cloneClass = cloneClass;\n   }\n\n   //因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可\n   @Override\n   protected Object clone() throws CloneNotSupportedException {\n      return super.clone();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nDeepProtoType:\n\npublic class DeepProtoType implements Serializable, Cloneable{\n   \n   public String name; //String 属性\n   public DeepCloneableTarget deepCloneableTarget;// 引用类型\n   public DeepProtoType() {\n      super();\n   }\n   \n   \n   //深拷贝 - 方式 1 使用clone 方法\n   @Override\n   protected Object clone() throws CloneNotSupportedException {\n      \n      Object deep = null;\n      //这里完成对基本数据类型(属性)和String的克隆\n      deep = super.clone(); \n      //对引用类型的属性，进行单独处理\n      DeepProtoType deepProtoType = (DeepProtoType)deep;\n      deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();\n      \n      // TODO Auto-generated method stub\n      return deepProtoType;\n   }\n   \n   //深拷贝 - 方式2 通过对象的序列化实现 (推荐)\n   public Object deepClone() {\n      \n      //创建流对象\n      ByteArrayOutputStream bos = null;\n      ObjectOutputStream oos = null;\n      ByteArrayInputStream bis = null;\n      ObjectInputStream ois = null;\n      \n      try {\n         \n         //序列化\n         bos = new ByteArrayOutputStream();\n         oos = new ObjectOutputStream(bos);\n         oos.writeObject(this); //当前这个对象以对象流的方式输出\n         \n         //反序列化\n         bis = new ByteArrayInputStream(bos.toByteArray());\n         ois = new ObjectInputStream(bis);\n         DeepProtoType copyObj = (DeepProtoType)ois.readObject();\n         \n         return copyObj;\n         \n      } catch (Exception e) {\n         // TODO: handle exception\n         e.printStackTrace();\n         return null;\n      } finally {\n         //关闭流\n         try {\n            bos.close();\n            oos.close();\n            bis.close();\n            ois.close();\n         } catch (Exception e2) {\n            // TODO: handle exception\n            System.out.println(e2.getMessage());\n         }\n      }\n      \n   }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\npublic class Client {\n\n   public static void main(String[] args) throws Exception {\n      // TODO Auto-generated method stub\n      DeepProtoType p = new DeepProtoType();\n      p.name = "宋江";\n      p.deepCloneableTarget = new DeepCloneableTarget("大牛", "小牛");\n      \n      //方式1 完成深拷贝\n      \n//    DeepProtoType p2 = (DeepProtoType) p.clone();\n//    \n//    System.out.println("p.name=" + p.name + "p.deepCloneableTarget=" + p.deepCloneableTarget.hashCode());\n//    System.out.println("p2.name=" + p.name + "p2.deepCloneableTarget=" + p2.deepCloneableTarget.hashCode());\n   \n      //方式2 完成深拷贝\n      DeepProtoType p2 = (DeepProtoType) p.deepClone();\n      \n      System.out.println("p.name=" + p.name + "p.deepCloneableTarget=" + p.deepCloneableTarget.hashCode());\n      System.out.println("p2.name=" + p.name + "p2.deepCloneableTarget=" + p2.deepCloneableTarget.hashCode());\n   \n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 6. 原型模式的注意事项和细节\n\n 1. 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。\n\n 2. 不用重新初始化对象，而是动态地获得对象运行时的状态。\n\n 3. 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。\n\n 4. 在实现深克隆的时候可能需要比较复杂的代码。\n\n 5. 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意。',normalizedContent:'# java设计模式-原型模式\n\n\n# 1. 克隆羊问题\n\n现在有一只羊tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和tom羊 属性完全相同的10只羊。\n\n\n# 1. 传统方式解决克隆羊问题\n\n# 1. 思路分析(uml类图)\n\n\n\n# 2. 代码\n\n羊\n\npublic class sheep {\n   private string name;\n   private int age;\n   private string color;\n   public sheep(string name, int age, string color) {\n      super();\n      this.name = name;\n      this.age = age;\n      this.color = color;\n   }\n   public string getname() {\n      return name;\n   }\n   public void setname(string name) {\n      this.name = name;\n   }\n   public int getage() {\n      return age;\n   }\n   public void setage(int age) {\n      this.age = age;\n   }\n   public string getcolor() {\n      return color;\n   }\n   public void setcolor(string color) {\n      this.color = color;\n   }\n   @override\n   public string tostring() {\n      return "sheep [name=" + name + ", age=" + age + ", color=" + color + "]";\n   }\n   \n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\npublic class client {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n      //传统的方法\n      sheep sheep = new sheep("tom", 1, "白色");\n      \n      sheep sheep2 = new sheep(sheep.getname(), sheep.getage(), sheep.getcolor());\n      sheep sheep3 = new sheep(sheep.getname(), sheep.getage(), sheep.getcolor());\n      sheep sheep4 = new sheep(sheep.getname(), sheep.getage(), sheep.getcolor());\n      sheep sheep5 = new sheep(sheep.getname(), sheep.getage(), sheep.getcolor());\n      //....\n      \n      system.out.println(sheep);\n      system.out.println(sheep2);\n      system.out.println(sheep3);\n      system.out.println(sheep4);\n      system.out.println(sheep5);\n      //...\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2. 传统的方式的优缺点\n\n 1. 优点是比较好理解，简单易操作。\n\n 2. 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低。\n\n 3. 总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活。\n\n 4. 改进的思路分析。\n\n> **思路：**java中object类是所有类的根类，object类提供了一个clone()方法，该方法可以将一个java对象复制一份，但是需要实现clone的java类必须要实现一个接口cloneable，该接口表示该类能够复制且具有复制的能力 => 原型模式\n\n\n# 2. 原型模式\n\n\n# 1. 基本介绍\n\n 1. 原型模式(prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。\n\n 2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。\n\n 3. 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()。\n\n 4. 形象的理解：孙大圣拔出猴毛， 变出其它孙大圣。\n\n\n# 2. 原理结构图(uml类图)\n\n原理结构图说明:\n\n 1. prototype : 原型类，声明一个克隆自己的接口。\n\n 2. concreteprototype: 具体的原型类, 实现一个克隆自己的操作。\n\n 3. client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)。\n\n\n# 3. 原型模式-解决克隆羊问题\n\n原型模式解决克隆羊问题的应用实例\n\n使用原型模式改进传统方式，让程序具有更高的效率和扩展性。实现cloneable\n\npublic class sheep implements cloneable {\n   private string name;\n   private int age;\n   private string color;\n   private string address = "蒙古羊";\n   public sheep friend; //是对象, 克隆是会如何处理\n   public sheep(string name, int age, string color) {\n      super();\n      this.name = name;\n      this.age = age;\n      this.color = color;\n   }\n   public string getname() {\n      return name;\n   }\n   public void setname(string name) {\n      this.name = name;\n   }\n   public int getage() {\n      return age;\n   }\n   public void setage(int age) {\n      this.age = age;\n   }\n   public string getcolor() {\n      return color;\n   }\n   public void setcolor(string color) {\n      this.color = color;\n   }\n   \n   \n   \n   @override\n   public string tostring() {\n      return "sheep [name=" + name + ", age=" + age + ", color=" + color + ", address=" + address + "]";\n   }\n   //克隆该实例，使用默认的clone方法来完成\n   @override\n   protected object clone()  {\n      \n      sheep sheep = null;\n      try {\n         sheep = (sheep)super.clone();\n      } catch (exception e) {\n         // todo: handle exception\n         system.out.println(e.getmessage());\n      }\n      // todo auto-generated method stub\n      return sheep;\n   }\n   \n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\npublic class client {\n\n   public static void main(string[] args) {\n      system.out.println("原型模式完成对象的创建");\n      // todo auto-generated method stub\n      sheep sheep = new sheep("tom", 1, "白色");\n      \n      // sheep.friend = new sheep("jack", 2, "黑色");\n      \n      sheep sheep2 = (sheep)sheep.clone(); //克隆\n      sheep sheep3 = (sheep)sheep.clone(); //克隆\n      sheep sheep4 = (sheep)sheep.clone(); //克隆\n      sheep sheep5 = (sheep)sheep.clone(); //克隆\n      \n      system.out.println("sheep2 =" + sheep2 + "sheep2.friend=" + sheep2.friend.hashcode());\n      system.out.println("sheep3 =" + sheep3 + "sheep3.friend=" + sheep3.friend.hashcode());\n      system.out.println("sheep4 =" + sheep4 + "sheep4.friend=" + sheep4.friend.hashcode());\n      system.out.println("sheep5 =" + sheep5 + "sheep5.friend=" + sheep5.friend.hashcode());\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4. 原型模式-在spring框架中源码分析\n\n 1. spring中原型bean的创建，就是原型模式的应用\n    \n    beans.xml\n    \n    \x3c!-- 这里我们的 scope="prototype" 即 原型模式来创建 --\x3e\n     <bean id="id01" class="org.example.spring.bean.monster"\n       scope="prototype"/>\n     \n     \n    </beans>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    monster\n    \n    /**\n     * 注释\n     * @author administrator\n     *\n     */\n    public class monster {\n    \n       private integer id = 10 ;\n       private string nickname = "牛魔王";\n       private string skill = "芭蕉扇";\n       public monster() {\n          \n          system.out.println("monster 创建..");\n       }\n       public monster(integer id, string nickname, string skill) {\n          //system.out.println("integer id, string nickname, string skill被调用");\n          this.id = id;\n          this.nickname = nickname;\n          this.skill = skill;\n       }\n       \n       public monster( string nickname, string skill,integer id) {\n          \n          this.id = id;\n          this.nickname = nickname;\n          this.skill = skill;\n       }\n       public integer getid() {\n          return id;\n       }\n       public void setid(integer id) {\n          this.id = id;\n       }\n       public string getnickname() {\n          return nickname;\n       }\n       public void setnickname(string nickname) {\n          this.nickname = nickname;\n       }\n       public string getskill() {\n          return skill;\n       }\n       public void setskill(string skill) {\n          this.skill = skill;\n       }\n       @override\n       public string tostring() {\n          return "monster [id=" + id + ", nickname=" + nickname + ", skill="\n                + skill + "]";\n       }\n       \n       \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    \n    \n    测试类：prototype\n    \n    public class prototype {\n    \n       public static void main(string[] args) {\n          // todo auto-generated method stub\n          applicationcontext applicationcontext = new classpathxmlapplicationcontext("beans.xml");\n          // 获取monster[通过id获取monster]\n          object bean = applicationcontext.getbean("id01");\n          system.out.println("bean" + bean); // 输出 "牛魔王" .....\n          \n          object bean2 = applicationcontext.getbean("id01");\n          \n          system.out.println("bean2" + bean2); //输出 "牛魔王" .....\n    \n          system.out.println(bean == bean2); // false\n          \n          // configurableapplicationcontext\n       }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 2. 代码分析+debug源码\n\n\n# 5. 深入讨论-浅拷贝和深拷贝\n\n\n# 1. 浅拷贝的介绍\n\n 1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。\n\n 2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。\n\n 3. 前面我们克隆羊就是浅拷贝。\n\n 4. 浅拷贝是使用默认的 clone()方法来实现sheep = (sheep) super.clone();\n\n\n# 2. 深拷贝基本介绍\n\n 1. 复制对象的所有基本数据类型的成员变量值。\n\n 2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝。\n\n 3. 深拷贝实现方式1：重写clone方法来实现深拷贝。\n\n 4. 深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)。\n\ndeepcloneabletarget：\n\npublic class deepcloneabletarget implements serializable, cloneable {\n   \n   /**\n    * \n    */\n   private static final long serialversionuid = 1l;\n\n   private string clonename;\n\n   private string cloneclass;\n\n   //构造器\n   public deepcloneabletarget(string clonename, string cloneclass) {\n      this.clonename = clonename;\n      this.cloneclass = cloneclass;\n   }\n\n   //因为该类的属性，都是string , 因此我们这里使用默认的clone完成即可\n   @override\n   protected object clone() throws clonenotsupportedexception {\n      return super.clone();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\ndeepprototype:\n\npublic class deepprototype implements serializable, cloneable{\n   \n   public string name; //string 属性\n   public deepcloneabletarget deepcloneabletarget;// 引用类型\n   public deepprototype() {\n      super();\n   }\n   \n   \n   //深拷贝 - 方式 1 使用clone 方法\n   @override\n   protected object clone() throws clonenotsupportedexception {\n      \n      object deep = null;\n      //这里完成对基本数据类型(属性)和string的克隆\n      deep = super.clone(); \n      //对引用类型的属性，进行单独处理\n      deepprototype deepprototype = (deepprototype)deep;\n      deepprototype.deepcloneabletarget  = (deepcloneabletarget)deepcloneabletarget.clone();\n      \n      // todo auto-generated method stub\n      return deepprototype;\n   }\n   \n   //深拷贝 - 方式2 通过对象的序列化实现 (推荐)\n   public object deepclone() {\n      \n      //创建流对象\n      bytearrayoutputstream bos = null;\n      objectoutputstream oos = null;\n      bytearrayinputstream bis = null;\n      objectinputstream ois = null;\n      \n      try {\n         \n         //序列化\n         bos = new bytearrayoutputstream();\n         oos = new objectoutputstream(bos);\n         oos.writeobject(this); //当前这个对象以对象流的方式输出\n         \n         //反序列化\n         bis = new bytearrayinputstream(bos.tobytearray());\n         ois = new objectinputstream(bis);\n         deepprototype copyobj = (deepprototype)ois.readobject();\n         \n         return copyobj;\n         \n      } catch (exception e) {\n         // todo: handle exception\n         e.printstacktrace();\n         return null;\n      } finally {\n         //关闭流\n         try {\n            bos.close();\n            oos.close();\n            bis.close();\n            ois.close();\n         } catch (exception e2) {\n            // todo: handle exception\n            system.out.println(e2.getmessage());\n         }\n      }\n      \n   }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\npublic class client {\n\n   public static void main(string[] args) throws exception {\n      // todo auto-generated method stub\n      deepprototype p = new deepprototype();\n      p.name = "宋江";\n      p.deepcloneabletarget = new deepcloneabletarget("大牛", "小牛");\n      \n      //方式1 完成深拷贝\n      \n//    deepprototype p2 = (deepprototype) p.clone();\n//    \n//    system.out.println("p.name=" + p.name + "p.deepcloneabletarget=" + p.deepcloneabletarget.hashcode());\n//    system.out.println("p2.name=" + p.name + "p2.deepcloneabletarget=" + p2.deepcloneabletarget.hashcode());\n   \n      //方式2 完成深拷贝\n      deepprototype p2 = (deepprototype) p.deepclone();\n      \n      system.out.println("p.name=" + p.name + "p.deepcloneabletarget=" + p.deepcloneabletarget.hashcode());\n      system.out.println("p2.name=" + p.name + "p2.deepcloneabletarget=" + p2.deepcloneabletarget.hashcode());\n   \n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 6. 原型模式的注意事项和细节\n\n 1. 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。\n\n 2. 不用重新初始化对象，而是动态地获得对象运行时的状态。\n\n 3. 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。\n\n 4. 在实现深克隆的时候可能需要比较复杂的代码。\n\n 5. 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Java设计模式-建造者模式",frontmatter:{title:"Java设计模式-建造者模式",date:"2023-02-25T20:46:26.000Z",permalink:"/pages/85ff30/"},regularPath:"/02.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"02.编程基础/04.设计模式/7.Java设计模式-建造者模式.md",key:"v-70fa0b4f",path:"/pages/85ff30/",headers:[{level:2,title:"1. 盖房项目需求",slug:"_1-盖房项目需求",normalizedTitle:"1. 盖房项目需求",charIndex:21},{level:3,title:"1. 类图",slug:"_1-类图",normalizedTitle:"1. 类图",charIndex:127},{level:3,title:"2. 代码实现",slug:"_2-代码实现",normalizedTitle:"2. 代码实现",charIndex:137},{level:3,title:"3. 传统方式解决盖房需求问题分析",slug:"_3-传统方式解决盖房需求问题分析",normalizedTitle:"3. 传统方式解决盖房需求问题分析",charIndex:1208},{level:2,title:"2. 建造者模式",slug:"_2-建造者模式",normalizedTitle:"2. 建造者模式",charIndex:1379},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍",normalizedTitle:"1. 基本介绍",charIndex:1392},{level:3,title:"2. 建造者模式的四个角色",slug:"_2-建造者模式的四个角色",normalizedTitle:"2. 建造者模式的四个角色",charIndex:1577},{level:3,title:"3. 建造者模式原理类图",slug:"_3-建造者模式原理类图",normalizedTitle:"3. 建造者模式原理类图",charIndex:1817},{level:2,title:"3. 建造者模式解决盖房需求",slug:"_3-建造者模式解决盖房需求",normalizedTitle:"3. 建造者模式解决盖房需求",charIndex:1834},{level:3,title:"1. 类图",slug:"_1-类图-2",normalizedTitle:"1. 类图",charIndex:127},{level:3,title:"2. 代码实现",slug:"_2-代码实现-2",normalizedTitle:"2. 代码实现",charIndex:137},{level:2,title:"4. JDK的应用和源码分析-StringBuilder【重点】",slug:"_4-jdk的应用和源码分析-stringbuilder【重点】",normalizedTitle:"4. jdk的应用和源码分析-stringbuilder【重点】",charIndex:5453},{level:3,title:"1. 源码",slug:"_1-源码",normalizedTitle:"1. 源码",charIndex:5490},{level:3,title:"2. 源码中建造者模式角色分析",slug:"_2-源码中建造者模式角色分析",normalizedTitle:"2. 源码中建造者模式角色分析",charIndex:5576},{level:2,title:"5. 建造者模式的注意事项和细节",slug:"_5-建造者模式的注意事项和细节",normalizedTitle:"5. 建造者模式的注意事项和细节",charIndex:5867}],headersStr:"1. 盖房项目需求 1. 类图 2. 代码实现 3. 传统方式解决盖房需求问题分析 2. 建造者模式 1. 基本介绍 2. 建造者模式的四个角色 3. 建造者模式原理类图 3. 建造者模式解决盖房需求 1. 类图 2. 代码实现 4. JDK的应用和源码分析-StringBuilder【重点】 1. 源码 2. 源码中建造者模式角色分析 5. 建造者模式的注意事项和细节",content:'# Java设计模式-建造者模式\n\n\n# 1. 盖房项目需求\n\n 1. 需要建房子：这一过程为打桩、砌墙、封顶。\n\n 2. 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的。\n\n 3. 请编写程序，完成需求。\n\n\n# 1. 类图\n\n\n# 2. 代码实现\n\nAbstractHouse\n\npublic abstract class AbstractHouse {\n   \n   //打地基\n   public abstract void buildBasic();\n   //砌墙\n   public abstract void buildWalls();\n   //封顶\n   public abstract void roofed();\n   \n   public void build() {\n      buildBasic();\n      buildWalls();\n      roofed();\n   }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nCommonHouse\n\npublic class CommonHouse extends AbstractHouse {\n\n   @Override\n   public void buildBasic() {\n      // TODO Auto-generated method stub\n      System.out.println(" 普通房子打地基 ");\n   }\n\n   @Override\n   public void buildWalls() {\n      // TODO Auto-generated method stub\n      System.out.println(" 普通房子砌墙 ");\n   }\n\n   @Override\n   public void roofed() {\n      // TODO Auto-generated method stub\n      System.out.println(" 普通房子封顶 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nClient\n\npublic class Client {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      CommonHouse commonHouse = new CommonHouse();\n      commonHouse.build();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3. 传统方式解决盖房需求问题分析\n\n 1. 优点是比较好理解，简单易操作。\n\n 2. 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。\n\n 3. 解决方案：将产品和产品建造过程解耦 => 建造者模式。\n\n\n# 2. 建造者模式\n\n\n# 1. 基本介绍\n\n 1. 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。\n\n 2. 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。\n\n\n# 2. 建造者模式的四个角色\n\n 1. Product（产品角色）：一个具体的产品对象。\n\n 2. Builder（抽象建造者）：创建一个Product对象的各个部件指定的 接口/抽象类。\n\n 3. ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。\n\n 4. Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。\n\n\n# 3. 建造者模式原理类图\n\n\n# 3. 建造者模式解决盖房需求\n\n需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们使用建造者模式(Builder Pattern)来完成\n\n\n# 1. 类图\n\n\n# 2. 代码实现\n\nHouse：产品\n\n/**\n * 产品->Product\n */\npublic class House {\n   private String baise;\n   private String wall;\n   private String roofed;\n   public String getBaise() {\n      return baise;\n   }\n   public void setBaise(String baise) {\n      this.baise = baise;\n   }\n   public String getWall() {\n      return wall;\n   }\n   public void setWall(String wall) {\n      this.wall = wall;\n   }\n   public String getRoofed() {\n      return roofed;\n   }\n   public void setRoofed(String roofed) {\n      this.roofed = roofed;\n   }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nHouseBuilder： 抽象的建造者\n\n/**\n * 抽象的建造者\n */\npublic abstract class HouseBuilder {\n\n   protected House house = new House();\n\n   /**\n    * 将建造的流程写好, 抽象的方法\n    */\n   public abstract void buildBasic();\n   public abstract void buildWalls();\n   public abstract void roofed();\n\n   /**\n    * 建造房子好， 将产品(房子) 返回\n    */\n   public House buildHouse() {\n      return house;\n   }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nCommonHouse：普通房子（具体的建造者）\n\npublic class CommonHouse extends HouseBuilder {\n\n   @Override\n   public void buildBasic() {\n      // TODO Auto-generated method stub\n      System.out.println(" 普通房子打地基5米 ");\n   }\n\n   @Override\n   public void buildWalls() {\n      // TODO Auto-generated method stub\n      System.out.println(" 普通房子砌墙10cm ");\n   }\n\n   @Override\n   public void roofed() {\n      // TODO Auto-generated method stub\n      System.out.println(" 普通房子屋顶 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nHighBuilding：高楼（具体的建造者）\n\npublic class HighBuilding extends HouseBuilder {\n\n   @Override\n   public void buildBasic() {\n      // TODO Auto-generated method stub\n      System.out.println(" 高楼的打地基100米 ");\n   }\n\n   @Override\n   public void buildWalls() {\n      // TODO Auto-generated method stub\n      System.out.println(" 高楼的砌墙20cm ");\n   }\n\n   @Override\n   public void roofed() {\n      // TODO Auto-generated method stub\n      System.out.println(" 高楼的透明屋顶 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nHouseDirector：指挥者\n\n/**\n * 指挥者，这里去指定制作流程，返回产品\n */\npublic class HouseDirector {\n   \n   HouseBuilder houseBuilder = null;\n\n   /**\n    * 构造器传入 houseBuilder\n    */\n   public HouseDirector(HouseBuilder houseBuilder) {\n      this.houseBuilder = houseBuilder;\n   }\n\n   /**\n    * 通过setter 传入 houseBuilder\n    */\n   public void setHouseBuilder(HouseBuilder houseBuilder) {\n      this.houseBuilder = houseBuilder;\n   }\n\n   /**\n    * 如何处理建造房子的流程，交给指挥者\n    */\n   public House constructHouse() {\n      houseBuilder.buildBasic();\n      houseBuilder.buildWalls();\n      houseBuilder.roofed();\n      return houseBuilder.buildHouse();\n   }\n   \n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nClient：\n\npublic class Client {\n   public static void main(String[] args) {\n      \n      //盖普通房子\n      CommonHouse commonHouse = new CommonHouse();\n      //准备创建房子的指挥者\n      HouseDirector houseDirector = new HouseDirector(commonHouse);\n      \n      //完成盖房子，返回产品(普通房子)\n      House house = houseDirector.constructHouse();\n      \n      //System.out.println("输出流程");\n      \n      System.out.println("--------------------------");\n      //盖高楼\n      HighBuilding highBuilding = new HighBuilding();\n      //重置建造者\n      houseDirector.setHouseBuilder(highBuilding);\n      //完成盖房子，返回产品(高楼)\n      houseDirector.constructHouse();\n      \n      \n      \n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 4. JDK的应用和源码分析-StringBuilder【重点】\n\n\n# 1. 源码\n\nStringBuilder：具体建造者，指挥者\n\nAbstractStringBuilder：不能实例化的建造者\n\nAppendable：抽象建造者\n\n\n# 2. 源码中建造者模式角色分析\n\n 1. Appendable 接口定义了多个append方法(抽象方法), 即Appendable 为抽象建造者, 定义了抽象方法\n\n 2. AbstractStringBuilder 实现了 Appendable 接口方法，这里的AbstractStringBuilder 已经是建造者，只是不能实例化\n\n 3. StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了AbstractStringBuilder\n\n\n# 5. 建造者模式的注意事项和细节\n\n 1. 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\n\n 2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象。\n\n 3. 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\n\n 4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”。\n\n 5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\n\n 6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。\n\n 7. 抽象工厂模式 VS 建造者模式\n    \n    抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。',normalizedContent:'# java设计模式-建造者模式\n\n\n# 1. 盖房项目需求\n\n 1. 需要建房子：这一过程为打桩、砌墙、封顶。\n\n 2. 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的。\n\n 3. 请编写程序，完成需求。\n\n\n# 1. 类图\n\n\n# 2. 代码实现\n\nabstracthouse\n\npublic abstract class abstracthouse {\n   \n   //打地基\n   public abstract void buildbasic();\n   //砌墙\n   public abstract void buildwalls();\n   //封顶\n   public abstract void roofed();\n   \n   public void build() {\n      buildbasic();\n      buildwalls();\n      roofed();\n   }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\ncommonhouse\n\npublic class commonhouse extends abstracthouse {\n\n   @override\n   public void buildbasic() {\n      // todo auto-generated method stub\n      system.out.println(" 普通房子打地基 ");\n   }\n\n   @override\n   public void buildwalls() {\n      // todo auto-generated method stub\n      system.out.println(" 普通房子砌墙 ");\n   }\n\n   @override\n   public void roofed() {\n      // todo auto-generated method stub\n      system.out.println(" 普通房子封顶 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nclient\n\npublic class client {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n      commonhouse commonhouse = new commonhouse();\n      commonhouse.build();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3. 传统方式解决盖房需求问题分析\n\n 1. 优点是比较好理解，简单易操作。\n\n 2. 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。\n\n 3. 解决方案：将产品和产品建造过程解耦 => 建造者模式。\n\n\n# 2. 建造者模式\n\n\n# 1. 基本介绍\n\n 1. 建造者模式（builder pattern） 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。\n\n 2. 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。\n\n\n# 2. 建造者模式的四个角色\n\n 1. product（产品角色）：一个具体的产品对象。\n\n 2. builder（抽象建造者）：创建一个product对象的各个部件指定的 接口/抽象类。\n\n 3. concretebuilder（具体建造者）：实现接口，构建和装配各个部件。\n\n 4. director（指挥者）：构建一个使用builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。\n\n\n# 3. 建造者模式原理类图\n\n\n# 3. 建造者模式解决盖房需求\n\n需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们使用建造者模式(builder pattern)来完成\n\n\n# 1. 类图\n\n\n# 2. 代码实现\n\nhouse：产品\n\n/**\n * 产品->product\n */\npublic class house {\n   private string baise;\n   private string wall;\n   private string roofed;\n   public string getbaise() {\n      return baise;\n   }\n   public void setbaise(string baise) {\n      this.baise = baise;\n   }\n   public string getwall() {\n      return wall;\n   }\n   public void setwall(string wall) {\n      this.wall = wall;\n   }\n   public string getroofed() {\n      return roofed;\n   }\n   public void setroofed(string roofed) {\n      this.roofed = roofed;\n   }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nhousebuilder： 抽象的建造者\n\n/**\n * 抽象的建造者\n */\npublic abstract class housebuilder {\n\n   protected house house = new house();\n\n   /**\n    * 将建造的流程写好, 抽象的方法\n    */\n   public abstract void buildbasic();\n   public abstract void buildwalls();\n   public abstract void roofed();\n\n   /**\n    * 建造房子好， 将产品(房子) 返回\n    */\n   public house buildhouse() {\n      return house;\n   }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\ncommonhouse：普通房子（具体的建造者）\n\npublic class commonhouse extends housebuilder {\n\n   @override\n   public void buildbasic() {\n      // todo auto-generated method stub\n      system.out.println(" 普通房子打地基5米 ");\n   }\n\n   @override\n   public void buildwalls() {\n      // todo auto-generated method stub\n      system.out.println(" 普通房子砌墙10cm ");\n   }\n\n   @override\n   public void roofed() {\n      // todo auto-generated method stub\n      system.out.println(" 普通房子屋顶 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nhighbuilding：高楼（具体的建造者）\n\npublic class highbuilding extends housebuilder {\n\n   @override\n   public void buildbasic() {\n      // todo auto-generated method stub\n      system.out.println(" 高楼的打地基100米 ");\n   }\n\n   @override\n   public void buildwalls() {\n      // todo auto-generated method stub\n      system.out.println(" 高楼的砌墙20cm ");\n   }\n\n   @override\n   public void roofed() {\n      // todo auto-generated method stub\n      system.out.println(" 高楼的透明屋顶 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nhousedirector：指挥者\n\n/**\n * 指挥者，这里去指定制作流程，返回产品\n */\npublic class housedirector {\n   \n   housebuilder housebuilder = null;\n\n   /**\n    * 构造器传入 housebuilder\n    */\n   public housedirector(housebuilder housebuilder) {\n      this.housebuilder = housebuilder;\n   }\n\n   /**\n    * 通过setter 传入 housebuilder\n    */\n   public void sethousebuilder(housebuilder housebuilder) {\n      this.housebuilder = housebuilder;\n   }\n\n   /**\n    * 如何处理建造房子的流程，交给指挥者\n    */\n   public house constructhouse() {\n      housebuilder.buildbasic();\n      housebuilder.buildwalls();\n      housebuilder.roofed();\n      return housebuilder.buildhouse();\n   }\n   \n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nclient：\n\npublic class client {\n   public static void main(string[] args) {\n      \n      //盖普通房子\n      commonhouse commonhouse = new commonhouse();\n      //准备创建房子的指挥者\n      housedirector housedirector = new housedirector(commonhouse);\n      \n      //完成盖房子，返回产品(普通房子)\n      house house = housedirector.constructhouse();\n      \n      //system.out.println("输出流程");\n      \n      system.out.println("--------------------------");\n      //盖高楼\n      highbuilding highbuilding = new highbuilding();\n      //重置建造者\n      housedirector.sethousebuilder(highbuilding);\n      //完成盖房子，返回产品(高楼)\n      housedirector.constructhouse();\n      \n      \n      \n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 4. jdk的应用和源码分析-stringbuilder【重点】\n\n\n# 1. 源码\n\nstringbuilder：具体建造者，指挥者\n\nabstractstringbuilder：不能实例化的建造者\n\nappendable：抽象建造者\n\n\n# 2. 源码中建造者模式角色分析\n\n 1. appendable 接口定义了多个append方法(抽象方法), 即appendable 为抽象建造者, 定义了抽象方法\n\n 2. abstractstringbuilder 实现了 appendable 接口方法，这里的abstractstringbuilder 已经是建造者，只是不能实例化\n\n 3. stringbuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 abstractstringbuilder 完成, 而stringbuilder 继承了abstractstringbuilder\n\n\n# 5. 建造者模式的注意事项和细节\n\n 1. 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\n\n 2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象。\n\n 3. 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\n\n 4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”。\n\n 5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\n\n 6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。\n\n 7. 抽象工厂模式 vs 建造者模式\n    \n    抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"IDEA配置",frontmatter:{title:"IDEA配置",date:"2023-03-01T22:30:37.000Z",permalink:"/pages/6ad6ad/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/01.IDEA/01.IDEA%E9%85%8D%E7%BD%AE.html",relativePath:"03.开发工具/01.集成开发环境/01.IDEA/01.IDEA配置.md",key:"v-0f364269",path:"/pages/6ad6ad/",headers:[{level:2,title:"1. 全局设置入口",slug:"_1-全局设置入口",normalizedTitle:"1. 全局设置入口",charIndex:15},{level:2,title:"2. 取消在启动时打开最近的项目",slug:"_2-取消在启动时打开最近的项目",normalizedTitle:"2. 取消在启动时打开最近的项目",charIndex:31},{level:2,title:"3. 取消自动更新",slug:"_3-取消自动更新",normalizedTitle:"3. 取消自动更新",charIndex:54},{level:2,title:"4. Ctrl+鼠标滚轮 改变字体大小",slug:"_4-ctrl-鼠标滚轮-改变字体大小",normalizedTitle:"4. ctrl+鼠标滚轮 改变字体大小",charIndex:70},{level:2,title:"5. 自动删除无用的导入",slug:"_5-自动删除无用的导入",normalizedTitle:"5. 自动删除无用的导入",charIndex:96},{level:2,title:"6. 显示方法分隔符",slug:"_6-显示方法分隔符",normalizedTitle:"6. 显示方法分隔符",charIndex:115},{level:2,title:"7. 忽略大小写提示",slug:"_7-忽略大小写提示",normalizedTitle:"7. 忽略大小写提示",charIndex:132},{level:2,title:"8. 取消单行显示Tabs",slug:"_8-取消单行显示tabs",normalizedTitle:"8. 取消单行显示tabs",charIndex:149},{level:2,title:"9. 编码",slug:"_9-编码",normalizedTitle:"9. 编码",charIndex:169},{level:2,title:"10. 突出显示项目树中包含修改过的文件的目录",slug:"_10-突出显示项目树中包含修改过的文件的目录",normalizedTitle:"10. 突出显示项目树中包含修改过的文件的目录",charIndex:181}],headersStr:"1. 全局设置入口 2. 取消在启动时打开最近的项目 3. 取消自动更新 4. Ctrl+鼠标滚轮 改变字体大小 5. 自动删除无用的导入 6. 显示方法分隔符 7. 忽略大小写提示 8. 取消单行显示Tabs 9. 编码 10. 突出显示项目树中包含修改过的文件的目录",content:"# IDEA全局设置\n\n\n# 1. 全局设置入口\n\n\n\n\n# 2. 取消在启动时打开最近的项目\n\n\n\n\n# 3. 取消自动更新\n\n\n\n\n# 4. Ctrl+鼠标滚轮 改变字体大小\n\n\n\n\n# 5. 自动删除无用的导入\n\n\n\n\n# 6. 显示方法分隔符\n\n\n\n\n# 7. 忽略大小写提示\n\n\n\n\n# 8. 取消单行显示Tabs\n\n\n\n\n# 9. 编码\n\n\n\n\n# 10. 突出显示项目树中包含修改过的文件的目录\n\n",normalizedContent:"# idea全局设置\n\n\n# 1. 全局设置入口\n\n\n\n\n# 2. 取消在启动时打开最近的项目\n\n\n\n\n# 3. 取消自动更新\n\n\n\n\n# 4. ctrl+鼠标滚轮 改变字体大小\n\n\n\n\n# 5. 自动删除无用的导入\n\n\n\n\n# 6. 显示方法分隔符\n\n\n\n\n# 7. 忽略大小写提示\n\n\n\n\n# 8. 取消单行显示tabs\n\n\n\n\n# 9. 编码\n\n\n\n\n# 10. 突出显示项目树中包含修改过的文件的目录\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/10, 08:04:32",lastUpdatedTimestamp:1678406672e3},{title:"Java设计模式-工厂模式",frontmatter:{title:"Java设计模式-工厂模式",date:"2023-02-25T20:46:26.000Z",permalink:"/pages/40d394/"},regularPath:"/02.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"02.编程基础/04.设计模式/5.Java设计模式-工厂模式.md",key:"v-44588890",path:"/pages/40d394/",headers:[{level:2,title:"0. 传统形式",slug:"_0-传统形式",normalizedTitle:"0. 传统形式",charIndex:148},{level:3,title:"1. 制作披萨",slug:"_1-制作披萨",normalizedTitle:"1. 制作披萨",charIndex:162},{level:3,title:"2. 订购披萨",slug:"_2-订购披萨",normalizedTitle:"2. 订购披萨",charIndex:1557},{level:3,title:"3. 传统的方式的优缺点",slug:"_3-传统的方式的优缺点",normalizedTitle:"3. 传统的方式的优缺点",charIndex:3243},{level:2,title:"1.简单工厂模式(静态工厂模式 )",slug:"_1-简单工厂模式-静态工厂模式",normalizedTitle:"1.简单工厂模式(静态工厂模式 )",charIndex:3583},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍",normalizedTitle:"1. 基本介绍",charIndex:3605},{level:3,title:"2. 代码实现",slug:"_2-代码实现",normalizedTitle:"2. 代码实现",charIndex:3789},{level:3,title:"3. 代码静态形式的改造",slug:"_3-代码静态形式的改造",normalizedTitle:"3. 代码静态形式的改造",charIndex:6127},{level:2,title:"2.工厂方法模式",slug:"_2-工厂方法模式",normalizedTitle:"2.工厂方法模式",charIndex:8064},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍-2",normalizedTitle:"1. 基本介绍",charIndex:3605},{level:3,title:"2. 代码实现",slug:"_2-代码实现-2",normalizedTitle:"2. 代码实现",charIndex:3789},{level:4,title:"1. 制作披萨",slug:"_1-制作披萨-2",normalizedTitle:"1. 制作披萨",charIndex:162},{level:4,title:"2. 订购披萨",slug:"_2-订购披萨-2",normalizedTitle:"2. 订购披萨",charIndex:1557},{level:2,title:"3.抽象工厂模式",slug:"_3-抽象工厂模式",normalizedTitle:"3.抽象工厂模式",charIndex:12830},{level:3,title:"1. 基本介绍",slug:"_1-基本介绍-3",normalizedTitle:"1. 基本介绍",charIndex:3605},{level:3,title:"2. 代码实现",slug:"_2-代码实现-3",normalizedTitle:"2. 代码实现",charIndex:3789},{level:4,title:"1. 制作披萨",slug:"_1-制作披萨-3",normalizedTitle:"1. 制作披萨",charIndex:162},{level:4,title:"2. 订购披萨",slug:"_2-订购披萨-3",normalizedTitle:"2. 订购披萨",charIndex:1557},{level:2,title:"4. 工厂模式JDK源码分析",slug:"_4-工厂模式jdk源码分析",normalizedTitle:"4. 工厂模式jdk源码分析",charIndex:17556},{level:2,title:"5. 总结",slug:"_5-总结",normalizedTitle:"5. 总结",charIndex:20491}],headersStr:"0. 传统形式 1. 制作披萨 2. 订购披萨 3. 传统的方式的优缺点 1.简单工厂模式(静态工厂模式 ) 1. 基本介绍 2. 代码实现 3. 代码静态形式的改造 2.工厂方法模式 1. 基本介绍 2. 代码实现 1. 制作披萨 2. 订购披萨 3.抽象工厂模式 1. 基本介绍 2. 代码实现 1. 制作披萨 2. 订购披萨 4. 工厂模式JDK源码分析 5. 总结",content:'# Java设计模式-工厂模式\n\n看一个具体的需求\n\n看一个披萨的项目：要便于披萨种类的扩展，要便于维护\n\n 1. 披萨的种类很多(比如 GreekPizz、CheesePizz 等)。\n 2. 披萨的制作有 prepare，bake, cut, box。\n 3. 完成披萨店订购功能。\n\n\n# 0. 传统形式\n\n\n\n\n# 1. 制作披萨\n\n 1. pizza 抽象类：prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\n/**\n * 将Pizza 类做成抽象\n */\npublic abstract class Pizza {\n\n   /**\n    * 名字\n    */\n   protected String name;\n\n   /**\n    * prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n    */\n   public abstract void prepare();\n\n\n   /**\n    * bake\n    */\n   public void bake() {\n      System.out.println(name + " baking;");\n   }\n\n   /**\n    * cut\n    */\n   public void cut() {\n      System.out.println(name + " cutting;");\n   }\n\n   /**\n    * box\n    */\n   public void box() {\n      System.out.println(name + " boxing;");\n   }\n\n   public void setName(String name) {\n      this.name = name;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n 2. 奶酪披萨 CheesePizza\n\npublic class CheesePizza extends Pizza {\n\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      System.out.println(" 给制作奶酪披萨 准备原材料 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 3. 希腊披萨 GreekPizza\n\npublic class GreekPizza extends Pizza {\n\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      System.out.println(" 给希腊披萨 准备原材料 ");\n   }\t\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 4. 胡椒披萨PepperPizza\n\npublic class PepperPizza extends Pizza {\n\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      System.out.println(" 给胡椒披萨准备原材料 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2. 订购披萨\n\n 1. OrderPizza 订购披萨\n\npublic class OrderPizza {\n\n    /**\n\t * 构造器\n\t */\n\tpublic OrderPizza() {\n\t\tPizza pizza = null;\n\t\tString orderType; // 订购披萨的类型\n\t\tdo {\n\t\t\torderType = getType();\n\t\t\tif ("greek".equals(orderType)) {\n\t\t\t\tpizza = new GreekPizza();\n\t\t\t\tpizza.setName(" 希腊披萨 ");\n\t\t\t} else if ("cheese".equals(orderType)) {\n\t\t\t\tpizza = new CheesePizza();\n\t\t\t\tpizza.setName(" 奶酪披萨 ");\n\t\t\t} else if ("pepper".equals(orderType)) {\n\t\t\t\tpizza = new PepperPizza();\n\t\t\t\tpizza.setName(" 胡椒披萨 ");\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//输出pizza 制作过程\n\t\t\tpizza.prepare();\n\t\t\tpizza.bake();\n\t\t\tpizza.cut();\n\t\t\tpizza.box();\n\n\t\t} while (true);\n\t}\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    */\n   private String getType() {\n      try {\n         BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n         System.out.println("input pizza 种类:");\n         String str = strin.readLine();\n         return str;\n      } catch (IOException e) {\n         e.printStackTrace();\n         return "";\n      }\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n 2. PizzaStore 相当于一个客户端，发出订购\n\n/**\n * 相当于一个客户端，发出订购\n */\npublic class PizzaStore {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      new OrderPizza();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\ninput pizza 种类:\ngreek\n 给希腊披萨 准备原材料 \n 希腊披萨  baking;\n 希腊披萨  cutting;\n 希腊披萨  boxing;\ninput pizza 种类:\ncheese\n 给制作奶酪披萨 准备原材料 \n 奶酪披萨  baking;\n 奶酪披萨  cutting;\n 奶酪披萨  boxing;\ninput pizza 种类:\npepper\n 给胡椒披萨准备原材料 \n胡椒披萨 baking;\n胡椒披萨 cutting;\n胡椒披萨 boxing;\ninput pizza 种类:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3. 传统的方式的优缺点\n\n 1. 优点是比较好理解，简单易操作。\n\n 2. 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n 3. 比如我们这时要新增加一个Pizza的种类(Pepper披萨)，我们需要做如下修改，维护成本高。\n\n 4. 改进的思路分析\n    \n    **分析：**修改代码可以接受，但是如果我们在其它的地方也有创建Pizza的代码，就意味着，也需要修改，而创建Pizza的代码，往往有多处。\n\n**思路：**把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该类就可，其它有创建到Pizza对象的代码就不需要修改了.-> 简单工厂模式\n\n\n# 1.简单工厂模式(静态工厂模式 )\n\n\n# 1. 基本介绍\n\n 1. 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式\n\n 2. 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)\n\n 3. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.\n\n\n# 2. 代码实现\n\n定制披萨代码同传统形式。\n\n1. 简单工厂类\n\n/**\n * 简单工厂类\n */\npublic class SimpleFactory {\n\n   /**\n    * 根据orderType 返回对应的Pizza 对象 简单工厂类\n    */\n   public Pizza createPizza(String orderType) {\n\n      Pizza pizza = null;\n\n      System.out.println("使用简单工厂模式");\n      if ("greek".equals(orderType)) {\n         pizza = new GreekPizza();\n         pizza.setName(" 希腊披萨 ");\n      } else if ("cheese".equals(orderType)) {\n         pizza = new CheesePizza();\n         pizza.setName(" 奶酪披萨 ");\n      } else if ("pepper".equals(orderType)) {\n         pizza = new PepperPizza();\n         pizza.setName(" 胡椒披萨 ");\n      }\n      \n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 2. OrderPizza 订购披萨\n\npublic class OrderPizza {\n\n   /**\n    * 定义一个简单工厂对象\n    */\n   SimpleFactory simpleFactory;\n   Pizza pizza = null;\n\n   /**\n    * 构造器\n    */\n   public OrderPizza(SimpleFactory simpleFactory) {\n      setFactory(simpleFactory);\n   }\n   \n   public void setFactory(SimpleFactory simpleFactory) {\n      //用户输入的\n      String orderType = "";\n\n      //设置简单工厂对象\n      this.simpleFactory = simpleFactory;\n      \n      do {\n         orderType = getType(); \n         pizza = this.simpleFactory.createPizza(orderType);\n         \n         //输出pizza\n         if(pizza != null) {\n            //订购成功\n            pizza.prepare();\n            pizza.bake();\n            pizza.cut();\n            pizza.box();\n         } else {\n            System.out.println(" 订购披萨失败 ");\n            break;\n         }\n      }while(true);\n   }\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    */\n   private String getType() {\n      try {\n         BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n         System.out.println("input pizza 种类:");\n         String str = strin.readLine();\n         return str;\n      } catch (IOException e) {\n         e.printStackTrace();\n         return "";\n      }\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n 3. PizzaStore 相当于一个客户端，发出订购\n\n/**\n * 相当于一个客户端，发出订购\n */\npublic class PizzaStore {\n\n   public static void main(String[] args) {\n      //使用简单工厂模式\n      new OrderPizza(new SimpleFactory());\n      System.out.println("~~退出程序~~");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3. 代码静态形式的改造\n\n 1. 静态工厂类\n\n/**\n * 简单工厂类\n */\npublic class SimpleFactory {\n\n   /**\n    * 简单工厂模式 也叫 静态工厂模式\n    */\n   \n   public static Pizza createPizza2(String orderType) {\n\n      Pizza pizza = null;\n\n      System.out.println("使用简单工厂模式2");\n      if ("greek".equals(orderType)) {\n         pizza = new GreekPizza();\n         pizza.setName(" 希腊披萨 ");\n      } else if ("cheese".equals(orderType)) {\n         pizza = new CheesePizza();\n         pizza.setName(" 奶酪披萨 ");\n      } else if ("pepper".equals(orderType)) {\n         pizza = new PepperPizza();\n         pizza.setName("胡椒披萨");\n      }\n      \n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n 2. OrderPizza 订购披萨\n\npublic class OrderPizza2 {\n\n   Pizza pizza = null;\n   String orderType = "";\n\n   /**\n    * 构造器\n    */\n   public OrderPizza2() {\n      \n      do {\n         orderType = getType();\n         pizza = SimpleFactory.createPizza2(orderType);\n\n         // 输出pizza\n         if (pizza != null) {\n            // 订购成功\n            pizza.prepare();\n            pizza.bake();\n            pizza.cut();\n            pizza.box();\n         } else {\n            System.out.println(" 订购披萨失败 ");\n            break;\n         }\n      } while (true);\n   }\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    */\n   private String getType() {\n      try {\n         BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n         System.out.println("input pizza 种类:");\n         String str = strin.readLine();\n         return str;\n      } catch (IOException e) {\n         e.printStackTrace();\n         return "";\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n 3. PizzaStore 相当于一个客户端，发出订购\n\n/**\n * 相当于一个客户端，发出订购\n */\npublic class PizzaStore {\n\n   public static void main(String[] args) {\n      new OrderPizza2();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.工厂方法模式\n\n新的需求\n\n披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。\n\n思路1\n\n使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好。\n\n思路2\n\n使用工厂方法模式。\n\n\n# 1. 基本介绍\n\n工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。\n\n工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。\n\n\n# 2. 代码实现\n\n# 1. 制作披萨\n\n 1. pizza 抽象类：prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\n/**\n * 将Pizza 类做成抽象\n */\npublic abstract class Pizza {\n\n   /**\n    * 名字\n    */\n   protected String name;\n\n   /**\n    * prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n    */\n   public abstract void prepare();\n\n\n   /**\n    * bake\n    */\n   public void bake() {\n      System.out.println(name + " baking;");\n   }\n\n   /**\n    * cut\n    */\n   public void cut() {\n      System.out.println(name + " cutting;");\n   }\n\n   /**\n    * box 打包\n    */\n   public void box() {\n      System.out.println(name + " boxing;");\n   }\n\n   public void setName(String name) {\n      this.name = name;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n 2. 北京的奶酪pizza BJCheesePizza\n\npublic class BJCheesePizza extends Pizza {\n\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      setName("北京的奶酪pizza");\n      System.out.println(" 北京的奶酪pizza 准备原材料");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. 北京的胡椒pizza BJPepperPizza\n\npublic class BJPepperPizza extends Pizza {\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      setName("北京的胡椒pizza");\n      System.out.println(" 北京的胡椒pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 伦敦的奶酪pizza LDCheesePizza\n\npublic class LDCheesePizza extends Pizza{\n\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      setName("伦敦的奶酪pizza");\n      System.out.println(" 伦敦的奶酪pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 5. 伦敦的胡椒pizza LDPepperPizza\n\npublic class LDPepperPizza extends Pizza{\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      setName("伦敦的胡椒pizza");\n      System.out.println(" 伦敦的胡椒pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2. 订购披萨\n\n 1. OrderPizza抽象类：createPizza抽象方法，让各个工厂子类自己实现。\n\npublic abstract class OrderPizza {\n\n   /**\n    * 定义一个抽象方法，createPizza , 让各个工厂子类自己实现\n    */\n   abstract Pizza createPizza(String orderType);\n\n   /**\n    * 构造器\n    */\n   public OrderPizza() {\n      Pizza pizza = null;\n      // 订购披萨的类型\n      String orderType;\n      do {\n         orderType = getType();\n         //抽象方法，由工厂子类完成\n         pizza = createPizza(orderType);\n         //输出pizza 制作过程\n         pizza.prepare();\n         pizza.bake();\n         pizza.cut();\n         pizza.box();\n         \n      } while (true);\n   }\n\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    * @return\n    */\n   private String getType() {\n      try {\n         BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n         System.out.println("input pizza 种类:");\n         String str = strin.readLine();\n         return str;\n      } catch (IOException e) {\n         e.printStackTrace();\n         return "";\n      }\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n 2. 北京pizza BJOrderPizza\n\npublic class BJOrderPizza extends OrderPizza {\n\n   \n   @Override\n   Pizza createPizza(String orderType) {\n   \n      Pizza pizza = null;\n      if(orderType.equals("cheese")) {\n         pizza = new BJCheesePizza();\n      } else if (orderType.equals("pepper")) {\n         pizza = new BJPepperPizza();\n      }\n      // TODO Auto-generated method stub\n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 3. 伦敦pizza LDOrderPizza\n\npublic class LDOrderPizza extends OrderPizza {\n\n   \n   @Override\n   Pizza createPizza(String orderType) {\n   \n      Pizza pizza = null;\n      if(orderType.equals("cheese")) {\n         pizza = new LDCheesePizza();\n      } else if (orderType.equals("pepper")) {\n         pizza = new LDPepperPizza();\n      }\n      // TODO Auto-generated method stub\n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 4. PizzaStore 相当于一个客户端，发出订购\n\npublic class PizzaStore {\n\n   public static void main(String[] args) {\n      String loc = "bj";\n      if (loc.equals("bj")) {\n         //创建北京口味的各种Pizza\n         new BJOrderPizza();\n      } else {\n         //创建伦敦口味的各种Pizza\n         new LDOrderPizza();\n      }\n      // TODO Auto-generated method stub\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n结果：\n\ninput pizza 种类:\ncheese\n 北京的奶酪pizza 准备原材料\n北京的奶酪pizza baking;\n北京的奶酪pizza cutting;\n北京的奶酪pizza boxing;\ninput pizza 种类:\npepper\n 北京的胡椒pizza 准备原材料\n北京的胡椒pizza baking;\n北京的胡椒pizza cutting;\n北京的胡椒pizza boxing;\ninput pizza 种类:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.抽象工厂模式\n\n\n# 1. 基本介绍\n\n 1. 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类\n\n 2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。\n\n 3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。\n\n 4. 将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，利于代码的维护和扩展。\n\n 5. 类图\n\n\n# 2. 代码实现\n\n# 1. 制作披萨\n\n 1. pizza 抽象类：prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\n/**\n * 将Pizza 类做成抽象\n */\npublic abstract class Pizza {\n\n   /**\n    * 名字\n    */\n   protected String name;\n\n   /**\n    * prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n    */\n   public abstract void prepare();\n\n\n   /**\n    * bake\n    */\n   public void bake() {\n      System.out.println(name + " baking;");\n   }\n\n   /**\n    * cut\n    */\n   public void cut() {\n      System.out.println(name + " cutting;");\n   }\n\n   /**\n    * box 打包\n    */\n   public void box() {\n      System.out.println(name + " boxing;");\n   }\n\n   public void setName(String name) {\n      this.name = name;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n 2. 北京的奶酪pizza BJCheesePizza\n\npublic class BJCheesePizza extends Pizza {\n\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      setName("北京的奶酪pizza");\n      System.out.println(" 北京的奶酪pizza 准备原材料");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. 北京的胡椒pizza BJPepperPizza\n\npublic class BJPepperPizza extends Pizza {\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      setName("北京的胡椒pizza");\n      System.out.println(" 北京的胡椒pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 伦敦的奶酪pizza LDCheesePizza\n\npublic class LDCheesePizza extends Pizza{\n\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      setName("伦敦的奶酪pizza");\n      System.out.println(" 伦敦的奶酪pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 5. 伦敦的胡椒pizza LDPepperPizza\n\npublic class LDPepperPizza extends Pizza{\n   @Override\n   public void prepare() {\n      // TODO Auto-generated method stub\n      setName("伦敦的胡椒pizza");\n      System.out.println(" 伦敦的胡椒pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2. 订购披萨\n\n 1. AbsFactory：一个抽象工厂模式的抽象层(接口)\n\n/**\n * 一个抽象工厂模式的抽象层(接口)\n */\npublic interface AbsFactory {\n   /**\n    * 让下面的工厂子类来 具体实现\n    */\n   public Pizza createPizza(String orderType);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. BJFactory：北京工厂子类\n\n/**\n * 这是工厂子类\n */\npublic class BJFactory implements AbsFactory {\n\n   @Override\n   public Pizza createPizza(String orderType) {\n      System.out.println("~使用的是抽象工厂模式~");\n      // TODO Auto-generated method stub\n      Pizza pizza = null;\n      if(orderType.equals("cheese")) {\n         pizza = new BJCheesePizza();\n      } else if (orderType.equals("pepper")){\n         pizza = new BJPepperPizza();\n      }\n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 3. LDFactory：伦敦工厂子类\n\npublic class LDFactory implements AbsFactory {\n\n   @Override\n   public Pizza createPizza(String orderType) {\n      System.out.println("~使用的是抽象工厂模式~");\n      Pizza pizza = null;\n      if (orderType.equals("cheese")) {\n         pizza = new LDCheesePizza();\n      } else if (orderType.equals("pepper")) {\n         pizza = new LDPepperPizza();\n      }\n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 4. OrderPizza：\n\npublic class OrderPizza {\n\n   AbsFactory factory;\n\n   /**\n    * 构造器\n    * @param factory\n    */\n   public OrderPizza(AbsFactory factory) {\n      setFactory(factory);\n   }\n\n   private void setFactory(AbsFactory factory) {\n      Pizza pizza = null;\n      // 用户输入\n      String orderType = "";\n      this.factory = factory;\n      do {\n         orderType = getType();\n         // factory 可能是北京的工厂子类，也可能是伦敦的工厂子类\n         pizza = factory.createPizza(orderType);\n         // 订购ok\n         if (pizza != null) {\n            pizza.prepare();\n            pizza.bake();\n            pizza.cut();\n            pizza.box();\n         } else {\n            System.out.println("订购失败");\n            break;\n         }\n      } while (true);\n   }\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    * @return\n    */\n   private String getType() {\n      try {\n         BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n         System.out.println("input pizza 种类:");\n         String str = strin.readLine();\n         return str;\n      } catch (IOException e) {\n         e.printStackTrace();\n         return "";\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n 5. PizzaStore：相当于一个客户端，发出订购\n\npublic class PizzaStore {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      //new OrderPizza(new BJFactory());\n      new OrderPizza(new LDFactory());\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4. 工厂模式JDK源码分析\n\n工厂模式在JDK-Calendar应用的源码分析\n\n 1. JDK 中的Calendar类中，就使用了简单工厂模式\n\n 2. 源码分析+Debug源码+说明\n\npublic class Factory {\n\n   public static void main(String[] args) {\n      // TODO Auto-generated method stub\n      // getInstance 是 Calendar 静态方法\n      Calendar cal = Calendar.getInstance();\n      // 注意月份下标从0开始，所以取月份要+1\n      System.out.println("年:" + cal.get(Calendar.YEAR));\n      System.out.println("月:" + (cal.get(Calendar.MONTH) + 1));\n      System.out.println("日:" + cal.get(Calendar.DAY_OF_MONTH));\n      System.out.println("时:" + cal.get(Calendar.HOUR_OF_DAY));\n      System.out.println("分:" + cal.get(Calendar.MINUTE));\n      System.out.println("秒:" + cal.get(Calendar.SECOND));\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nCalendar.getInstance()\n\npublic static Calendar getInstance()\n{\n    return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));\n}\n\n\n1\n2\n3\n4\n\n\ncreateCalendar\n\nprivate static Calendar createCalendar(TimeZone zone,\n                                       Locale aLocale)\n{\n    CalendarProvider provider =\n        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)\n                             .getCalendarProvider();\n    if (provider != null) {\n        try {\n            return provider.getInstance(zone, aLocale);\n        } catch (IllegalArgumentException iae) {\n            // fall back to the default instantiation\n        }\n    }\n\n    Calendar cal = null;\n\n    if (aLocale.hasExtensions()) {\n        String caltype = aLocale.getUnicodeLocaleType("ca");\n        if (caltype != null) {\n            switch (caltype) {\n            case "buddhist":\n            cal = new BuddhistCalendar(zone, aLocale);\n                break;\n            case "japanese":\n                cal = new JapaneseImperialCalendar(zone, aLocale);\n                break;\n            case "gregory":\n                cal = new GregorianCalendar(zone, aLocale);\n                break;\n            }\n        }\n    }\n    if (cal == null) {\n        // If no known calendar type is explicitly specified,\n        // perform the traditional way to create a Calendar:\n        // create a BuddhistCalendar for th_TH locale,\n        // a JapaneseImperialCalendar for ja_JP_JP locale, or\n        // a GregorianCalendar for any other locales.\n        // NOTE: The language, country and variant strings are interned.\n        if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {\n            cal = new BuddhistCalendar(zone, aLocale);\n        } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"\n                   && aLocale.getCountry() == "JP") {\n            cal = new JapaneseImperialCalendar(zone, aLocale);\n        } else {\n            cal = new GregorianCalendar(zone, aLocale);\n        }\n    }\n    return cal;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 5. 总结\n\n工厂模式其实是加了一层接口通过增加接口或者父类的形式去降低耦合性，并且如果有功能的扩张，是不需要在原来的代码上改动的。\n\n 1. 工厂模式的意义\n\n将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。\n\n 2. 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)\n\n 3. 设计模式的依赖抽象原则\n\n 创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。\n\n 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)\n\n 不要覆盖基类中已经实现的方法。',normalizedContent:'# java设计模式-工厂模式\n\n看一个具体的需求\n\n看一个披萨的项目：要便于披萨种类的扩展，要便于维护\n\n 1. 披萨的种类很多(比如 greekpizz、cheesepizz 等)。\n 2. 披萨的制作有 prepare，bake, cut, box。\n 3. 完成披萨店订购功能。\n\n\n# 0. 传统形式\n\n\n\n\n# 1. 制作披萨\n\n 1. pizza 抽象类：prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\n/**\n * 将pizza 类做成抽象\n */\npublic abstract class pizza {\n\n   /**\n    * 名字\n    */\n   protected string name;\n\n   /**\n    * prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n    */\n   public abstract void prepare();\n\n\n   /**\n    * bake\n    */\n   public void bake() {\n      system.out.println(name + " baking;");\n   }\n\n   /**\n    * cut\n    */\n   public void cut() {\n      system.out.println(name + " cutting;");\n   }\n\n   /**\n    * box\n    */\n   public void box() {\n      system.out.println(name + " boxing;");\n   }\n\n   public void setname(string name) {\n      this.name = name;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n 2. 奶酪披萨 cheesepizza\n\npublic class cheesepizza extends pizza {\n\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      system.out.println(" 给制作奶酪披萨 准备原材料 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 3. 希腊披萨 greekpizza\n\npublic class greekpizza extends pizza {\n\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      system.out.println(" 给希腊披萨 准备原材料 ");\n   }\t\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 4. 胡椒披萨pepperpizza\n\npublic class pepperpizza extends pizza {\n\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      system.out.println(" 给胡椒披萨准备原材料 ");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2. 订购披萨\n\n 1. orderpizza 订购披萨\n\npublic class orderpizza {\n\n    /**\n\t * 构造器\n\t */\n\tpublic orderpizza() {\n\t\tpizza pizza = null;\n\t\tstring ordertype; // 订购披萨的类型\n\t\tdo {\n\t\t\tordertype = gettype();\n\t\t\tif ("greek".equals(ordertype)) {\n\t\t\t\tpizza = new greekpizza();\n\t\t\t\tpizza.setname(" 希腊披萨 ");\n\t\t\t} else if ("cheese".equals(ordertype)) {\n\t\t\t\tpizza = new cheesepizza();\n\t\t\t\tpizza.setname(" 奶酪披萨 ");\n\t\t\t} else if ("pepper".equals(ordertype)) {\n\t\t\t\tpizza = new pepperpizza();\n\t\t\t\tpizza.setname(" 胡椒披萨 ");\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//输出pizza 制作过程\n\t\t\tpizza.prepare();\n\t\t\tpizza.bake();\n\t\t\tpizza.cut();\n\t\t\tpizza.box();\n\n\t\t} while (true);\n\t}\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    */\n   private string gettype() {\n      try {\n         bufferedreader strin = new bufferedreader(new inputstreamreader(system.in));\n         system.out.println("input pizza 种类:");\n         string str = strin.readline();\n         return str;\n      } catch (ioexception e) {\n         e.printstacktrace();\n         return "";\n      }\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n 2. pizzastore 相当于一个客户端，发出订购\n\n/**\n * 相当于一个客户端，发出订购\n */\npublic class pizzastore {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n      new orderpizza();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\ninput pizza 种类:\ngreek\n 给希腊披萨 准备原材料 \n 希腊披萨  baking;\n 希腊披萨  cutting;\n 希腊披萨  boxing;\ninput pizza 种类:\ncheese\n 给制作奶酪披萨 准备原材料 \n 奶酪披萨  baking;\n 奶酪披萨  cutting;\n 奶酪披萨  boxing;\ninput pizza 种类:\npepper\n 给胡椒披萨准备原材料 \n胡椒披萨 baking;\n胡椒披萨 cutting;\n胡椒披萨 boxing;\ninput pizza 种类:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3. 传统的方式的优缺点\n\n 1. 优点是比较好理解，简单易操作。\n\n 2. 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n 3. 比如我们这时要新增加一个pizza的种类(pepper披萨)，我们需要做如下修改，维护成本高。\n\n 4. 改进的思路分析\n    \n    **分析：**修改代码可以接受，但是如果我们在其它的地方也有创建pizza的代码，就意味着，也需要修改，而创建pizza的代码，往往有多处。\n\n**思路：**把创建pizza对象封装到一个类中，这样我们有新的pizza种类时，只需要修改该类就可，其它有创建到pizza对象的代码就不需要修改了.-> 简单工厂模式\n\n\n# 1.简单工厂模式(静态工厂模式 )\n\n\n# 1. 基本介绍\n\n 1. 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式\n\n 2. 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)\n\n 3. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.\n\n\n# 2. 代码实现\n\n定制披萨代码同传统形式。\n\n1. 简单工厂类\n\n/**\n * 简单工厂类\n */\npublic class simplefactory {\n\n   /**\n    * 根据ordertype 返回对应的pizza 对象 简单工厂类\n    */\n   public pizza createpizza(string ordertype) {\n\n      pizza pizza = null;\n\n      system.out.println("使用简单工厂模式");\n      if ("greek".equals(ordertype)) {\n         pizza = new greekpizza();\n         pizza.setname(" 希腊披萨 ");\n      } else if ("cheese".equals(ordertype)) {\n         pizza = new cheesepizza();\n         pizza.setname(" 奶酪披萨 ");\n      } else if ("pepper".equals(ordertype)) {\n         pizza = new pepperpizza();\n         pizza.setname(" 胡椒披萨 ");\n      }\n      \n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 2. orderpizza 订购披萨\n\npublic class orderpizza {\n\n   /**\n    * 定义一个简单工厂对象\n    */\n   simplefactory simplefactory;\n   pizza pizza = null;\n\n   /**\n    * 构造器\n    */\n   public orderpizza(simplefactory simplefactory) {\n      setfactory(simplefactory);\n   }\n   \n   public void setfactory(simplefactory simplefactory) {\n      //用户输入的\n      string ordertype = "";\n\n      //设置简单工厂对象\n      this.simplefactory = simplefactory;\n      \n      do {\n         ordertype = gettype(); \n         pizza = this.simplefactory.createpizza(ordertype);\n         \n         //输出pizza\n         if(pizza != null) {\n            //订购成功\n            pizza.prepare();\n            pizza.bake();\n            pizza.cut();\n            pizza.box();\n         } else {\n            system.out.println(" 订购披萨失败 ");\n            break;\n         }\n      }while(true);\n   }\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    */\n   private string gettype() {\n      try {\n         bufferedreader strin = new bufferedreader(new inputstreamreader(system.in));\n         system.out.println("input pizza 种类:");\n         string str = strin.readline();\n         return str;\n      } catch (ioexception e) {\n         e.printstacktrace();\n         return "";\n      }\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n 3. pizzastore 相当于一个客户端，发出订购\n\n/**\n * 相当于一个客户端，发出订购\n */\npublic class pizzastore {\n\n   public static void main(string[] args) {\n      //使用简单工厂模式\n      new orderpizza(new simplefactory());\n      system.out.println("~~退出程序~~");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3. 代码静态形式的改造\n\n 1. 静态工厂类\n\n/**\n * 简单工厂类\n */\npublic class simplefactory {\n\n   /**\n    * 简单工厂模式 也叫 静态工厂模式\n    */\n   \n   public static pizza createpizza2(string ordertype) {\n\n      pizza pizza = null;\n\n      system.out.println("使用简单工厂模式2");\n      if ("greek".equals(ordertype)) {\n         pizza = new greekpizza();\n         pizza.setname(" 希腊披萨 ");\n      } else if ("cheese".equals(ordertype)) {\n         pizza = new cheesepizza();\n         pizza.setname(" 奶酪披萨 ");\n      } else if ("pepper".equals(ordertype)) {\n         pizza = new pepperpizza();\n         pizza.setname("胡椒披萨");\n      }\n      \n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n 2. orderpizza 订购披萨\n\npublic class orderpizza2 {\n\n   pizza pizza = null;\n   string ordertype = "";\n\n   /**\n    * 构造器\n    */\n   public orderpizza2() {\n      \n      do {\n         ordertype = gettype();\n         pizza = simplefactory.createpizza2(ordertype);\n\n         // 输出pizza\n         if (pizza != null) {\n            // 订购成功\n            pizza.prepare();\n            pizza.bake();\n            pizza.cut();\n            pizza.box();\n         } else {\n            system.out.println(" 订购披萨失败 ");\n            break;\n         }\n      } while (true);\n   }\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    */\n   private string gettype() {\n      try {\n         bufferedreader strin = new bufferedreader(new inputstreamreader(system.in));\n         system.out.println("input pizza 种类:");\n         string str = strin.readline();\n         return str;\n      } catch (ioexception e) {\n         e.printstacktrace();\n         return "";\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n 3. pizzastore 相当于一个客户端，发出订购\n\n/**\n * 相当于一个客户端，发出订购\n */\npublic class pizzastore {\n\n   public static void main(string[] args) {\n      new orderpizza2();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.工厂方法模式\n\n新的需求\n\n披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。\n\n思路1\n\n使用简单工厂模式，创建不同的简单工厂类，比如bjpizzasimplefactory、ldpizzasimplefactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好。\n\n思路2\n\n使用工厂方法模式。\n\n\n# 1. 基本介绍\n\n工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。\n\n工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。\n\n\n# 2. 代码实现\n\n# 1. 制作披萨\n\n 1. pizza 抽象类：prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\n/**\n * 将pizza 类做成抽象\n */\npublic abstract class pizza {\n\n   /**\n    * 名字\n    */\n   protected string name;\n\n   /**\n    * prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n    */\n   public abstract void prepare();\n\n\n   /**\n    * bake\n    */\n   public void bake() {\n      system.out.println(name + " baking;");\n   }\n\n   /**\n    * cut\n    */\n   public void cut() {\n      system.out.println(name + " cutting;");\n   }\n\n   /**\n    * box 打包\n    */\n   public void box() {\n      system.out.println(name + " boxing;");\n   }\n\n   public void setname(string name) {\n      this.name = name;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n 2. 北京的奶酪pizza bjcheesepizza\n\npublic class bjcheesepizza extends pizza {\n\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      setname("北京的奶酪pizza");\n      system.out.println(" 北京的奶酪pizza 准备原材料");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. 北京的胡椒pizza bjpepperpizza\n\npublic class bjpepperpizza extends pizza {\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      setname("北京的胡椒pizza");\n      system.out.println(" 北京的胡椒pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 伦敦的奶酪pizza ldcheesepizza\n\npublic class ldcheesepizza extends pizza{\n\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      setname("伦敦的奶酪pizza");\n      system.out.println(" 伦敦的奶酪pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 5. 伦敦的胡椒pizza ldpepperpizza\n\npublic class ldpepperpizza extends pizza{\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      setname("伦敦的胡椒pizza");\n      system.out.println(" 伦敦的胡椒pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2. 订购披萨\n\n 1. orderpizza抽象类：createpizza抽象方法，让各个工厂子类自己实现。\n\npublic abstract class orderpizza {\n\n   /**\n    * 定义一个抽象方法，createpizza , 让各个工厂子类自己实现\n    */\n   abstract pizza createpizza(string ordertype);\n\n   /**\n    * 构造器\n    */\n   public orderpizza() {\n      pizza pizza = null;\n      // 订购披萨的类型\n      string ordertype;\n      do {\n         ordertype = gettype();\n         //抽象方法，由工厂子类完成\n         pizza = createpizza(ordertype);\n         //输出pizza 制作过程\n         pizza.prepare();\n         pizza.bake();\n         pizza.cut();\n         pizza.box();\n         \n      } while (true);\n   }\n\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    * @return\n    */\n   private string gettype() {\n      try {\n         bufferedreader strin = new bufferedreader(new inputstreamreader(system.in));\n         system.out.println("input pizza 种类:");\n         string str = strin.readline();\n         return str;\n      } catch (ioexception e) {\n         e.printstacktrace();\n         return "";\n      }\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n 2. 北京pizza bjorderpizza\n\npublic class bjorderpizza extends orderpizza {\n\n   \n   @override\n   pizza createpizza(string ordertype) {\n   \n      pizza pizza = null;\n      if(ordertype.equals("cheese")) {\n         pizza = new bjcheesepizza();\n      } else if (ordertype.equals("pepper")) {\n         pizza = new bjpepperpizza();\n      }\n      // todo auto-generated method stub\n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 3. 伦敦pizza ldorderpizza\n\npublic class ldorderpizza extends orderpizza {\n\n   \n   @override\n   pizza createpizza(string ordertype) {\n   \n      pizza pizza = null;\n      if(ordertype.equals("cheese")) {\n         pizza = new ldcheesepizza();\n      } else if (ordertype.equals("pepper")) {\n         pizza = new ldpepperpizza();\n      }\n      // todo auto-generated method stub\n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 4. pizzastore 相当于一个客户端，发出订购\n\npublic class pizzastore {\n\n   public static void main(string[] args) {\n      string loc = "bj";\n      if (loc.equals("bj")) {\n         //创建北京口味的各种pizza\n         new bjorderpizza();\n      } else {\n         //创建伦敦口味的各种pizza\n         new ldorderpizza();\n      }\n      // todo auto-generated method stub\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n结果：\n\ninput pizza 种类:\ncheese\n 北京的奶酪pizza 准备原材料\n北京的奶酪pizza baking;\n北京的奶酪pizza cutting;\n北京的奶酪pizza boxing;\ninput pizza 种类:\npepper\n 北京的胡椒pizza 准备原材料\n北京的胡椒pizza baking;\n北京的胡椒pizza cutting;\n北京的胡椒pizza boxing;\ninput pizza 种类:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.抽象工厂模式\n\n\n# 1. 基本介绍\n\n 1. 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类\n\n 2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。\n\n 3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。\n\n 4. 将工厂抽象成两层，absfactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，利于代码的维护和扩展。\n\n 5. 类图\n\n\n# 2. 代码实现\n\n# 1. 制作披萨\n\n 1. pizza 抽象类：prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\n/**\n * 将pizza 类做成抽象\n */\npublic abstract class pizza {\n\n   /**\n    * 名字\n    */\n   protected string name;\n\n   /**\n    * prepare 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n    */\n   public abstract void prepare();\n\n\n   /**\n    * bake\n    */\n   public void bake() {\n      system.out.println(name + " baking;");\n   }\n\n   /**\n    * cut\n    */\n   public void cut() {\n      system.out.println(name + " cutting;");\n   }\n\n   /**\n    * box 打包\n    */\n   public void box() {\n      system.out.println(name + " boxing;");\n   }\n\n   public void setname(string name) {\n      this.name = name;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n 2. 北京的奶酪pizza bjcheesepizza\n\npublic class bjcheesepizza extends pizza {\n\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      setname("北京的奶酪pizza");\n      system.out.println(" 北京的奶酪pizza 准备原材料");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. 北京的胡椒pizza bjpepperpizza\n\npublic class bjpepperpizza extends pizza {\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      setname("北京的胡椒pizza");\n      system.out.println(" 北京的胡椒pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 伦敦的奶酪pizza ldcheesepizza\n\npublic class ldcheesepizza extends pizza{\n\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      setname("伦敦的奶酪pizza");\n      system.out.println(" 伦敦的奶酪pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 5. 伦敦的胡椒pizza ldpepperpizza\n\npublic class ldpepperpizza extends pizza{\n   @override\n   public void prepare() {\n      // todo auto-generated method stub\n      setname("伦敦的胡椒pizza");\n      system.out.println(" 伦敦的胡椒pizza 准备原材料");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2. 订购披萨\n\n 1. absfactory：一个抽象工厂模式的抽象层(接口)\n\n/**\n * 一个抽象工厂模式的抽象层(接口)\n */\npublic interface absfactory {\n   /**\n    * 让下面的工厂子类来 具体实现\n    */\n   public pizza createpizza(string ordertype);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. bjfactory：北京工厂子类\n\n/**\n * 这是工厂子类\n */\npublic class bjfactory implements absfactory {\n\n   @override\n   public pizza createpizza(string ordertype) {\n      system.out.println("~使用的是抽象工厂模式~");\n      // todo auto-generated method stub\n      pizza pizza = null;\n      if(ordertype.equals("cheese")) {\n         pizza = new bjcheesepizza();\n      } else if (ordertype.equals("pepper")){\n         pizza = new bjpepperpizza();\n      }\n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 3. ldfactory：伦敦工厂子类\n\npublic class ldfactory implements absfactory {\n\n   @override\n   public pizza createpizza(string ordertype) {\n      system.out.println("~使用的是抽象工厂模式~");\n      pizza pizza = null;\n      if (ordertype.equals("cheese")) {\n         pizza = new ldcheesepizza();\n      } else if (ordertype.equals("pepper")) {\n         pizza = new ldpepperpizza();\n      }\n      return pizza;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 4. orderpizza：\n\npublic class orderpizza {\n\n   absfactory factory;\n\n   /**\n    * 构造器\n    * @param factory\n    */\n   public orderpizza(absfactory factory) {\n      setfactory(factory);\n   }\n\n   private void setfactory(absfactory factory) {\n      pizza pizza = null;\n      // 用户输入\n      string ordertype = "";\n      this.factory = factory;\n      do {\n         ordertype = gettype();\n         // factory 可能是北京的工厂子类，也可能是伦敦的工厂子类\n         pizza = factory.createpizza(ordertype);\n         // 订购ok\n         if (pizza != null) {\n            pizza.prepare();\n            pizza.bake();\n            pizza.cut();\n            pizza.box();\n         } else {\n            system.out.println("订购失败");\n            break;\n         }\n      } while (true);\n   }\n\n   /**\n    * 写一个方法，可以获取客户希望订购的披萨种类\n    * @return\n    */\n   private string gettype() {\n      try {\n         bufferedreader strin = new bufferedreader(new inputstreamreader(system.in));\n         system.out.println("input pizza 种类:");\n         string str = strin.readline();\n         return str;\n      } catch (ioexception e) {\n         e.printstacktrace();\n         return "";\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n 5. pizzastore：相当于一个客户端，发出订购\n\npublic class pizzastore {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n      //new orderpizza(new bjfactory());\n      new orderpizza(new ldfactory());\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4. 工厂模式jdk源码分析\n\n工厂模式在jdk-calendar应用的源码分析\n\n 1. jdk 中的calendar类中，就使用了简单工厂模式\n\n 2. 源码分析+debug源码+说明\n\npublic class factory {\n\n   public static void main(string[] args) {\n      // todo auto-generated method stub\n      // getinstance 是 calendar 静态方法\n      calendar cal = calendar.getinstance();\n      // 注意月份下标从0开始，所以取月份要+1\n      system.out.println("年:" + cal.get(calendar.year));\n      system.out.println("月:" + (cal.get(calendar.month) + 1));\n      system.out.println("日:" + cal.get(calendar.day_of_month));\n      system.out.println("时:" + cal.get(calendar.hour_of_day));\n      system.out.println("分:" + cal.get(calendar.minute));\n      system.out.println("秒:" + cal.get(calendar.second));\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\ncalendar.getinstance()\n\npublic static calendar getinstance()\n{\n    return createcalendar(timezone.getdefault(), locale.getdefault(locale.category.format));\n}\n\n\n1\n2\n3\n4\n\n\ncreatecalendar\n\nprivate static calendar createcalendar(timezone zone,\n                                       locale alocale)\n{\n    calendarprovider provider =\n        localeprovideradapter.getadapter(calendarprovider.class, alocale)\n                             .getcalendarprovider();\n    if (provider != null) {\n        try {\n            return provider.getinstance(zone, alocale);\n        } catch (illegalargumentexception iae) {\n            // fall back to the default instantiation\n        }\n    }\n\n    calendar cal = null;\n\n    if (alocale.hasextensions()) {\n        string caltype = alocale.getunicodelocaletype("ca");\n        if (caltype != null) {\n            switch (caltype) {\n            case "buddhist":\n            cal = new buddhistcalendar(zone, alocale);\n                break;\n            case "japanese":\n                cal = new japaneseimperialcalendar(zone, alocale);\n                break;\n            case "gregory":\n                cal = new gregoriancalendar(zone, alocale);\n                break;\n            }\n        }\n    }\n    if (cal == null) {\n        // if no known calendar type is explicitly specified,\n        // perform the traditional way to create a calendar:\n        // create a buddhistcalendar for th_th locale,\n        // a japaneseimperialcalendar for ja_jp_jp locale, or\n        // a gregoriancalendar for any other locales.\n        // note: the language, country and variant strings are interned.\n        if (alocale.getlanguage() == "th" && alocale.getcountry() == "th") {\n            cal = new buddhistcalendar(zone, alocale);\n        } else if (alocale.getvariant() == "jp" && alocale.getlanguage() == "ja"\n                   && alocale.getcountry() == "jp") {\n            cal = new japaneseimperialcalendar(zone, alocale);\n        } else {\n            cal = new gregoriancalendar(zone, alocale);\n        }\n    }\n    return cal;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 5. 总结\n\n工厂模式其实是加了一层接口通过增加接口或者父类的形式去降低耦合性，并且如果有功能的扩张，是不需要在原来的代码上改动的。\n\n 1. 工厂模式的意义\n\n将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。\n\n 2. 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)\n\n 3. 设计模式的依赖抽象原则\n\n 创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。\n\n 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)\n\n 不要覆盖基类中已经实现的方法。',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"IDEA快捷键(windows)",frontmatter:{title:"IDEA快捷键(windows)",date:"2023-03-01T22:30:37.000Z",permalink:"/pages/9f28c6/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/01.IDEA/02.IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE(windows).html",relativePath:"03.开发工具/01.集成开发环境/01.IDEA/02.IDEA快捷键(windows).md",key:"v-73b1812c",path:"/pages/9f28c6/",headers:[{level:2,title:"1. 官方文档",slug:"_1-官方文档",normalizedTitle:"1. 官方文档",charIndex:23},{level:2,title:"2. 文档翻译",slug:"_2-文档翻译",normalizedTitle:"2. 文档翻译",charIndex:87},{level:3,title:"1. 记住这些快捷键",slug:"_1-记住这些快捷键",normalizedTitle:"1. 记住这些快捷键",charIndex:99},{level:3,title:"2. 综合的",slug:"_2-综合的",normalizedTitle:"2. 综合的",charIndex:757},{level:3,title:"3. 调试",slug:"_3-调试",normalizedTitle:"3. 调试",charIndex:1528},{level:3,title:"4. 搜索/替换",slug:"_4-搜索-替换",normalizedTitle:"4. 搜索/替换",charIndex:1929},{level:3,title:"5. 编辑",slug:"_5-编辑",normalizedTitle:"5. 编辑",charIndex:2440},{level:3,title:"6. 重构",slug:"_6-重构",normalizedTitle:"6. 重构",charIndex:5632},{level:3,title:"7. 导航",slug:"_7-导航",normalizedTitle:"7. 导航",charIndex:6148},{level:3,title:"8. 编译和运行",slug:"_8-编译和运行",normalizedTitle:"8. 编译和运行",charIndex:8595},{level:3,title:"9. 使用搜索",slug:"_9-使用搜索",normalizedTitle:"9. 使用搜索",charIndex:9111},{level:3,title:"10. 版本控制/本地历史",slug:"_10-版本控制-本地历史",normalizedTitle:"10. 版本控制/本地历史",charIndex:9386},{level:2,title:"3. 自定义快捷键",slug:"_3-自定义快捷键",normalizedTitle:"3. 自定义快捷键",charIndex:9802}],headersStr:"1. 官方文档 2. 文档翻译 1. 记住这些快捷键 2. 综合的 3. 调试 4. 搜索/替换 5. 编辑 6. 重构 7. 导航 8. 编译和运行 9. 使用搜索 10. 版本控制/本地历史 3. 自定义快捷键",content:'# IDEA快捷键(windows)\n\n\n# 1. 官方文档\n\nIntelliJIDEA_ReferenceCard.pdf (jetbrains.com)\n\n\n\n\n\n\n# 2. 文档翻译\n\n\n# 1. 记住这些快捷键\n\nREMEMBER THESE SHORTCUTS                 记住这些快捷键     \nSmart code completion                    智能代码完成      Ctrl + Shift + Space\nSearch everywhere                        全局搜索        Double Shift\nShow intention actions and quick-fixes   显示提示和快速修复   Alt + Enter\nGenerate code                            生成代码        Alt + Ins\nParameter info                           参数信息        Ctrl + P\nExtend selection                         扩展选择        Ctrl + W\nShrink selection                         收缩选择        Ctrl + Shift + W\nRecent files popup                       最近的文件弹出窗口   Ctrl + E\nRename                                   重命名         Shift + F6\n\n\n# 2. 综合的\n\nGENERAL                                     综合的              \nOpen corresponding tool window              打开相应的工具窗口        Alt + #[0-9]\nSave all                                    保存所有             Ctrl + S\nSynchronize                                 同步               Ctrl + Alt + Y\nToggle maximizing editor                    切换最大化编辑器         Ctrl + Shift + F12\nInspect current file with current profile   使用当前配置文件检查当前文件   Alt + Shift + I\nQuick switch current scheme                 快速切换当前主题         Ctrl + BackQuote (`)\nOpen Settings dialog                        打开"设置"对话框        Ctrl + Alt + S\nOpen Project Structure dialog               打开"项目结构"对话框      Ctrl + Alt + Shift + S\nFind Action                                 寻找操作             Ctrl + Shift + A\n\n\n# 3. 调试\n\nDEBUGGING                    调试        \nStep over / into             跳过/跳入     F8/F7\nSmart step into / Step out   快速跳入/跳出   Shift + F7/Shift + F8\nRun to cursor                运行到光标     Alt + F9\nEvaluate expression          计算表达式     Alt + F8\nResume program               恢复程序      F9\nToggle breakpoint            切换断点      Ctrl + F8\nView breakpoints             查看断点      Ctrl + Shift + F8\n\n\n# 4. 搜索/替换\n\nSEARCH / REPLACE         搜索/替换       \nSearch everywhere        全局搜索        Double Shift\nFind                     搜索          Ctrl + F\nFind next / previous     搜索下一个/上一个   F3/Shift + F3\nReplace                  替换          Ctrl + R\nFind in path             在路径中搜索      Ctrl + Shift + F\nReplace in path          在路径中替换      Ctrl + Shift + R\nSelect next occurrence   选择下一个引用     Alt + J\nSelect all occurrences   选择所有引用      Ctrl + Alt + Shift + J\nUnselect occurrence      取消选择事件      Alt + Shift + J\n\n\n# 5. 编辑\n\nEDITING                                           编辑             \nBasic code completion                             基本代码完成         Ctrl + Space\nSmart code completion                             智能代码完成         Ctrl + Shift + Space\nComplete statement                                完整声明           Ctrl + Shift + Enter\nParameter info                                    参数信息           Ctrl + P\nQuick documentation lookup                        快速文档查找         Ctrl + Q\nExternal Doc                                      外部文档           Shift + F1\nBrief Info                                        简要信息           Ctrl + mouse\nShow descriptions of error at caret               显示插入符号处的错误说明   Ctrl + F1\nGenerate code…                                    生成代码…          Alt + Insert\nOverride methods                                  重写方法           Ctrl + O\nImplement methods                                 实现方法           Ctrl + I\nSurround with…                                    环绕             Ctrl + Alt + T\nComment / uncomment with line comment             注释/取消行注释       Ctrl + /\nComment / uncomment with block comment            注释/取消块注释       Ctrl + Shift + /\nExtend selection                                  扩展选择           Ctrl + W\nShrink selection                                  收缩选择           Ctrl + Shift + W\nContext info                                      上下文信息          Alt + Q\nShow intention actions and quick-fixes            显示提示和快速修复      Alt + Enter\nReformat code                                     格式化代码          Ctrl + Alt + L\nOptimize imports                                  优化进口           Ctrl + Alt + O\nAuto-indent line(s)                               自动缩进行          Ctrl + Alt + I\nIndent / unindent selected lines                  缩进/取消缩进选中行     Tab/Shift + Tab\nCut current line to clipboard                     将当前行剪切到剪贴板     Ctrl + X, Shift + Delete\nCopy current line to clipboard                    将当前行复制到剪贴板     Ctrl + C , Ctrl + Insert\nPaste from clipboard                              从剪贴板粘贴         Ctrl + V, Shift + Insert\nPaste from recent buffers…                        从最近的缓冲区粘贴      Ctrl + Shift + V\nDuplicate current line                            复制当前行          Ctrl + D\nDelete line at caret                              删除当前行          Ctrl + Y\nSmart line join                                   智能线路连接         Ctrl + Shift + J\nSmart line split                                  插入行            Ctrl + Enter\nStart new line                                    换行             Shift + Enter\nToggle case for word at caret or selected block   切换大小写          Ctrl + Shift + U\nSelect till code block end / start                选中至代码块结束/开始    Ctrl + Shift + ]/[\nDelete to word end                                删除到字结尾         Ctrl + Delete\nDelete to word start                              删除到字开始         Ctrl + Backspace\nExpand / collapse code block                      展开/折叠代码块       Ctrl + NumPad+/-\nExpand al                                         展开所有           Ctrl + Shift + NumPad+\nCollapse all                                      折叠所有           Ctrl + Shift + NumPad-\nClose active editor tab                           关闭活动编辑器选项卡     Ctrl + F4\n\n\n# 6. 重构\n\nREFACTORING         重构     \nCopy                复制     F5\nMove                移动     F6\nSafe Delete         安全删除   Alt + Delete\nRename              重命名    Shift + F6\nRefactor this       重构     Ctrl + Alt + Shift + T\nChange Signature    更改签名   Ctrl + F6\nInline              内联     Ctrl + Alt + N\nExtract Method      提取方法   Ctrl + Alt + M\nExtract Variable    提取变量   Ctrl + Alt + V\nExtract Field       提取字段   Ctrl + Alt + F\nExtract Constant    提取常数   Ctrl + Alt + C\nExtract Parameter   提取参数   Ctrl + Alt + P\n\n\n# 7. 导航\n\nNAVIGATION                                  导航                 \nGo to class                                 搜索类                Ctrl + N\nGo to file                                  搜索文件               Ctrl + Shift + N\nGo to symbol                                搜索符号               Ctrl + Alt + Shift + N\nGo to next / previous editor tab            跳转到下一个/上一个编辑器选项卡   Alt + Right/Left\nGo back to previous tool window             返回到上一个工具窗口         F12\nGo to editor (from tool window)             跳转到编辑器（从工具窗口）      Esc\nHide active or last active window           隐藏活动窗口或上次活动窗口      Shift + Esc\nGo to line                                  跳转到指定行             Ctrl + G\nRecent files popup                          最近的文件弹出窗口          Ctrl + E\nRecent locations popup                      最近位置弹出窗口           Ctrl + Shift + E\nNavigate back / forward                     向后/向前导航            Ctrl + Alt + Left/Right\nNavigate to last edit location              导航到最后一个编辑位置        Ctrl + Shift + Backspace\nSelect current file or symbol in any view   在任何视图中选择当前文件或符号    Alt + F1\nGo to declaration                           跳转到声明              Ctrl + B, Ctrl + Click\nGo to implementation(s)                     跳转到实现类             Ctrl + Alt + B\nOpen quick definition lookup                打开快速定义查找           Ctrl + Shift + I\nGo to type declaration                      跳转到类型声明            Ctrl + Shift + B\nGo to super-method / super-class            跳转到超级方法/超级类        Ctrl + U\nGo to previous / next method                跳转到上一个/下一个方法       Alt + Up/Down\nMove to code block end / start              移动到代码块结束/开始        Ctrl + ]/[\nFile structure popup                        文件结构弹出窗口           Ctrl + F12\nType hierarchy                              类型层次结构             Ctrl + H\nMethod hierarchy                            方法层次               Ctrl + Shift + H\nCall hierarchy                              调用层次结构             Ctrl + Alt + H\nNext / Previous highlighted error           下一个/上一个突出的错误       F2/Shift + F2\nEdit source / View source                   编辑源/查看源            F4/Ctrl + Enter\nShow navigation bar                         显示导航栏              Alt + Home\nToggle bookmark                             切换书签               F11\nToggle bookmark with mnemonic               使用助记符切换书签          Ctrl + F11\nGo to numbered bookmark                     跳转到编号书签            Ctrl + #[0-9]\nShow bookmarks                              显示书签               Shift + F11\n\n\n# 8. 编译和运行\n\nCOMPILE AND RUN                            编译和运行          \nBuild project                              编译项目           Ctrl + F9\nCompile selected file, package or module   编译选定的文件、包或模块   Ctrl + Shift + F9\nSelect configuration and run / debug       选择配置并运行/调试     Alt + Shift + F10/F9\nRun / Debug                                运行/调试          Shift + F10/F9\nRun context configuration from editor      从编辑器运行上下文配置    Ctrl + Shift + F10\nRun anything                               运行所有           Double Ctrl\n\n\n# 9. 使用搜索\n\nUSAGE SEARCH                        使用搜索            \nFind usages / Find usages in file   查找用法/在文件中查找用法   Alt + F7/Ctrl + F7\nHighlight usages in file            突显文件中的用法        Ctrl + Shift + F7\nShow usages                         显示用法            Ctrl + Alt + F7\n\n\n# 10. 版本控制/本地历史\n\nVCS / LOCAL HISTORY       版本控制/本地历史    \nCommit project to VCS     提交项目到"VCS"   Ctrl + K\nUpdate project from VCS   从"VCS"更新项目   Ctrl + T\nPush commits              推送提交         Ctrl + Shift + K\n‘VCS’ quick popup         VCS快速弹出      Alt + BackQuote (`)\n\nLIVE TEMPLATES                动态模板      \nSurround with Live Template   用动态模板环绕   Ctrl + Alt + J\nInsert Live Template          插入动态模板    Ctrl + J\n\n\n# 3. 自定义快捷键\n\n添加快捷键 Alt+E\n\n',normalizedContent:'# idea快捷键(windows)\n\n\n# 1. 官方文档\n\nintellijidea_referencecard.pdf (jetbrains.com)\n\n\n\n\n\n\n# 2. 文档翻译\n\n\n# 1. 记住这些快捷键\n\nremember these shortcuts                 记住这些快捷键     \nsmart code completion                    智能代码完成      ctrl + shift + space\nsearch everywhere                        全局搜索        double shift\nshow intention actions and quick-fixes   显示提示和快速修复   alt + enter\ngenerate code                            生成代码        alt + ins\nparameter info                           参数信息        ctrl + p\nextend selection                         扩展选择        ctrl + w\nshrink selection                         收缩选择        ctrl + shift + w\nrecent files popup                       最近的文件弹出窗口   ctrl + e\nrename                                   重命名         shift + f6\n\n\n# 2. 综合的\n\ngeneral                                     综合的              \nopen corresponding tool window              打开相应的工具窗口        alt + #[0-9]\nsave all                                    保存所有             ctrl + s\nsynchronize                                 同步               ctrl + alt + y\ntoggle maximizing editor                    切换最大化编辑器         ctrl + shift + f12\ninspect current file with current profile   使用当前配置文件检查当前文件   alt + shift + i\nquick switch current scheme                 快速切换当前主题         ctrl + backquote (`)\nopen settings dialog                        打开"设置"对话框        ctrl + alt + s\nopen project structure dialog               打开"项目结构"对话框      ctrl + alt + shift + s\nfind action                                 寻找操作             ctrl + shift + a\n\n\n# 3. 调试\n\ndebugging                    调试        \nstep over / into             跳过/跳入     f8/f7\nsmart step into / step out   快速跳入/跳出   shift + f7/shift + f8\nrun to cursor                运行到光标     alt + f9\nevaluate expression          计算表达式     alt + f8\nresume program               恢复程序      f9\ntoggle breakpoint            切换断点      ctrl + f8\nview breakpoints             查看断点      ctrl + shift + f8\n\n\n# 4. 搜索/替换\n\nsearch / replace         搜索/替换       \nsearch everywhere        全局搜索        double shift\nfind                     搜索          ctrl + f\nfind next / previous     搜索下一个/上一个   f3/shift + f3\nreplace                  替换          ctrl + r\nfind in path             在路径中搜索      ctrl + shift + f\nreplace in path          在路径中替换      ctrl + shift + r\nselect next occurrence   选择下一个引用     alt + j\nselect all occurrences   选择所有引用      ctrl + alt + shift + j\nunselect occurrence      取消选择事件      alt + shift + j\n\n\n# 5. 编辑\n\nediting                                           编辑             \nbasic code completion                             基本代码完成         ctrl + space\nsmart code completion                             智能代码完成         ctrl + shift + space\ncomplete statement                                完整声明           ctrl + shift + enter\nparameter info                                    参数信息           ctrl + p\nquick documentation lookup                        快速文档查找         ctrl + q\nexternal doc                                      外部文档           shift + f1\nbrief info                                        简要信息           ctrl + mouse\nshow descriptions of error at caret               显示插入符号处的错误说明   ctrl + f1\ngenerate code…                                    生成代码…          alt + insert\noverride methods                                  重写方法           ctrl + o\nimplement methods                                 实现方法           ctrl + i\nsurround with…                                    环绕             ctrl + alt + t\ncomment / uncomment with line comment             注释/取消行注释       ctrl + /\ncomment / uncomment with block comment            注释/取消块注释       ctrl + shift + /\nextend selection                                  扩展选择           ctrl + w\nshrink selection                                  收缩选择           ctrl + shift + w\ncontext info                                      上下文信息          alt + q\nshow intention actions and quick-fixes            显示提示和快速修复      alt + enter\nreformat code                                     格式化代码          ctrl + alt + l\noptimize imports                                  优化进口           ctrl + alt + o\nauto-indent line(s)                               自动缩进行          ctrl + alt + i\nindent / unindent selected lines                  缩进/取消缩进选中行     tab/shift + tab\ncut current line to clipboard                     将当前行剪切到剪贴板     ctrl + x, shift + delete\ncopy current line to clipboard                    将当前行复制到剪贴板     ctrl + c , ctrl + insert\npaste from clipboard                              从剪贴板粘贴         ctrl + v, shift + insert\npaste from recent buffers…                        从最近的缓冲区粘贴      ctrl + shift + v\nduplicate current line                            复制当前行          ctrl + d\ndelete line at caret                              删除当前行          ctrl + y\nsmart line join                                   智能线路连接         ctrl + shift + j\nsmart line split                                  插入行            ctrl + enter\nstart new line                                    换行             shift + enter\ntoggle case for word at caret or selected block   切换大小写          ctrl + shift + u\nselect till code block end / start                选中至代码块结束/开始    ctrl + shift + ]/[\ndelete to word end                                删除到字结尾         ctrl + delete\ndelete to word start                              删除到字开始         ctrl + backspace\nexpand / collapse code block                      展开/折叠代码块       ctrl + numpad+/-\nexpand al                                         展开所有           ctrl + shift + numpad+\ncollapse all                                      折叠所有           ctrl + shift + numpad-\nclose active editor tab                           关闭活动编辑器选项卡     ctrl + f4\n\n\n# 6. 重构\n\nrefactoring         重构     \ncopy                复制     f5\nmove                移动     f6\nsafe delete         安全删除   alt + delete\nrename              重命名    shift + f6\nrefactor this       重构     ctrl + alt + shift + t\nchange signature    更改签名   ctrl + f6\ninline              内联     ctrl + alt + n\nextract method      提取方法   ctrl + alt + m\nextract variable    提取变量   ctrl + alt + v\nextract field       提取字段   ctrl + alt + f\nextract constant    提取常数   ctrl + alt + c\nextract parameter   提取参数   ctrl + alt + p\n\n\n# 7. 导航\n\nnavigation                                  导航                 \ngo to class                                 搜索类                ctrl + n\ngo to file                                  搜索文件               ctrl + shift + n\ngo to symbol                                搜索符号               ctrl + alt + shift + n\ngo to next / previous editor tab            跳转到下一个/上一个编辑器选项卡   alt + right/left\ngo back to previous tool window             返回到上一个工具窗口         f12\ngo to editor (from tool window)             跳转到编辑器（从工具窗口）      esc\nhide active or last active window           隐藏活动窗口或上次活动窗口      shift + esc\ngo to line                                  跳转到指定行             ctrl + g\nrecent files popup                          最近的文件弹出窗口          ctrl + e\nrecent locations popup                      最近位置弹出窗口           ctrl + shift + e\nnavigate back / forward                     向后/向前导航            ctrl + alt + left/right\nnavigate to last edit location              导航到最后一个编辑位置        ctrl + shift + backspace\nselect current file or symbol in any view   在任何视图中选择当前文件或符号    alt + f1\ngo to declaration                           跳转到声明              ctrl + b, ctrl + click\ngo to implementation(s)                     跳转到实现类             ctrl + alt + b\nopen quick definition lookup                打开快速定义查找           ctrl + shift + i\ngo to type declaration                      跳转到类型声明            ctrl + shift + b\ngo to super-method / super-class            跳转到超级方法/超级类        ctrl + u\ngo to previous / next method                跳转到上一个/下一个方法       alt + up/down\nmove to code block end / start              移动到代码块结束/开始        ctrl + ]/[\nfile structure popup                        文件结构弹出窗口           ctrl + f12\ntype hierarchy                              类型层次结构             ctrl + h\nmethod hierarchy                            方法层次               ctrl + shift + h\ncall hierarchy                              调用层次结构             ctrl + alt + h\nnext / previous highlighted error           下一个/上一个突出的错误       f2/shift + f2\nedit source / view source                   编辑源/查看源            f4/ctrl + enter\nshow navigation bar                         显示导航栏              alt + home\ntoggle bookmark                             切换书签               f11\ntoggle bookmark with mnemonic               使用助记符切换书签          ctrl + f11\ngo to numbered bookmark                     跳转到编号书签            ctrl + #[0-9]\nshow bookmarks                              显示书签               shift + f11\n\n\n# 8. 编译和运行\n\ncompile and run                            编译和运行          \nbuild project                              编译项目           ctrl + f9\ncompile selected file, package or module   编译选定的文件、包或模块   ctrl + shift + f9\nselect configuration and run / debug       选择配置并运行/调试     alt + shift + f10/f9\nrun / debug                                运行/调试          shift + f10/f9\nrun context configuration from editor      从编辑器运行上下文配置    ctrl + shift + f10\nrun anything                               运行所有           double ctrl\n\n\n# 9. 使用搜索\n\nusage search                        使用搜索            \nfind usages / find usages in file   查找用法/在文件中查找用法   alt + f7/ctrl + f7\nhighlight usages in file            突显文件中的用法        ctrl + shift + f7\nshow usages                         显示用法            ctrl + alt + f7\n\n\n# 10. 版本控制/本地历史\n\nvcs / local history       版本控制/本地历史    \ncommit project to vcs     提交项目到"vcs"   ctrl + k\nupdate project from vcs   从"vcs"更新项目   ctrl + t\npush commits              推送提交         ctrl + shift + k\n‘vcs’ quick popup         vcs快速弹出      alt + backquote (`)\n\nlive templates                动态模板      \nsurround with live template   用动态模板环绕   ctrl + alt + j\ninsert live template          插入动态模板    ctrl + j\n\n\n# 3. 自定义快捷键\n\n添加快捷键 alt+e\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/10, 08:04:32",lastUpdatedTimestamp:1678406672e3},{title:"IDEA必备插件",frontmatter:{title:"IDEA必备插件",date:"2023-03-01T22:30:37.000Z",permalink:"/pages/17fe21/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/01.IDEA/03.IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6.html",relativePath:"03.开发工具/01.集成开发环境/01.IDEA/03.IDEA必备插件.md",key:"v-73345ea5",path:"/pages/17fe21/",headers:[{level:2,title:"1. 插件入口",slug:"_1-插件入口",normalizedTitle:"1. 插件入口",charIndex:15},{level:2,title:"2. IDEA必备插件",slug:"_2-idea必备插件",normalizedTitle:"2. idea必备插件",charIndex:29},{level:3,title:"1. Alibaba Java Coding Guidelines",slug:"_1-alibaba-java-coding-guidelines",normalizedTitle:"1. alibaba java coding guidelines",charIndex:119},{level:3,title:"2. CamelCase",slug:"_2-camelcase",normalizedTitle:"2. camelcase",charIndex:370},{level:3,title:"3. Chinese (Simpllified) Language Pack/中文语言包",slug:"_3-chinese-simpllified-language-pack-中文语言包",normalizedTitle:"3. chinese (simpllified) language pack/中文语言包",charIndex:527},{level:3,title:"4. CodeGlance3",slug:"_4-codeglance3",normalizedTitle:"4. codeglance3",charIndex:639},{level:3,title:"5. Codota Al Autocomplete for Java and JavaScript",slug:"_5-codota-al-autocomplete-for-java-and-javascript",normalizedTitle:"5. codota al autocomplete for java and javascript",charIndex:746},{level:3,title:"6. Gitee",slug:"_6-gitee",normalizedTitle:"6. gitee",charIndex:952},{level:3,title:"7. GitToolBox",slug:"_7-gittoolbox",normalizedTitle:"7. gittoolbox",charIndex:1039},{level:3,title:"8. Grep Console",slug:"_8-grep-console",normalizedTitle:"8. grep console",charIndex:1116},{level:3,title:"9. GsonFormatPlus",slug:"_9-gsonformatplus",normalizedTitle:"9. gsonformatplus",charIndex:1223},{level:3,title:"10. Json Prase",slug:"_10-json-prase",normalizedTitle:"10. json prase",charIndex:1358},{level:3,title:"11. Key promoter X",slug:"_11-key-promoter-x",normalizedTitle:"11. key promoter x",charIndex:1496},{level:3,title:"12. Lombok",slug:"_12-lombok",normalizedTitle:"12. lombok",charIndex:1645},{level:3,title:"13. Maven Helper",slug:"_13-maven-helper",normalizedTitle:"13. maven helper",charIndex:1722},{level:3,title:"14. MyBatis Log Free",slug:"_14-mybatis-log-free",normalizedTitle:"14. mybatis log free",charIndex:1854},{level:3,title:"15. MybatisX",slug:"_15-mybatisx",normalizedTitle:"15. mybatisx",charIndex:2102},{level:3,title:"16. Rainbow Brackets",slug:"_16-rainbow-brackets",normalizedTitle:"16. rainbow brackets",charIndex:2217},{level:3,title:"17. Redis Helper",slug:"_17-redis-helper",normalizedTitle:"17. redis helper",charIndex:2319},{level:3,title:"18. RestfulToolkit-fix",slug:"_18-restfultoolkit-fix",normalizedTitle:"18. restfultoolkit-fix",charIndex:2486},{level:3,title:"19. SequenceDiagram",slug:"_19-sequencediagram",normalizedTitle:"19. sequencediagram",charIndex:2612},{level:3,title:"20. Translation",slug:"_20-translation",normalizedTitle:"20. translation",charIndex:2744}],headersStr:"1. 插件入口 2. IDEA必备插件 1. Alibaba Java Coding Guidelines 2. CamelCase 3. Chinese (Simpllified) Language Pack/中文语言包 4. CodeGlance3 5. Codota Al Autocomplete for Java and JavaScript 6. Gitee 7. GitToolBox 8. Grep Console 9. GsonFormatPlus 10. Json Prase 11. Key promoter X 12. Lombok 13. Maven Helper 14. MyBatis Log Free 15. MybatisX 16. Rainbow Brackets 17. Redis Helper 18. RestfulToolkit-fix 19. SequenceDiagram 20. Translation",content:'# IDEA必备插件\n\n\n# 1. 插件入口\n\n\n\n\n# 2. IDEA必备插件\n\n插件安装目录：C:\\Users\\用户名\\AppData\\Roaming\\JetBrains\\IntelliJIdea2021.3\\plugins\n\n\n# 1. Alibaba Java Coding Guidelines\n\n推荐指数：★★★★★\n\n\n\n介绍：阿里巴巴Java编码指南\n\n安装之后右键菜单会多出两个选项，可对整个项目或单个文件进行编码规约扫描，快捷键"Ctrl+Alt+Shift+J"。默认开启实时检测功能，可选择关闭。\n\n\n\n扫描后会将不规范的代码按从高到低 Blocker/Critical/Major(崩溃/严重/重要) 三个等级显示在下方，双击详细描述可进行代码定位，右侧窗口提供了修改建议，可对同一问题进行批量修改。\n\n\n\n\n# 2. CamelCase\n\n推荐指数：★★★\n\n\n\n介绍：字符串格式转换工具\n\n安装之后在设置中找到"Camel Case"选项，选择需要转换的格式，本人只保留了驼峰和下划线两种格式。如需使用多种格式，下方还可对格式顺序进行调整。\n\n选中文本后使用快捷键"Shift+Alt+U"，即可进行转换格式。\n\n\n\n\n# 3. Chinese (Simpllified) Language Pack/中文语言包\n\n推荐指数：★★★★\n\n\n\n介绍：IDEA中文语言包\n\n安装之后能将IDEA绝大多数功能菜单汉化，根据个人习惯决定是否启用。\n\n\n# 4. CodeGlance3\n\n推荐指数：★★★★\n\n\n\n介绍：代码预览插件\n\n安装之后会在代码右侧生成小地图，可选中小地图上下拖动，快速进行代码定位。\n\n显示/隐藏小地图快捷键：Ctrl+Shift+G\n\n\n# 5. Codota Al Autocomplete for Java and JavaScript\n\n推荐指数：★★★★\n\n\n\n介绍：Java和JavaScript的智能补全插件\n\n安装之后可结合当前代码上下文给予代码建议；可搜索代码示例，选中相关代码右键选择"Get relevant examples"，会在右侧窗口展示GitHub上的相关代码示例，也可点击"Add"，输入关键词进行搜索。\n\n\n\n\n\n\n# 6. Gitee\n\n推荐指数：★★★★\n\n\n\n介绍：Gitee插件\n\n提供了和IDEA内置插件GitHub类似的功能，更好地在IDEA和Gitee之间协同工作。\n\n\n\n\n# 7. GitToolBox\n\n推荐指数：★★★★\n\n\n\n介绍：Git功能增强插件\n\n安装之后可显示未同步的文件，每行代码显示上次提交的相关信息。\n\n\n# 8. Grep Console\n\n推荐指数：★★★\n\n\n\n介绍：控制台日志增强插件\n\n安装之后在设置中找到"Grep Console"选项，根据个人习惯设置控制台不同级别日志的颜色。以下设置仅供参考。\n\n\n\n\n# 9. GsonFormatPlus\n\n推荐指数：★★★\n\n\n\n介绍：JSON转实体类插件\n\n安装之后在JAVA类中使用快捷键Alt+Insert，选择"GsonFormatPlus"，在弹出的窗口中输入JSON数据并识别，选择JAVA数据类型后生成类属性。\n\n\n\n\n# 10. Json Prase\n\n推荐指数：★★★\n\n\n\n介绍：JSON数据格式化工具\n\n安装之后在IDEA右侧工具栏会生成"Json Parser"快捷方式，点击即可调出工具窗口，将JSON数据输入上方框内点击"Parse"即可进行格式化，比用在线工具网站方便。\n\n\n\n\n# 11. Key promoter X\n\n推荐指数：★★★\n\n\n\n介绍：快捷键提示工具\n\n安装之后鼠标进行的操作若有快捷键则会在IDEA右下角进行提示，并进行数据统计，IDEA新手熟悉快捷键必备。\n\n可点击IDEA右侧工具栏的"Key promoter X"快捷方式，调出数据统计窗口。\n\n\n\n\n# 12. Lombok\n\n推荐指数：★★★★\n\n\n\n介绍：简化实体类代码插件\n\n通过注解的形式简化一些臃肿的Java代码，新版IDEA已内部捆绑。\n\n\n# 13. Maven Helper\n\n推荐指数：★★★★\n\n\n\n介绍：Maven助手\n\n安装之后再次打开pom文件，文件左下角会多出一个视图。\n\n切换到"Dependency Analyzer"视图，可查看冲突的依赖，可以列表形式或树形式查看所有依赖。\n\n\n\n\n# 14. MyBatis Log Free\n\n推荐指数：★★★★★\n\n\n\n介绍：MyBatis日志插件\n\n安装之后在"Tools"内启用，启用后会多出一个只打印SQL的控制台。可把普通控制台放左边，SQL控制台放右边。\n\n此款插件为免费，在插件市场就能搜到，还有另一款类似的插件"Mybatis Log Plugin"目前已收费。目前感觉两款插件没太大区别，"Mybatis Log Plugin"打印的SQL是大写的，"MyBatis Log Free"打印的SQL是小写且格式化过的。\n\n\n# 15. MybatisX\n\n推荐指数：★★★★★\n\n\n\n介绍：MyBatis增强插件\n\n安装之后可在Dao层接口和对应的xml文件之间快速跳转，在Dao层接口定义好方法后可在对应的xml文件快速生成基础的SQL标签。\n\n\n\n\n# 16. Rainbow Brackets\n\n推荐指数：★★★★\n\n\n\n介绍：彩虹括号插件\n\n多个配对括号展示不同颜色\n\nCtrl+鼠标右键：框选当前区域代码\n\nAlt+鼠标右键：沉浸当前区域代码\n\n\n# 17. Redis Helper\n\n推荐指数：★★★★\n\n\n\n介绍：Redis助手\n\n安装之后在IDEA右侧工具栏会生成"Redis Helper"快捷方式，点击即可调出使用窗口，类似于IDEA自带的"Database"插件。\n\n此款插件为免费，在插件市场就能搜到，类似的插件"Rddis""Iddis2"目前皆已收费。\n\n\n\n\n# 18. RestfulToolkit-fix\n\n推荐指数：★★★★★\n\n\n\n介绍：快速定位接口工具\n\n安装之后使用快捷键"Ctrl+"或"Ctrl+Alt+N"调出搜索窗口，输入接口名，即可快速定位接口位置，比用IDEA的全局搜索效率高。\n\n\n\n\n# 19. SequenceDiagram\n\n推荐指数：★★★\n\n\n\n介绍：时序图插件\n\n以时序图的方式展示方法的调用关系。\n\n安装之后选中一个类或方法右键选择"Sequence Diagram"，即可调出时序图，可点击左侧工具按钮设置调用深度。\n\n\n\n\n\n\n\n\n# 20. Translation\n\n推荐指数：★★★★\n\n\n\n介绍：翻译插件\n\n安装之后选中文本后使用快捷键"Ctrl+Shift+Y"，即可进行中英文转换。',normalizedContent:'# idea必备插件\n\n\n# 1. 插件入口\n\n\n\n\n# 2. idea必备插件\n\n插件安装目录：c:\\users\\用户名\\appdata\\roaming\\jetbrains\\intellijidea2021.3\\plugins\n\n\n# 1. alibaba java coding guidelines\n\n推荐指数：★★★★★\n\n\n\n介绍：阿里巴巴java编码指南\n\n安装之后右键菜单会多出两个选项，可对整个项目或单个文件进行编码规约扫描，快捷键"ctrl+alt+shift+j"。默认开启实时检测功能，可选择关闭。\n\n\n\n扫描后会将不规范的代码按从高到低 blocker/critical/major(崩溃/严重/重要) 三个等级显示在下方，双击详细描述可进行代码定位，右侧窗口提供了修改建议，可对同一问题进行批量修改。\n\n\n\n\n# 2. camelcase\n\n推荐指数：★★★\n\n\n\n介绍：字符串格式转换工具\n\n安装之后在设置中找到"camel case"选项，选择需要转换的格式，本人只保留了驼峰和下划线两种格式。如需使用多种格式，下方还可对格式顺序进行调整。\n\n选中文本后使用快捷键"shift+alt+u"，即可进行转换格式。\n\n\n\n\n# 3. chinese (simpllified) language pack/中文语言包\n\n推荐指数：★★★★\n\n\n\n介绍：idea中文语言包\n\n安装之后能将idea绝大多数功能菜单汉化，根据个人习惯决定是否启用。\n\n\n# 4. codeglance3\n\n推荐指数：★★★★\n\n\n\n介绍：代码预览插件\n\n安装之后会在代码右侧生成小地图，可选中小地图上下拖动，快速进行代码定位。\n\n显示/隐藏小地图快捷键：ctrl+shift+g\n\n\n# 5. codota al autocomplete for java and javascript\n\n推荐指数：★★★★\n\n\n\n介绍：java和javascript的智能补全插件\n\n安装之后可结合当前代码上下文给予代码建议；可搜索代码示例，选中相关代码右键选择"get relevant examples"，会在右侧窗口展示github上的相关代码示例，也可点击"add"，输入关键词进行搜索。\n\n\n\n\n\n\n# 6. gitee\n\n推荐指数：★★★★\n\n\n\n介绍：gitee插件\n\n提供了和idea内置插件github类似的功能，更好地在idea和gitee之间协同工作。\n\n\n\n\n# 7. gittoolbox\n\n推荐指数：★★★★\n\n\n\n介绍：git功能增强插件\n\n安装之后可显示未同步的文件，每行代码显示上次提交的相关信息。\n\n\n# 8. grep console\n\n推荐指数：★★★\n\n\n\n介绍：控制台日志增强插件\n\n安装之后在设置中找到"grep console"选项，根据个人习惯设置控制台不同级别日志的颜色。以下设置仅供参考。\n\n\n\n\n# 9. gsonformatplus\n\n推荐指数：★★★\n\n\n\n介绍：json转实体类插件\n\n安装之后在java类中使用快捷键alt+insert，选择"gsonformatplus"，在弹出的窗口中输入json数据并识别，选择java数据类型后生成类属性。\n\n\n\n\n# 10. json prase\n\n推荐指数：★★★\n\n\n\n介绍：json数据格式化工具\n\n安装之后在idea右侧工具栏会生成"json parser"快捷方式，点击即可调出工具窗口，将json数据输入上方框内点击"parse"即可进行格式化，比用在线工具网站方便。\n\n\n\n\n# 11. key promoter x\n\n推荐指数：★★★\n\n\n\n介绍：快捷键提示工具\n\n安装之后鼠标进行的操作若有快捷键则会在idea右下角进行提示，并进行数据统计，idea新手熟悉快捷键必备。\n\n可点击idea右侧工具栏的"key promoter x"快捷方式，调出数据统计窗口。\n\n\n\n\n# 12. lombok\n\n推荐指数：★★★★\n\n\n\n介绍：简化实体类代码插件\n\n通过注解的形式简化一些臃肿的java代码，新版idea已内部捆绑。\n\n\n# 13. maven helper\n\n推荐指数：★★★★\n\n\n\n介绍：maven助手\n\n安装之后再次打开pom文件，文件左下角会多出一个视图。\n\n切换到"dependency analyzer"视图，可查看冲突的依赖，可以列表形式或树形式查看所有依赖。\n\n\n\n\n# 14. mybatis log free\n\n推荐指数：★★★★★\n\n\n\n介绍：mybatis日志插件\n\n安装之后在"tools"内启用，启用后会多出一个只打印sql的控制台。可把普通控制台放左边，sql控制台放右边。\n\n此款插件为免费，在插件市场就能搜到，还有另一款类似的插件"mybatis log plugin"目前已收费。目前感觉两款插件没太大区别，"mybatis log plugin"打印的sql是大写的，"mybatis log free"打印的sql是小写且格式化过的。\n\n\n# 15. mybatisx\n\n推荐指数：★★★★★\n\n\n\n介绍：mybatis增强插件\n\n安装之后可在dao层接口和对应的xml文件之间快速跳转，在dao层接口定义好方法后可在对应的xml文件快速生成基础的sql标签。\n\n\n\n\n# 16. rainbow brackets\n\n推荐指数：★★★★\n\n\n\n介绍：彩虹括号插件\n\n多个配对括号展示不同颜色\n\nctrl+鼠标右键：框选当前区域代码\n\nalt+鼠标右键：沉浸当前区域代码\n\n\n# 17. redis helper\n\n推荐指数：★★★★\n\n\n\n介绍：redis助手\n\n安装之后在idea右侧工具栏会生成"redis helper"快捷方式，点击即可调出使用窗口，类似于idea自带的"database"插件。\n\n此款插件为免费，在插件市场就能搜到，类似的插件"rddis""iddis2"目前皆已收费。\n\n\n\n\n# 18. restfultoolkit-fix\n\n推荐指数：★★★★★\n\n\n\n介绍：快速定位接口工具\n\n安装之后使用快捷键"ctrl+"或"ctrl+alt+n"调出搜索窗口，输入接口名，即可快速定位接口位置，比用idea的全局搜索效率高。\n\n\n\n\n# 19. sequencediagram\n\n推荐指数：★★★\n\n\n\n介绍：时序图插件\n\n以时序图的方式展示方法的调用关系。\n\n安装之后选中一个类或方法右键选择"sequence diagram"，即可调出时序图，可点击左侧工具按钮设置调用深度。\n\n\n\n\n\n\n\n\n# 20. translation\n\n推荐指数：★★★★\n\n\n\n介绍：翻译插件\n\n安装之后选中文本后使用快捷键"ctrl+shift+y"，即可进行中英文转换。',charsets:{cjk:!0},lastUpdated:"2023/03/10, 08:04:32",lastUpdatedTimestamp:1678406672e3},{title:"VSCode",frontmatter:{title:"VSCode",date:"2023-02-27T11:03:11.000Z",permalink:"/pages/e4d5d1/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/02.VSCode/01.VSCode.html",relativePath:"03.开发工具/01.集成开发环境/02.VSCode/01.VSCode.md",key:"v-f3a4d5ce",path:"/pages/e4d5d1/",headersStr:null,content:"# VSCode",normalizedContent:"# vscode",charsets:{},lastUpdated:"2023/03/01, 22:43:28",lastUpdatedTimestamp:1677681808e3},{title:"接口测试工具",frontmatter:{title:"接口测试工具",date:"2023-02-27T11:05:17.000Z",permalink:"/pages/5082de/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/04.%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01.%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.html",relativePath:"03.开发工具/01.集成开发环境/04.接口测试工具/01.接口测试工具.md",key:"v-3e5f36c2",path:"/pages/5082de/",headersStr:null,content:"# 接口测试工具",normalizedContent:"# 接口测试工具",charsets:{cjk:!0},lastUpdated:"2023/03/01, 22:43:28",lastUpdatedTimestamp:1677681808e3},{title:"MySQL图形化管理工具",frontmatter:{title:"MySQL图形化管理工具",date:"2023-02-27T11:02:52.000Z",permalink:"/pages/17afa5/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/03.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A5%E5%85%B7/01.MySQL%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.html",relativePath:"03.开发工具/01.集成开发环境/03.数据库工具/01.MySQL图形化管理工具.md",key:"v-46869018",path:"/pages/17afa5/",headers:[{level:2,title:"1. MySQL Workbench",slug:"_1-mysql-workbench",normalizedTitle:"1. mysql workbench",charIndex:145},{level:2,title:"2. Navicat 😄",slug:"_2-navicat",normalizedTitle:"2. navicat 😄",charIndex:957},{level:3,title:"1. 破解版",slug:"_1-破解版",normalizedTitle:"1. 破解版",charIndex:1180},{level:3,title:"2. 连接数据库",slug:"_2-连接数据库",normalizedTitle:"2. 连接数据库",charIndex:1237},{level:3,title:"3. 问题",slug:"_3-问题",normalizedTitle:"3. 问题",charIndex:1399},{level:4,title:"mysql ERROR 1130 问题解决方案 😄",slug:"mysql-error-1130-问题解决方案",normalizedTitle:"mysql error 1130 问题解决方案 😄",charIndex:1408},{level:2,title:"3. SQLyog",slug:"_3-sqlyog",normalizedTitle:"3. sqlyog",charIndex:2153},{level:2,title:"4. dbeaver",slug:"_4-dbeaver",normalizedTitle:"4. dbeaver",charIndex:2407},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:2807}],headersStr:"1. MySQL Workbench 2. Navicat 😄 1. 破解版 2. 连接数据库 3. 问题 mysql ERROR 1130 问题解决方案 😄 3. SQLyog 4. dbeaver 扩展",content:"# 数据库工具\n\nMySQL图形化管理工具极大地方便了数据库的操作与管理，常用的图形化管理工具有：MySQL Workbench、phpMyAdmin、Navicat Preminum、MySQLDumper、SQLyog、dbeaver、MySQL ODBCConnector。\n\n\n# 1. MySQL Workbench\n\nMySQL官方提供的图形化管理工具MySQL Workbench完全支持MySQL 5.0以上的版本。MySQL Workbench分为社区版和商业版，社区版完全免费，而商业版则是按年收费。MySQL Workbench 为数据库管理员、程序开发者和系统规划师提供可视化设计、模型建立、以及数据库管理功能。它包含了用于创建复杂的数据建模ER模型，正向和逆向数据库工程，也可以用于执行通常需要花费大量时间的、难以变更和管理的文档任务。\n\n下载地址：http://dev.mysql.com/downloads/workbench/。\n\n使用：\n\n首先，我们点击 Windows 左下角的“开始”按钮，如果你是 Win10 系统，可以直接看到所有程序。接着，找到“MySQL”，点开，找到“MySQL Workbench 8.0 CE”。点击打开 Workbench，如下图所示：\n\n左下角有个本地连接，点击，录入 Root 的密码，登录本地 MySQL 数据库服务器，如下图所示：\n\n这是一个图形化的界面，我来给你介绍下这个界面。\n\n * 上方是菜单。左上方是导航栏，这里我们可以看到 MySQL 数据库服务器里面的数据 库，包括数据表、视图、存储过程和函数；左下方是信息栏，可以显示上方选中的数据 库、数据表等对象的信息。\n\n * 中间上方是工作区，你可以在这里写 SQL 语句，点击上方菜单栏左边的第三个运行按 钮，就可以执行工作区的 SQL 语句了。\n\n * 中间下方是输出区，用来显示 SQL 语句的运行情况，包括什么时间开始运行的、运行的内容、运行的输出，以及所花费的时长等信息。\n\n好了，下面我们就用 Workbench 实际创建一个数据库，并且导入一个 Excel 数据文件， 来生成一个数据表。数据表是存储数据的载体，有了数据表以后，我们就能对数据进行操作了。\n\n\n# 2. Navicat 😄\n\nNavicat MySQL是一个强大的MySQL数据库服务器管理和开发工具。它可以与任何3.21或以上版本的MySQL一起工作，支持触发器、存储过程、函数、事件、视图、管理用户等，对于新手来说易学易用。其精心设计的图形用户界面（GUI）可以让用户用一种安全简便的方式来快速方便地创建、组织、访问和共享信息。Navicat支持中文，有免费版本提供。 下载地址：http://www.navicat.com/。\n\n\n# 1. 破解版\n\n安装破解版：https://zhuanlan.zhihu.com/p/492364793\n\n\n# 2. 连接数据库\n\n 1. 进入连接数据库配置页面\n    \n    * 方式一：点击文件-》新建连接-》MySQL\n      \n      \n    \n    * 方式二：连接-》MySQL\n      \n      \n\n 2. 填写数据库连接信息\n\n 3. 测试连接\n\n 4. 最后点击 “确认”，完成连接。\n\n\n# 3. 问题\n\n# mysql ERROR 1130 问题解决方案 😄\n\n\n\n 1. 改表法\n\n可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”\n\nmysql -u root -pvmware\nmysql>use mysql;\nmysql>update user set host = '%' where user = 'root';\nmysql>flush privileges;\nmysql>select host, user from user;\n\n\n1\n2\n3\n4\n5\n\n\n\n\n 2. 授权法\n\n例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。\n\nGRANT ALL PRIVILEGES ON *.* TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;\n\n\n1\n\n\n如果你想允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器，并使用mypassword作为密码\n\nGRANT ALL PRIVILEGES ON *.* TO 'myuser'@'192.168.1.3' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;\n\n\n1\n\n\n参考：\n\n连接MYSQL数据库，报1130错误的解决方法 - 腾讯云开发者社区-腾讯云 (tencent.com)\n\n(mysql ERROR 1130 问题解决方案_推敲的博客-CSDN博客🐱\n\n\n# 3. SQLyog\n\nSQLyog 是业界著名的 Webyog 公司出品的一款简洁高效、功能强大的图形化 MySQL 数据库管理工具。这款工具是使用C++语言开发的。该工具可以方便地创建数据库、表、视图和索引等，还可以方便地进行插入、更新和删除等操作，同时可以方便地进行数据库、数据表的备份和还原。该工具不仅可以通过SQL文件进行大量文件的导入和导出，还可以导入和导出XML、HTML和CSV等多种格式的数据。 下载地址：http://www.webyog.com/，读者也可以搜索中文版的下载址。\n\n\n# 4. dbeaver\n\nDBeaver是一个通用的数据库管理工具和 SQL 客户端，支持所有流行的数据库：MySQL、PostgreSQL、SQLite、Oracle、DB2、SQL Server、 Sybase、MS Access、Teradata、 Firebird、Apache Hive、Phoenix、Presto等。DBeaver比大多数的SQL管理工具要轻量，而且支持中文界面。DBeaver社区版作为一个免费开源的产品，和其他类似的软件相比，在功能和易用性上都毫不逊色。\n\n唯一需要注意是 DBeaver 是用Java编程语言开发的，所以需要拥有 JDK（Java Development ToolKit）环境。如果电脑上没有JDK，在选择安装DBeaver组件时，勾选“Include Java”即可。\n\n下载地址：https://dbeaver.io/download/\n\n\n# 扩展\n\n有些图形界面工具，特别是旧版本的图形界面工具，在连接MySQL8时出现“Authentication plugin 'caching_sha2_password' cannot be loaded”错误。\n\n出现这个原因是MySQL8之前的版本中加密规则是mysql_native_password，而在MySQL8之后，加密规则是caching_sha2_password。解决问题方法有两种，第一种是升级图形界面工具版本，第二种是把MySQL8用户登录密码加密规则还原成mysql_native_password。\n\n第二种解决方案如下，用命令行登录MySQL数据库之后，执行如下命令修改用户密码加密规则并更新用户密码，这里修改用户名为“root@localhost”的用户密码规则为“mysql_native_password”，密码值为“123456”，如图所示。\n\n#使用mysql数据库\nUSE mysql;\n#修改'root'@'localhost'用户的密码规则和密码\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'abc123';\n#刷新权限\nFLUSH PRIVILEGES;\n\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"# 数据库工具\n\nmysql图形化管理工具极大地方便了数据库的操作与管理，常用的图形化管理工具有：mysql workbench、phpmyadmin、navicat preminum、mysqldumper、sqlyog、dbeaver、mysql odbcconnector。\n\n\n# 1. mysql workbench\n\nmysql官方提供的图形化管理工具mysql workbench完全支持mysql 5.0以上的版本。mysql workbench分为社区版和商业版，社区版完全免费，而商业版则是按年收费。mysql workbench 为数据库管理员、程序开发者和系统规划师提供可视化设计、模型建立、以及数据库管理功能。它包含了用于创建复杂的数据建模er模型，正向和逆向数据库工程，也可以用于执行通常需要花费大量时间的、难以变更和管理的文档任务。\n\n下载地址：http://dev.mysql.com/downloads/workbench/。\n\n使用：\n\n首先，我们点击 windows 左下角的“开始”按钮，如果你是 win10 系统，可以直接看到所有程序。接着，找到“mysql”，点开，找到“mysql workbench 8.0 ce”。点击打开 workbench，如下图所示：\n\n左下角有个本地连接，点击，录入 root 的密码，登录本地 mysql 数据库服务器，如下图所示：\n\n这是一个图形化的界面，我来给你介绍下这个界面。\n\n * 上方是菜单。左上方是导航栏，这里我们可以看到 mysql 数据库服务器里面的数据 库，包括数据表、视图、存储过程和函数；左下方是信息栏，可以显示上方选中的数据 库、数据表等对象的信息。\n\n * 中间上方是工作区，你可以在这里写 sql 语句，点击上方菜单栏左边的第三个运行按 钮，就可以执行工作区的 sql 语句了。\n\n * 中间下方是输出区，用来显示 sql 语句的运行情况，包括什么时间开始运行的、运行的内容、运行的输出，以及所花费的时长等信息。\n\n好了，下面我们就用 workbench 实际创建一个数据库，并且导入一个 excel 数据文件， 来生成一个数据表。数据表是存储数据的载体，有了数据表以后，我们就能对数据进行操作了。\n\n\n# 2. navicat 😄\n\nnavicat mysql是一个强大的mysql数据库服务器管理和开发工具。它可以与任何3.21或以上版本的mysql一起工作，支持触发器、存储过程、函数、事件、视图、管理用户等，对于新手来说易学易用。其精心设计的图形用户界面（gui）可以让用户用一种安全简便的方式来快速方便地创建、组织、访问和共享信息。navicat支持中文，有免费版本提供。 下载地址：http://www.navicat.com/。\n\n\n# 1. 破解版\n\n安装破解版：https://zhuanlan.zhihu.com/p/492364793\n\n\n# 2. 连接数据库\n\n 1. 进入连接数据库配置页面\n    \n    * 方式一：点击文件-》新建连接-》mysql\n      \n      \n    \n    * 方式二：连接-》mysql\n      \n      \n\n 2. 填写数据库连接信息\n\n 3. 测试连接\n\n 4. 最后点击 “确认”，完成连接。\n\n\n# 3. 问题\n\n# mysql error 1130 问题解决方案 😄\n\n\n\n 1. 改表法\n\n可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”\n\nmysql -u root -pvmware\nmysql>use mysql;\nmysql>update user set host = '%' where user = 'root';\nmysql>flush privileges;\nmysql>select host, user from user;\n\n\n1\n2\n3\n4\n5\n\n\n\n\n 2. 授权法\n\n例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。\n\ngrant all privileges on *.* to 'myuser'@'%' identified by 'mypassword' with grant option;\n\n\n1\n\n\n如果你想允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器，并使用mypassword作为密码\n\ngrant all privileges on *.* to 'myuser'@'192.168.1.3' identified by 'mypassword' with grant option;\n\n\n1\n\n\n参考：\n\n连接mysql数据库，报1130错误的解决方法 - 腾讯云开发者社区-腾讯云 (tencent.com)\n\n(mysql error 1130 问题解决方案_推敲的博客-csdn博客🐱\n\n\n# 3. sqlyog\n\nsqlyog 是业界著名的 webyog 公司出品的一款简洁高效、功能强大的图形化 mysql 数据库管理工具。这款工具是使用c++语言开发的。该工具可以方便地创建数据库、表、视图和索引等，还可以方便地进行插入、更新和删除等操作，同时可以方便地进行数据库、数据表的备份和还原。该工具不仅可以通过sql文件进行大量文件的导入和导出，还可以导入和导出xml、html和csv等多种格式的数据。 下载地址：http://www.webyog.com/，读者也可以搜索中文版的下载址。\n\n\n# 4. dbeaver\n\ndbeaver是一个通用的数据库管理工具和 sql 客户端，支持所有流行的数据库：mysql、postgresql、sqlite、oracle、db2、sql server、 sybase、ms access、teradata、 firebird、apache hive、phoenix、presto等。dbeaver比大多数的sql管理工具要轻量，而且支持中文界面。dbeaver社区版作为一个免费开源的产品，和其他类似的软件相比，在功能和易用性上都毫不逊色。\n\n唯一需要注意是 dbeaver 是用java编程语言开发的，所以需要拥有 jdk（java development toolkit）环境。如果电脑上没有jdk，在选择安装dbeaver组件时，勾选“include java”即可。\n\n下载地址：https://dbeaver.io/download/\n\n\n# 扩展\n\n有些图形界面工具，特别是旧版本的图形界面工具，在连接mysql8时出现“authentication plugin 'caching_sha2_password' cannot be loaded”错误。\n\n出现这个原因是mysql8之前的版本中加密规则是mysql_native_password，而在mysql8之后，加密规则是caching_sha2_password。解决问题方法有两种，第一种是升级图形界面工具版本，第二种是把mysql8用户登录密码加密规则还原成mysql_native_password。\n\n第二种解决方案如下，用命令行登录mysql数据库之后，执行如下命令修改用户密码加密规则并更新用户密码，这里修改用户名为“root@localhost”的用户密码规则为“mysql_native_password”，密码值为“123456”，如图所示。\n\n#使用mysql数据库\nuse mysql;\n#修改'root'@'localhost'用户的密码规则和密码\nalter user 'root'@'localhost' identified with mysql_native_password by 'abc123';\n#刷新权限\nflush privileges;\n\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2023/03/10, 00:02:40",lastUpdatedTimestamp:167837776e4},{title:"SVN基础",frontmatter:{title:"SVN基础",date:"2023-02-25T21:31:23.000Z",permalink:"/pages/00b1bb/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/03.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01.Svn/1.SVN%E5%9F%BA%E7%A1%80.html",relativePath:"03.开发工具/03.代码管理工具/01.Svn/1.SVN基础.md",key:"v-c97358b4",path:"/pages/00b1bb/",headers:[{level:2,title:"1. svn简介",slug:"_1-svn简介",normalizedTitle:"1. svn简介",charIndex:12},{level:3,title:"0. 什么是svn?",slug:"_0-什么是svn",normalizedTitle:"0. 什么是svn?",charIndex:25},{level:3,title:"1.  svn跟git比较",slug:"_1-svn跟git比较",normalizedTitle:"1.  svn跟git比较",charIndex:null},{level:3,title:"2. svn主要应用",slug:"_2-svn主要应用",normalizedTitle:"2. svn主要应用",charIndex:299},{level:3,title:"3. svn仓库(服务端)",slug:"_3-svn仓库-服务端",normalizedTitle:"3. svn仓库(服务端)",charIndex:380},{level:3,title:"4.  svn客户端安装及汉化",slug:"_4-svn客户端安装及汉化",normalizedTitle:"4.  svn客户端安装及汉化",charIndex:null},{level:2,title:"2.SVN快速上手",slug:"_2-svn快速上手",normalizedTitle:"2.svn快速上手",charIndex:519},{level:3,title:"1. Checkout同步代码",slug:"_1-checkout同步代码",normalizedTitle:"1. checkout同步代码",charIndex:533},{level:3,title:"2. Update更新代码",slug:"_2-update更新代码",normalizedTitle:"2. update更新代码",charIndex:696},{level:3,title:"3. Commit提交代码",slug:"_3-commit提交代码",normalizedTitle:"3. commit提交代码",charIndex:737},{level:3,title:"4. 忽略文件",slug:"_4-忽略文件",normalizedTitle:"4. 忽略文件",charIndex:858},{level:3,title:"5. 撤销本地修改",slug:"_5-撤销本地修改",normalizedTitle:"5. 撤销本地修改",charIndex:975},{level:3,title:"6. 撤销已经提交的代码",slug:"_6-撤销已经提交的代码",normalizedTitle:"6. 撤销已经提交的代码",charIndex:1085},{level:3,title:"7. SVN仓库目录和开发建议",slug:"_7-svn仓库目录和开发建议",normalizedTitle:"7. svn仓库目录和开发建议",charIndex:1254},{level:3,title:"8. 如何创建分支",slug:"_8-如何创建分支",normalizedTitle:"8. 如何创建分支",charIndex:1429},{level:3,title:"9. 如何合并代码",slug:"_9-如何合并代码",normalizedTitle:"9. 如何合并代码",charIndex:1580},{level:3,title:"10. 切换分支",slug:"_10-切换分支",normalizedTitle:"10. 切换分支",charIndex:1928},{level:3,title:"11. 修改仓库地址",slug:"_11-修改仓库地址",normalizedTitle:"11. 修改仓库地址",charIndex:1984},{level:2,title:"3.SVN常用命令",slug:"_3-svn常用命令",normalizedTitle:"3.svn常用命令",charIndex:2154}],headersStr:"1. svn简介 0. 什么是svn? 1.  svn跟git比较 2. svn主要应用 3. svn仓库(服务端) 4.  svn客户端安装及汉化 2.SVN快速上手 1. Checkout同步代码 2. Update更新代码 3. Commit提交代码 4. 忽略文件 5. 撤销本地修改 6. 撤销已经提交的代码 7. SVN仓库目录和开发建议 8. 如何创建分支 9. 如何合并代码 10. 切换分支 11. 修改仓库地址 3.SVN常用命令",content:'# SVN基础\n\n\n# 1. svn简介\n\n\n# 0. 什么是svn?\n\nSVN是subversion的缩写，是一个开放源代码的版本控制系统，通过采用分支管理系统的高效管理，简而言之就是用于多个人共同开发同一个项目，实现共享资源，实现最终集中式的管理.\n\n> 来源: 百度百科\n\n1. 代码版本管理工具\n2. 能够记住每次修改的内容\n3. 查看所有的修改记录\n4. 回复到任何历史版本\n5. 恢复已经删除的文件\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1. svn跟git比较\n\n * 使用简单,上手快\n\n * 目录级权限控制,企业安全必备\n\n * 子目录Checkout,减少不必要的文件检测\n\n\n# 2. svn主要应用\n\n * 开发人员用来做代码的版本控制\n * 用来存储一些重要的文件,比如合同.\n * 公司存储内部文件共享,并且能按照目录划分权限\n\n\n# 3. svn仓库(服务端)\n\n推荐: https://svnbucket.com/\n\n\n# 4. svn客户端安装及汉化\n\n> 资源链接：https://pan.baidu.com/s/1Zx7q5wBlwrbkLmsGp2vPtg 提取码：b0gj\n\n安装步骤: 略\n\n\n# 2.SVN快速上手\n\n\n# 1. Checkout同步代码\n\n 1. 项目详情-源码页面-复制SVN地址\n 2. 在你需要保存代码的地方右键选择“SVN Chekout…”\n 3. 填写仓库地址，填写保存目录，输入网站登录用户名密码。\n 4. 点击确定就能同步代码到本地了。\n\n> 如果你还没有代码仓库，你可以到 SVNBucket 注册一个。\n\n\n# 2. Update更新代码\n\n右键 SVN Update 就能更新代码了\n\n\n# 3. Commit提交代码\n\n提交代码也很简单，右键“SVN Commit…”，填入提交描述，就可以把本地提交的代码提交到服务器了。\n\n> 在提交代码前我们应该update下代码，这是个好习惯，可以避免覆盖别人的代码和代码冲突。\n\n\n\n\n# 4. 忽略文件\n\n有时候某些目录或者文件我们不想提交到 SVN 服务器，这时我们可以忽略这些文件。 下面演示忽略 temp 目录和 *.map 文件\n\n撤销忽略，文件的操作方式步骤是一样的，目录的有点不一样，请看下面演示\n\n\n\n\n# 5. 撤销本地修改\n\n有时候我们本地修改了一些文件，但是突然又不需要了，想丢弃本地的修改回去SVN上最新的版本怎么操作呢？ 右键选中需要撤销的文件，TortoiseSVN->Rever就可以丢弃本地修改了。\n\n\n\n\n# 6. 撤销已经提交的代码\n\n已经提交到SVN仓库的代码发现改错了，还能后悔撤回吗？\n\n 1. TortoiseSVN==>show log查看提交记录\n 2. 选择我们需要回去的版本，右键选择"Revert to this version"，这样就回去了指定的版本\n 3. 最后你还需要commit下撤销后的代码到SVN仓库\n\n\n\n\n# 7. SVN仓库目录和开发建议\n\n我们建议每个仓库的根目录都创建trunk、branches、tags目录，这是经典的 SVN 目录结构，方便开发和维护\n\n> 个人比较喜欢的开发模式是，开发时都在trunk写代码，上线产品后就创建分支到branches目录，线上版本出问题了，我们应该在对应的分支上进行修复，并且把修复后的代码合并到主干上。\n\n\n# 8. 如何创建分支\n\n以上面的目录结构为例子，我们从当前主干创建一个分支出去，表示1.0版本，操作步骤如下：\n\n 1. 右键trunk目录=>TortoiseSVN=>Branch/tag\n 2. 填写分支路径/branches/online1.0，填写注释，选择最用最新的版本开分支，如下：\n\n\n# 9. 如何合并代码\n\n假设我们在分支上修复了一个线上的BUG，需要把代码那个代码合并到主干来，操作步骤：\n\n 1. 在分支的跟目录点击show log\n 2. 选中需要合并过去主干的提交记录（可以多选）\n 3. 点击merge revision to …\n 4. 选择主干的跟目录，点击确定，就合并过去了。\n 5. 在主干上提交这次合并的内容\n\n\n\nSVN的这个指定提交记录合并功能非常的方便，我们日常中经常会遇到线上出问题需要修复，修复后把代码合并到主干的情况。\n\n> 你在分支上的什么目录点击合并，那就需要定位到主干的对应目录合并，不然会出错。\n\n> 另外如果你有大量的代码需要合并或者不知道哪些提交记录需要合并，可以使用Beyond Compare来进行对比合并，也是非常方便的。\n\n\n# 10. 切换分支\n\n右键TortoiseSVN=>Switch=>选择需要切换的分支，点击确定就可以了\n\n\n# 11. 修改仓库地址\n\n如果您的仓库地址变了，是不是需要重新checkout一份代码呢？\n\n快速更换：右键点击仓库根目录 => TortoiseSVN => relocate，修改仓库地址，点击确定后就修改好了\n\n> 以上资源来自: https://easydoc.top/s/78711005/uSJD1CDg/60815798\n\n\n# 3.SVN常用命令\n\n首先推荐大家一个应该是国内外最好的SVN仓库，不限私有，不限成员：SVNBucket\n\n# checkout代码\nsvn co svn://svnbucket.com/xxx/xxx\n# 更新代码\nsvn up\n# 提交代码\nsvn commit -m "提交描述"\n# 添加新文件到版本库\nsvn add filename\n# 添加当前目录下所有php文件\nsvn add *.php\n# 递归添加当前目录下的所有新文件\nsvn add . --no-ignore --force\n# 查看指定文件的所有log\nsvn log test.php\n# 查看指定版本号的log\nsvn svn log -r 100\n# 撤销本地文件的修改（还没提交的）\nsvn revert test.php\nsvn revert -r 目录名\n# 撤销目录下所有本地修改\nsvn revert --recursive 目录名\n# 查看当前工作区的所有改动\nsvn diff\n# 查看当前工作区test.php文件与最新版本的差异\nsvn diff test.php  \n# 指定版本号比较差异\nsvn diff -r 200:201 test.php  \n# 查看当前工作区和版本301中bin目录的差异\nsvn diff -r 301 bin\n# 查看当前工作区的状态\nsvn status\n# 查看svn信息\nsvn info\n# 查看文件列表，可以指定-r查看，查看指定版本号的文件列表\nsvn ls \nsvn ls -r 100\n# 显示文件的每一行最后是谁修改的（出了BUG，经常用来查这段代码是谁改的）\nsvn blame filename.php\n# 查看指定版本的文件内容，不加版本号就是查看最新版本的\nsvn cat test.py -r 2\n# 清理\nsvn cleanup\n# 若想创建了一个文件夹，并且把它加入版本控制，但忽略文件夹中的所有文件的内容\nsvn mkdir spool \nsvn propset svn:ignore \'*\' spool \nsvn ci -m \'Adding "spool" and ignoring its contents.\'\n# 若想创建一个文件夹，但不加入版本控制，即忽略这个文件夹\nsvn mkdir spool \nsvn propset svn:ignore \'spool\' . \nsvn ci -m \'Ignoring a directory called "spool".\'\n# 切换当前项目到指定分支。服务器上更新新版本我们经常就用这个命令来把当前代码切换到新的分支\nsvn switch svn://svnbucket.com/test/branches/online1.0\n# 重定向仓库地址到新地址\nsvn switch --relocate 原svn地址 新svn地址\n# 创建分支，从主干创建一个分支保存到branches/online1.0\nsvn cp -m "描述内容" http://svnbucket.com/repos/trunk http://svnbucket.com/repos/branches/online1.0\n# 合并主干上的最新代码到分支上\ncd branches/online1.0\nsvn merge http://svnbucket.com/repos/trunk \n# 分支合并到主干\nsvn merge --reintegrate http://svnbucket.com/repos/branches/online1.0\n# 删除分支\nsvn rm http://svnbucket.com/repos/branches/online1.0\n# 查看SVN帮助\nsvn help\n# 查看指定命令的帮助信息\nsvn help commit\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n> 以上资源来自: https://easydoc.top/s/78711005/uSJD1CDg/33195524',normalizedContent:'# svn基础\n\n\n# 1. svn简介\n\n\n# 0. 什么是svn?\n\nsvn是subversion的缩写，是一个开放源代码的版本控制系统，通过采用分支管理系统的高效管理，简而言之就是用于多个人共同开发同一个项目，实现共享资源，实现最终集中式的管理.\n\n> 来源: 百度百科\n\n1. 代码版本管理工具\n2. 能够记住每次修改的内容\n3. 查看所有的修改记录\n4. 回复到任何历史版本\n5. 恢复已经删除的文件\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1. svn跟git比较\n\n * 使用简单,上手快\n\n * 目录级权限控制,企业安全必备\n\n * 子目录checkout,减少不必要的文件检测\n\n\n# 2. svn主要应用\n\n * 开发人员用来做代码的版本控制\n * 用来存储一些重要的文件,比如合同.\n * 公司存储内部文件共享,并且能按照目录划分权限\n\n\n# 3. svn仓库(服务端)\n\n推荐: https://svnbucket.com/\n\n\n# 4. svn客户端安装及汉化\n\n> 资源链接：https://pan.baidu.com/s/1zx7q5wblwrbklmsgp2vptg 提取码：b0gj\n\n安装步骤: 略\n\n\n# 2.svn快速上手\n\n\n# 1. checkout同步代码\n\n 1. 项目详情-源码页面-复制svn地址\n 2. 在你需要保存代码的地方右键选择“svn chekout…”\n 3. 填写仓库地址，填写保存目录，输入网站登录用户名密码。\n 4. 点击确定就能同步代码到本地了。\n\n> 如果你还没有代码仓库，你可以到 svnbucket 注册一个。\n\n\n# 2. update更新代码\n\n右键 svn update 就能更新代码了\n\n\n# 3. commit提交代码\n\n提交代码也很简单，右键“svn commit…”，填入提交描述，就可以把本地提交的代码提交到服务器了。\n\n> 在提交代码前我们应该update下代码，这是个好习惯，可以避免覆盖别人的代码和代码冲突。\n\n\n\n\n# 4. 忽略文件\n\n有时候某些目录或者文件我们不想提交到 svn 服务器，这时我们可以忽略这些文件。 下面演示忽略 temp 目录和 *.map 文件\n\n撤销忽略，文件的操作方式步骤是一样的，目录的有点不一样，请看下面演示\n\n\n\n\n# 5. 撤销本地修改\n\n有时候我们本地修改了一些文件，但是突然又不需要了，想丢弃本地的修改回去svn上最新的版本怎么操作呢？ 右键选中需要撤销的文件，tortoisesvn->rever就可以丢弃本地修改了。\n\n\n\n\n# 6. 撤销已经提交的代码\n\n已经提交到svn仓库的代码发现改错了，还能后悔撤回吗？\n\n 1. tortoisesvn==>show log查看提交记录\n 2. 选择我们需要回去的版本，右键选择"revert to this version"，这样就回去了指定的版本\n 3. 最后你还需要commit下撤销后的代码到svn仓库\n\n\n\n\n# 7. svn仓库目录和开发建议\n\n我们建议每个仓库的根目录都创建trunk、branches、tags目录，这是经典的 svn 目录结构，方便开发和维护\n\n> 个人比较喜欢的开发模式是，开发时都在trunk写代码，上线产品后就创建分支到branches目录，线上版本出问题了，我们应该在对应的分支上进行修复，并且把修复后的代码合并到主干上。\n\n\n# 8. 如何创建分支\n\n以上面的目录结构为例子，我们从当前主干创建一个分支出去，表示1.0版本，操作步骤如下：\n\n 1. 右键trunk目录=>tortoisesvn=>branch/tag\n 2. 填写分支路径/branches/online1.0，填写注释，选择最用最新的版本开分支，如下：\n\n\n# 9. 如何合并代码\n\n假设我们在分支上修复了一个线上的bug，需要把代码那个代码合并到主干来，操作步骤：\n\n 1. 在分支的跟目录点击show log\n 2. 选中需要合并过去主干的提交记录（可以多选）\n 3. 点击merge revision to …\n 4. 选择主干的跟目录，点击确定，就合并过去了。\n 5. 在主干上提交这次合并的内容\n\n\n\nsvn的这个指定提交记录合并功能非常的方便，我们日常中经常会遇到线上出问题需要修复，修复后把代码合并到主干的情况。\n\n> 你在分支上的什么目录点击合并，那就需要定位到主干的对应目录合并，不然会出错。\n\n> 另外如果你有大量的代码需要合并或者不知道哪些提交记录需要合并，可以使用beyond compare来进行对比合并，也是非常方便的。\n\n\n# 10. 切换分支\n\n右键tortoisesvn=>switch=>选择需要切换的分支，点击确定就可以了\n\n\n# 11. 修改仓库地址\n\n如果您的仓库地址变了，是不是需要重新checkout一份代码呢？\n\n快速更换：右键点击仓库根目录 => tortoisesvn => relocate，修改仓库地址，点击确定后就修改好了\n\n> 以上资源来自: https://easydoc.top/s/78711005/usjd1cdg/60815798\n\n\n# 3.svn常用命令\n\n首先推荐大家一个应该是国内外最好的svn仓库，不限私有，不限成员：svnbucket\n\n# checkout代码\nsvn co svn://svnbucket.com/xxx/xxx\n# 更新代码\nsvn up\n# 提交代码\nsvn commit -m "提交描述"\n# 添加新文件到版本库\nsvn add filename\n# 添加当前目录下所有php文件\nsvn add *.php\n# 递归添加当前目录下的所有新文件\nsvn add . --no-ignore --force\n# 查看指定文件的所有log\nsvn log test.php\n# 查看指定版本号的log\nsvn svn log -r 100\n# 撤销本地文件的修改（还没提交的）\nsvn revert test.php\nsvn revert -r 目录名\n# 撤销目录下所有本地修改\nsvn revert --recursive 目录名\n# 查看当前工作区的所有改动\nsvn diff\n# 查看当前工作区test.php文件与最新版本的差异\nsvn diff test.php  \n# 指定版本号比较差异\nsvn diff -r 200:201 test.php  \n# 查看当前工作区和版本301中bin目录的差异\nsvn diff -r 301 bin\n# 查看当前工作区的状态\nsvn status\n# 查看svn信息\nsvn info\n# 查看文件列表，可以指定-r查看，查看指定版本号的文件列表\nsvn ls \nsvn ls -r 100\n# 显示文件的每一行最后是谁修改的（出了bug，经常用来查这段代码是谁改的）\nsvn blame filename.php\n# 查看指定版本的文件内容，不加版本号就是查看最新版本的\nsvn cat test.py -r 2\n# 清理\nsvn cleanup\n# 若想创建了一个文件夹，并且把它加入版本控制，但忽略文件夹中的所有文件的内容\nsvn mkdir spool \nsvn propset svn:ignore \'*\' spool \nsvn ci -m \'adding "spool" and ignoring its contents.\'\n# 若想创建一个文件夹，但不加入版本控制，即忽略这个文件夹\nsvn mkdir spool \nsvn propset svn:ignore \'spool\' . \nsvn ci -m \'ignoring a directory called "spool".\'\n# 切换当前项目到指定分支。服务器上更新新版本我们经常就用这个命令来把当前代码切换到新的分支\nsvn switch svn://svnbucket.com/test/branches/online1.0\n# 重定向仓库地址到新地址\nsvn switch --relocate 原svn地址 新svn地址\n# 创建分支，从主干创建一个分支保存到branches/online1.0\nsvn cp -m "描述内容" http://svnbucket.com/repos/trunk http://svnbucket.com/repos/branches/online1.0\n# 合并主干上的最新代码到分支上\ncd branches/online1.0\nsvn merge http://svnbucket.com/repos/trunk \n# 分支合并到主干\nsvn merge --reintegrate http://svnbucket.com/repos/branches/online1.0\n# 删除分支\nsvn rm http://svnbucket.com/repos/branches/online1.0\n# 查看svn帮助\nsvn help\n# 查看指定命令的帮助信息\nsvn help commit\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n> 以上资源来自: https://easydoc.top/s/78711005/usjd1cdg/33195524',charsets:{cjk:!0},lastUpdated:"2023/03/01, 22:43:28",lastUpdatedTimestamp:1677681808e3},{title:"Git安装",frontmatter:{title:"Git安装",date:"2023-03-01T22:14:29.000Z",permalink:"/pages/d486f7/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/03.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02.Git/1.Git%E5%AE%89%E8%A3%85.html",relativePath:"03.开发工具/03.代码管理工具/02.Git/1.Git安装.md",key:"v-4ccda259",path:"/pages/d486f7/",headers:[{level:2,title:"一、Git下载",slug:"一、git下载",normalizedTitle:"一、git下载",charIndex:10},{level:2,title:"二、Git安装",slug:"二、git安装",normalizedTitle:"二、git安装",charIndex:375},{level:3,title:"1.运行安装文件",slug:"_1-运行安装文件",normalizedTitle:"1.运行安装文件",charIndex:417},{level:3,title:"2.选择安装位置",slug:"_2-选择安装位置",normalizedTitle:"2.选择安装位置",charIndex:432},{level:3,title:"3.选择组件",slug:"_3-选择组件",normalizedTitle:"3.选择组件",charIndex:506},{level:3,title:"4.选择开始菜单文件夹",slug:"_4-选择开始菜单文件夹",normalizedTitle:"4.选择开始菜单文件夹",charIndex:519},{level:3,title:"5.选择Git默认编辑器",slug:"_5-选择git默认编辑器",normalizedTitle:"5.选择git默认编辑器",charIndex:537},{level:3,title:"6.在新存储库中调整初始分支的名称",slug:"_6-在新存储库中调整初始分支的名称",normalizedTitle:"6.在新存储库中调整初始分支的名称",charIndex:556},{level:3,title:"7.调整Path环境",slug:"_7-调整path环境",normalizedTitle:"7.调整path环境",charIndex:580},{level:3,title:"8.选择SSH可执行文件",slug:"_8-选择ssh可执行文件",normalizedTitle:"8.选择ssh可执行文件",charIndex:597},{level:3,title:"9.选择HTTPS传输后端",slug:"_9-选择https传输后端",normalizedTitle:"9.选择https传输后端",charIndex:618},{level:3,title:"10.配置行结束转换",slug:"_10-配置行结束转换",normalizedTitle:"10.配置行结束转换",charIndex:638},{level:3,title:"11.将终端仿真器配置为与Git Bash一起使用",slug:"_11-将终端仿真器配置为与git-bash一起使用",normalizedTitle:"11.将终端仿真器配置为与git bash一起使用",charIndex:655},{level:3,title:'12.选择"git pull"的默认行为',slug:"_12-选择-git-pull-的默认行为",normalizedTitle:"12.选择&quot;git pull&quot;的默认行为",charIndex:null},{level:3,title:"13.选择凭证助手",slug:"_13-选择凭证助手",normalizedTitle:"13.选择凭证助手",charIndex:714},{level:3,title:"14.配置额外选项",slug:"_14-配置额外选项",normalizedTitle:"14.配置额外选项",charIndex:730},{level:3,title:"15.配置实验选项",slug:"_15-配置实验选项",normalizedTitle:"15.配置实验选项",charIndex:746},{level:3,title:"16.完成Git安装向导",slug:"_16-完成git安装向导",normalizedTitle:"16.完成git安装向导",charIndex:762},{level:3,title:"17. 验证",slug:"_17-验证",normalizedTitle:"17. 验证",charIndex:781}],headersStr:'一、Git下载 二、Git安装 1.运行安装文件 2.选择安装位置 3.选择组件 4.选择开始菜单文件夹 5.选择Git默认编辑器 6.在新存储库中调整初始分支的名称 7.调整Path环境 8.选择SSH可执行文件 9.选择HTTPS传输后端 10.配置行结束转换 11.将终端仿真器配置为与Git Bash一起使用 12.选择"git pull"的默认行为 13.选择凭证助手 14.配置额外选项 15.配置实验选项 16.完成Git安装向导 17. 验证',content:'# Git\n\n\n# 一、Git下载\n\n官网下载地址：Git (git-scm.com)\n\n国内镜像地址：https://npm.taobao.org/mirrors/git-for-windows/\n\n点击"Download for Windows"，跳转至详细下载页面。\n\n以Windows64位安装版为例，点击"64-bit Git for Windows Setup."即可进行下载。\n\n附：官网下载速度较慢，如需快速下载，可通过国内镜像网站（镜像网站不一定同步至最新版）。\n\n镜像下载地址：CNPM Binaries Mirror (npmmirror.com)\n\n新版在页尾，选择一个版本点击，会跳转至此版本的详细下载页面。\n\n以Windows64位安装版为例，点击"Git-2.34.1-64-bit.exe"即可进行下载。\n\n\n\n\n# 二、Git安装\n\n基本全部默认下一步即可，但还是记录一下安装过程，供参考。\n\n\n# 1.运行安装文件\n\n\n\n\n# 2.选择安装位置\n\n记得SVN集成到IDEA的时候，由于SVN安装路径有空格，导致过一些问题。所以这里Git安装路径也改成不带空格的。\n\n\n\n\n# 3.选择组件\n\n\n\n\n# 4.选择开始菜单文件夹\n\n\n\n\n# 5.选择Git默认编辑器\n\n\n\n\n# 6.在新存储库中调整初始分支的名称\n\n\n\n\n# 7.调整Path环境\n\n\n\n\n# 8.选择SSH可执行文件\n\n\n\n\n\n\n# 9.选择HTTPS传输后端\n\n\n\n\n# 10.配置行结束转换\n\n\n\n\n# 11.将终端仿真器配置为与Git Bash一起使用\n\n\n\n\n# 12.选择"git pull"的默认行为\n\n\n\n\n# 13.选择凭证助手\n\n\n\n\n# 14.配置额外选项\n\n\n\n\n# 15.配置实验选项\n\n\n\n\n# 16.完成Git安装向导\n\n\n\n\n# 17. 验证\n\ngit version\n\n\n1\n\n\n',normalizedContent:'# git\n\n\n# 一、git下载\n\n官网下载地址：git (git-scm.com)\n\n国内镜像地址：https://npm.taobao.org/mirrors/git-for-windows/\n\n点击"download for windows"，跳转至详细下载页面。\n\n以windows64位安装版为例，点击"64-bit git for windows setup."即可进行下载。\n\n附：官网下载速度较慢，如需快速下载，可通过国内镜像网站（镜像网站不一定同步至最新版）。\n\n镜像下载地址：cnpm binaries mirror (npmmirror.com)\n\n新版在页尾，选择一个版本点击，会跳转至此版本的详细下载页面。\n\n以windows64位安装版为例，点击"git-2.34.1-64-bit.exe"即可进行下载。\n\n\n\n\n# 二、git安装\n\n基本全部默认下一步即可，但还是记录一下安装过程，供参考。\n\n\n# 1.运行安装文件\n\n\n\n\n# 2.选择安装位置\n\n记得svn集成到idea的时候，由于svn安装路径有空格，导致过一些问题。所以这里git安装路径也改成不带空格的。\n\n\n\n\n# 3.选择组件\n\n\n\n\n# 4.选择开始菜单文件夹\n\n\n\n\n# 5.选择git默认编辑器\n\n\n\n\n# 6.在新存储库中调整初始分支的名称\n\n\n\n\n# 7.调整path环境\n\n\n\n\n# 8.选择ssh可执行文件\n\n\n\n\n\n\n# 9.选择https传输后端\n\n\n\n\n# 10.配置行结束转换\n\n\n\n\n# 11.将终端仿真器配置为与git bash一起使用\n\n\n\n\n# 12.选择"git pull"的默认行为\n\n\n\n\n# 13.选择凭证助手\n\n\n\n\n# 14.配置额外选项\n\n\n\n\n# 15.配置实验选项\n\n\n\n\n# 16.完成git安装向导\n\n\n\n\n# 17. 验证\n\ngit version\n\n\n1\n\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/10, 08:04:32",lastUpdatedTimestamp:1678406672e3},{title:"Git常用命令",frontmatter:{title:"Git常用命令",date:"2023-02-25T21:31:23.000Z",permalink:"/pages/8e6be6/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/03.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02.Git/2.Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"03.开发工具/03.代码管理工具/02.Git/2.Git常用命令.md",key:"v-d0c08d72",path:"/pages/8e6be6/",headers:[{level:2,title:"1. 常用命令",slug:"_1-常用命令",normalizedTitle:"1. 常用命令",charIndex:14},{level:2,title:"2. 需要记住的命令",slug:"_2-需要记住的命令",normalizedTitle:"2. 需要记住的命令",charIndex:722},{level:3,title:"一、新建代码库",slug:"一、新建代码库",normalizedTitle:"一、新建代码库",charIndex:908},{level:3,title:"二、配置",slug:"二、配置",normalizedTitle:"二、配置",charIndex:1057},{level:3,title:"三、增加/删除文件",slug:"三、增加-删除文件",normalizedTitle:"三、增加/删除文件",charIndex:1328},{level:3,title:"四、代码提交",slug:"四、代码提交",normalizedTitle:"四、代码提交",charIndex:1728},{level:3,title:"五、分支",slug:"五、分支",normalizedTitle:"五、分支",charIndex:2129},{level:3,title:"六、标签",slug:"六、标签",normalizedTitle:"六、标签",charIndex:2922},{level:3,title:"七、查看信息",slug:"七、查看信息",normalizedTitle:"七、查看信息",charIndex:3339},{level:3,title:"八、远程同步",slug:"八、远程同步",normalizedTitle:"八、远程同步",charIndex:4448},{level:3,title:"九、撤销",slug:"九、撤销",normalizedTitle:"九、撤销",charIndex:4997},{level:3,title:"十、其他",slug:"十、其他",normalizedTitle:"十、其他",charIndex:5649}],headersStr:"1. 常用命令 2. 需要记住的命令 一、新建代码库 二、配置 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销 十、其他",content:'# Git常用命令\n\n\n# 1. 常用命令\n\n# 配置Git账号\ngit config --global user.email "134808823@qq.com"\ngit config --global user.name "afreebird"\n \n\n# 在当前目录新建一个Git代码库\ngit init\n \n\n# 新建一个目录，将其初始化为Git代码库\ngit init [project-name]\n\n# 下载一个项目和它的整个代码历史\ngit clone [url]\n \n\n# 查看状态\ngit status\n\n# 提交文件\ngit add .\n\n# 提交文件\ngit commit -m ""\n\n# 查看分支\ngit branch\n\n# 切换分支\ngit checkout [branch]\n\n# 创建分支、并切换到分支 newbranch\ngit checkout -b [branch]\n\n# 推送到远程仓库【远程仓库有对应分支】\ngit push origin [branch]:[branch]\n\n# 强制推送数据到远程仓库【远程仓库没有对应分支】\ngit push --set-upstream origin [branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n \n\n# 合并后推送到远程仓库\ngit push\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 2. 需要记住的命令\n\n我每天使用 Git ，但是很多命令记不住。\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\nWorkspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个Git代码库\n$ git init\n \n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n \n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\ngit fetch [remote]\n\n# 显示所有远程仓库\ngit remote -v\n\n# 显示某个远程仓库的信息\ngit remote show [remote]\n\n# 增加一个新的远程仓库，并命名\ngit remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\ngit pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库【重点】\ngit push [remote] [branch]\n\n# 推送到远程仓库【重点】\ngit push origin [branch]:[branch]\n-- 设置关联 【***********重点***********】\ngit push --set-upstream origin [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\ngit push [remote] --force\n\n# 推送所有分支到远程仓库\ngit push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十、其他\n\n# 生成一个可供发布的压缩包\n$ git archive\n\n\n1\n2\n',normalizedContent:'# git常用命令\n\n\n# 1. 常用命令\n\n# 配置git账号\ngit config --global user.email "134808823@qq.com"\ngit config --global user.name "afreebird"\n \n\n# 在当前目录新建一个git代码库\ngit init\n \n\n# 新建一个目录，将其初始化为git代码库\ngit init [project-name]\n\n# 下载一个项目和它的整个代码历史\ngit clone [url]\n \n\n# 查看状态\ngit status\n\n# 提交文件\ngit add .\n\n# 提交文件\ngit commit -m ""\n\n# 查看分支\ngit branch\n\n# 切换分支\ngit checkout [branch]\n\n# 创建分支、并切换到分支 newbranch\ngit checkout -b [branch]\n\n# 推送到远程仓库【远程仓库有对应分支】\ngit push origin [branch]:[branch]\n\n# 强制推送数据到远程仓库【远程仓库没有对应分支】\ngit push --set-upstream origin [branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n \n\n# 合并后推送到远程仓库\ngit push\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 2. 需要记住的命令\n\n我每天使用 git ，但是很多命令记不住。\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 git 命令清单。几个专用名词的译名如下。\n\nworkspace：工作区index / stage：暂存区repository：仓库区（或本地仓库）remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个git代码库\n$ git init\n \n# 新建一个目录，将其初始化为git代码库\n$ git init [project-name]\n \n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\ngit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的git配置\n$ git config --list\n\n# 编辑git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagname]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -s [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\ngit fetch [remote]\n\n# 显示所有远程仓库\ngit remote -v\n\n# 显示某个远程仓库的信息\ngit remote show [remote]\n\n# 增加一个新的远程仓库，并命名\ngit remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\ngit pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库【重点】\ngit push [remote] [branch]\n\n# 推送到远程仓库【重点】\ngit push origin [branch]:[branch]\n-- 设置关联 【***********重点***********】\ngit push --set-upstream origin [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\ngit push [remote] --force\n\n# 推送所有分支到远程仓库\ngit push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十、其他\n\n# 生成一个可供发布的压缩包\n$ git archive\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2023/03/01, 22:43:28",lastUpdatedTimestamp:1677681808e3},{title:"Git配置用户信息和SSH免密",frontmatter:{title:"Git配置用户信息和SSH免密",date:"2023-03-01T22:14:29.000Z",permalink:"/pages/502fb9/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/03.%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02.Git/3.Git%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%92%8CSSH%E5%85%8D%E5%AF%86.html",relativePath:"03.开发工具/03.代码管理工具/02.Git/3.Git配置用户信息和SSH免密.md",key:"v-2ee64fb9",path:"/pages/502fb9/",headers:[{level:2,title:"1. 配置用户信息",slug:"_1-配置用户信息",normalizedTitle:"1. 配置用户信息",charIndex:22},{level:3,title:"1.1 查看配置信息",slug:"_1-1-查看配置信息",normalizedTitle:"1.1 查看配置信息",charIndex:36},{level:3,title:"1.2 配置用户信息",slug:"_1-2-配置用户信息",normalizedTitle:"1.2 配置用户信息",charIndex:273},{level:2,title:"2. 配置SSH免密登录",slug:"_2-配置ssh免密登录",normalizedTitle:"2. 配置ssh免密登录",charIndex:476},{level:3,title:"2.1 创建SSH key",slug:"_2-1-创建ssh-key",normalizedTitle:"2.1 创建ssh key",charIndex:493},{level:3,title:"2.2 复制SSH公钥到gitee上",slug:"_2-2-复制ssh公钥到gitee上",normalizedTitle:"2.2 复制ssh公钥到gitee上",charIndex:682},{level:3,title:"2.3 本地终端验证",slug:"_2-3-本地终端验证",normalizedTitle:"2.3 本地终端验证",charIndex:813}],headersStr:"1. 配置用户信息 1.1 查看配置信息 1.2 配置用户信息 2. 配置SSH免密登录 2.1 创建SSH key 2.2 复制SSH公钥到gitee上 2.3 本地终端验证",content:'# Git配置用户信息和SSH免密\n\n\n# 1. 配置用户信息\n\n\n# 1.1 查看配置信息\n\n# 查看所有配置\n$ git config -l/--list\n# 查看系统配置\n$ git config --system -l/--list\n# 查看用户配置\n$ git config --global -l/--list\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\nGit配置文件存储位置 ①系统配置文件：git安装位置etc目录下的gitconfig文件 ②用户配置文件：当前用户目录下的.gitconfig文件（初始化用户配置前无此文件）\n\n\n# 1.2 配置用户信息\n\n用户名和邮箱为必需的配置\n\n$ git config --global user.name "[user-name]"\n$ git config --global user.email "[user-email@example.com]"\n\n\n1\n2\n\n\n\n\n执行完未报错即配置成功，此命令会在当前用户目录下生成.gitconfig文件\n\n\n\n可打开此文件确认用户配置\n\n\n\n\n# 2. 配置SSH免密登录\n\n\n# 2.1 创建SSH key\n\n$ ssh-keygen [-t rsa] [-C "user-email@example.com"]\n可选参数：\n-t 指定密钥类型，默认"rsa"，可省略\n-C 设置秘钥注释，如邮箱，可省略\n\n\n1\n2\n3\n4\n\n\n执行ssh-keygen，连按3次回车即可\n\n\n\n执行完会在当前用户目录下生成.ssh文件夹，该文件夹下有两个文件\n\n\n\n\n# 2.2 复制SSH公钥到gitee上\n\n打开gitee的个人账户设置\n\n\n\n点击"SSH公钥"，将.ssh文件夹下的id_rsa.pub文件内容复制粘贴到公钥输入框内\n\n\n\n点击"确定"，输入当前账号密码进行验证\n\n\n\n验证通过即成功添加SSH公钥\n\n\n\n\n# 2.3 本地终端验证\n\n执行ssh -T git@gitee.com，提示如下信息则SSH免密配置成功\n\n\n\n附：Git中使用HTTPS和SSH协议的区别\n\n * HTTPS可以随意clone项目；而SSH则要先将生成密钥对的公钥上传至服务器。\n\n * HTTPS在push的时候需要验证用户名和密码；而SSH除非生成密钥对的时候设置了密码，否则不需要输入密码。\n\n * HTTPS利于匿名访问，适合开源项目，方便被别人clone(但没有push权限)；\n\n * SSH不利于匿名访问，适合内部项目，只要配置了SSH公钥即可自由实现clone和push操作。',normalizedContent:'# git配置用户信息和ssh免密\n\n\n# 1. 配置用户信息\n\n\n# 1.1 查看配置信息\n\n# 查看所有配置\n$ git config -l/--list\n# 查看系统配置\n$ git config --system -l/--list\n# 查看用户配置\n$ git config --global -l/--list\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\ngit配置文件存储位置 ①系统配置文件：git安装位置etc目录下的gitconfig文件 ②用户配置文件：当前用户目录下的.gitconfig文件（初始化用户配置前无此文件）\n\n\n# 1.2 配置用户信息\n\n用户名和邮箱为必需的配置\n\n$ git config --global user.name "[user-name]"\n$ git config --global user.email "[user-email@example.com]"\n\n\n1\n2\n\n\n\n\n执行完未报错即配置成功，此命令会在当前用户目录下生成.gitconfig文件\n\n\n\n可打开此文件确认用户配置\n\n\n\n\n# 2. 配置ssh免密登录\n\n\n# 2.1 创建ssh key\n\n$ ssh-keygen [-t rsa] [-c "user-email@example.com"]\n可选参数：\n-t 指定密钥类型，默认"rsa"，可省略\n-c 设置秘钥注释，如邮箱，可省略\n\n\n1\n2\n3\n4\n\n\n执行ssh-keygen，连按3次回车即可\n\n\n\n执行完会在当前用户目录下生成.ssh文件夹，该文件夹下有两个文件\n\n\n\n\n# 2.2 复制ssh公钥到gitee上\n\n打开gitee的个人账户设置\n\n\n\n点击"ssh公钥"，将.ssh文件夹下的id_rsa.pub文件内容复制粘贴到公钥输入框内\n\n\n\n点击"确定"，输入当前账号密码进行验证\n\n\n\n验证通过即成功添加ssh公钥\n\n\n\n\n# 2.3 本地终端验证\n\n执行ssh -t git@gitee.com，提示如下信息则ssh免密配置成功\n\n\n\n附：git中使用https和ssh协议的区别\n\n * https可以随意clone项目；而ssh则要先将生成密钥对的公钥上传至服务器。\n\n * https在push的时候需要验证用户名和密码；而ssh除非生成密钥对的时候设置了密码，否则不需要输入密码。\n\n * https利于匿名访问，适合开源项目，方便被别人clone(但没有push权限)；\n\n * ssh不利于匿名访问，适合内部项目，只要配置了ssh公钥即可自由实现clone和push操作。',charsets:{cjk:!0},lastUpdated:"2023/03/10, 08:04:32",lastUpdatedTimestamp:1678406672e3},{title:"Maven下载安装与配置",frontmatter:{title:"Maven下载安装与配置",date:"2023-03-01T22:11:32.000Z",permalink:"/pages/020d30/"},regularPath:"/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/04.%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86&%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/01.Maven/01.Maven%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html",relativePath:"03.开发工具/04.项目管理&构建工具/01.Maven/01.Maven下载安装与配置.md",key:"v-030c0378",path:"/pages/020d30/",headers:[{level:2,title:"1. Maven下载",slug:"_1-maven下载",normalizedTitle:"1. maven下载",charIndex:19},{level:2,title:"2. Maven安装",slug:"_2-maven安装",normalizedTitle:"2. maven安装",charIndex:116},{level:2,title:"3. 配置环境变量",slug:"_3-配置环境变量",normalizedTitle:"3. 配置环境变量",charIndex:171},{level:3,title:"3.1 打开环境变量",slug:"_3-1-打开环境变量",normalizedTitle:"3.1 打开环境变量",charIndex:185},{level:3,title:"3.2 新建系统变量MAVEN_HOME",slug:"_3-2-新建系统变量maven-home",normalizedTitle:"3.2 新建系统变量maven_home",charIndex:240},{level:3,title:"3.3 配置系统变量Path",slug:"_3-3-配置系统变量path",normalizedTitle:"3.3 配置系统变量path",charIndex:323},{level:3,title:"3.4 检验环境变量是否配置成功",slug:"_3-4-检验环境变量是否配置成功",normalizedTitle:"3.4 检验环境变量是否配置成功",charIndex:476},{level:2,title:"4. 修改配置文件",slug:"_4-修改配置文件",normalizedTitle:"4. 修改配置文件",charIndex:556},{level:3,title:"4.1 配置本地仓库",slug:"_4-1-配置本地仓库",normalizedTitle:"4.1 配置本地仓库",charIndex:572},{level:3,title:"4.2 配置阿里云镜像",slug:"_4-2-配置阿里云镜像",normalizedTitle:"4.2 配置阿里云镜像",charIndex:748},{level:3,title:"4.3 配置JDK",slug:"_4-3-配置jdk",normalizedTitle:"4.3 配置jdk",charIndex:980},{level:2,title:"5. 集成到IDEA",slug:"_5-集成到idea",normalizedTitle:"5. 集成到idea",charIndex:1388},{level:3,title:"5.1 全局设置入口",slug:"_5-1-全局设置入口",normalizedTitle:"5.1 全局设置入口",charIndex:1403},{level:3,title:"5.2 配置本地安装的Maven",slug:"_5-2-配置本地安装的maven",normalizedTitle:"5.2 配置本地安装的maven",charIndex:1420}],headersStr:"1. Maven下载 2. Maven安装 3. 配置环境变量 3.1 打开环境变量 3.2 新建系统变量MAVEN_HOME 3.3 配置系统变量Path 3.4 检验环境变量是否配置成功 4. 修改配置文件 4.1 配置本地仓库 4.2 配置阿里云镜像 4.3 配置JDK 5. 集成到IDEA 5.1 全局设置入口 5.2 配置本地安装的Maven",content:'# Maven下载安装与配置\n\n\n# 1. Maven下载\n\n官网下载地址：Maven – Download Apache Maven\n\n\n\n点击"apache-maven-3.8.4-bin.zip"，即可进行下载。\n\n\n\n\n# 2. Maven安装\n\n将下载的压缩包解压至需要安装的目录，如E:\\Program Files。\n\n\n\n\n# 3. 配置环境变量\n\n\n# 3.1 打开环境变量\n\n右键此电脑->属性||打开设置->系统->关于，高级系统设置->环境变量\n\n\n\n\n# 3.2 新建系统变量MAVEN_HOME\n\n变量名为"MAVEN_HOME"，变量值为Maven的安装路径，可点击"浏览目录"选择Maven的安装目录。\n\n\n\n\n# 3.3 配置系统变量Path\n\n选中系统变量Path点击"编辑"，弹出的窗口点击"新建"，输入Maven安装目录下的bin目录的绝对路径（可点击"浏览"，选择Maven安装目录下的bin目录），也可输入相对路径%MAVEN_HOME%\\bin。\n\n配置好之后，弹出的窗口全部点击"确定"关闭即可。\n\n\n# 3.4 检验环境变量是否配置成功\n\nwindows+r输入cmd回车，打开命令提示符。\n\n\n\n执行mvn -v，可打印出已安装的maven版本号。\n\n\n\n\n# 4. 修改配置文件\n\n\n\n\n# 4.1 配置本地仓库\n\n在安装目录下新建"maven-repo"文件夹作为本地仓库。\n\n\n\n打开settings.xml，搜索""，在注释下方配置本地仓库的地址。\n\n<localRepository>E:\\Program Files\\apache-maven-3.8.4\\maven-repo</localRepository>\n\n\n1\n\n\n\n\n\n# 4.2 配置阿里云镜像\n\n搜索""，在结束标签上方加入如下镜像配置。\n\n<mirror>\n    <id>nexus-aliyun</id>\n    <mirrorOf>central</mirrorOf>\n    <name>Nexus aliyun</name>\n    <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n</mirror>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# 4.3 配置JDK\n\n<profile>\n    <id>jdk-1.8</id>\n    <activation>\n    \t<activeByDefault>true</activeByDefault>\n        \t<jdk>1.8</jdk>\n    </activation>\n    <properties>\n    \t<maven.compiler.source>1.8</maven.compiler.source>\n\t\t<maven.compiler.target>1.8</maven.compiler.target>\n\t\t<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\n    </properties>\n</profile>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n\n# 5. 集成到IDEA\n\n\n# 5.1 全局设置入口\n\n\n\n\n# 5.2 配置本地安装的Maven\n\n打开设置，选择Maven，修改以下三项配置。\n\n"Maven home path"选择Maven的安装目录；"User settings file"选择Maven安装目录conf文件夹下的"settings.xml"文件；"Local repository"选择安装目录下新建的"maven-repo"目录。\n\n设置完之后点击"Apply"“OK”，关闭窗口即可。\n\nIDEA自带的maven仓库在C:\\Users\\用户名.m2\\repository，可将此文件夹下的内容全部删除以节省C盘空间。\n\n',normalizedContent:'# maven下载安装与配置\n\n\n# 1. maven下载\n\n官网下载地址：maven – download apache maven\n\n\n\n点击"apache-maven-3.8.4-bin.zip"，即可进行下载。\n\n\n\n\n# 2. maven安装\n\n将下载的压缩包解压至需要安装的目录，如e:\\program files。\n\n\n\n\n# 3. 配置环境变量\n\n\n# 3.1 打开环境变量\n\n右键此电脑->属性||打开设置->系统->关于，高级系统设置->环境变量\n\n\n\n\n# 3.2 新建系统变量maven_home\n\n变量名为"maven_home"，变量值为maven的安装路径，可点击"浏览目录"选择maven的安装目录。\n\n\n\n\n# 3.3 配置系统变量path\n\n选中系统变量path点击"编辑"，弹出的窗口点击"新建"，输入maven安装目录下的bin目录的绝对路径（可点击"浏览"，选择maven安装目录下的bin目录），也可输入相对路径%maven_home%\\bin。\n\n配置好之后，弹出的窗口全部点击"确定"关闭即可。\n\n\n# 3.4 检验环境变量是否配置成功\n\nwindows+r输入cmd回车，打开命令提示符。\n\n\n\n执行mvn -v，可打印出已安装的maven版本号。\n\n\n\n\n# 4. 修改配置文件\n\n\n\n\n# 4.1 配置本地仓库\n\n在安装目录下新建"maven-repo"文件夹作为本地仓库。\n\n\n\n打开settings.xml，搜索""，在注释下方配置本地仓库的地址。\n\n<localrepository>e:\\program files\\apache-maven-3.8.4\\maven-repo</localrepository>\n\n\n1\n\n\n\n\n\n# 4.2 配置阿里云镜像\n\n搜索""，在结束标签上方加入如下镜像配置。\n\n<mirror>\n    <id>nexus-aliyun</id>\n    <mirrorof>central</mirrorof>\n    <name>nexus aliyun</name>\n    <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n</mirror>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# 4.3 配置jdk\n\n<profile>\n    <id>jdk-1.8</id>\n    <activation>\n    \t<activebydefault>true</activebydefault>\n        \t<jdk>1.8</jdk>\n    </activation>\n    <properties>\n    \t<maven.compiler.source>1.8</maven.compiler.source>\n\t\t<maven.compiler.target>1.8</maven.compiler.target>\n\t\t<maven.compiler.compilerversion>1.8</maven.compiler.compilerversion>\n    </properties>\n</profile>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n\n# 5. 集成到idea\n\n\n# 5.1 全局设置入口\n\n\n\n\n# 5.2 配置本地安装的maven\n\n打开设置，选择maven，修改以下三项配置。\n\n"maven home path"选择maven的安装目录；"user settings file"选择maven安装目录conf文件夹下的"settings.xml"文件；"local repository"选择安装目录下新建的"maven-repo"目录。\n\n设置完之后点击"apply"“ok”，关闭窗口即可。\n\nidea自带的maven仓库在c:\\users\\用户名.m2\\repository，可将此文件夹下的内容全部删除以节省c盘空间。\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/10, 08:04:32",lastUpdatedTimestamp:1678406672e3},{title:"反射&注解",frontmatter:{title:"反射&注解",date:"2023-02-25T21:36:07.000Z",permalink:"/pages/0705f0/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/01.Spring%E5%AE%B6%E6%97%8F/01.Spring/0.%E5%8F%8D%E5%B0%84&%E6%B3%A8%E8%A7%A3.html",relativePath:"04.后端应用框架/01.Spring家族/01.Spring/0.反射&注解.md",key:"v-08e3a87c",path:"/pages/0705f0/",headers:[{level:2,title:"1. 反射 ==reflect重点==",slug:"_1-反射-reflect重点",normalizedTitle:"1. 反射 ==reflect重点==",charIndex:12},{level:3,title:"1. 反射概述",slug:"_1-反射概述",normalizedTitle:"1. 反射概述",charIndex:36},{level:3,title:"2. 获取Class类对象的方式",slug:"_2-获取class类对象的方式",normalizedTitle:"2. 获取class类对象的方式",charIndex:86},{level:4,title:"1. 三种方式 ==3个阶段: 源码,Class,runtime阶段==",slug:"_1-三种方式-3个阶段-源码-class-runtime阶段",normalizedTitle:"1. 三种方式 ==3个阶段: 源码,class,runtime阶段==",charIndex:106},{level:4,title:"2. 结论",slug:"_2-结论",normalizedTitle:"2. 结论",charIndex:418},{level:3,title:"3.  Class对象",slug:"_3-class对象",normalizedTitle:"3.  class对象",charIndex:null},{level:4,title:"1. 获取功能",slug:"_1-获取功能",normalizedTitle:"1. 获取功能",charIndex:1142},{level:5,title:"1. 获取成员变量",slug:"_1-获取成员变量",normalizedTitle:"1. 获取成员变量",charIndex:1153},{level:5,title:"2. 获取构造方法",slug:"_2-获取构造方法",normalizedTitle:"2. 获取构造方法",charIndex:3351},{level:5,title:"3. 获取成员方法",slug:"_3-获取成员方法",normalizedTitle:"3. 获取成员方法",charIndex:4717},{level:5,title:"4. 获取类型",slug:"_4-获取类型",normalizedTitle:"4. 获取类型",charIndex:5049},{level:3,title:"4. 案例",slug:"_4-案例",normalizedTitle:"4. 案例",charIndex:6486},{level:4,title:"1. 代码 [配置文件形式]",slug:"_1-代码-配置文件形式",normalizedTitle:"1. 代码 [配置文件形式]",charIndex:6537},{level:2,title:"2. 注解 ==annotation==",slug:"_2-注解-annotation",normalizedTitle:"2. 注解 ==annotation==",charIndex:8110},{level:3,title:"1. 概述",slug:"_1-概述",normalizedTitle:"1. 概述",charIndex:8135},{level:3,title:"2. JDK中预定义的一些注解",slug:"_2-jdk中预定义的一些注解",normalizedTitle:"2. jdk中预定义的一些注解",charIndex:8503},{level:3,title:"3. 自定义注解",slug:"_3-自定义注解",normalizedTitle:"3. 自定义注解",charIndex:9178},{level:4,title:"1. 格式",slug:"_1-格式",normalizedTitle:"1. 格式",charIndex:9190},{level:4,title:"2. 本质",slug:"_2-本质",normalizedTitle:"2. 本质",charIndex:9254},{level:4,title:"3. 属性：==接口中的抽象方法==",slug:"_3-属性-接口中的抽象方法",normalizedTitle:"3. 属性：==接口中的抽象方法==",charIndex:9379},{level:5,title:"1. 案例一",slug:"_1-案例一",normalizedTitle:"1. 案例一",charIndex:9689},{level:5,title:"2. 案例一",slug:"_2-案例一",normalizedTitle:"2. 案例一",charIndex:10129},{level:4,title:"4.  元注解：==用于描述注解的注解==",slug:"_4-元注解-用于描述注解的注解",normalizedTitle:"4.  元注解：==用于描述注解的注解==",charIndex:null},{level:5,title:"1. @Target",slug:"_1-target",normalizedTitle:"1. @target",charIndex:10400},{level:5,title:"2. @Retention",slug:"_2-retention",normalizedTitle:"2. @retention",charIndex:10524},{level:3,title:"4. 在程序中是用(解析)注解",slug:"_4-在程序中是用-解析-注解",normalizedTitle:"4. 在程序中是用(解析)注解",charIndex:12333},{level:3,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:15940}],headersStr:"1. 反射 ==reflect重点== 1. 反射概述 2. 获取Class类对象的方式 1. 三种方式 ==3个阶段: 源码,Class,runtime阶段== 2. 结论 3.  Class对象 1. 获取功能 1. 获取成员变量 2. 获取构造方法 3. 获取成员方法 4. 获取类型 4. 案例 1. 代码 [配置文件形式] 2. 注解 ==annotation== 1. 概述 2. JDK中预定义的一些注解 3. 自定义注解 1. 格式 2. 本质 3. 属性：==接口中的抽象方法== 1. 案例一 2. 案例一 4.  元注解：==用于描述注解的注解== 1. @Target 2. @Retention 4. 在程序中是用(解析)注解 5. 案例",content:'# 反射&注解\n\n\n# 1. 反射 ==reflect重点==\n\n\n# 1. 反射概述\n\n * 框架的灵魂\n * 将类的各个组成部分封装为其他对象,这就是反射机制\n\n\n# 2. 获取Class类对象的方式\n\n# 1. 三种方式 ==3个阶段: 源码,Class,runtime阶段==\n\n 1. **Class.forName(“全限定类型”); ** [未加载进内存]\n    \n    将字节码文件加载进内存,返回Class对象\n    \n    * 应用: 多用于配置文件,将类名定义在配置文件中,读取文件,加载类\n\n 2. **类名.class ** [加载进内存]\n    \n    通过类名的属性class获取\n    \n    * 应用: 多用于参数的传递\n\n 3. 对象.getClass()\n    \n    getClass()方法在Object类中定义着\n    \n    * 对用于对象的获取字节码的方式\n\n# 2. 结论\n\n * 同一个字节码文件(*.class)在一次运行过程中,只会被加载一次,不论哪种方式加载进内存,都是同一个.\n\npublic static void main(String[] args) throws Exception {\n    // 1. Class.forName\n    Class<?> cls1 = Class.forName("com.chggx.domain.Person");\n    System.out.println(cls1);\n    // class com.chggx.domain.Person\n\n    // 2. 类名.class\n    Class<Person> cls2 = Person.class;\n    System.out.println(cls2);\n\n    // 3. 对象.getClass()\n    Person person = new Person();\n    Class<? extends Person> cls3 = person.getClass();\n    System.out.println(cls3);\n\n    // 4. 比较三个对象\n    // ==: 基本类型比较值,引用类型比较地址值\n    System.out.println(cls1 == cls2); // true\n    System.out.println(cls1 == cls3); // true\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3. Class对象\n\n# 1. 获取功能\n\n# 1. 获取成员变量\n\n 1. field:\n    * ① 设置值 set()\n    * ②获取值 get()\n 2. 忽略安全修饰符,暴力反射 ddd.setAccessible(true);\n\nField ddd = personClass.getDeclaredField("ddd");\n// get() [java.lang.IllegalAccessException]\n// 不为public修饰时,忽略访问权限修饰符的安全检查\n// 暴力反射\nddd.setAccessible(true);\nObject value1 = ddd.get(person);\nSystem.out.println(value1);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n修饰符和类型    方法                              描述\nField     getField(String name)           获取所有public修饰的成员变量\nField[]   getFields()                     获取指定名称的 public修饰的成员变量\nField     getDeclaredField(String name)   获取所有的成员变量，不考虑修饰符\nField[]   getDeclaredFields()             获取指定的成员变量，不考虑修饰符\n\n 3. 代码\n\npublic static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n\n    // 0. 获取Person的Class对象\n    Class<Person> personClass = Person.class;\n\n    /*\n    1. 获取成员变量们\n        * Field[] getFields() ：获取所有public修饰的成员变量\n        * Field getField(String name)   获取指定名称的 public修饰的成员变量\n        * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符\n        * Field getDeclaredField(String name)\n     */\n    // 1.1 Field[] getFields() ：获取所有public修饰的成员变量\n    Field[] fields = personClass.getFields();\n    Arrays.asList(fields).forEach(System.out::println);\n\n    System.out.println("----------");\n    // 1.2 Field getField(String name)   获取指定名称的 public修饰的成员变量\n    Field aaa = personClass.getField("aaa");\n    // 操作获取的成员变量 aaa\n    // get(): 获取\n    Person person = new Person();\n    Object value = aaa.get(person);\n    System.out.println(value);\n    // set(): 设置\n    aaa.set(person,"张三");\n    System.out.println(person);\n\n    System.out.println("=============");\n    // 1.3 Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符\n    Field[] declaredFields = personClass.getDeclaredFields();\n    Arrays.asList(declaredFields).forEach(System.out::println);\n    // 1.4 Field getDeclaredField(String name)\n    Field ddd = personClass.getDeclaredField("ddd");\n    // get() [java.lang.IllegalAccessException]\n    // 不为public修饰时,忽略访问权限修饰符的安全检查\n    // 暴力反射\n    ddd.setAccessible(true);\n    Object value1 = ddd.get(person);\n    System.out.println(value1);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# 2. 获取构造方法\n\n修饰符和类型           方法                                                   描述\nConstructor      getConstructor(Class... parameterTypes)              \nConstructor[]    getConstructors()                                    \nConstructor<T>   getDeclaredConstructor(Class<?>... parameterTypes)   \nConstructor[]    getDeclaredConstructors()                            \n\n 1. Constructor创建对象\n    \n    * T newInstance(Object... initargs)\n\n 2. 代码\n\npublic static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException {\n\n    // 0. 获取Person的Class对象\n    Class<Person> personClass = Person.class;\n\n    /*\n    2. 获取构造方法们\n            * Constructor<?>[] getConstructors()\n            * Constructor<T> getConstructor(Class<?>... parameterTypes)\n            * Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)\n            * Constructor<?>[] getDeclaredConstructors()\n     */\n   // 1. Constructor<T> getConstructor(Class<?>... parameterTypes)\n    Constructor<Person> constructor = personClass.getConstructor(String.class, int.class);\n    System.out.println(constructor);\n\n    // 创建对象 T  newInstance(Object... initargs)\n    Person person = constructor.newInstance("张三", 23);\n    System.out.println(person);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 3. 获取成员方法\n\n修饰符和类型     方法\nMethod     getDeclaredMethod(String name, Class... parameterTypes)\nMethod[]   getDeclaredMethods()\nMethod     getEnclosingMethod()\nMethod     getMethod(String name, Class... parameterTypes)\nMethod[]   getMethods()\n\n 1. 执行方法对象\n    * Object invoke(Object obj, Object... args)\n 2. 获取方法名---\n    * getName();\n\n# 4. 获取类型\n\n饰符和类型    方法\nString   getName()\n\npublic static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n\n    // 0. 获取Person的Class对象\n    Class<Person> personClass = Person.class;\n\n    /*\n    3. 获取成员方法们：\n        * Method[] getMethods()\n        * Method getMethod(String name, 类<?>... parameterTypes)\n        * Method[] getDeclaredMethods()\n        * Method getDeclaredMethod(String name, 类<?>... parameterTypes)\n     */\n    // 1.1\n    Method method = personClass.getMethod("eat");\n    Person person = new Person();\n    // 执行方法: Object    invoke(Object obj, Object... args)\n    method.invoke(person);\n\n    // 1.2\n    Method method2 = personClass.getMethod("eat", String.class);\n    // 执行方法: Object    invoke(Object obj, Object... args)\n    method2.invoke(person,"吃饭");\n\n    System.out.println("-----------------------------");\n\n    // 2.1\n    Method[] methods = personClass.getMethods();\n    // 所有的方法\n    Arrays.asList(methods).forEach(method1 -> {\n        System.out.println(method);\n        // 获取方法名 getName();\n        System.out.println(method.getName());\n    });\n    // 支持暴力反射\n\n    System.out.println("-----------------------------");\n\n    // 3 获取全限定类名 String getName()\n    String className = personClass.getName();\n    System.out.println(className);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4. 案例\n\n * 需求: 写一个""框架",可以帮我们创建任意类的对象,并执行其中的任意方法\n\n# 1. 代码 [配置文件形式]\n\n * Person\n\npublic class Person {\n\n    public void eat(){\n        System.out.println("eat...");\n    }\n\n    public void eat(String food){\n        System.out.println(food);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * Student\n\npublic class Student {\n\n    public void sleep(){\n        System.out.println("sleep...");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * pro.properties\n\n#className=com.chggx.domain.Person\n#methodName=eat\nclassName=com.chggx.domain.Student\nmethodName=sleep\n\n\n1\n2\n3\n4\n\n * ReflectTest\n\npublic class ReflectTest {\n\n    public static void main(String[] args) throws Exception {\n        // 可以创建任意对象,可以执行任意方法\n//        Person person = new Person();\n//        person.eat();\n\n        // 反射\n        // 1. 加载配置文件\n        // 1.1 创建Properties\n        Properties properties = new Properties();\n        // 1.2 加载配置文件,转换为一个集合\n        // 1.2.1 获取class目录下的配置文件\n        ClassLoader classLoader = ReflectTest.class.getClassLoader();\n        InputStream is = classLoader.getResourceAsStream("pro.properties");\n        // 1.3 加载\n        properties.load(is);\n\n        // 2. 获取配置文件中定义的数据\n        String className = properties.getProperty("className");\n        String methodName = properties.getProperty("methodName");\n\n        // 3. 加载该类进内存\n        Class<?> cls = Class.forName(className);\n\n        // 4. 创建对象\n        Object obj = cls.newInstance();\n\n        // 5. 获取方法对象\n        Method method = cls.getMethod(methodName);\n\n        // 6. 执行方法\n        method.invoke(obj);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 2. 注解 ==annotation==\n\n\n# 1. 概述\n\n* 概念: 说明程序的。给计算机看的\n* 注释: 用文字描述程序的。给程序员看的\n\n* 定义: 注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。\n* 概念描述：\n\t* JDK1.5之后的新特性\n\t* 说明程序的\n\t* 使用注解：@注解名称\n* 作用分类：\n\t①编写文档: 通过代码里标识的注解生成文档【生成文档doc文档】\n\t②代码分析: 通过代码里标识的注解对代码进行分析【使用反射】\n\t③编译检查: 通过代码里标识的注解让编译器能够实现基本的编译检查【Override】\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2. JDK中预定义的一些注解\n\n@Override: 检测被该注解标注的方法是否是继承自父类(接口)的\n@Deprecated: 该注解标注的内容，表示已过时\n@SuppressWarnings: 压制警告\n\t* 一般传递参数all  @SuppressWarnings("all")\n\n\n1\n2\n3\n4\n\n * 代码\n\n@SuppressWarnings("all")\npublic class AnnotationDemo01 {\n\n    @Override\n    public String toString() {\n        return super.toString();\n    }\n\n    /**\n     * @Deprecated: 标注已过时\n     */\n    @Deprecated\n    public void show1(){\n        // 有缺陷\n    }\n\n    /**\n     * 压制警告 "all"\n     */\n    @SuppressWarnings("all")\n    public void show2(){\n        // 取代show1()\n    }\n\n    public void demo(){\n        //\n        show1();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 3. 自定义注解\n\n# 1. 格式\n\n// 元注解\npublic @interface 注解名称{\n    属性列表;\n}\n\n\n1\n2\n3\n4\n\n\n# 2. 本质\n\n本质：注解本质上就是一个接口，该接口默认继承Annotation接口\npublic interface MyAnnotation extends java.lang.annotation.Annotation {}\n\n\n1\n2\n\n\n# 3. 属性：==接口中的抽象方法==\n\n要求:\n1. 属性的返回值类型有下列取值\n   \t * 基本数据类型\n     * String\n     * 枚举\n     * 注解\n     * 以上类型的数组\n\n 2. 定义了属性，在使用时需要给属性赋值\n    1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。\n    2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。\n    3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 1. 案例一\n\n * 代码\n\npublic @interface MyAnnotation {\n\n    // 基本类型\n    int anno1();\n\n    // String类型\n    String anno2();\n\n    // 枚举\n    Person per();\n\n    // 注解\n    MyAnnotation2 annotation();\n    \n    // 数组\n    String[] str();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 赋值\n\n @MyAnnotation(anno1 = 1, anno2 = "2", per = Person.P1, annotation = @MyAnnotation2,str = {"aaa","bbb"})\npublic void show2() {\n    // 取代show1()\n}\n\n\n1\n2\n3\n4\n\n\n# 2. 案例一\n\npublic @interface MyAnnotation3 {\n\n   // 基本类型 \n   int value();\n\n    // String类型 默认default数据\n    String anno2() default "2";\n\n    // 枚举\n    Person per();\n\n    // 注解\n    MyAnnotation2 annotation();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 4. 元注解：==用于描述注解的注解==\n\n1. @Target: 描述注解能够作用的位置\n    * ElementType取值：\n        * TYPE: 可以作用于类上\n        * METHOD: 可以作用于方法上\n        * FIELD: 可以作用于成员变量上\n2. @Retention：描述注解被保留的阶段\n    * RetentionPolicy取值:\n        * SOURCE: 源码\n        * CLASS: class\n        * RUNTIME: 运行时\n    * @Retention(RetentionPolicy.RUNTIME): 当前被描述的注解，会保留到class字节码文件中，并被JVM读取到\n3. @Documented: 描述注解是否被抽取到api文档中\n4. @Inherited: 描述注解是否被子类继承\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 1. @Target\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/28 18:06\n * @Description: <h1> 元注解: 用于描述注解的注解 </h1>\n * 1. @Target：描述注解能够作用的位置\n *     * ElementType取值：\n *         * TYPE：可以作用于类上\n *         * METHOD：可以作用于方法上\n *         * FIELD：可以作用于成员变量上\n * 2. @Retention：描述注解被保留的阶段\n *     * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到\n * 3. @Documented：描述注解是否被抽取到api文档中\n * 4. @Inherited：描述注解是否被子类继承\n */\n@Target(value = {ElementType.TYPE,ElementType.METHOD,ElementType.FIELD})\npublic @interface MyAnnotation4 {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n@MyAnnotation4\npublic class Worker {\n\n    @MyAnnotation4\n    private String name;\n\n    @MyAnnotation4\n    public void eat(){\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 类,属性,方法都可使用\n\n# 2. @Retention\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/28 18:06\n * @Description: <h1> 元注解: 用于描述注解的注解 </h1>\n * 1. @Target：描述注解能够作用的位置\n *     * ElementType取值：\n *         * TYPE：可以作用于类上\n *         * METHOD：可以作用于方法上\n *         * FIELD：可以作用于成员变量上\n * 2. @Retention：描述注解被保留的阶段\n *     * RetentionPolicy取值:\n *         * SOURCE: 源码\n *         * CLASS: class\n *         * RUNTIME: 运行时\n *     * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到\n * 3. @Documented：描述注解是否被抽取到api文档中\n * 4. @Inherited：描述注解是否被子类继承\n */\n@Target(value = {ElementType.TYPE,ElementType.METHOD,ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\npublic @interface MyAnnotation4 {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 4. 在程序中是用(解析)注解\n\n 1. 获取注解中定义的属性值\n\n\t1. 获取注解定义的位置的对象  （Class，Method,Field）\n\t2. 获取指定的注解\n\t\t* getAnnotation(Class)\n\t\t//其实就是在内存中生成了一个该注解接口的子类实现对象\n\n\t            public class ProImpl implements Pro{\n\t                public String className(){\n\t                    return "cn.itcast.annotation.Demo1";\n\t                }\n\t                public String methodName(){\n\t                    return "show";\n\t                }\n\t            }\n\t3. 调用注解中的抽象方法获取配置的属性值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n 2. 代码\n    \n    * 注解类: 取代之前配置的pro.properties配置文件\n    \n    /**\n     * @Author: CHGGX\n     * @Date: 2020/04/28 21:11\n     * @Description: <h1> 描述需要执行的类名,和方法名 </h1>\n     * 作用于类(TYPE),在运行期执行\n     */\n    @Target(value = ElementType.TYPE)\n    @Retention(RetentionPolicy.RUNTIME)\n    public @interface Pro {\n    \n        /**\n         * 类名\n         */\n        String className();\n    \n        /**\n         * 方法名\n         */\n        String methodName();\n    \n        /*\n          public class ProImpl implements Pro{\n                public String className(){\n                    return "com.chggx.annotation.Pr1";\n                };\n                public String methodName(){\n                    return "show";\n                 };\n              }\n         */\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n    * 应用方法的类\n    \n    public class Pr1 {\n    \n        public void show1(){\n            System.out.println("Pr1...show1....");\n        }\n    \n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n    \n    public class Pr2 {\n    \n        public void show2(){\n            System.out.println("Pr2...show2....");\n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    * 反射测试类 注解实现\n    \n    @Pro(className = "com.chggx.annotation.Pr1", methodName = "show1")\n    public class ReflectTest {\n    \n        public static void main(String[] args) throws Exception {\n    \n            // 1. 解析注解\n            // 1.1 获取该类的字节码文件对象\n            Class<ReflectTest> rtc = ReflectTest.class;\n            // 2 获取上边注解对象\n            // 就是在内存中去生成了一个该注解接口的子类实现对象\n            Pro annotation = rtc.getAnnotation(Pro.class);\n            /*\n              public class ProImpl implements Pro{\n                    public String className(){\n                        return "com.chggx.annotation.Pr1";\n                    };\n                    public String methodName(){\n                        return "show";\n                     };\n                  }\n             */\n            // 3.调用注解对象中定义的抽象方法,获取返回值\n            // 类名\n            String className = annotation.className();\n            // 方法名\n            String methodName = annotation.methodName();\n    \n            System.out.println(className);\n            System.out.println(methodName);\n    \n            // 4. 加载该类进内存\n            Class<?> cls = Class.forName(className);\n    \n            // 5. 创建对象\n            Object obj = cls.newInstance();\n    \n            // 6. 获取方法对象\n            Method method = cls.getMethod(methodName);\n    \n            // 7. 执行方法\n            method.invoke(obj);\n    \n    \n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    \n\n\n# 5. 案例',normalizedContent:'# 反射&注解\n\n\n# 1. 反射 ==reflect重点==\n\n\n# 1. 反射概述\n\n * 框架的灵魂\n * 将类的各个组成部分封装为其他对象,这就是反射机制\n\n\n# 2. 获取class类对象的方式\n\n# 1. 三种方式 ==3个阶段: 源码,class,runtime阶段==\n\n 1. **class.forname(“全限定类型”); ** [未加载进内存]\n    \n    将字节码文件加载进内存,返回class对象\n    \n    * 应用: 多用于配置文件,将类名定义在配置文件中,读取文件,加载类\n\n 2. **类名.class ** [加载进内存]\n    \n    通过类名的属性class获取\n    \n    * 应用: 多用于参数的传递\n\n 3. 对象.getclass()\n    \n    getclass()方法在object类中定义着\n    \n    * 对用于对象的获取字节码的方式\n\n# 2. 结论\n\n * 同一个字节码文件(*.class)在一次运行过程中,只会被加载一次,不论哪种方式加载进内存,都是同一个.\n\npublic static void main(string[] args) throws exception {\n    // 1. class.forname\n    class<?> cls1 = class.forname("com.chggx.domain.person");\n    system.out.println(cls1);\n    // class com.chggx.domain.person\n\n    // 2. 类名.class\n    class<person> cls2 = person.class;\n    system.out.println(cls2);\n\n    // 3. 对象.getclass()\n    person person = new person();\n    class<? extends person> cls3 = person.getclass();\n    system.out.println(cls3);\n\n    // 4. 比较三个对象\n    // ==: 基本类型比较值,引用类型比较地址值\n    system.out.println(cls1 == cls2); // true\n    system.out.println(cls1 == cls3); // true\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3. class对象\n\n# 1. 获取功能\n\n# 1. 获取成员变量\n\n 1. field:\n    * ① 设置值 set()\n    * ②获取值 get()\n 2. 忽略安全修饰符,暴力反射 ddd.setaccessible(true);\n\nfield ddd = personclass.getdeclaredfield("ddd");\n// get() [java.lang.illegalaccessexception]\n// 不为public修饰时,忽略访问权限修饰符的安全检查\n// 暴力反射\nddd.setaccessible(true);\nobject value1 = ddd.get(person);\nsystem.out.println(value1);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n修饰符和类型    方法                              描述\nfield     getfield(string name)           获取所有public修饰的成员变量\nfield[]   getfields()                     获取指定名称的 public修饰的成员变量\nfield     getdeclaredfield(string name)   获取所有的成员变量，不考虑修饰符\nfield[]   getdeclaredfields()             获取指定的成员变量，不考虑修饰符\n\n 3. 代码\n\npublic static void main(string[] args) throws nosuchfieldexception, illegalaccessexception {\n\n    // 0. 获取person的class对象\n    class<person> personclass = person.class;\n\n    /*\n    1. 获取成员变量们\n        * field[] getfields() ：获取所有public修饰的成员变量\n        * field getfield(string name)   获取指定名称的 public修饰的成员变量\n        * field[] getdeclaredfields()  获取所有的成员变量，不考虑修饰符\n        * field getdeclaredfield(string name)\n     */\n    // 1.1 field[] getfields() ：获取所有public修饰的成员变量\n    field[] fields = personclass.getfields();\n    arrays.aslist(fields).foreach(system.out::println);\n\n    system.out.println("----------");\n    // 1.2 field getfield(string name)   获取指定名称的 public修饰的成员变量\n    field aaa = personclass.getfield("aaa");\n    // 操作获取的成员变量 aaa\n    // get(): 获取\n    person person = new person();\n    object value = aaa.get(person);\n    system.out.println(value);\n    // set(): 设置\n    aaa.set(person,"张三");\n    system.out.println(person);\n\n    system.out.println("=============");\n    // 1.3 field[] getdeclaredfields()  获取所有的成员变量，不考虑修饰符\n    field[] declaredfields = personclass.getdeclaredfields();\n    arrays.aslist(declaredfields).foreach(system.out::println);\n    // 1.4 field getdeclaredfield(string name)\n    field ddd = personclass.getdeclaredfield("ddd");\n    // get() [java.lang.illegalaccessexception]\n    // 不为public修饰时,忽略访问权限修饰符的安全检查\n    // 暴力反射\n    ddd.setaccessible(true);\n    object value1 = ddd.get(person);\n    system.out.println(value1);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# 2. 获取构造方法\n\n修饰符和类型           方法                                                   描述\nconstructor      getconstructor(class... parametertypes)              \nconstructor[]    getconstructors()                                    \nconstructor<t>   getdeclaredconstructor(class<?>... parametertypes)   \nconstructor[]    getdeclaredconstructors()                            \n\n 1. constructor创建对象\n    \n    * t newinstance(object... initargs)\n\n 2. 代码\n\npublic static void main(string[] args) throws nosuchfieldexception, illegalaccessexception, nosuchmethodexception, invocationtargetexception, instantiationexception {\n\n    // 0. 获取person的class对象\n    class<person> personclass = person.class;\n\n    /*\n    2. 获取构造方法们\n            * constructor<?>[] getconstructors()\n            * constructor<t> getconstructor(class<?>... parametertypes)\n            * constructor<t> getdeclaredconstructor(class<?>... parametertypes)\n            * constructor<?>[] getdeclaredconstructors()\n     */\n   // 1. constructor<t> getconstructor(class<?>... parametertypes)\n    constructor<person> constructor = personclass.getconstructor(string.class, int.class);\n    system.out.println(constructor);\n\n    // 创建对象 t  newinstance(object... initargs)\n    person person = constructor.newinstance("张三", 23);\n    system.out.println(person);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 3. 获取成员方法\n\n修饰符和类型     方法\nmethod     getdeclaredmethod(string name, class... parametertypes)\nmethod[]   getdeclaredmethods()\nmethod     getenclosingmethod()\nmethod     getmethod(string name, class... parametertypes)\nmethod[]   getmethods()\n\n 1. 执行方法对象\n    * object invoke(object obj, object... args)\n 2. 获取方法名---\n    * getname();\n\n# 4. 获取类型\n\n饰符和类型    方法\nstring   getname()\n\npublic static void main(string[] args) throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n\n    // 0. 获取person的class对象\n    class<person> personclass = person.class;\n\n    /*\n    3. 获取成员方法们：\n        * method[] getmethods()\n        * method getmethod(string name, 类<?>... parametertypes)\n        * method[] getdeclaredmethods()\n        * method getdeclaredmethod(string name, 类<?>... parametertypes)\n     */\n    // 1.1\n    method method = personclass.getmethod("eat");\n    person person = new person();\n    // 执行方法: object    invoke(object obj, object... args)\n    method.invoke(person);\n\n    // 1.2\n    method method2 = personclass.getmethod("eat", string.class);\n    // 执行方法: object    invoke(object obj, object... args)\n    method2.invoke(person,"吃饭");\n\n    system.out.println("-----------------------------");\n\n    // 2.1\n    method[] methods = personclass.getmethods();\n    // 所有的方法\n    arrays.aslist(methods).foreach(method1 -> {\n        system.out.println(method);\n        // 获取方法名 getname();\n        system.out.println(method.getname());\n    });\n    // 支持暴力反射\n\n    system.out.println("-----------------------------");\n\n    // 3 获取全限定类名 string getname()\n    string classname = personclass.getname();\n    system.out.println(classname);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4. 案例\n\n * 需求: 写一个""框架",可以帮我们创建任意类的对象,并执行其中的任意方法\n\n# 1. 代码 [配置文件形式]\n\n * person\n\npublic class person {\n\n    public void eat(){\n        system.out.println("eat...");\n    }\n\n    public void eat(string food){\n        system.out.println(food);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * student\n\npublic class student {\n\n    public void sleep(){\n        system.out.println("sleep...");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * pro.properties\n\n#classname=com.chggx.domain.person\n#methodname=eat\nclassname=com.chggx.domain.student\nmethodname=sleep\n\n\n1\n2\n3\n4\n\n * reflecttest\n\npublic class reflecttest {\n\n    public static void main(string[] args) throws exception {\n        // 可以创建任意对象,可以执行任意方法\n//        person person = new person();\n//        person.eat();\n\n        // 反射\n        // 1. 加载配置文件\n        // 1.1 创建properties\n        properties properties = new properties();\n        // 1.2 加载配置文件,转换为一个集合\n        // 1.2.1 获取class目录下的配置文件\n        classloader classloader = reflecttest.class.getclassloader();\n        inputstream is = classloader.getresourceasstream("pro.properties");\n        // 1.3 加载\n        properties.load(is);\n\n        // 2. 获取配置文件中定义的数据\n        string classname = properties.getproperty("classname");\n        string methodname = properties.getproperty("methodname");\n\n        // 3. 加载该类进内存\n        class<?> cls = class.forname(classname);\n\n        // 4. 创建对象\n        object obj = cls.newinstance();\n\n        // 5. 获取方法对象\n        method method = cls.getmethod(methodname);\n\n        // 6. 执行方法\n        method.invoke(obj);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 2. 注解 ==annotation==\n\n\n# 1. 概述\n\n* 概念: 说明程序的。给计算机看的\n* 注释: 用文字描述程序的。给程序员看的\n\n* 定义: 注解（annotation），也叫元数据。一种代码级别的说明。它是jdk1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。\n* 概念描述：\n\t* jdk1.5之后的新特性\n\t* 说明程序的\n\t* 使用注解：@注解名称\n* 作用分类：\n\t①编写文档: 通过代码里标识的注解生成文档【生成文档doc文档】\n\t②代码分析: 通过代码里标识的注解对代码进行分析【使用反射】\n\t③编译检查: 通过代码里标识的注解让编译器能够实现基本的编译检查【override】\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2. jdk中预定义的一些注解\n\n@override: 检测被该注解标注的方法是否是继承自父类(接口)的\n@deprecated: 该注解标注的内容，表示已过时\n@suppresswarnings: 压制警告\n\t* 一般传递参数all  @suppresswarnings("all")\n\n\n1\n2\n3\n4\n\n * 代码\n\n@suppresswarnings("all")\npublic class annotationdemo01 {\n\n    @override\n    public string tostring() {\n        return super.tostring();\n    }\n\n    /**\n     * @deprecated: 标注已过时\n     */\n    @deprecated\n    public void show1(){\n        // 有缺陷\n    }\n\n    /**\n     * 压制警告 "all"\n     */\n    @suppresswarnings("all")\n    public void show2(){\n        // 取代show1()\n    }\n\n    public void demo(){\n        //\n        show1();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 3. 自定义注解\n\n# 1. 格式\n\n// 元注解\npublic @interface 注解名称{\n    属性列表;\n}\n\n\n1\n2\n3\n4\n\n\n# 2. 本质\n\n本质：注解本质上就是一个接口，该接口默认继承annotation接口\npublic interface myannotation extends java.lang.annotation.annotation {}\n\n\n1\n2\n\n\n# 3. 属性：==接口中的抽象方法==\n\n要求:\n1. 属性的返回值类型有下列取值\n   \t * 基本数据类型\n     * string\n     * 枚举\n     * 注解\n     * 以上类型的数组\n\n 2. 定义了属性，在使用时需要给属性赋值\n    1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。\n    2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。\n    3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 1. 案例一\n\n * 代码\n\npublic @interface myannotation {\n\n    // 基本类型\n    int anno1();\n\n    // string类型\n    string anno2();\n\n    // 枚举\n    person per();\n\n    // 注解\n    myannotation2 annotation();\n    \n    // 数组\n    string[] str();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 赋值\n\n @myannotation(anno1 = 1, anno2 = "2", per = person.p1, annotation = @myannotation2,str = {"aaa","bbb"})\npublic void show2() {\n    // 取代show1()\n}\n\n\n1\n2\n3\n4\n\n\n# 2. 案例一\n\npublic @interface myannotation3 {\n\n   // 基本类型 \n   int value();\n\n    // string类型 默认default数据\n    string anno2() default "2";\n\n    // 枚举\n    person per();\n\n    // 注解\n    myannotation2 annotation();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 4. 元注解：==用于描述注解的注解==\n\n1. @target: 描述注解能够作用的位置\n    * elementtype取值：\n        * type: 可以作用于类上\n        * method: 可以作用于方法上\n        * field: 可以作用于成员变量上\n2. @retention：描述注解被保留的阶段\n    * retentionpolicy取值:\n        * source: 源码\n        * class: class\n        * runtime: 运行时\n    * @retention(retentionpolicy.runtime): 当前被描述的注解，会保留到class字节码文件中，并被jvm读取到\n3. @documented: 描述注解是否被抽取到api文档中\n4. @inherited: 描述注解是否被子类继承\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 1. @target\n\n/**\n * @author: chggx\n * @date: 2020/04/28 18:06\n * @description: <h1> 元注解: 用于描述注解的注解 </h1>\n * 1. @target：描述注解能够作用的位置\n *     * elementtype取值：\n *         * type：可以作用于类上\n *         * method：可以作用于方法上\n *         * field：可以作用于成员变量上\n * 2. @retention：描述注解被保留的阶段\n *     * @retention(retentionpolicy.runtime)：当前被描述的注解，会保留到class字节码文件中，并被jvm读取到\n * 3. @documented：描述注解是否被抽取到api文档中\n * 4. @inherited：描述注解是否被子类继承\n */\n@target(value = {elementtype.type,elementtype.method,elementtype.field})\npublic @interface myannotation4 {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n@myannotation4\npublic class worker {\n\n    @myannotation4\n    private string name;\n\n    @myannotation4\n    public void eat(){\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 类,属性,方法都可使用\n\n# 2. @retention\n\n/**\n * @author: chggx\n * @date: 2020/04/28 18:06\n * @description: <h1> 元注解: 用于描述注解的注解 </h1>\n * 1. @target：描述注解能够作用的位置\n *     * elementtype取值：\n *         * type：可以作用于类上\n *         * method：可以作用于方法上\n *         * field：可以作用于成员变量上\n * 2. @retention：描述注解被保留的阶段\n *     * retentionpolicy取值:\n *         * source: 源码\n *         * class: class\n *         * runtime: 运行时\n *     * @retention(retentionpolicy.runtime)：当前被描述的注解，会保留到class字节码文件中，并被jvm读取到\n * 3. @documented：描述注解是否被抽取到api文档中\n * 4. @inherited：描述注解是否被子类继承\n */\n@target(value = {elementtype.type,elementtype.method,elementtype.field})\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\npublic @interface myannotation4 {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 4. 在程序中是用(解析)注解\n\n 1. 获取注解中定义的属性值\n\n\t1. 获取注解定义的位置的对象  （class，method,field）\n\t2. 获取指定的注解\n\t\t* getannotation(class)\n\t\t//其实就是在内存中生成了一个该注解接口的子类实现对象\n\n\t            public class proimpl implements pro{\n\t                public string classname(){\n\t                    return "cn.itcast.annotation.demo1";\n\t                }\n\t                public string methodname(){\n\t                    return "show";\n\t                }\n\t            }\n\t3. 调用注解中的抽象方法获取配置的属性值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n 2. 代码\n    \n    * 注解类: 取代之前配置的pro.properties配置文件\n    \n    /**\n     * @author: chggx\n     * @date: 2020/04/28 21:11\n     * @description: <h1> 描述需要执行的类名,和方法名 </h1>\n     * 作用于类(type),在运行期执行\n     */\n    @target(value = elementtype.type)\n    @retention(retentionpolicy.runtime)\n    public @interface pro {\n    \n        /**\n         * 类名\n         */\n        string classname();\n    \n        /**\n         * 方法名\n         */\n        string methodname();\n    \n        /*\n          public class proimpl implements pro{\n                public string classname(){\n                    return "com.chggx.annotation.pr1";\n                };\n                public string methodname(){\n                    return "show";\n                 };\n              }\n         */\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n    * 应用方法的类\n    \n    public class pr1 {\n    \n        public void show1(){\n            system.out.println("pr1...show1....");\n        }\n    \n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n    \n    public class pr2 {\n    \n        public void show2(){\n            system.out.println("pr2...show2....");\n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    * 反射测试类 注解实现\n    \n    @pro(classname = "com.chggx.annotation.pr1", methodname = "show1")\n    public class reflecttest {\n    \n        public static void main(string[] args) throws exception {\n    \n            // 1. 解析注解\n            // 1.1 获取该类的字节码文件对象\n            class<reflecttest> rtc = reflecttest.class;\n            // 2 获取上边注解对象\n            // 就是在内存中去生成了一个该注解接口的子类实现对象\n            pro annotation = rtc.getannotation(pro.class);\n            /*\n              public class proimpl implements pro{\n                    public string classname(){\n                        return "com.chggx.annotation.pr1";\n                    };\n                    public string methodname(){\n                        return "show";\n                     };\n                  }\n             */\n            // 3.调用注解对象中定义的抽象方法,获取返回值\n            // 类名\n            string classname = annotation.classname();\n            // 方法名\n            string methodname = annotation.methodname();\n    \n            system.out.println(classname);\n            system.out.println(methodname);\n    \n            // 4. 加载该类进内存\n            class<?> cls = class.forname(classname);\n    \n            // 5. 创建对象\n            object obj = cls.newinstance();\n    \n            // 6. 获取方法对象\n            method method = cls.getmethod(methodname);\n    \n            // 7. 执行方法\n            method.invoke(obj);\n    \n    \n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    \n\n\n# 5. 案例',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"SpringBoot基础",frontmatter:{title:"SpringBoot基础",date:"2023-02-25T21:36:59.000Z",permalink:"/pages/c71dea/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/01.Spring%E5%AE%B6%E6%97%8F/03.SpringBoot/1.SpringBoot%E5%9F%BA%E7%A1%80.html",relativePath:"04.后端应用框架/01.Spring家族/03.SpringBoot/1.SpringBoot基础.md",key:"v-d6d27a90",path:"/pages/c71dea/",headers:[{level:2,title:"1. SpringBoot简介",slug:"_1-springboot简介",normalizedTitle:"1. springboot简介",charIndex:19},{level:3,title:"1.1 Features",slug:"_1-1-features",normalizedTitle:"1.1 features",charIndex:39},{level:3,title:"1.2 Reactive",slug:"_1-2-reactive",normalizedTitle:"1.2 reactive",charIndex:655},{level:2,title:"2. SpringBoot快速入门",slug:"_2-springboot快速入门",normalizedTitle:"2. springboot快速入门",charIndex:983},{level:3,title:"2.1 创建项目",slug:"_2-1-创建项目",normalizedTitle:"2.1 创建项目",charIndex:1031},{level:3,title:"2.2 项目结构",slug:"_2-2-项目结构",normalizedTitle:"2.2 项目结构",charIndex:1086},{level:3,title:"2.3 响应数据",slug:"_2-3-响应数据",normalizedTitle:"2.3 响应数据",charIndex:6356},{level:3,title:"2.4 编写服务",slug:"_2-4-编写服务",normalizedTitle:"2.4 编写服务",charIndex:7477},{level:3,title:"2.5 启动应用",slug:"_2-5-启动应用",normalizedTitle:"2.5 启动应用",charIndex:7840},{level:2,title:"3. 日志配置",slug:"_3-日志配置",normalizedTitle:"3. 日志配置",charIndex:10287},{level:3,title:"3.1 引入依赖",slug:"_3-1-引入依赖",normalizedTitle:"3.1 引入依赖",charIndex:10354},{level:3,title:"3.2 配置文件",slug:"_3-2-配置文件",normalizedTitle:"3.2 配置文件",charIndex:10577},{level:3,title:"3.3 解决依赖冲突",slug:"_3-3-解决依赖冲突",normalizedTitle:"3.3 解决依赖冲突",charIndex:12174},{level:3,title:"3.4 测试效果",slug:"_3-4-测试效果",normalizedTitle:"3.4 测试效果",charIndex:13543},{level:2,title:"4. WEB应用开发",slug:"_4-web应用开发",normalizedTitle:"4. web应用开发",charIndex:14548},{level:3,title:"4.1 访问静态资源",slug:"_4-1-访问静态资源",normalizedTitle:"4.1 访问静态资源",charIndex:14563},{level:3,title:"4.2 模板引擎",slug:"_4-2-模板引擎",normalizedTitle:"4.2 模板引擎",charIndex:14855},{level:3,title:"4.3 Thymeleaf",slug:"_4-3-thymeleaf",normalizedTitle:"4.3 thymeleaf",charIndex:15274},{level:4,title:"4.3.1 添加依赖",slug:"_4-3-1-添加依赖",normalizedTitle:"4.3.1 添加依赖",charIndex:15418},{level:4,title:"4.3.2 编写模板文件",slug:"_4-3-2-编写模板文件",normalizedTitle:"4.3.2 编写模板文件",charIndex:15614},{level:4,title:"4.3.3 生成模板数据",slug:"_4-3-3-生成模板数据",normalizedTitle:"4.3.3 生成模板数据",charIndex:15986},{level:4,title:"4.3.4 Thymeleaf默认配置",slug:"_4-3-4-thymeleaf默认配置",normalizedTitle:"4.3.4 thymeleaf默认配置",charIndex:16248},{level:3,title:"4.4 项目热加载(页面)",slug:"_4-4-项目热加载-页面",normalizedTitle:"4.4 项目热加载(页面)",charIndex:17430},{level:2,title:"5. 数据访问",slug:"_5-数据访问",normalizedTitle:"5. 数据访问",charIndex:18043},{level:3,title:"5.1 数据源配置",slug:"_5-1-数据源配置",normalizedTitle:"5.1 数据源配置",charIndex:18055},{level:3,title:"5.2 事务配置",slug:"_5-2-事务配置",normalizedTitle:"5.2 事务配置",charIndex:18712},{level:3,title:"5.3 SpringBoot整合Mybatis",slug:"_5-3-springboot整合mybatis",normalizedTitle:"5.3 springboot整合mybatis",charIndex:18998},{level:4,title:"5.3.1 依赖",slug:"_5-3-1-依赖",normalizedTitle:"5.3.1 依赖",charIndex:19047},{level:4,title:"5.3.2 Mapper 接口扫描配置",slug:"_5-3-2-mapper-接口扫描配置",normalizedTitle:"5.3.2 mapper 接口扫描配置",charIndex:19325},{level:4,title:"5.3.3 Mapper 映射文件配置",slug:"_5-3-3-mapper-映射文件配置",normalizedTitle:"5.3.3 mapper 映射文件配置",charIndex:19668},{level:4,title:"5.3.4 分页插件",slug:"_5-3-4-分页插件",normalizedTitle:"5.3.4 分页插件",charIndex:19753},{level:4,title:"5.3.5 代码生成器",slug:"_5-3-5-代码生成器",normalizedTitle:"5.3.5 代码生成器",charIndex:20544},{level:4,title:"5.3.6 MybatisPlus配置文件",slug:"_5-3-6-mybatisplus配置文件",normalizedTitle:"5.3.6 mybatisplus配置文件",charIndex:24872},{level:3,title:"5.4 SpringBoot整合Redis",slug:"_5-4-springboot整合redis",normalizedTitle:"5.4 springboot整合redis",charIndex:25488},{level:4,title:"5.4.1 添加依赖",slug:"_5-4-1-添加依赖",normalizedTitle:"5.4.1 添加依赖",charIndex:25513},{level:4,title:"5.4.2 数据源配置",slug:"_5-4-2-数据源配置",normalizedTitle:"5.4.2 数据源配置",charIndex:26166},{level:4,title:"5.4.3 配置类",slug:"_5-4-3-配置类",normalizedTitle:"5.4.3 配置类",charIndex:26707},{level:4,title:"5.4.4 测试",slug:"_5-4-4-测试",normalizedTitle:"5.4.4 测试",charIndex:28956}],headersStr:"1. SpringBoot简介 1.1 Features 1.2 Reactive 2. SpringBoot快速入门 2.1 创建项目 2.2 项目结构 2.3 响应数据 2.4 编写服务 2.5 启动应用 3. 日志配置 3.1 引入依赖 3.2 配置文件 3.3 解决依赖冲突 3.4 测试效果 4. WEB应用开发 4.1 访问静态资源 4.2 模板引擎 4.3 Thymeleaf 4.3.1 添加依赖 4.3.2 编写模板文件 4.3.3 生成模板数据 4.3.4 Thymeleaf默认配置 4.4 项目热加载(页面) 5. 数据访问 5.1 数据源配置 5.2 事务配置 5.3 SpringBoot整合Mybatis 5.3.1 依赖 5.3.2 Mapper 接口扫描配置 5.3.3 Mapper 映射文件配置 5.3.4 分页插件 5.3.5 代码生成器 5.3.6 MybatisPlus配置文件 5.4 SpringBoot整合Redis 5.4.1 添加依赖 5.4.2 数据源配置 5.4.3 配置类 5.4.4 测试",content:'# SpringBoot基础\n\n\n# 1. SpringBoot简介\n\n\n# 1.1 Features\n\n * Create stand-alone Spring applications 创建独立的Spring应用程序\n * Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 直接嵌入Tomcat、Jetty或Undertow(不需要部署WAR文件)\n * Provide opinionated \'starter\' dependencies to simplify your build configuration 提供自以为是的“启动器”依赖关系来简化构建配置\n * Automatically configure Spring and 3rd party libraries whenever possible 在可能的情况下自动配置Spring和第三方库\n * Provide production-ready features such as metrics, health checks, and externalized configuration 提供可用于生产的特性，如度量、运行状况检查和外部化配置\n * Absolutely no code generation and no requirement for XML configuration 绝对不需要代码生成，也不需要XML配置\n\n\n# 1.2 Reactive\n\n\n\n> ①. Reactive系统具有某些特性，使其非常适合低延迟、高吞吐量的工作负载。Project Reactor和Spring组合一起工作，使开发人员能够构建响应性、弹性、弹性和消息驱动的企业级反应性系统。\n> \n> ②. Spring投资组合提供了两个并行的堆栈。一种是基于带有Spring MVC和Spring数据结构的Servlet API。另一个是完全被动的堆栈，它利用了Spring WebFlux和Spring Data的被动存储库。在这两种情况下，Spring Security都为您提供了对这两个栈的本机支持。\n> \n> ③. reactor 核反应堆, 让基于 Spring 的项目发生核聚变。\n\n\n# 2. SpringBoot快速入门\n\n * 使用 IntelliJ IDEA 创建项目\n\n\n# 2.1 创建项目\n\n * 同官网.使用使用IntelliJ IDEA快速构建springboot项目\n\n\n# 2.2 项目结构\n\n\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.1.RELEASE</version>\n        <relativePath/> \x3c!-- lookup parent from repository --\x3e\n    </parent>\n    <groupId>com.chggx.springboot</groupId>\n    <artifactId>i-boot</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>i-boot</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n           \x3c!-- <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>--\x3e\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n> 本次使用springboot版本2.3.1,对应spring版本5.2.7\n\n * 非web环境启动器,启动项目\n\n\x3c!--非web环境启动器--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.3.1.RELEASE)\n\n2020-06-25 08:01:21.213  INFO 8440 --- [           main] com.chggx.springboot.IBootApplication    : Starting IBootApplication on HP-EliteBook-745-G5 with PID 8440 (D:\\java-code\\kuangjia\\springboot\\i-boot\\target\\classes started by HP in D:\\java-code\\kuangjia\\springboot)\n2020-06-25 08:01:21.217  INFO 8440 --- [           main] com.chggx.springboot.IBootApplication    : No active profile set, falling back to default profiles: default\n2020-06-25 08:01:21.928  INFO 8440 --- [           main] com.chggx.springboot.IBootApplication    : Started IBootApplication in 1.26 seconds (JVM running for 3.006)\n\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * web环境启动器,启动项目\n\n\x3c!--web环境启动器--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\nBoot 内嵌了 Tomcat ，启动应该的时候已经启动了 Tomcat并且将我们的应用部署到了 Tomcat容\n\n器。\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.3.1.RELEASE)\n\n2020-06-25 08:06:25.689  INFO 16224 --- [           main] com.chggx.springboot.IBootApplication    : Starting IBootApplication on HP-EliteBook-745-G5 with PID 16224 (D:\\java-code\\kuangjia\\springboot\\i-boot\\target\\classes started by HP in D:\\java-code\\kuangjia\\springboot)\n2020-06-25 08:06:25.695  INFO 16224 --- [           main] com.chggx.springboot.IBootApplication    : No active profile set, falling back to default profiles: default\n2020-06-25 08:06:26.912  INFO 16224 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\n2020-06-25 08:06:26.926  INFO 16224 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2020-06-25 08:06:26.926  INFO 16224 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.36]\n2020-06-25 08:06:27.049  INFO 16224 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2020-06-25 08:06:27.050  INFO 16224 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1257 ms\n2020-06-25 08:06:27.294  INFO 16224 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService \'applicationTaskExecutor\'\n2020-06-25 08:06:27.520  INFO 16224 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path \'\'\n2020-06-25 08:06:27.533  INFO 16224 --- [           main] com.chggx.springboot.IBootApplication    : Started IBootApplication in 2.365 seconds (JVM running for 3.607)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n浏览器预览\n\n\n\n\n# 2.3 响应数据\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 业务响应对象 </h1>\n */\npublic class R extends ConcurrentHashMap<String, Object> {\n\n    public R() {\n        this.put("code", HttpStatus.OK.value());\n        this.put("msg", "success !!!");\n    }\n\n    public static R ok() {\n        return new R();\n    }\n\n    public static R ok(String msg) {\n        return R.ok().put("msg", msg);\n    }\n\n    public static R ok(Object data) {\n        return R.ok().put("data", data);\n    }\n\n    public static R ok(String msg, Object data) {\n        return R.ok(msg).put("data", data);\n    }\n\n    public static R error(HttpStatus status, String error) {\n        return R.ok().put("code", status).put("error", error).put("msg", "");\n    }\n\n    public static R error(HttpStatus status, String error, String msg) {\n        return R.ok().put("code", status).put("error", error).put("msg", msg);\n    }\n\n    @Override\n    public R put(String key, Object value) {\n        super.put(key, value);\n        return this;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 2.4 编写服务\n\n/**\n * @Author: CHGGX\n * @Date: 2020/06/25 8:25\n * @Description: <h1> </h1>\n */\n@Controller\npublic class HelloBootController {\n\n    @GetMapping("/hello")\n    @ResponseBody\n    public R hello() {\n        return R.ok("hello SpringBoot !");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> @RestController相当于: @Controller和@ResponseBody不返回页面.返回相应数据结果\n\n\n# 2.5 启动应用\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.3.1.RELEASE)\n\n2020-06-25 08:29:13.612  INFO 5040 --- [           main] com.chggx.springboot.IBootApplication    : Starting IBootApplication on HP-EliteBook-745-G5 with PID 5040 (D:\\java-code\\kuangjia\\springboot\\i-boot\\target\\classes started by HP in D:\\java-code\\kuangjia\\springboot)\n2020-06-25 08:29:13.618  INFO 5040 --- [           main] com.chggx.springboot.IBootApplication    : No active profile set, falling back to default profiles: default\n2020-06-25 08:29:14.697  INFO 5040 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\n2020-06-25 08:29:14.710  INFO 5040 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2020-06-25 08:29:14.710  INFO 5040 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.36]\n2020-06-25 08:29:14.824  INFO 5040 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2020-06-25 08:29:14.825  INFO 5040 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1140 ms\n2020-06-25 08:29:15.009  INFO 5040 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService \'applicationTaskExecutor\'\n2020-06-25 08:29:15.233  INFO 5040 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path \'\'\n2020-06-25 08:29:15.249  INFO 5040 --- [           main] com.chggx.springboot.IBootApplication    : Started IBootApplication in 2.13 seconds (JVM running for 3.573)\n2020-06-25 08:29:21.549  INFO 5040 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet \'dispatcherServlet\'\n2020-06-25 08:29:21.550  INFO 5040 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet \'dispatcherServlet\'\n2020-06-25 08:29:21.558  INFO 5040 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 8 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n\n# 3. 日志配置\n\n * 此处使用log4j2: log4j-api + log4j-core\n * 还可以使用logback\n\n\n# 3.1 引入依赖\n\nspringboot中默认的日志依赖\n\n\n\n需要在项目中引入 log4j2 的启动器\n\n\x3c!-- log4j2 日志 --\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-log4j2</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 3.2 配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<configuration> \x3c!--先定义所有的appender--\x3e\n    <appenders> \x3c!--输出控制台的配置--\x3e\n        <console name="Console" target="SYSTEM_OUT"> \x3c!--输出日志的格式--\x3e\n            \x3c!--<patternlayout pattern="%d{yyyy-MM-dd HH:mm:ss} [%p] %c %m %n"/>--\x3e\n            <patternlayout pattern="[%p] %m %n"/>\n        </console>\n    </appenders>\n    <loggers>\n        <root level="DEBUG"> \x3c!--输出到控制台--\x3e\n            <appender-ref ref="Console"/>\n        </root>\n        <logger name="org.springframework" level="ERROR"/>\n        <logger name="com.baomidou" level="ERROR"/>\n        <logger name="org.hibernate" level="ERROR"/>\n        <logger name="com.alibaba.druid" level="ERROR"/>\n        <logger name="org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration" level="warn"/>\n        <logger name="org.springframework.boot.actuate.endpoint.jmx" level="warn"/>\n    </loggers>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n启动服务.报错\n\nSLF4J: Class path contains multiple SLF4J bindings.\nSLF4J: Found binding in [jar:file:/E:/develop/webapp/maven/maven_repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]\nSLF4J: Found binding in [jar:file:/E:/develop/webapp/maven/maven_repository/org/apache/logging/log4j/log4j-slf4j-impl/2.13.3/log4j-slf4j-impl-2.13.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]\nSLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.\nSLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.3 解决依赖冲突\n\nspring-boot-starter-web 和 spring-boot-starter-test 两个启动器依赖了 spring-boot- starter 启动器\n\n> spring-boot-starter 是 Spring boot 非 WEB 环境的启动器。\n> \n> spring-boot-starter 启动器依赖了 spring-boot-starter-logging 启动器\n\n\n\n> 1.spring-boot-starter-logging 启动器为 Spring boot 项目提供日志支持\n> \n> 默认集成了如下日志类库：\n> \n> ① slf4j 日志门面系统\n> \n> ② logback Spring boot 默认使用的日志框架\n> \n> ③ log4j2\n> \n> ④ .....\n> \n> 2.logback 和 log4j2 两个日志类库同时存在会导致 log4j2 不起作用，需要排除logback 的依赖。\n> \n> 因为已经引入了 spring-boot-starter-log4j2 ，所以将 Spring 默认的日志启动器的依赖排除\n> \n> 就可以了。\n\n排除的依赖\n\n\x3c!--web环境启动器--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    \x3c!--排除web启动器的logging依赖--\x3e\n    <exclusions>\n        <exclusion>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-logging</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\x3c!--测试启动器--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n    \x3c!--排除test启动器的logging依赖--\x3e\n    <exclusions>\n        <exclusion>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-logging</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 3.4 测试效果\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.3.1.RELEASE)\n\n[INFO] Starting IBootApplication on HP-EliteBook-745-G5 with PID 20204 (D:\\java-code\\kuangjia\\springboot\\i-boot\\target\\classes started by HP in D:\\java-code\\kuangjia\\springboot) \n[DEBUG] Running with Spring Boot v2.3.1.RELEASE, Spring v5.2.7.RELEASE \n[INFO] No active profile set, falling back to default profiles: default \n[INFO] Initializing ProtocolHandler ["http-nio-8080"] \n[INFO] Starting service [Tomcat] \n[INFO] Starting Servlet engine: [Apache Tomcat/9.0.36] \n[INFO] Initializing Spring embedded WebApplicationContext \n[INFO] Starting ProtocolHandler ["http-nio-8080"] \n[INFO] Started IBootApplication in 2.927 seconds (JVM running for 4.391) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4. WEB应用开发\n\n\n# 4.1 访问静态资源\n\nSpring Boot 默认提供静态资源目录位置需置于 classpath下，目录名需符合如下规则：\n\n * /static\n\n * /public\n\n * /resources\n\n * /META-INF/resources\n\n此处以/static为例;\n\n\n\n访问路径\n\n * http://localhost:8080/image/01.jpg\n * http://localhost:8080/image/02.jpg\n\n> 注意: 此处访问路径不包含/static,/public,resources,/META-INF/resources\n\n\n# 4.2 模板引擎\n\n模板的诞生是为了将显示与数据分离，其本质是将模板文件和数据通过模板引擎生成最终的视图代码。\n\n以 HTML 为例\n\n * 不使用模板\n   \n   后端语言 将数据渲染到HTML标签里， 输出 HTML 文档给客户端，比如 JSP 技术。\n\n * 使用模板\n   \n   后端语言 将数据交给模板引擎，模板引擎将模板文件和数据进行渲染，输出 HTML 文档给客户\n\n端。\n\n浏览完最后将 HTML 文档的内容渲染成可视化的网页。\n\nSpring Boot 建议使用模板引擎处理动态网页，不建议使用 JSP 。\n\nSpring Boot 提供了默认配置的模板引擎主要有以下几种：\n\n * Thymeleaf [推荐]\n\n * FreeMarker\n\n * Velocity\n\n * Groovy\n\n * Mustache\n\n> 模板文件的默认路径为： src/main/resources/templates。\n\n\n# 4.3 Thymeleaf\n\nThymeleaf 是一个服务器端的 Java 模板引擎，可用于 Web 与非 Web 环境中的应用开发。\n\nThymeleaf 的主要目标是提供一种可被浏览器正确显示、格式良好的模板创建方式。\n\nThymeleaf 是现代 WEB 程序的理想选择。\n\n# 4.3.1 添加依赖\n\n\x3c!-- Thymeleaf: 服务器端的Java模板引擎 --\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 4.3.2 编写模板文件\n\n在 templates 中编写模板文件\n\n\n\n * index.html\n\n<!DOCTYPE html>\n<html xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Hello Thymeleaf</title></head>\n<body><h1 th:text="${hello}">Hello Thymeleaf</h1></body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> xmlns:th="http://www.thymeleaf.org": HTML中引入\n> \n> th:text: thymeleaf文本标签\n> \n> ${}: 后台取值 #{}: 国际化\n\n# 4.3.3 生成模板数据\n\n@Controller\npublic class HelloBootController {\n\n    @GetMapping("/thymeleaf")\n    public String thymeleaf(Model model){\n        model.addAttribute("hello","hello Thymeleaf !");\n        return "index";\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 浏览器访问\n\n\n\n# 4.3.4 Thymeleaf默认配置\n\nSpring Boot 为 Thymeleaf模板引擎提供了如下默认配置，要修改默认配置可以在 Spring Boot配置文件\n\napplication.properties 中覆盖对应配置。\n\n# Thymeleaf默认配置\n# Enable template caching. 是否缓存(默认缓存true)\nspring.thymeleaf.cache=true\n# 是否检查模板位置\nspring.thymeleaf.check-template=true\n# 检查模板位置是否存在\nspring.thymeleaf.check-template-location = true\n# 设置请求类型 (Content-Type值) spring.thymeleaf.content-type = text/html\nspring.thymeleaf.servlet.content-type=text/html\n# 是否启用thymeleaf模板引擎(默认true)\nspring.thymeleaf.enabled=true\n# 模板编码 Template encoding.\nspring.thymeleaf.encoding=UTF-8\n# 应该从解决方案中排除的视图名称的逗号分隔列表。\nspring.thymeleaf.excluded-view-names =\n# 应用于模板的模板模式。另请参见StandardTemplateModeHandlers。 Template mode to be applied to templates. See also StandardTemplateModeHandlers.\nspring.thymeleaf.mode=HTML5\n# 构建URL时预先查看名称的前缀 Prefix that gets prepended to view names when building a URL.\nspring.thymeleaf.prefix=classpath:/templates/\n# 构建URL时附加到查看名称的后缀 Suffix that gets appended to view names when building a URL.\nspring.thymeleaf.suffix=.html\n# 链中模板解析器的顺序。\nspring.thymeleaf.template-resolver-order =\n# 可以解析的视图名称的逗号分隔列表\nspring.thymeleaf.view-names = \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 4.4 项目热加载(页面)\n\n\n\n\x3c!--devtools热加载--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * 问题\n   \n   \n\n * 解决\n   \n   pom 文件中添加\n\n<plugins>\n    \x3c!--springboot编译运行打包部署.构建插件--\x3e\n    <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n        \x3c!--解决引入热部署依赖后,出现"x"的问题--\x3e\n        <configuration>\n            <fork>true</fork>\n        </configuration>\n    </plugin>\n</plugins>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5. 数据访问\n\n\n# 5.1 数据源配置\n\n添加依赖\n\n引入 MySQL JDBC 驱动和 Druid 数据库连接池依赖。\n\n\x3c!--JDBC驱动--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n\n\x3c!-- mysql驱动 --\x3e\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.47</version>\n    <scope>runtime</scope>\n</dependency>\n\n\x3c!-- Druid数据库连接池 --\x3e\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n    <version>1.1.20</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在src/main/resources/application.properties 中配置数据源信息。\n\n\n# 5.2 事务配置\n\n在应用程序入口类添加 @EnableTransactionManagement 启用事务管理支持。\n\n@SpringBootApplication\n@EnableTransactionManagement\npublic class IBootApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(IBootApplication.class, args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5.3 SpringBoot整合Mybatis\n\n * 此处使用 Mybatis-Plus\n\n# 5.3.1 依赖\n\n\x3c!--mybatis 和 mybatis-plus驱动--\x3e\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.2.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 引入上面依赖不需要: spring-boot-starter-jdbc和mybatis-spring-boot-starter两个驱动\n\n# 5.3.2 Mapper 接口扫描配置\n\n * 启动类上添加@MapperScan注解\n\n@SpringBootApplication\n@EnableTransactionManagement\n@MapperScan("com.chggx.springboot.*.mapper")\npublic class IBootApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(IBootApplication.class, args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> @MapperScan: Mybatis注解\n\n# 5.3.3 Mapper 映射文件配置\n\n在 src/main/resources/application.properties 中配置Mapper映射文件位置。\n\n# 5.3.4 分页插件\n\n/**\n * @Author: CHGGX\n * @Description: <h1> MybatisPlus配置类 </h1>\n */\n@Configuration\n@EnableTransactionManagement\n@MapperScan("com.chggx.springboot.*.mapper")\npublic class MyBatisConfig {\n\n    /*** MyBatis-puls 分页插件配置 * @return */\n    @Bean\n    public PaginationInterceptor paginationInterceptor() {\n        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();\n        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false\n        paginationInterceptor.setOverflow(false);\n        // 设置最大单页限制数量，默认 500 条，-1 不受限制\n        paginationInterceptor.setLimit(-1);\n        return paginationInterceptor;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n> @EnableTransactionManagement,@MapperScan("com.chggx.springboot.*.mapper"): 可以配置在MybatisPlus配置类中.\n\n# 5.3.5 代码生成器\n\n * 方案一\n\n/**\n * @Author: CHGGX\n * @Description: <h1> MybatisPlus代码生成 </h1>\n */\npublic class MyBatisGenerator {\n\n    /**\n     * 读取控制台内容\n     */\n    public static String scanner(String tip) {\n        Scanner scanner = new Scanner(System.in);\n        StringBuilder help = new StringBuilder();\n        help.append("请输入" + tip + "：");\n        System.out.println(help.toString());\n        if (scanner.hasNext()) {\n            String ipt = scanner.next();\n            if (StringUtils.isNotEmpty(ipt)) {\n                return ipt;\n            }\n        }\n        throw new MybatisPlusException("请输入正确的" + tip + "！");\n    }\n\n    public static void main(String[] args) {\n        // 代码生成器\n        AutoGenerator mpg = new AutoGenerator();\n        // 全局配置\n        GlobalConfig gc = new GlobalConfig();\n        String projectPath = System.getProperty("user.dir");\n//        gc.setOutputDir(projectPath + "/src/main/java");\n        gc.setOutputDir("C:\\\\Users\\\\HP\\\\Desktop\\\\新建文件夹\\\\i-boot" + "/src/main/java");\n        gc.setAuthor("CHGGX");\n        gc.setOpen(false);\n        // gc.setSwagger2(true); // 实体属性Swagger2注解\n        gc.setBaseResultMap(true);\n        gc.setBaseColumnList(true);\n        mpg.setGlobalConfig(gc);\n\n        // 数据源配置\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl("jdbc:mysql://localhost:3306/i-auth?useSSL=false");\n        dsc.setDriverName("com.mysql.jdbc.Driver");\n        dsc.setUsername("root");\n        dsc.setPassword("123456");\n        mpg.setDataSource(dsc);\n\n        // 包配置\n        PackageConfig pc = new PackageConfig();\n        pc.setModuleName(scanner("模块名"));\n        pc.setParent("com.chggx.springboot");\n        mpg.setPackageInfo(pc);\n\n        // 自定义配置\n        InjectionConfig cfg = new InjectionConfig() {\n            @Override\n            public void initMap() {\n                // to do nothing\n            }\n        };\n\n        List<FileOutConfig> focList = new ArrayList<>();\n        focList.add(new FileOutConfig("/templates/mapper.xml.ftl") {\n            @Override\n            public String outputFile(TableInfo tableInfo) {\n                // 自定义输入文件名称\n               /* return projectPath + "/src/main/resources/mapper/" + pc.getModuleName()\n                        + "/" + tableInfo.getEntityName() + "Mapper" + StringPool.DOT_XML;*/\n                return "C:\\\\Users\\\\HP\\\\Desktop\\\\新建文件夹\\\\i-boot" + "/src/main/resources/mapper/" + pc.getModuleName()\n                        + "/" + tableInfo.getEntityName() + "Mapper" + StringPool.DOT_XML;\n            }\n        });\n        cfg.setFileOutConfigList(focList);\n        mpg.setCfg(cfg);\n        mpg.setTemplate(new TemplateConfig().setXml(null));\n\n        // 策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        strategy.setNaming(NamingStrategy.underline_to_camel);\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);\n        // 使用Lombok插件\n        strategy.setEntityLombokModel(true);\n        strategy.setInclude(scanner("表名"));\n\n        strategy.setSuperServiceClass("com.chggx.springboot.common.service.IService");\n        strategy.setSuperServiceImplClass("com.chggx.springboot.common.service.impl.ServiceImpl");\n\n        // Controller配置\n        strategy.setSkipView(false);\n        strategy.setControllerMappingHyphenStyle(true);\n        // @Controller @RestController\n        strategy.setRestControllerStyle(false);\n\n        strategy.setTablePrefix(pc.getModuleName() + "_");\n        mpg.setStrategy(strategy);\n        // 选择 freemarker 引擎需要指定如下加，注意 pom 依赖必须有！\n        mpg.setTemplateEngine(new FreemarkerTemplateEngine());\n        mpg.execute();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n测试生成\n\n\n\n> 测出使用lombok,添加下面依赖\n\n\x3c!--Lombok--\x3e\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.12</version>\n    <scope>provided</scope>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 方案二\n\n参考我的博客\n\n\x3c!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --\x3e\n<dependency>\n    <groupId>org.apache.velocity</groupId>\n    <artifactId>velocity-engine-core</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 5.3.6 MybatisPlus配置文件\n\n# Mybatis Plus 配置\nmybatis-plus:\n  # mybatis plus日志 使用logback\n  #  configuration:\n  #    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n  # 实体扫描\n  typeAliasesPackage: com.chggx.blog.sys.entity\n  # Mybatis-plus xml路径配置\n  mapper-locations: classpath:/mapper/*Mapper.xml\n  configuration:\n    cache‐enabled: false\n    map‐underscore‐to‐camel‐case: true\n  global-config:\n    db-config:\n      # 逻辑删除\n      logic-delete-value: 1\n      logic-not-delete-value: 0\n    # 刷新mapper, 调试神器\n    refresh: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 此处是yml格式配置\n\n> MybatisPlus的测试此处省略...\n\n\n# 5.4 SpringBoot整合Redis\n\n# 5.4.1 添加依赖\n\nJedis 在实现上是直接连接 Redis 服务器，在多个线程间共享一个 Jedis 实例时是线程不\n安全的，如果想要在多线程场景下使用 Jedis ，需要使用连接池，每个线程都使用自己的\nJedis 实例，当连接数量增多时，会消耗较多的物理资源。\n与 Jedis 相比， Lettuce 则完全克服了其线程不安全的缺点： Lettuce 是一个可伸缩的线\n程安全的 Redis 客户端，支持同步、异步和响应式模式。多个线程可以共享一个连接实例，而\n不必担心多线程并发问题。它基于优秀 Netty NIO 框架构建，支持 Redis 的更多高级功能。\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 综上使用Lettuce客户端\n\n\x3c!--redis 访问启动器 --\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\x3c!--redis客户端Lettuce 数据库连接池依赖 --\x3e\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 5.4.2 数据源配置\n\n# Redis配置\n# Redis数据库索引（默认为0）\nspring.redis.database=0\n# Redis服务器地址 （默认localhost）\nspring.redis.host=localhost\n# Redis服务器连接端口 （默认6379）\nspring.redis.port=6379\n# Redis服务器连接密码（默认为空）\nspring.redis.password=\n# 连接超时时间\nspring.redis.timeout=10000ms\n# 最大连接数（使用负值表示没有限制） 默认 8\nspring.redis.lettuce.pool.max-active=8\n# 最小空闲连接 默认 0\nspring.redis.lettuce.pool.min-idle=0\n# 最大空闲连接 默认 8\nspring.redis.lettuce.pool.max-idle=8\n# 最大阻塞等待时间（使用负值表示没有限制） 默认 -1ms\nspring.redis.lettuce.pool.max-wait=-1ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 5.4.3 配置类\n\n/**\n * @Author: CHGGX\n * @Description: <h1> redis配置类 </h1>\n */\n@Configuration\npublic class RedisConfig {\n\n    /**\n     * 连接工厂\n     */\n    @Autowired\n    private RedisConnectionFactory redisConnectionFactory;\n\n    @Bean\n    public StringRedisSerializer stringRedisSerializer() {\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n        return stringRedisSerializer;\n    }\n\n    @Bean\n    public Jackson2JsonRedisSerializer jackson2JsonRedisSerializer() {\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n        return jackson2JsonRedisSerializer;\n    }\n\n    /**\n     * StringRedisTemplate\n     * @return StringRedisTemplate\n     */\n    @Bean\n    public StringRedisTemplate stringRedisTemplate() {\n        StringRedisTemplate stringRedisTemplate = new StringRedisTemplate();\n        // 注入数据库连接工厂\n        stringRedisTemplate.setConnectionFactory(redisConnectionFactory);\n        // 开启事务支持\n        stringRedisTemplate.setEnableTransactionSupport(true);\n        return stringRedisTemplate;\n    }\n\n    /**\n     * RedisTemplate\n     * @return RedisTemplate\n     */\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate() {\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        redisTemplate.setKeySerializer(stringRedisSerializer());\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer());\n        redisTemplate.setHashKeySerializer(stringRedisSerializer());\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer());\n        // 开启事务支持\n        redisTemplate.setEnableTransactionSupport(true);\n        return redisTemplate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n# 5.4.4 测试\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class RedisTest {\n\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n\n    @Test\n    public void test(){\n        redisTemplate.opsForValue().set("kq","Hello Redis !");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# springboot基础\n\n\n# 1. springboot简介\n\n\n# 1.1 features\n\n * create stand-alone spring applications 创建独立的spring应用程序\n * embed tomcat, jetty or undertow directly (no need to deploy war files) 直接嵌入tomcat、jetty或undertow(不需要部署war文件)\n * provide opinionated \'starter\' dependencies to simplify your build configuration 提供自以为是的“启动器”依赖关系来简化构建配置\n * automatically configure spring and 3rd party libraries whenever possible 在可能的情况下自动配置spring和第三方库\n * provide production-ready features such as metrics, health checks, and externalized configuration 提供可用于生产的特性，如度量、运行状况检查和外部化配置\n * absolutely no code generation and no requirement for xml configuration 绝对不需要代码生成，也不需要xml配置\n\n\n# 1.2 reactive\n\n\n\n> ①. reactive系统具有某些特性，使其非常适合低延迟、高吞吐量的工作负载。project reactor和spring组合一起工作，使开发人员能够构建响应性、弹性、弹性和消息驱动的企业级反应性系统。\n> \n> ②. spring投资组合提供了两个并行的堆栈。一种是基于带有spring mvc和spring数据结构的servlet api。另一个是完全被动的堆栈，它利用了spring webflux和spring data的被动存储库。在这两种情况下，spring security都为您提供了对这两个栈的本机支持。\n> \n> ③. reactor 核反应堆, 让基于 spring 的项目发生核聚变。\n\n\n# 2. springboot快速入门\n\n * 使用 intellij idea 创建项目\n\n\n# 2.1 创建项目\n\n * 同官网.使用使用intellij idea快速构建springboot项目\n\n\n# 2.2 项目结构\n\n\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelversion>4.0.0</modelversion>\n    <parent>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-parent</artifactid>\n        <version>2.3.1.release</version>\n        <relativepath/> \x3c!-- lookup parent from repository --\x3e\n    </parent>\n    <groupid>com.chggx.springboot</groupid>\n    <artifactid>i-boot</artifactid>\n    <version>0.0.1-snapshot</version>\n    <name>i-boot</name>\n    <description>demo project for spring boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-test</artifactid>\n            <scope>test</scope>\n           \x3c!-- <exclusions>\n                <exclusion>\n                    <groupid>org.junit.vintage</groupid>\n                    <artifactid>junit-vintage-engine</artifactid>\n                </exclusion>\n            </exclusions>--\x3e\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-maven-plugin</artifactid>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n> 本次使用springboot版本2.3.1,对应spring版本5.2.7\n\n * 非web环境启动器,启动项目\n\n\x3c!--非web环境启动器--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::        (v2.3.1.release)\n\n2020-06-25 08:01:21.213  info 8440 --- [           main] com.chggx.springboot.ibootapplication    : starting ibootapplication on hp-elitebook-745-g5 with pid 8440 (d:\\java-code\\kuangjia\\springboot\\i-boot\\target\\classes started by hp in d:\\java-code\\kuangjia\\springboot)\n2020-06-25 08:01:21.217  info 8440 --- [           main] com.chggx.springboot.ibootapplication    : no active profile set, falling back to default profiles: default\n2020-06-25 08:01:21.928  info 8440 --- [           main] com.chggx.springboot.ibootapplication    : started ibootapplication in 1.26 seconds (jvm running for 3.006)\n\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * web环境启动器,启动项目\n\n\x3c!--web环境启动器--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\nboot 内嵌了 tomcat ，启动应该的时候已经启动了 tomcat并且将我们的应用部署到了 tomcat容\n\n器。\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::        (v2.3.1.release)\n\n2020-06-25 08:06:25.689  info 16224 --- [           main] com.chggx.springboot.ibootapplication    : starting ibootapplication on hp-elitebook-745-g5 with pid 16224 (d:\\java-code\\kuangjia\\springboot\\i-boot\\target\\classes started by hp in d:\\java-code\\kuangjia\\springboot)\n2020-06-25 08:06:25.695  info 16224 --- [           main] com.chggx.springboot.ibootapplication    : no active profile set, falling back to default profiles: default\n2020-06-25 08:06:26.912  info 16224 --- [           main] o.s.b.w.embedded.tomcat.tomcatwebserver  : tomcat initialized with port(s): 8080 (http)\n2020-06-25 08:06:26.926  info 16224 --- [           main] o.apache.catalina.core.standardservice   : starting service [tomcat]\n2020-06-25 08:06:26.926  info 16224 --- [           main] org.apache.catalina.core.standardengine  : starting servlet engine: [apache tomcat/9.0.36]\n2020-06-25 08:06:27.049  info 16224 --- [           main] o.a.c.c.c.[tomcat].[localhost].[/]       : initializing spring embedded webapplicationcontext\n2020-06-25 08:06:27.050  info 16224 --- [           main] w.s.c.servletwebserverapplicationcontext : root webapplicationcontext: initialization completed in 1257 ms\n2020-06-25 08:06:27.294  info 16224 --- [           main] o.s.s.concurrent.threadpooltaskexecutor  : initializing executorservice \'applicationtaskexecutor\'\n2020-06-25 08:06:27.520  info 16224 --- [           main] o.s.b.w.embedded.tomcat.tomcatwebserver  : tomcat started on port(s): 8080 (http) with context path \'\'\n2020-06-25 08:06:27.533  info 16224 --- [           main] com.chggx.springboot.ibootapplication    : started ibootapplication in 2.365 seconds (jvm running for 3.607)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n浏览器预览\n\n\n\n\n# 2.3 响应数据\n\n/**\n * @author: chggx\n * @description: <h1> 业务响应对象 </h1>\n */\npublic class r extends concurrenthashmap<string, object> {\n\n    public r() {\n        this.put("code", httpstatus.ok.value());\n        this.put("msg", "success !!!");\n    }\n\n    public static r ok() {\n        return new r();\n    }\n\n    public static r ok(string msg) {\n        return r.ok().put("msg", msg);\n    }\n\n    public static r ok(object data) {\n        return r.ok().put("data", data);\n    }\n\n    public static r ok(string msg, object data) {\n        return r.ok(msg).put("data", data);\n    }\n\n    public static r error(httpstatus status, string error) {\n        return r.ok().put("code", status).put("error", error).put("msg", "");\n    }\n\n    public static r error(httpstatus status, string error, string msg) {\n        return r.ok().put("code", status).put("error", error).put("msg", msg);\n    }\n\n    @override\n    public r put(string key, object value) {\n        super.put(key, value);\n        return this;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 2.4 编写服务\n\n/**\n * @author: chggx\n * @date: 2020/06/25 8:25\n * @description: <h1> </h1>\n */\n@controller\npublic class hellobootcontroller {\n\n    @getmapping("/hello")\n    @responsebody\n    public r hello() {\n        return r.ok("hello springboot !");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> @restcontroller相当于: @controller和@responsebody不返回页面.返回相应数据结果\n\n\n# 2.5 启动应用\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::        (v2.3.1.release)\n\n2020-06-25 08:29:13.612  info 5040 --- [           main] com.chggx.springboot.ibootapplication    : starting ibootapplication on hp-elitebook-745-g5 with pid 5040 (d:\\java-code\\kuangjia\\springboot\\i-boot\\target\\classes started by hp in d:\\java-code\\kuangjia\\springboot)\n2020-06-25 08:29:13.618  info 5040 --- [           main] com.chggx.springboot.ibootapplication    : no active profile set, falling back to default profiles: default\n2020-06-25 08:29:14.697  info 5040 --- [           main] o.s.b.w.embedded.tomcat.tomcatwebserver  : tomcat initialized with port(s): 8080 (http)\n2020-06-25 08:29:14.710  info 5040 --- [           main] o.apache.catalina.core.standardservice   : starting service [tomcat]\n2020-06-25 08:29:14.710  info 5040 --- [           main] org.apache.catalina.core.standardengine  : starting servlet engine: [apache tomcat/9.0.36]\n2020-06-25 08:29:14.824  info 5040 --- [           main] o.a.c.c.c.[tomcat].[localhost].[/]       : initializing spring embedded webapplicationcontext\n2020-06-25 08:29:14.825  info 5040 --- [           main] w.s.c.servletwebserverapplicationcontext : root webapplicationcontext: initialization completed in 1140 ms\n2020-06-25 08:29:15.009  info 5040 --- [           main] o.s.s.concurrent.threadpooltaskexecutor  : initializing executorservice \'applicationtaskexecutor\'\n2020-06-25 08:29:15.233  info 5040 --- [           main] o.s.b.w.embedded.tomcat.tomcatwebserver  : tomcat started on port(s): 8080 (http) with context path \'\'\n2020-06-25 08:29:15.249  info 5040 --- [           main] com.chggx.springboot.ibootapplication    : started ibootapplication in 2.13 seconds (jvm running for 3.573)\n2020-06-25 08:29:21.549  info 5040 --- [nio-8080-exec-1] o.a.c.c.c.[tomcat].[localhost].[/]       : initializing spring dispatcherservlet \'dispatcherservlet\'\n2020-06-25 08:29:21.550  info 5040 --- [nio-8080-exec-1] o.s.web.servlet.dispatcherservlet        : initializing servlet \'dispatcherservlet\'\n2020-06-25 08:29:21.558  info 5040 --- [nio-8080-exec-1] o.s.web.servlet.dispatcherservlet        : completed initialization in 8 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n\n# 3. 日志配置\n\n * 此处使用log4j2: log4j-api + log4j-core\n * 还可以使用logback\n\n\n# 3.1 引入依赖\n\nspringboot中默认的日志依赖\n\n\n\n需要在项目中引入 log4j2 的启动器\n\n\x3c!-- log4j2 日志 --\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-log4j2</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 3.2 配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<configuration> \x3c!--先定义所有的appender--\x3e\n    <appenders> \x3c!--输出控制台的配置--\x3e\n        <console name="console" target="system_out"> \x3c!--输出日志的格式--\x3e\n            \x3c!--<patternlayout pattern="%d{yyyy-mm-dd hh:mm:ss} [%p] %c %m %n"/>--\x3e\n            <patternlayout pattern="[%p] %m %n"/>\n        </console>\n    </appenders>\n    <loggers>\n        <root level="debug"> \x3c!--输出到控制台--\x3e\n            <appender-ref ref="console"/>\n        </root>\n        <logger name="org.springframework" level="error"/>\n        <logger name="com.baomidou" level="error"/>\n        <logger name="org.hibernate" level="error"/>\n        <logger name="com.alibaba.druid" level="error"/>\n        <logger name="org.springframework.boot.actuate.autoconfigure.crshautoconfiguration" level="warn"/>\n        <logger name="org.springframework.boot.actuate.endpoint.jmx" level="warn"/>\n    </loggers>\n</configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n启动服务.报错\n\nslf4j: class path contains multiple slf4j bindings.\nslf4j: found binding in [jar:file:/e:/develop/webapp/maven/maven_repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/staticloggerbinder.class]\nslf4j: found binding in [jar:file:/e:/develop/webapp/maven/maven_repository/org/apache/logging/log4j/log4j-slf4j-impl/2.13.3/log4j-slf4j-impl-2.13.3.jar!/org/slf4j/impl/staticloggerbinder.class]\nslf4j: see http://www.slf4j.org/codes.html#multiple_bindings for an explanation.\nslf4j: actual binding is of type [ch.qos.logback.classic.util.contextselectorstaticbinder]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.3 解决依赖冲突\n\nspring-boot-starter-web 和 spring-boot-starter-test 两个启动器依赖了 spring-boot- starter 启动器\n\n> spring-boot-starter 是 spring boot 非 web 环境的启动器。\n> \n> spring-boot-starter 启动器依赖了 spring-boot-starter-logging 启动器\n\n\n\n> 1.spring-boot-starter-logging 启动器为 spring boot 项目提供日志支持\n> \n> 默认集成了如下日志类库：\n> \n> ① slf4j 日志门面系统\n> \n> ② logback spring boot 默认使用的日志框架\n> \n> ③ log4j2\n> \n> ④ .....\n> \n> 2.logback 和 log4j2 两个日志类库同时存在会导致 log4j2 不起作用，需要排除logback 的依赖。\n> \n> 因为已经引入了 spring-boot-starter-log4j2 ，所以将 spring 默认的日志启动器的依赖排除\n> \n> 就可以了。\n\n排除的依赖\n\n\x3c!--web环境启动器--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n    \x3c!--排除web启动器的logging依赖--\x3e\n    <exclusions>\n        <exclusion>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-logging</artifactid>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\x3c!--测试启动器--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-test</artifactid>\n    <scope>test</scope>\n    \x3c!--排除test启动器的logging依赖--\x3e\n    <exclusions>\n        <exclusion>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-logging</artifactid>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 3.4 测试效果\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::        (v2.3.1.release)\n\n[info] starting ibootapplication on hp-elitebook-745-g5 with pid 20204 (d:\\java-code\\kuangjia\\springboot\\i-boot\\target\\classes started by hp in d:\\java-code\\kuangjia\\springboot) \n[debug] running with spring boot v2.3.1.release, spring v5.2.7.release \n[info] no active profile set, falling back to default profiles: default \n[info] initializing protocolhandler ["http-nio-8080"] \n[info] starting service [tomcat] \n[info] starting servlet engine: [apache tomcat/9.0.36] \n[info] initializing spring embedded webapplicationcontext \n[info] starting protocolhandler ["http-nio-8080"] \n[info] started ibootapplication in 2.927 seconds (jvm running for 4.391) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4. web应用开发\n\n\n# 4.1 访问静态资源\n\nspring boot 默认提供静态资源目录位置需置于 classpath下，目录名需符合如下规则：\n\n * /static\n\n * /public\n\n * /resources\n\n * /meta-inf/resources\n\n此处以/static为例;\n\n\n\n访问路径\n\n * http://localhost:8080/image/01.jpg\n * http://localhost:8080/image/02.jpg\n\n> 注意: 此处访问路径不包含/static,/public,resources,/meta-inf/resources\n\n\n# 4.2 模板引擎\n\n模板的诞生是为了将显示与数据分离，其本质是将模板文件和数据通过模板引擎生成最终的视图代码。\n\n以 html 为例\n\n * 不使用模板\n   \n   后端语言 将数据渲染到html标签里， 输出 html 文档给客户端，比如 jsp 技术。\n\n * 使用模板\n   \n   后端语言 将数据交给模板引擎，模板引擎将模板文件和数据进行渲染，输出 html 文档给客户\n\n端。\n\n浏览完最后将 html 文档的内容渲染成可视化的网页。\n\nspring boot 建议使用模板引擎处理动态网页，不建议使用 jsp 。\n\nspring boot 提供了默认配置的模板引擎主要有以下几种：\n\n * thymeleaf [推荐]\n\n * freemarker\n\n * velocity\n\n * groovy\n\n * mustache\n\n> 模板文件的默认路径为： src/main/resources/templates。\n\n\n# 4.3 thymeleaf\n\nthymeleaf 是一个服务器端的 java 模板引擎，可用于 web 与非 web 环境中的应用开发。\n\nthymeleaf 的主要目标是提供一种可被浏览器正确显示、格式良好的模板创建方式。\n\nthymeleaf 是现代 web 程序的理想选择。\n\n# 4.3.1 添加依赖\n\n\x3c!-- thymeleaf: 服务器端的java模板引擎 --\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-thymeleaf</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 4.3.2 编写模板文件\n\n在 templates 中编写模板文件\n\n\n\n * index.html\n\n<!doctype html>\n<html xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>hello thymeleaf</title></head>\n<body><h1 th:text="${hello}">hello thymeleaf</h1></body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> xmlns:th="http://www.thymeleaf.org": html中引入\n> \n> th:text: thymeleaf文本标签\n> \n> ${}: 后台取值 #{}: 国际化\n\n# 4.3.3 生成模板数据\n\n@controller\npublic class hellobootcontroller {\n\n    @getmapping("/thymeleaf")\n    public string thymeleaf(model model){\n        model.addattribute("hello","hello thymeleaf !");\n        return "index";\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 浏览器访问\n\n\n\n# 4.3.4 thymeleaf默认配置\n\nspring boot 为 thymeleaf模板引擎提供了如下默认配置，要修改默认配置可以在 spring boot配置文件\n\napplication.properties 中覆盖对应配置。\n\n# thymeleaf默认配置\n# enable template caching. 是否缓存(默认缓存true)\nspring.thymeleaf.cache=true\n# 是否检查模板位置\nspring.thymeleaf.check-template=true\n# 检查模板位置是否存在\nspring.thymeleaf.check-template-location = true\n# 设置请求类型 (content-type值) spring.thymeleaf.content-type = text/html\nspring.thymeleaf.servlet.content-type=text/html\n# 是否启用thymeleaf模板引擎(默认true)\nspring.thymeleaf.enabled=true\n# 模板编码 template encoding.\nspring.thymeleaf.encoding=utf-8\n# 应该从解决方案中排除的视图名称的逗号分隔列表。\nspring.thymeleaf.excluded-view-names =\n# 应用于模板的模板模式。另请参见standardtemplatemodehandlers。 template mode to be applied to templates. see also standardtemplatemodehandlers.\nspring.thymeleaf.mode=html5\n# 构建url时预先查看名称的前缀 prefix that gets prepended to view names when building a url.\nspring.thymeleaf.prefix=classpath:/templates/\n# 构建url时附加到查看名称的后缀 suffix that gets appended to view names when building a url.\nspring.thymeleaf.suffix=.html\n# 链中模板解析器的顺序。\nspring.thymeleaf.template-resolver-order =\n# 可以解析的视图名称的逗号分隔列表\nspring.thymeleaf.view-names = \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 4.4 项目热加载(页面)\n\n\n\n\x3c!--devtools热加载--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-devtools</artifactid>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * 问题\n   \n   \n\n * 解决\n   \n   pom 文件中添加\n\n<plugins>\n    \x3c!--springboot编译运行打包部署.构建插件--\x3e\n    <plugin>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-maven-plugin</artifactid>\n        \x3c!--解决引入热部署依赖后,出现"x"的问题--\x3e\n        <configuration>\n            <fork>true</fork>\n        </configuration>\n    </plugin>\n</plugins>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5. 数据访问\n\n\n# 5.1 数据源配置\n\n添加依赖\n\n引入 mysql jdbc 驱动和 druid 数据库连接池依赖。\n\n\x3c!--jdbc驱动--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-jdbc</artifactid>\n</dependency>\n\n\x3c!-- mysql驱动 --\x3e\n<dependency>\n    <groupid>mysql</groupid>\n    <artifactid>mysql-connector-java</artifactid>\n    <version>5.1.47</version>\n    <scope>runtime</scope>\n</dependency>\n\n\x3c!-- druid数据库连接池 --\x3e\n<dependency>\n    <groupid>com.alibaba</groupid>\n    <artifactid>druid-spring-boot-starter</artifactid>\n    <version>1.1.20</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在src/main/resources/application.properties 中配置数据源信息。\n\n\n# 5.2 事务配置\n\n在应用程序入口类添加 @enabletransactionmanagement 启用事务管理支持。\n\n@springbootapplication\n@enabletransactionmanagement\npublic class ibootapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(ibootapplication.class, args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5.3 springboot整合mybatis\n\n * 此处使用 mybatis-plus\n\n# 5.3.1 依赖\n\n\x3c!--mybatis 和 mybatis-plus驱动--\x3e\n<dependency>\n    <groupid>com.baomidou</groupid>\n    <artifactid>mybatis-plus-boot-starter</artifactid>\n    <version>3.2.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 引入上面依赖不需要: spring-boot-starter-jdbc和mybatis-spring-boot-starter两个驱动\n\n# 5.3.2 mapper 接口扫描配置\n\n * 启动类上添加@mapperscan注解\n\n@springbootapplication\n@enabletransactionmanagement\n@mapperscan("com.chggx.springboot.*.mapper")\npublic class ibootapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(ibootapplication.class, args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> @mapperscan: mybatis注解\n\n# 5.3.3 mapper 映射文件配置\n\n在 src/main/resources/application.properties 中配置mapper映射文件位置。\n\n# 5.3.4 分页插件\n\n/**\n * @author: chggx\n * @description: <h1> mybatisplus配置类 </h1>\n */\n@configuration\n@enabletransactionmanagement\n@mapperscan("com.chggx.springboot.*.mapper")\npublic class mybatisconfig {\n\n    /*** mybatis-puls 分页插件配置 * @return */\n    @bean\n    public paginationinterceptor paginationinterceptor() {\n        paginationinterceptor paginationinterceptor = new paginationinterceptor();\n        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false\n        paginationinterceptor.setoverflow(false);\n        // 设置最大单页限制数量，默认 500 条，-1 不受限制\n        paginationinterceptor.setlimit(-1);\n        return paginationinterceptor;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n> @enabletransactionmanagement,@mapperscan("com.chggx.springboot.*.mapper"): 可以配置在mybatisplus配置类中.\n\n# 5.3.5 代码生成器\n\n * 方案一\n\n/**\n * @author: chggx\n * @description: <h1> mybatisplus代码生成 </h1>\n */\npublic class mybatisgenerator {\n\n    /**\n     * 读取控制台内容\n     */\n    public static string scanner(string tip) {\n        scanner scanner = new scanner(system.in);\n        stringbuilder help = new stringbuilder();\n        help.append("请输入" + tip + "：");\n        system.out.println(help.tostring());\n        if (scanner.hasnext()) {\n            string ipt = scanner.next();\n            if (stringutils.isnotempty(ipt)) {\n                return ipt;\n            }\n        }\n        throw new mybatisplusexception("请输入正确的" + tip + "！");\n    }\n\n    public static void main(string[] args) {\n        // 代码生成器\n        autogenerator mpg = new autogenerator();\n        // 全局配置\n        globalconfig gc = new globalconfig();\n        string projectpath = system.getproperty("user.dir");\n//        gc.setoutputdir(projectpath + "/src/main/java");\n        gc.setoutputdir("c:\\\\users\\\\hp\\\\desktop\\\\新建文件夹\\\\i-boot" + "/src/main/java");\n        gc.setauthor("chggx");\n        gc.setopen(false);\n        // gc.setswagger2(true); // 实体属性swagger2注解\n        gc.setbaseresultmap(true);\n        gc.setbasecolumnlist(true);\n        mpg.setglobalconfig(gc);\n\n        // 数据源配置\n        datasourceconfig dsc = new datasourceconfig();\n        dsc.seturl("jdbc:mysql://localhost:3306/i-auth?usessl=false");\n        dsc.setdrivername("com.mysql.jdbc.driver");\n        dsc.setusername("root");\n        dsc.setpassword("123456");\n        mpg.setdatasource(dsc);\n\n        // 包配置\n        packageconfig pc = new packageconfig();\n        pc.setmodulename(scanner("模块名"));\n        pc.setparent("com.chggx.springboot");\n        mpg.setpackageinfo(pc);\n\n        // 自定义配置\n        injectionconfig cfg = new injectionconfig() {\n            @override\n            public void initmap() {\n                // to do nothing\n            }\n        };\n\n        list<fileoutconfig> foclist = new arraylist<>();\n        foclist.add(new fileoutconfig("/templates/mapper.xml.ftl") {\n            @override\n            public string outputfile(tableinfo tableinfo) {\n                // 自定义输入文件名称\n               /* return projectpath + "/src/main/resources/mapper/" + pc.getmodulename()\n                        + "/" + tableinfo.getentityname() + "mapper" + stringpool.dot_xml;*/\n                return "c:\\\\users\\\\hp\\\\desktop\\\\新建文件夹\\\\i-boot" + "/src/main/resources/mapper/" + pc.getmodulename()\n                        + "/" + tableinfo.getentityname() + "mapper" + stringpool.dot_xml;\n            }\n        });\n        cfg.setfileoutconfiglist(foclist);\n        mpg.setcfg(cfg);\n        mpg.settemplate(new templateconfig().setxml(null));\n\n        // 策略配置\n        strategyconfig strategy = new strategyconfig();\n        strategy.setnaming(namingstrategy.underline_to_camel);\n        strategy.setcolumnnaming(namingstrategy.underline_to_camel);\n        // 使用lombok插件\n        strategy.setentitylombokmodel(true);\n        strategy.setinclude(scanner("表名"));\n\n        strategy.setsuperserviceclass("com.chggx.springboot.common.service.iservice");\n        strategy.setsuperserviceimplclass("com.chggx.springboot.common.service.impl.serviceimpl");\n\n        // controller配置\n        strategy.setskipview(false);\n        strategy.setcontrollermappinghyphenstyle(true);\n        // @controller @restcontroller\n        strategy.setrestcontrollerstyle(false);\n\n        strategy.settableprefix(pc.getmodulename() + "_");\n        mpg.setstrategy(strategy);\n        // 选择 freemarker 引擎需要指定如下加，注意 pom 依赖必须有！\n        mpg.settemplateengine(new freemarkertemplateengine());\n        mpg.execute();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n测试生成\n\n\n\n> 测出使用lombok,添加下面依赖\n\n\x3c!--lombok--\x3e\n<dependency>\n    <groupid>org.projectlombok</groupid>\n    <artifactid>lombok</artifactid>\n    <version>1.18.12</version>\n    <scope>provided</scope>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 方案二\n\n参考我的博客\n\n\x3c!-- velocity 模板引擎, mybatis plus 代码生成器需要 --\x3e\n<dependency>\n    <groupid>org.apache.velocity</groupid>\n    <artifactid>velocity-engine-core</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 5.3.6 mybatisplus配置文件\n\n# mybatis plus 配置\nmybatis-plus:\n  # mybatis plus日志 使用logback\n  #  configuration:\n  #    log-impl: org.apache.ibatis.logging.stdout.stdoutimpl\n  # 实体扫描\n  typealiasespackage: com.chggx.blog.sys.entity\n  # mybatis-plus xml路径配置\n  mapper-locations: classpath:/mapper/*mapper.xml\n  configuration:\n    cache‐enabled: false\n    map‐underscore‐to‐camel‐case: true\n  global-config:\n    db-config:\n      # 逻辑删除\n      logic-delete-value: 1\n      logic-not-delete-value: 0\n    # 刷新mapper, 调试神器\n    refresh: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 此处是yml格式配置\n\n> mybatisplus的测试此处省略...\n\n\n# 5.4 springboot整合redis\n\n# 5.4.1 添加依赖\n\njedis 在实现上是直接连接 redis 服务器，在多个线程间共享一个 jedis 实例时是线程不\n安全的，如果想要在多线程场景下使用 jedis ，需要使用连接池，每个线程都使用自己的\njedis 实例，当连接数量增多时，会消耗较多的物理资源。\n与 jedis 相比， lettuce 则完全克服了其线程不安全的缺点： lettuce 是一个可伸缩的线\n程安全的 redis 客户端，支持同步、异步和响应式模式。多个线程可以共享一个连接实例，而\n不必担心多线程并发问题。它基于优秀 netty nio 框架构建，支持 redis 的更多高级功能。\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 综上使用lettuce客户端\n\n\x3c!--redis 访问启动器 --\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\x3c!--redis客户端lettuce 数据库连接池依赖 --\x3e\n<dependency>\n    <groupid>org.apache.commons</groupid>\n    <artifactid>commons-pool2</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 5.4.2 数据源配置\n\n# redis配置\n# redis数据库索引（默认为0）\nspring.redis.database=0\n# redis服务器地址 （默认localhost）\nspring.redis.host=localhost\n# redis服务器连接端口 （默认6379）\nspring.redis.port=6379\n# redis服务器连接密码（默认为空）\nspring.redis.password=\n# 连接超时时间\nspring.redis.timeout=10000ms\n# 最大连接数（使用负值表示没有限制） 默认 8\nspring.redis.lettuce.pool.max-active=8\n# 最小空闲连接 默认 0\nspring.redis.lettuce.pool.min-idle=0\n# 最大空闲连接 默认 8\nspring.redis.lettuce.pool.max-idle=8\n# 最大阻塞等待时间（使用负值表示没有限制） 默认 -1ms\nspring.redis.lettuce.pool.max-wait=-1ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 5.4.3 配置类\n\n/**\n * @author: chggx\n * @description: <h1> redis配置类 </h1>\n */\n@configuration\npublic class redisconfig {\n\n    /**\n     * 连接工厂\n     */\n    @autowired\n    private redisconnectionfactory redisconnectionfactory;\n\n    @bean\n    public stringredisserializer stringredisserializer() {\n        stringredisserializer stringredisserializer = new stringredisserializer();\n        return stringredisserializer;\n    }\n\n    @bean\n    public jackson2jsonredisserializer jackson2jsonredisserializer() {\n        jackson2jsonredisserializer jackson2jsonredisserializer = new jackson2jsonredisserializer<>(object.class);\n        objectmapper objectmapper = new objectmapper();\n        objectmapper.setvisibility(propertyaccessor.all, jsonautodetect.visibility.any);\n        objectmapper.enabledefaulttyping(objectmapper.defaulttyping.non_final);\n        jackson2jsonredisserializer.setobjectmapper(objectmapper);\n        return jackson2jsonredisserializer;\n    }\n\n    /**\n     * stringredistemplate\n     * @return stringredistemplate\n     */\n    @bean\n    public stringredistemplate stringredistemplate() {\n        stringredistemplate stringredistemplate = new stringredistemplate();\n        // 注入数据库连接工厂\n        stringredistemplate.setconnectionfactory(redisconnectionfactory);\n        // 开启事务支持\n        stringredistemplate.setenabletransactionsupport(true);\n        return stringredistemplate;\n    }\n\n    /**\n     * redistemplate\n     * @return redistemplate\n     */\n    @bean\n    public redistemplate<string, object> redistemplate() {\n        redistemplate<string, object> redistemplate = new redistemplate<>();\n        redistemplate.setconnectionfactory(redisconnectionfactory);\n        redistemplate.setkeyserializer(stringredisserializer());\n        redistemplate.setvalueserializer(jackson2jsonredisserializer());\n        redistemplate.sethashkeyserializer(stringredisserializer());\n        redistemplate.sethashvalueserializer(jackson2jsonredisserializer());\n        // 开启事务支持\n        redistemplate.setenabletransactionsupport(true);\n        return redistemplate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n# 5.4.4 测试\n\n@runwith(springrunner.class)\n@springboottest\npublic class redistest {\n\n    @autowired\n    private stringredistemplate redistemplate;\n\n    @test\n    public void test(){\n        redistemplate.opsforvalue().set("kq","hello redis !");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Spring基础",frontmatter:{title:"Spring基础",date:"2023-02-25T21:36:07.000Z",permalink:"/pages/cb7d50/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/01.Spring%E5%AE%B6%E6%97%8F/01.Spring/1.Spring%E5%9F%BA%E7%A1%80.html",relativePath:"04.后端应用框架/01.Spring家族/01.Spring/1.Spring基础.md",key:"v-704229bc",path:"/pages/cb7d50/",headers:[{level:3,title:"1. spring优势",slug:"_1-spring优势",normalizedTitle:"1. spring优势",charIndex:15},{level:3,title:"2. spring体系结构",slug:"_2-spring体系结构",normalizedTitle:"2. spring体系结构",charIndex:239},{level:4,title:"1. spring5模快结构图",slug:"_1-spring5模快结构图",normalizedTitle:"1. spring5模快结构图",charIndex:258},{level:3,title:"3. 入门JDBC操作 程序解耦",slug:"_3-入门jdbc操作-程序解耦",normalizedTitle:"3. 入门jdbc操作 程序解耦",charIndex:294},{level:3,title:"4. 解耦合",slug:"_4-解耦合",normalizedTitle:"4. 解耦合",charIndex:1523},{level:4,title:"1. 配置文件",slug:"_1-配置文件",normalizedTitle:"1. 配置文件",charIndex:1533},{level:4,title:"2. 业务逻辑",slug:"_2-业务逻辑",normalizedTitle:"2. 业务逻辑",charIndex:1674},{level:5,title:"1. dao层",slug:"_1-dao层",normalizedTitle:"1. dao层",charIndex:1685},{level:5,title:"2. service",slug:"_2-service",normalizedTitle:"2. service",charIndex:2043},{level:5,title:"3. AccountController",slug:"_3-accountcontroller",normalizedTitle:"3. accountcontroller",charIndex:2691},{level:4,title:"3. 工厂模式解耦",slug:"_3-工厂模式解耦",normalizedTitle:"3. 工厂模式解耦",charIndex:3159},{level:2,title:"2. Spring IOC 与 DI",slug:"_2-spring-ioc-与-di",normalizedTitle:"2. spring ioc 与 di",charIndex:6007},{level:3,title:"1. IOC 控制反转  [Inversion Of Control]",slug:"_1-ioc-控制反转-inversion-of-control",normalizedTitle:"1. ioc 控制反转  [inversion of control]",charIndex:null},{level:4,title:"1. 控制反转解决色问题",slug:"_1-控制反转解决色问题",normalizedTitle:"1. 控制反转解决色问题",charIndex:6068},{level:4,title:"2.  IOC的概述 解耦合",slug:"_2-ioc的概述-解耦合",normalizedTitle:"2.  ioc的概述 解耦合",charIndex:null},{level:3,title:"2. IOC入门应用",slug:"_2-ioc入门应用",normalizedTitle:"2. ioc入门应用",charIndex:6407},{level:4,title:"1. 依赖",slug:"_1-依赖",normalizedTitle:"1. 依赖",charIndex:6421},{level:4,title:"2.  配置文件",slug:"_2-配置文件",normalizedTitle:"2.  配置文件",charIndex:null},{level:4,title:"3. ApplicationContext操作",slug:"_3-applicationcontext操作",normalizedTitle:"3. applicationcontext操作",charIndex:7267},{level:3,title:"3. IOC核心容器的两个接口",slug:"_3-ioc核心容器的两个接口",normalizedTitle:"3. ioc核心容器的两个接口",charIndex:8484},{level:4,title:"1. ApplicationContext 单例对象使用",slug:"_1-applicationcontext-单例对象使用",normalizedTitle:"1. applicationcontext 单例对象使用",charIndex:8503},{level:4,title:"2. BeanFactory 多例对象使用",slug:"_2-beanfactory-多例对象使用",normalizedTitle:"2. beanfactory 多例对象使用",charIndex:8790},{level:4,title:"3. 使用",slug:"_3-使用",normalizedTitle:"3. 使用",charIndex:9125},{level:3,title:"4. spring对bean的管理细节",slug:"_4-spring对bean的管理细节",normalizedTitle:"4. spring对bean的管理细节",charIndex:11350},{level:4,title:"1.  创建Bean的三种方式",slug:"_1-创建bean的三种方式",normalizedTitle:"1.  创建bean的三种方式",charIndex:null},{level:5,title:"1. 构造函数创建对象",slug:"_1-构造函数创建对象",normalizedTitle:"1. 构造函数创建对象",charIndex:11391},{level:5,title:"2. 普通工厂的方法创建对象",slug:"_2-普通工厂的方法创建对象",normalizedTitle:"2. 普通工厂的方法创建对象",charIndex:12698},{level:5,title:"3.  工厂中的静态方法创建对象",slug:"_3-工厂中的静态方法创建对象",normalizedTitle:"3.  工厂中的静态方法创建对象",charIndex:null},{level:4,title:"2. bean对象的作用范围 scope",slug:"_2-bean对象的作用范围-scope",normalizedTitle:"2. bean对象的作用范围 scope",charIndex:16131},{level:4,title:"3. bean对象的生命周期",slug:"_3-bean对象的生命周期",normalizedTitle:"3. bean对象的生命周期",charIndex:11940},{level:5,title:"1. 单例 ==立即加载==",slug:"_1-单例-立即加载",normalizedTitle:"1. 单例 ==立即加载==",charIndex:16546},{level:5,title:"2. 多例 ==懒加载==",slug:"_2-多例-懒加载",normalizedTitle:"2. 多例 ==懒加载==",charIndex:18429},{level:3,title:"5. 依赖注入 DI",slug:"_5-依赖注入-di",normalizedTitle:"5. 依赖注入 di",charIndex:19260},{level:4,title:"1. 概述",slug:"_1-概述",normalizedTitle:"1. 概述",charIndex:19274},{level:4,title:"2. 注入方式",slug:"_2-注入方式",normalizedTitle:"2. 注入方式",charIndex:19438},{level:5,title:"1.  构造方法",slug:"_1-构造方法",normalizedTitle:"1.  构造方法",charIndex:null},{level:5,title:"2. set方法 [推荐: 可以使用默认的构造方法]",slug:"_2-set方法-推荐-可以使用默认的构造方法",normalizedTitle:"2. set方法 [推荐: 可以使用默认的构造方法]",charIndex:23102},{level:5,title:"3. 注解方式",slug:"_3-注解方式",normalizedTitle:"3. 注解方式",charIndex:26518},{level:4,title:"3. 能注入的数据",slug:"_3-能注入的数据",normalizedTitle:"3. 能注入的数据",charIndex:26545},{level:5,title:"1. 基本类型",slug:"_1-基本类型",normalizedTitle:"1. 基本类型",charIndex:26558},{level:5,title:"2. 其他bean类型(在配置文件中或者注解配置过得bean)",slug:"_2-其他bean类型-在配置文件中或者注解配置过得bean",normalizedTitle:"2. 其他bean类型(在配置文件中或者注解配置过得bean)",charIndex:26586},{level:5,title:"3.  复杂类型/集合类型",slug:"_3-复杂类型-集合类型",normalizedTitle:"3.  复杂类型/集合类型",charIndex:null},{level:3,title:"6. ioc注解",slug:"_6-ioc注解",normalizedTitle:"6. ioc注解",charIndex:29852},{level:4,title:"1.  用于创建对象的注解",slug:"_1-用于创建对象的注解",normalizedTitle:"1.  用于创建对象的注解",charIndex:null},{level:5,title:"1. @Component",slug:"_1-component",normalizedTitle:"1. @component",charIndex:30180},{level:5,title:"2. 衍生注解使用",slug:"_2-衍生注解使用",normalizedTitle:"2. 衍生注解使用",charIndex:33149},{level:4,title:"2. 用于注入数据的",slug:"_2-用于注入数据的",normalizedTitle:"2. 用于注入数据的",charIndex:30851},{level:5,title:"1. @Autowired ==自动按照类型注入==",slug:"_1-autowired-自动按照类型注入",normalizedTitle:"1. @autowired ==自动按照类型注入==",charIndex:34793},{level:5,title:"2. @Qualifier ==解决@Autowired多类型匹配==",slug:"_2-qualifier-解决-autowired多类型匹配",normalizedTitle:"2. @qualifier ==解决@autowired多类型匹配==",charIndex:35082},{level:5,title:"3. @Resource ==替换上边两个==",slug:"_3-resource-替换上边两个",normalizedTitle:"3. @resource ==替换上边两个==",charIndex:36090},{level:5,title:"4.  @Value ==注入基本类型和String类型==",slug:"_4-value-注入基本类型和string类型",normalizedTitle:"4.  @value ==注入基本类型和string类型==",charIndex:null},{level:5,title:"5. 总结",slug:"_5-总结",normalizedTitle:"5. 总结",charIndex:36833},{level:4,title:"3. 用于改变作用范围的",slug:"_3-用于改变作用范围的",normalizedTitle:"3. 用于改变作用范围的",charIndex:30939},{level:4,title:"4. 和生命周期有关的",slug:"_4-和生命周期有关的",normalizedTitle:"4. 和生命周期有关的",charIndex:31016},{level:5,title:"1. @PreDestroy ==销毁==",slug:"_1-predestroy-销毁",normalizedTitle:"1. @predestroy ==销毁==",charIndex:37250},{level:5,title:"2. @PostConstruct ==初始胡==",slug:"_2-postconstruct-初始胡",normalizedTitle:"2. @postconstruct ==初始胡==",charIndex:37292},{level:5,title:"3. 应用",slug:"_3-应用",normalizedTitle:"3. 应用",charIndex:29112},{level:2,title:"3. spring的新注解",slug:"_3-spring的新注解",normalizedTitle:"3. spring的新注解",charIndex:41338},{level:3,title:"1. 新注解",slug:"_1-新注解",normalizedTitle:"1. 新注解",charIndex:41356},{level:3,title:"2. 新注解取代xml",slug:"_2-新注解取代xml",normalizedTitle:"2. 新注解取代xml",charIndex:42280},{level:4,title:"1. xml形式",slug:"_1-xml形式",normalizedTitle:"1. xml形式",charIndex:42295},{level:4,title:"2. 注解形式",slug:"_2-注解形式",normalizedTitle:"2. 注解形式",charIndex:43608},{level:3,title:"3. @Qualifier另一种使用",slug:"_3-qualifier另一种使用",normalizedTitle:"3. @qualifier另一种使用",charIndex:46827},{level:3,title:"4. junit",slug:"_4-junit",normalizedTitle:"4. junit",charIndex:48475},{level:4,title:"1. 普通junit",slug:"_1-普通junit",normalizedTitle:"1. 普通junit",charIndex:48487},{level:4,title:"2. Spring集成junit",slug:"_2-spring集成junit",normalizedTitle:"2. spring集成junit",charIndex:48944},{level:4,title:"3.  案例 ==注解形式==",slug:"_3-案例-注解形式",normalizedTitle:"3.  案例 ==注解形式==",charIndex:null},{level:2,title:"4. 动态代理(proxy)",slug:"_4-动态代理-proxy",normalizedTitle:"4. 动态代理(proxy)",charIndex:50822},{level:3,title:"1. 基于接口的动态代理",slug:"_1-基于接口的动态代理",normalizedTitle:"1. 基于接口的动态代理",charIndex:51077},{level:4,title:"1. 概述",slug:"_1-概述-2",normalizedTitle:"1. 概述",charIndex:19274},{level:4,title:"2.  代码实现",slug:"_2-代码实现",normalizedTitle:"2.  代码实现",charIndex:null},{level:3,title:"2. 基于子类的动态代理",slug:"_2-基于子类的动态代理",normalizedTitle:"2. 基于子类的动态代理",charIndex:54170},{level:4,title:"1. 概述",slug:"_1-概述-3",normalizedTitle:"1. 概述",charIndex:19274},{level:4,title:"2.  实现",slug:"_2-实现",normalizedTitle:"2.  实现",charIndex:null},{level:3,title:"3. 案例",slug:"_3-案例",normalizedTitle:"3. 案例",charIndex:49674},{level:4,title:"1. 事务问题",slug:"_1-事务问题",normalizedTitle:"1. 事务问题",charIndex:56922},{level:4,title:"2. 基于接口的动态地理方式处理",slug:"_2-基于接口的动态地理方式处理",normalizedTitle:"2. 基于接口的动态地理方式处理",charIndex:58904},{level:5,title:"1. 创建代理工厂",slug:"_1-创建代理工厂",normalizedTitle:"1. 创建代理工厂",charIndex:58924},{level:2,title:"5. Spring AOP",slug:"_5-spring-aop",normalizedTitle:"5. spring aop",charIndex:61914},{level:3,title:"1. 概述",slug:"_1-概述-4",normalizedTitle:"1. 概述",charIndex:19274},{level:4,title:"1. 什么是AOP",slug:"_1-什么是aop",normalizedTitle:"1. 什么是aop",charIndex:61941},{level:4,title:"2. AOP优势",slug:"_2-aop优势",normalizedTitle:"2. aop优势",charIndex:62073},{level:4,title:"3. AOP 的实现方式",slug:"_3-aop-的实现方式",normalizedTitle:"3. aop 的实现方式",charIndex:62165},{level:3,title:"2.  AOP术语",slug:"_2-aop术语",normalizedTitle:"2.  aop术语",charIndex:null},{level:3,title:"3. AOP使用",slug:"_3-aop使用",normalizedTitle:"3. aop使用",charIndex:62754},{level:4,title:"1. 切入点表达式",slug:"_1-切入点表达式",normalizedTitle:"1. 切入点表达式",charIndex:62941},{level:4,title:"2. spring基于XML的AOP配置",slug:"_2-spring基于xml的aop配置",normalizedTitle:"2. spring基于xml的aop配置",charIndex:63991},{level:5,title:"1. 入门",slug:"_1-入门",normalizedTitle:"1. 入门",charIndex:64200},{level:5,title:"2.  通知类型",slug:"_2-通知类型",normalizedTitle:"2.  通知类型",charIndex:null},{level:6,title:"1. xml写法",slug:"_1-xml写法",normalizedTitle:"1. xml写法",charIndex:65880},{level:6,title:"2.  优化代码",slug:"_2-优化代码",normalizedTitle:"2.  优化代码",charIndex:null},{level:5,title:"3. 环绕通知 😄",slug:"_3-环绕通知",normalizedTitle:"3. 环绕通知 😄",charIndex:66870},{level:6,title:"1. 环绕通知问题",slug:"_1-环绕通知问题",normalizedTitle:"1. 环绕通知问题",charIndex:66884},{level:6,title:"2. 解决",slug:"_2-解决",normalizedTitle:"2. 解决",charIndex:67679},{level:4,title:"3. 基于注解AOP配置 推荐环绕通知",slug:"_3-基于注解aop配置-推荐环绕通知",normalizedTitle:"3. 基于注解aop配置 推荐环绕通知",charIndex:68638},{level:5,title:"1. 配置",slug:"_1-配置",normalizedTitle:"1. 配置",charIndex:1533},{level:5,title:"2. 通知类",slug:"_2-通知类",normalizedTitle:"2. 通知类",charIndex:65552},{level:2,title:"6. Spring中的JdbcTemplate",slug:"_6-spring中的jdbctemplate",normalizedTitle:"6. spring中的jdbctemplate",charIndex:72173}],headersStr:"1. spring优势 2. spring体系结构 1. spring5模快结构图 3. 入门JDBC操作 程序解耦 4. 解耦合 1. 配置文件 2. 业务逻辑 1. dao层 2. service 3. AccountController 3. 工厂模式解耦 2. Spring IOC 与 DI 1. IOC 控制反转  [Inversion Of Control] 1. 控制反转解决色问题 2.  IOC的概述 解耦合 2. IOC入门应用 1. 依赖 2.  配置文件 3. ApplicationContext操作 3. IOC核心容器的两个接口 1. ApplicationContext 单例对象使用 2. BeanFactory 多例对象使用 3. 使用 4. spring对bean的管理细节 1.  创建Bean的三种方式 1. 构造函数创建对象 2. 普通工厂的方法创建对象 3.  工厂中的静态方法创建对象 2. bean对象的作用范围 scope 3. bean对象的生命周期 1. 单例 ==立即加载== 2. 多例 ==懒加载== 5. 依赖注入 DI 1. 概述 2. 注入方式 1.  构造方法 2. set方法 [推荐: 可以使用默认的构造方法] 3. 注解方式 3. 能注入的数据 1. 基本类型 2. 其他bean类型(在配置文件中或者注解配置过得bean) 3.  复杂类型/集合类型 6. ioc注解 1.  用于创建对象的注解 1. @Component 2. 衍生注解使用 2. 用于注入数据的 1. @Autowired ==自动按照类型注入== 2. @Qualifier ==解决@Autowired多类型匹配== 3. @Resource ==替换上边两个== 4.  @Value ==注入基本类型和String类型== 5. 总结 3. 用于改变作用范围的 4. 和生命周期有关的 1. @PreDestroy ==销毁== 2. @PostConstruct ==初始胡== 3. 应用 3. spring的新注解 1. 新注解 2. 新注解取代xml 1. xml形式 2. 注解形式 3. @Qualifier另一种使用 4. junit 1. 普通junit 2. Spring集成junit 3.  案例 ==注解形式== 4. 动态代理(proxy) 1. 基于接口的动态代理 1. 概述 2.  代码实现 2. 基于子类的动态代理 1. 概述 2.  实现 3. 案例 1. 事务问题 2. 基于接口的动态地理方式处理 1. 创建代理工厂 5. Spring AOP 1. 概述 1. 什么是AOP 2. AOP优势 3. AOP 的实现方式 2.  AOP术语 3. AOP使用 1. 切入点表达式 2. spring基于XML的AOP配置 1. 入门 2.  通知类型 1. xml写法 2.  优化代码 3. 环绕通知 😄 1. 环绕通知问题 2. 解决 3. 基于注解AOP配置 推荐环绕通知 1. 配置 2. 通知类 6. Spring中的JdbcTemplate",content:'# Spring基础\n\n\n# 1. spring优势\n\n 1. 方便解耦，简化开发\n    * 通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。\n 2. AOP 编程的支持\n 3. 声明式事务的支持\n 4. 方便程序的测试\n 5. 方便集成各种优秀框架\n 6. 降低 JavaEE API 的使用难度\n\n\n# 2. spring体系结构\n\n> # 1. spring5模快结构图\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 3. 入门JDBC操作 程序解耦\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 程序耦合 </h1>\n * 耦合: 程序间的依赖关系\n *      1. 类之间依赖\n *      2. 方法之间的依赖\n *  解耦: 降低程序间的依赖\n *\n *  开发过程应做到:\n *      编译期不依赖,运行期才依赖\n *  解耦思路:\n *      1. 使用反射来创建对象,避免使用new关键字\n *      2. 通过读取配置文件来获取要创建的对象全权限定类名\n *\n */\npublic class JdbcDemo01 {\n\n    public static void main(String[] args) throws Exception {\n\n        // 1. 注册驱动\n//        DriverManager.registerDriver(new com.mysql.jdbc.Driver());\n\n       Class.forName("new com.mysql.jdbc.Driver()");\n        // 2. 获取连接\n        Connection conn = DriverManager.getConnection(\n                "jdbc:mysql://localhost:3306/spring_jdbc",\n                "root",\n                "root"\n        );\n        // 3. 获取操作数据库的与处理对象\n        PreparedStatement pstm = conn.prepareStatement("select * from account");\n        // 4. 执行SQL,得到结果\n        ResultSet resultSet = pstm.executeQuery();\n        // 5. 遍历结果\n        while (resultSet.next()) {\n            System.out.println(resultSet.getString("name"));\n        }\n        // 6. 关闭流\n        resultSet.close();\n        pstm.close();\n        conn.close();\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 4. 解耦合\n\n# 1. 配置文件\n\n * bean.properties\n\naccountService=com.chggx.service.impl.AccountServiceImpl\naccountDao=com.chggx.dao.impl.AccountDaoImpl\n\n\n1\n2\n\n\n# 2. 业务逻辑\n\n# 1. dao层\n\n * AccountDao\n\npublic interface AccountDao {\n\n    /**\n     * 模拟保存账户\n     */\n    void saveAccount();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * AccountDaoImpl\n\npublic class AccountDaoImpl implements AccountDao {\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        System.out.println("save success...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2. service\n\n * AccountService\n\npublic interface AccountService {\n\n    /**\n     * 模拟保存账户\n     */\n    void saveAccount();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n * AccountServiceImpl\n   \n   使用factory工厂的方式获取对象\n\npublic class AccountServiceImpl implements AccountService {\n\n    /**\n     * 普通方式 (耦合度高)\n     */\n//    private final AccountDao accountDao = new AccountDaoImpl();\n\n    /**\n     * 解耦合\n     */\n    private final AccountDao accountDao = (AccountDao) BeanFactory.getBean("accountDao");\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        accountDao.saveAccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 3. AccountController\n\n * 解耦合 通过工厂的方式创建对象,实现程序间的解耦合\n\npublic class AccountController {\n\n    /**\n     * 模拟保存账户\n     */\n    public static void main(String[] args) {\n        // 普通方式 (耦合度高)\n      /*  AccountService service = new AccountServiceImpl();\n        service.saveAccount();*/\n\n        // 解耦合\n        AccountService service = (AccountService) BeanFactory.getBean("accountService");\n        service.saveAccount();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 3. 工厂模式解耦\n\n * 使用单例,每个对象只创建一次\n\n/**\n * @Author: CHGGX\n * @Date: 2020/04/28 22:14\n * @Description: <h1> 一个创建Bean对象的工厂(解耦合) </h1>\n * Bean: 在计算机英语中,有可重用组件的含义\n * JavaBean: java语言编写的可重用组件\n * 1. JavaBean > 实体类\n * 2. 它就是创建我们的service和dao对象的\n * 解决:\n * 1. 需要一个配置文件来配置我们的service和dao\n * 配置内容: 1) 唯一标识=权限定类名\n * 2. 通过读取配置文件中的内容,反射创建对象\n * <p>\n * 配置文件形式:\n * 1. xml\n * 2. properties: 推荐\n */\npublic class BeanFactory {\n\n    /**\n     * 定义一个Properties对象\n     */\n    private static Properties props;\n\n    /**\n     * 定义一个Map,用于存放我们要创建的对象,我们称之为容器\n     */\n    private static Map<String, Object> beans;\n\n    // 使用静态代码块Properties对象赋值\n    static {\n        try {\n            // 1. 实例化对象\n            props = new Properties();\n            // 获取"bean.properties"文件的流对象\n            // 获取Class对象 类名.class\n            InputStream is = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties");\n            // 加载配置文件\n            props.load(is);\n\n            //2. 实例化容器 [单例.只创建一次]\n            beans = new HashMap<String, Object>();\n            // 2.1 取出配置文件中所有的key\n            Enumeration<Object> keys = props.keys();\n            // 2.2 遍历枚举\n            while (keys.hasMoreElements()) {\n                // 2.2.1 去除每个key\n                String key = (String) keys.nextElement();\n                // 2.2.2 根据key获取值(类的权限定类名)\n                String beanPath = (String) props.get(key);\n                // 2.3 反射创建对象\n                Object value = Class.forName(beanPath).newInstance();\n                // 2.4 把key和value存入容器中(Map集合)\n                beans.put(key, value);\n            }\n        } catch (Exception e) {\n            // 错误 error子类\n            throw new ExceptionInInitializerError("Properties init error !");\n        }\n    }\n\n    /**\n     * 改进: Bean只创建一次,(创建的对象存入容器中.此处指Map集合)\n     *\n     * @param beanName Bean的名称\n     * @return Bean的对象\n     */\n    public static Object getBean(String beanName) {\n        // 根据Bean的名称从容器中获取Bean的对象\n        return beans.get(beanName);\n    }\n\n    /**\n     * 根据Bean的名称获取Bean的对象 [此处是多例,每次都创建对象]\n     *\n     * @param beanName Bean的名称\n     * @return Bean的对象\n     */\n//    public static Object getBean(String beanName) {\n//        Object bean = null;\n//        try {\n//            String beanPath = props.getProperty(beanName);\n//            // 获取Class对象 Class.forName("权限定类名")\n//            // Constructor创建对象  T newInstance(Object... initargs)\n//            bean = Class.forName(beanPath).newInstance();\n//        } catch (Exception e) {\n//            e.printStackTrace();\n//        }\n//        return bean;\n//    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n----------------------------------------\n\n\n# 2. Spring IOC 与 DI\n\n\n# 1. IOC 控制反转 [Inversion Of Control]\n\n# 1. 控制反转解决色问题\n\n\n\n原来： 我们在获取对象时，都是采用 new 的方式。是主动的。\n\n\n\n现在：我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。\n\n这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。\n\n> 我的理解:\n> \n> 1.之前有自己new创建对象 [主动]\n> \n> 2.先在由媒人帮我找对象 [被动]\n\n# 2. IOC的概述 解耦合\n\n 1. 控制反转: 把创建的对象权利交给框架(工厂),是框架的重要特性,并非面向对象编程的专用术语,它包含**依赖注入(DI)**和依赖查询\n\n 2. 明确 ioc 的作用：削减计算机程序的耦合(解除我们代码中的依赖关系)。降低程序间的耦合(依赖关系)\n\n\n# 2. IOC入门应用\n\n# 1. 依赖\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.6.RELEASE</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2. 配置文件\n\n * bean.xml\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给Spring来管理--\x3e\n    \x3c!--accountService--\x3e\n    <bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"/>\n    \x3c!--accountDao--\x3e\n    <bean id="accountDao" class="com.chggx.dao.impl.AccountDaoImpl"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 3. ApplicationContext操作\n\n\n\nApplicationContext接口\n\n 1. ClassPathXmlApplicationContext\n    \n    * 可以加载类路径下的配置文件,要求配置文件必须在类路径下,不在的话,加载不了.[推荐]\n\n 2. FileSystemXmlApplicationContext\n    \n    * 它可以加载磁盘任意路径下的配置文件(必须有访问权限)\n\n 3. AnnotationConfigApplicationContext\n    \n    * 它是用于读取注解创建容器的.\n\n   /**\n     * 获取spring的Ioc核心容器,并根据id获取对象\n     * ApplicationContext:\n     *  1. ClassPathXmlApplicationContext: 可以加载类路径下的配置文件,要求配置文件必须在类路径下,不在的话,加载不了.[推荐]\n     *  2. FileSystemXmlApplicationContext: 它可以加载磁盘任意路径下的配置文件(必须有访问权限)\n     *  3. AnnotationConfigApplicationContext: 它是用于读取注解创建容器的.\n     */\n    public static void main(String[] args) {\n        // 1. 获取核心容器兑现\n//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        ApplicationContext ac = new FileSystemXmlApplicationContext("D:\\\\java-code\\\\kuangjia\\\\spring\\\\spring\\\\spring_03_ioc\\\\src\\\\main\\\\resources\\\\bean.xml");\n        // 2. 根据id获取bean对象\n        AccountService accountService = (AccountService) ac.getBean("accountService");\n        AccountDao accountDao = ac.getBean("accountDao", AccountDao.class);\n\n        System.out.println(accountService);\n        System.out.println(accountDao);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3. IOC核心容器的两个接口\n\n# 1. ApplicationContext 单例对象使用\n\nApplicationContext: [单例对象使用 如: service,dao]\n    它在构建核心容器时,创建对象策略是采用立即加载的方式,也就是说,只要一读取完配置文件(bean.xml)马上就创建配置文件中配置的对象(通过反射实现)\n    如: 以下代码 [立即加载]\n        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); 读取配置文件时候,通过反射就创建对象了\n\n\n1\n2\n3\n4\n\n\n# 2. BeanFactory 多例对象使用\n\nBeanFactory: [多例对象使用]\n    它在构建核心容器时,创建对象的策略采用延迟加载的方式,也就是说,什么时候根据id(bean容器对象的唯一标识)获取对象了,什么时候才真正的创建对象.\n    如: 以下代码 [延迟加载]\n        BeanFactory factory = new XmlBeanFactory(resource); 读取配置文件\n        AccountService accountService = (AccountService) factory.getBean("accountService"); 根据ID调用对象时候,才创建对象\n\n\n1\n2\n3\n4\n5\n\n\n# 3. 使用\n\n/**\n     * 1. 获取spring的Ioc核心容器,并根据id获取对象\n     *  ApplicationContext:\n     *      1). ClassPathXmlApplicationContext: 可以加载类路径下的配置文件,要求配置文件必须在类路径下,不在的话,加载不了.[推荐]\n     *      2). FileSystemXmlApplicationContext: 它可以加载磁盘任意路径下的配置文件(必须有访问权限)\n     *      3). AnnotationConfigApplicationContext: 它是用于读取注解创建容器的.\n     *  2. 核心容器的两个接口引发出的问题:\n     *  ApplicationContext: [单例对象使用 如: service,dao]\n     *      它在构建核心容器时,创建对象策略是采用立即加载的方式,也就是说,只要一读取完配置文件(bean.xml)马上就创建配置文件中配置的对象(通过反射实现)\n     *      如: 以下代码 [立即加载]\n     *          ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); 读取配置文件时候,通过反射就创建对象了\n     *  BeanFactory: [多例对象使用]\n     *      它在构建核心容器时,创建对象的策略采用延迟加载的方式,也就是说,什么时候根据id(bean容器对象的唯一标识)获取对象了,什么时候才真正的创建对象.\n     *      如: 以下代码 [延迟加载]\n     *          BeanFactory factory = new XmlBeanFactory(resource); 读取配置文件\n     *          AccountService accountService = (AccountService) factory.getBean("accountService"); 根据ID调用对象时候,才创建对象\n     */\n    public static void main(String[] args) {\n\n        // ============= ApplicationContext [立即加载] =============\n\n//        // 1. 获取核心容器对象 [推荐 ClassPathXmlApplicationContext方式创建]\n//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n////        ApplicationContext ac = new FileSystemXmlApplicationContext("D:\\\\java-code\\\\kuangjia\\\\spring\\\\spring\\\\spring_03_ioc\\\\src\\\\main\\\\resources\\\\bean.xml");\n//        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n//        AccountService accountService = (AccountService) ac.getBean("accountService");\n//        AccountDao accountDao = ac.getBean("accountDao", AccountDao.class);\n//\n//        System.out.println(accountService);\n//        System.out.println(accountDao);\n\n        // ============= BeanFactory [延迟加载] =============\n        // 1. 加载配置文件"bean.xml"\n        ClassPathResource resource = new ClassPathResource("bean.xml");\n        // 2. 读取配置文件\n        BeanFactory factory = new XmlBeanFactory(resource);\n        // 3. 根据id创建Bean对象\n        AccountService accountService = (AccountService) factory.getBean("accountService");\n        System.out.println(accountService);\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 4. spring对bean的管理细节\n\n# 1. 创建Bean的三种方式\n\n# 1. 构造函数创建对象\n\n第一种方式: 在spring的配置文件中使用bean标签,配以id和class属性之后,且没有其他属性和标签时,采用的就是默认构造函数创建bean对象,此时如果类中没有默认的构造函数,则对象无法创建\n\n\n1\n\n * 配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--\n         spring对bean的管理细节:\n             1. 创建Bean的三种方式\n             2. bean对象的作用范围\n             3. bean对象的生命周期\n    --\x3e\n    \x3c!--创建Bean的三种方式--\x3e\n    \x3c!--\n        第一种方式: 使用默认的构造函数创建\n                    在spring的配置文件中使用bean标签,配以id和class属性之后,且没有其他属性和标签时,采用的就是默认构造函数创建bean对象,此时如果类中没有默认的构造函数,则对象无法创建\n     --\x3e\n    <bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"/>\n\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 类 [构造函数]\n\npublic class AccountServiceImpl implements AccountService {\n\n    /**\n     * 创建bean的方式: 构造函数\n     */\n    public AccountServiceImpl() {\n        System.out.println("AccountServiceImpl 对象创建了...");\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount(){\n        System.out.println("service saveAccount() ......");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 2. 普通工厂的方法创建对象\n\n第二种方式: 使用普通工厂中的方法创建对象(使用某个类中的方法创建对象,并存入spring容器)\n\n\n1\n\n * 工厂类\n\npackage com.chggx.factory;\n\nimport com.chggx.service.AccountService;\nimport com.chggx.service.impl.AccountServiceImpl;\n\n/**\n * @Description: <h1> 模拟一个工厂类 </h1>\n * 该类可能存在于jar包中的,我们无法通过修改源码的方式来提供默认构造函数\n */\npublic class InstanceFactory {\n\n    /**\n     * 构造函数\n     * @return AccountService\n     */\n    public AccountService getAccountService(){\n        return new AccountServiceImpl();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给Spring来管理--\x3e\n    \x3c!--\n         spring对bean的管理细节:\n             1. 创建Bean的三种方式\n             2. bean对象的作用范围\n             3. bean对象的生命周期\n    --\x3e\n    \x3c!--创建Bean的三种方式--\x3e\n    \x3c!--\n        第一种方式: 使用默认的构造函数创建\n                    在spring的配置文件中使用bean标签,配以id和class属性之后,且没有其他属性和标签时,\n                    采用的就是默认构造函数创建bean对象,此时如果类中没有默认的构造函数,则对象无法创建\n    <bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"/>\n     --\x3e\n    \x3c!--第二种方式: 使用普通工厂中的方法创建对象(使用某个类中的方法创建对象,并存入spring容器)--\x3e\n    <bean id="instanceFactory" class="com.chggx.factory.InstanceFactory"/>\n    <bean id="accountService" factory-bean="instanceFactory" factory-method="getAccountService"/>\n\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 3. 工厂中的静态方法创建对象\n\n第三种方式: 使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象,并存入spring容器)\n\n\n1\n\n * 工厂类\n\npackage com.chggx.factory;\n\nimport com.chggx.service.AccountService;\nimport com.chggx.service.impl.AccountServiceImpl;\n\n/**\n * @Description: <h1> 模拟一个工厂类 </h1>\n * 该类可能存在于jar包中的,我们无法通过修改源码的方式来提供默认构造函数\n */\npublic class StaticFactory {\n\n    /**\n     * 构造函数\n     * @return AccountService\n     */\n    public static AccountService getAccountService(){\n        return new AccountServiceImpl();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给Spring来管理--\x3e\n    \x3c!--\n         spring对bean的管理细节:\n             1. 创建Bean的三种方式\n             2. bean对象的作用范围\n             3. bean对象的生命周期\n    --\x3e\n    \x3c!--创建Bean的三种方式--\x3e\n    \x3c!--\n        第一种方式: 使用默认的构造函数创建\n                    在spring的配置文件中使用bean标签,配以id和class属性之后,且没有其他属性和标签时,\n                    采用的就是默认构造函数创建bean对象,此时如果类中没有默认的构造函数,则对象无法创建\n    <bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"/>\n     --\x3e\n\n    \x3c!--第二种方式: 使用普通工厂中的方法创建对象(使用某个类中的方法创建对象,并存入spring容器)--\x3e\n   \x3c!--\n    <bean id="instanceFactory" class="com.chggx.factory.InstanceFactory"/>\n    <bean id="accountService" factory-bean="instanceFactory" factory-method="getAccountService"/>\n    --\x3e\n\n    \x3c!--第三种方式: 使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象,并存入spring容器)--\x3e\n    <bean id="accountService" class="com.chggx.factory.StaticFactory" factory-method="getAccountService"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 2. bean对象的作用范围 scope\n\nbean的scope属性:\n\n作用: 用于指定bean的作用范围\n取值: [常用单例的和多例的]\n\n\n1\n2\n\n\n类型               描述\nsingleton        单例的(默认值)\nprototype        多例的\nrequest          作用于web应用的请求范围\nsession          作用于web应用的会话范围\nglobal-session   作用于集群环境的会话范围(全局会话范围),当不是集群环境时,它就是session\n\n * 应用\n\n<bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl" scope="prototype"/>\n\n\n1\n\n\n# 3. bean对象的生命周期\n\n * 单例对象的生命周期和容器相同\n\n# 1. 单例 ==立即加载==\n\n * 配置文件\n\n\x3c!--bean对象生命周期--\x3e\n\x3c!--\n    单例对象: [立即加载]\n        出生: 当容器创建时对象创建\n        活着: 只要容器还在,对象一直存在\n        死亡: 容器销毁,对象消亡\n       总结: 单例对象的生命周期和容器相同\n --\x3e\n\x3c!--init-method="init": 初始化 destroy-method="destroy": 销毁--\x3e\n<bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"\n      scope="singleton" init-method="init" destroy-method="destroy" />\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 业务方法\n\npublic class AccountServiceImpl implements AccountService {\n\n    /**\n     * 创建bean的方式: 构造函数\n     */\n    public AccountServiceImpl() {\n        System.out.println("AccountServiceImpl 对象创建了...");\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount(){\n        System.out.println("service saveAccount() ......");\n    }\n\n    /**\n     * 初始化\n     */\n    public void init(){\n        System.out.println("object init...");\n    }\n\n    /**\n     * 结束销毁\n     */\n    public void destroy(){\n        System.out.println("object destroy...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * 调用方法\n\npublic class AccountController {\n    \n    public static void main(String[] args) {\n\n        // ============= ApplicationContext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 ClassPathXmlApplicationContext方式创建]\n        // 多态\n//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        AccountService accountService = (AccountService) ac.getBean("accountService");\n        // 3. 调用方法\n        accountService.saveAccount();\n\n        // 手动关闭容器destroy\n        ac.close();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 执行结果\n\nAccountServiceImpl 对象创建了...\nobject init...\nservice saveAccount() ......\nobject destroy...\n\n\n1\n2\n3\n4\n\n\n# 2. 多例 ==懒加载==\n\n * 配置文件\n\n\x3c!--bean对象生命周期--\x3e\n\x3c!--\n    单例对象: [立即加载]\n        出生: 当容器创建时对象创建\n        活着: 只要容器还在,对象一直存在\n        死亡: 容器销毁,对象消亡\n       总结: 单例对象的生命周期和容器相同\n    多例对象: [懒加载]\n        出生: 当我们使用对象时spring框架为我们创建\n        活着: 对象只要是在使用过程中就一直存在\n        死亡: 当对象长时间不用,且没有别的对象引用时,有Java的垃圾回收器回收\n --\x3e\n\x3c!--init-method="init": 初始化 destroy-method="destroy": 销毁--\x3e\n\x3c!--单例: 立即加载--\x3e\n\x3c!--    <bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"\n        scope="singleton" init-method="init" destroy-method="destroy" />--\x3e\n\x3c!--多例: 懒加载--\x3e\n<bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"\n      scope="prototype" init-method="init" destroy-method="destroy"/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 结果\n\nAccountServiceImpl 对象创建了...\nobject init...\nservice saveAccount() ......\n\n\n1\n2\n3\n\n\n\n# 5. 依赖注入 DI\n\n# 1. 概述\n\n * 依赖注入: Dependency Injection\n\n * IOC作用: 降低程序间的耦合(依赖关系)\n\n * 依赖关系管理: 以后都交给spring维护\n\n * 在当前类需要用到其类的对象,有spring为我们提供,我们只需要在配置文件中说明\n\n\n1\n\n * 依赖关系的维护: 称之为 依赖注入.\n\n# 2. 注入方式\n\n# 1. 构造方法\n\n 1. 使用标签: constructor-arg\n 2. 标签出现位置: bean标签的内部\n 3. 标签中的属性\n\n属性      描述\ntype    用于指定要注入的数据的数据类型,该数据类型也是构造函数中某个或某些参数类型\nindex   用于指定要注入的数据给构造函数中指定指定索引位置的参数赋值,所以得位置从0开始\nname    用于指定给构造函数中名称的参数赋值 [推荐]\nvalue   用于基本类型和String类型的数据\nref     用于指定其他的bean类型数据.它指的就是spring的Ioc核心容器中出现过的bean对象\n\n 4. 优势\n    * 在获取bean对象时,注入数据是必须操作.否则对象无法创建成功\n 5. 弊端\n    * 改变了bean对象的实例化方式,使我们创建对象时,如果用不到这些数据,也必须提供\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给Spring来管理--\x3e\n    \x3c!--\n     spring中的依赖注入 DI:\n        1. 依赖注入: Dependency Injection\n        2. IOC作用: 降低程序间的耦合(依赖关系)\n        3. 依赖关系管理: 以后都交给spring维护\n         * 在当前类需要用到其类的对象,有spring为我们提供,我们只需要在配置文件中说明\n        4. 依赖关系的维护: 称之为 依赖注入.\n        5. 依赖注入:\n            5.1 能注入的数据: [3类]\n                基本类型\n                其他bean类型(在配置文件中或者注解配置过得bean)\n                复杂类型/集合类型\n            5.2 注入的方式: [3种]\n                第一种: 使用构造方法\n                第二种: 使用set方法提供\n                第三种: 使用注解提供\n    --\x3e\n\n    \x3c!--\n    构造函数注入\n        使用标签: constructor-arg\n        标签出现位置: bean标签的内部\n        标签中的属性\n            type: 用于指定要注入的数据的数据类型,该数据类型也是构造函数中某个或某些参数类型\n            index: 用于指定要注入的数据给构造函数中指定指定索引位置的参数赋值,所以得位置从0开始\n            name: 用于指定给构造函数中名称的参数赋值 [推荐]\n            ============= 以上三个用于指定给构造函数中哪个参数赋值 ===========\n            value: 用于基本类型和String类型的数据\n            ref: 用于指定其他的bean类型数据.它指的就是spring的Ioc核心容器中出现过的bean对象\n        优势:\n            在获取bean对象时,注入数据是必须操作.否则对象无法创建成功\n        弊端:\n            改变了bean对象的实例化方式,使我们创建对象时,如果用不到这些数据,也必须提供\n    --\x3e\n    <bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl">\n        <constructor-arg name="name" value="构造函数注入"/>\n        \x3c!--String可自动转换为Integer--\x3e\n        <constructor-arg name="age" value="18"/>\n        \x3c!--Date: 需要配置日期对象--\x3e\n        <constructor-arg name="birthday" ref="now"/>\n    </bean>\n\n    \x3c!--配置一个日期对象--\x3e\n    <bean id="now"  class="java.util.Date"/>\n\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n * 构造方法类\n\npublic class AccountServiceImpl implements AccountService {\n\n    /**\n     * 如果是经常变化的数据,并不适用与注入方式\n     */\n    private String name;\n    private Integer age;\n    private Date birthday;\n\n    /**\n     * 依赖注入: 使用构造方法\n     */\n    public AccountServiceImpl(String name, Integer age, Date birthday) {\n        this.name = name;\n        this.age = age;\n        this.birthday = birthday;\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        System.out.println("service saveAccount() ......" + name + "," + age + "," + birthday);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 应用\n\npublic class AccountController {\n\n    public static void main(String[] args) {\n\n        // ============= ApplicationContext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 ClassPathXmlApplicationContext方式创建]\n        // 多态\n//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n\n        // ============= 依赖注入方式: 构造方法 ==============\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        AccountService accountService = (AccountService) ac.getBean("accountService");\n        // 3. 调用方法\n        accountService.saveAccount();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 2. set方法 [推荐: 可以使用默认的构造方法]\n\n 1. 使用标签: property\n 2. 标签出现位置: bean标签的内部\n 3. 标签中的属性\n\n属性      描述\nname    用于指定给构造函数中名称的参数赋值\nvalue   用于基本类型和String类型的数据\nref     用于指定其他的bean类型数据.它指的就是spring的Ioc核心容器中出现过的bean对象\n\n 4. 优势\n    \n    * 创建对象时没有明确的限制,可以直接使用默认的构造函数\n\n 5. 弊端\n    \n    * 如果有某个成员那必须有值,则获取对象是有可能set方法没有执行\n\n * 配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给Spring来管理--\x3e\n    \x3c!--\n     spring中的依赖注入 DI:\n        1. 依赖注入: Dependency Injection\n        2. IOC作用: 降低程序间的耦合(依赖关系)\n        3. 依赖关系管理: 以后都交给spring维护\n         * 在当前类需要用到其类的对象,有spring为我们提供,我们只需要在配置文件中说明\n        4. 依赖关系的维护: 称之为 依赖注入.\n        5. 依赖注入:\n            5.1 能注入的数据: [3类]\n                基本类型\n                其他bean类型(在配置文件中或者注解配置过得bean)\n                复杂类型/集合类型\n            5.2 注入的方式: [3种]\n                第一种: 使用构造方法\n                第二种: 使用set方法提供\n                第三种: 使用注解提供\n    --\x3e\n    \x3c!--配置一个日期对象--\x3e\n    <bean id="now"  class="java.util.Date"/>\n\n    \x3c!--\n    set方法注入 [推荐]\n        使用标签: property\n        标签出现位置: bean标签的内部\n        标签中的属性\n            name: 用于指定注入是所调用的set方法名称\n                set方法名称: setName ==== name\n            value: 用于基本类型和String类型的数据\n            ref: 用于指定其他的bean类型数据.它指的就是spring的Ioc核心容器中出现过的bean对象\n        优势:\n            创建对象时没有明确的限制,可以直接使用默认的构造函数\n        弊端:\n            如果有某个成员那必须有值,则获取对象是有可能set方法没有执行\n    --\x3e\n    <bean id="accountService2" class="com.chggx.service.impl.AccountService2Impl">\n        <property name="name" value="set方法注入"/>\n        <property name="age" value="21"/>\n        <property name="birthday" ref="now"/>\n    </bean>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n * set方法类\n\npublic class AccountService2Impl implements AccountService {\n\n    /**\n     * 如果是经常变化的数据,并不适用与注入方式\n     */\n    private String name;\n    private Integer age;\n    private Date birthday;\n\n    /**\n     * 依赖注入: 使用set方法\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        System.out.println("service saveAccount() ......" + name + "," + age + "," + birthday);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 应用\n\npublic class AccountController {\n\n    public static void main(String[] args) {\n\n        // ============= ApplicationContext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 ClassPathXmlApplicationContext方式创建]\n        // 多态\n//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n\n        // ============= 依赖注入方式: set方法 ==============\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        AccountService accountService2 = (AccountService) ac.getBean("accountService2");\n        // 3. 调用方法\n        accountService2.saveAccount();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 3. 注解方式\n\n * 详细参考 ioc 注解\n\n# 3. 能注入的数据\n\n# 1. 基本类型\n\n * 参考 注入方式 中的使用\n\n# 2. 其他bean类型(在配置文件中或者注解配置过得bean)\n\n * 参考 注入方式 中的使用\n\n# 3. 复杂类型/集合类型\n\n * 结论: 结构相同,标签可以互换\n\n 1. 配置文件\n\n\x3c!--复杂类型的注入/集合类型的注入--\x3e\n\x3c!--\n    用于list结构集合注入的标签: list,array,set\n    用于Map结构集合注入的标签: map,prop\n    * 结论: 结构相同,标签可以互换\n--\x3e\n<bean name="accountService3" class="com.chggx.service.impl.AccountService3Impl">\n    \x3c!--1. 数组--\x3e\n    <property name="myStr">\n        <array>\n            <value>array1</value>\n            <value>array2</value>\n            <value>array3</value>\n        </array>\n    </property>\n    \x3c!--2. list集合--\x3e\n    <property name="myList">\n        <list>\n            <value>list1</value>\n            <value>list2</value>\n            <value>list3</value>\n        </list>\n    </property>\n    \x3c!--3. set集合--\x3e\n    <property name="mySet">\n        <set>\n            <value>set1</value>\n            <value>set2</value>\n            <value>set3</value>\n        </set>\n    </property>\n    \x3c!--4. map集合--\x3e\n    <property name="myMap">\n        <map>\n            <entry key="map1" value="aaa"/>\n            <entry key="map2" value="bbb"/>\n        </map>\n    </property>\n    \x3c!--5. map集合--\x3e\n    <property name="myProps">\n        <props>\n            <prop key="prop1">111</prop>\n            <prop key="prop2">222</prop>\n        </props>\n    </property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n 2. 类\n\npublic class AccountService3Impl implements AccountService {\n\n    /**\n     * 能注入的数据类型:  复杂类型/集合类型\n     */\n    private String[] myStr;\n    private List<String> myList;\n    private Set<String> mySet;\n    private Map<String,String> myMap;\n    private Properties myProps;\n\n    /**\n     * 依赖注入: 使用set方法\n     */\n    public void setMyStr(String[] myStr) {\n        this.myStr = myStr;\n    }\n\n    public void setMyList(List<String> myList) {\n        this.myList = myList;\n    }\n\n    public void setMySet(Set<String> mySet) {\n        this.mySet = mySet;\n    }\n\n    public void setMyMap(Map<String, String> myMap) {\n        this.myMap = myMap;\n    }\n\n    public void setMyProps(Properties myProps) {\n        this.myProps = myProps;\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        System.out.println(Arrays.toString(myStr));\n        System.out.println(myList);\n        System.out.println(mySet);\n        System.out.println(myMap);\n        System.out.println(myProps);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n 3. 应用\n\npublic class AccountController {\n\n    public static void main(String[] args) {\n\n        // ============= ApplicationContext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 ClassPathXmlApplicationContext方式创建]\n        // 多态\n//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n\n        // ============= 能注入的数据类型: 复杂类型/集合类型 set方法注入 ==============\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        AccountService accountService3 = (AccountService) ac.getBean("accountService3");\n        // 3. 调用方法\n        accountService3.saveAccount();\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 6. ioc注解\n\n# 1. 用于创建对象的注解\n\n * 它们的作用就和XML配置文件中编写一个标签实现的功能是一样的\n\n注解            作用                       属性\n@Component    用于把当前类作为对象,存入spring容器中   value:用于指定bean的id.当我们不写时,它默认是当前类名,且首字母改小写\n@Controller   一般用于表现层                  属性/作用同上\n@Service      一般用于业务层                  属性/作用同上\n@Repository   一般用于持久层                  属性/作用同上\n\n# 1. @Component\n\n/**\n * @Description: <h1> 账户业务层实现类 </h1>\n * xml配置\n *     <bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"/>\n *     属性： id,class,scope,init-method,destroy-method,property,name,value|ref\n *  注解\n *      1. 用于创建对象的注解:\n *          它们的作用就和XML配置文件中编写一个<bean></bean>标签实现的功能是一样的\n *          @Component:\n *              作用: 用于把当前类作为对象,存入spring容器中\n *              属性:\n *                  value: 用于指定bean的id.当我们不写时,它默认是当前类名,且首字母改小写\n \t\t\t\t衍生注解: 下面三个 与 @Component 的作用和属性一模一样,是spring框架为我们提供明确的三层使用的注解,使用我们的三层对象更加清晰\n *                  @Controller: 一般用于表现层\n *                  @Service: 一般用于业务层\n *                  @Repository: 一般用于持久层\n \n *      2. 用于注入数据的\n *          它们的作用就和XML配置文件中编写一个bean标签写一个<property></property>的标签是一样的\n *      3. 用于改变作用范围的\n *          它们的作用就和XML配置文件中编写一个bean标签使用scope属性实现的功能是一样的\n *      4. 和生命周期有关的\n *          它们的作用就和XML配置文件中编写一个bean标签使用init-method,destroy-method的作用是一样的\n */\n@Component(value="accountServiceImpl")\npublic class AccountServiceImpl implements AccountService {\n\n    /**\n     * 普通方式 (耦合度高)\n     */\n    private AccountDao accountDao;\n\n    public AccountServiceImpl() {\n        System.out.println("AccountServiceImpl 对象创建了...");\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        accountDao.saveAccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n * 配置文件 (开启包扫描,使用注解)\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    \x3c!--把对象的创建交给Spring来管理--\x3e\n    \x3c!--1. xml方式实现--\x3e\n    \x3c!--accountService--\x3e\n    \x3c!--<bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"/>--\x3e\n    \x3c!--accountDao--\x3e\n    \x3c!--<bean id="accountDao" class="com.chggx.dao.impl.AccountDaoImpl"/>--\x3e\n\n    \x3c!--2. 注解方式实现--\x3e\n    \x3c!--\n    告知spring在创建容器时要扫描的包,配置所需要的标签不是在beans的约束中,而是一个名称为content名称空间和约束中\n    --\x3e\n    \x3c!--包扫描--\x3e\n    <context:component-scan base-package="com.chggx"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 应用\n\npublic class AccountController {\n\n    public static void main(String[] args) {\n        // ============= ApplicationContext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 ClassPathXmlApplicationContext方式创建]\n        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        AccountService accountService = (AccountService) ac.getBean("accountServiceImpl");\n\n        System.out.println(accountService);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2. 衍生注解使用\n\n * dao\n\n@Repository(value = "accountDao")\npublic class AccountDaoImpl implements AccountDao {\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        System.out.println("save success...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * service\n\n@Service(value="accountService")\npublic class AccountServiceImpl implements AccountService {\n\n    private AccountDao accountDao;\n\n//    public AccountServiceImpl() {\n//        System.out.println("AccountServiceImpl 对象创建了...");\n//    }\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        accountDao.saveAccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 应用\n\npublic class AccountController {\n\n    public static void main(String[] args) {\n        // ============= ApplicationContext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 ClassPathXmlApplicationContext方式创建]\n        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        AccountService accountService = (AccountService) ac.getBean("accountService");\n        System.out.println(accountService);\n\n        AccountDao accountDao = ac.getBean("accountDao", AccountDao.class);\n        System.out.println(accountDao);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 2. 用于注入数据的\n\n * 它们的作用就和XML配置文件中编写一个bean标签写一个的标签是一样的\n\n注解           作用                            类型\n@Autowired   注入数据(按照类型)                    注入其他bean类型\n@Qualifier   注入数据(配置和@Autowired解决多类型注入问题   注入其他bean类型\n@Resource    注入数据(取代上面两个注解,根据bean的id注入)    注入其他bean类型\n@Value       注入基本数据类型和String类型             基本类型和String类型\n\n# 1. @Autowired ==自动按照类型注入==\n\n作用: 自动按照类型注入.\n\t  1. 容器中有唯一的一个bean对象类型和要注入的变量类型匹配,就可以注入成功\n      2. 如果ioc容器中没有任何bean的类型和要注入变量类型匹配,则报错(不能注入)\n      3. 如果ioc容器中有多个类型匹配时,报错,引出新的注解: @Qualifier\n出现位置: 可以是变量上,也可以是方法上\n细节: 使用注解注入时,set方法不是必须的\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 问题\n\n如果ioc容器中有多个类型匹配时 使用@Autowired怎样操作?\n\n# 2. @Qualifier ==解决@Autowired多类型匹配==\n\n作用: 在自动按照类中注入的基础之上,在按照名称注入.\n      它在给类成员注入时不能单独使用.但是在给方法参数注入时可以\n属性:\n    value: 用于指定注入bean的id\n\n\n1\n2\n3\n4\n\n * dao\n\n@Repository(value = "accountDao2")\npublic class AccountDao2Impl implements AccountDao {\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        System.out.println("save success 222...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n@Repository(value = "accountDao1")\npublic class AccountDaoImpl implements AccountDao {\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        System.out.println("save success 111...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * service调用\n\n@Service(value="accountService")\npublic class AccountServiceImpl implements AccountService {\n\n    @Autowired\n    @Qualifier(value = "accountDao1")\n    private AccountDao accountDao;\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        accountDao.saveAccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 3. @Resource ==替换上边两个==\n\n 作用: 直接按照bean的id注入.可以单独使用\n 属性:\n    name: 用于指定bean的id\n\n\n1\n2\n3\n\n\n@Service(value="accountService")\npublic class AccountServiceImpl implements AccountService {\n\n//    @Autowired\n//    @Qualifier(value = "accountDao1")\n    @Resource(name = "accountDao1")\n    private AccountDao accountDao;\n\n//    public AccountServiceImpl() {\n//        System.out.println("AccountServiceImpl 对象创建了...");\n//    }\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        accountDao.saveAccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 4. @Value ==注入基本类型和String类型==\n\n作用: 用于注入基本类型和String类型的数据\n属性:\n   value: 用于指定数据的值,可以使用spring中SpEL(也就是spring的el表达式)\n          SpEL写法: ${表达式}\n\n\n1\n2\n3\n4\n\n\n# 5. 总结\n\n 1. @Autowired,@Qualifier,@Resource: 只能注入其他bean类型,而基本类型和String类型无法使用上述注解实现,另外,集合类型的注入只能通过xml来实现\n\n 2. @Value 解决了 ==基本类型和String类型== 的注入\n\n# 3. 用于改变作用范围的\n\n * 它们的作用就和XML配置文件中编写一个bean标签使用scope属性实现的功能是一样的\n\n@Scope\n\n作用: 用于指定bean的作用范围\n属性:\n    value: 指定范围的取值,常用取值: singleton(默认),property\n\n\n1\n2\n3\n\n\n@Scope(value = "singleton") // 方法时\n\n\n1\n\n\n# 4. 和生命周期有关的\n\n * 它们的作用就和XML配置文件中编写一个bean标签使用init-method,destroy-method的作用是一样的\n\n# 1. @PreDestroy ==销毁==\n\n * 作用: 用于指定销毁方法\n\n# 2. @PostConstruct ==初始胡==\n\n * 用于指定初始化方法\n\n# 3. 应用\n\n * 方法\n\n/**\n * @Description: <h1> 账户业务层实现类 </h1>\n * xml配置\n *     <bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"/>\n *     属性： id,class,scope,init-method,destroy-method,property,name,value|ref\n *  注解\n *      1. 用于创建对象的注解:\n *          它们的作用就和XML配置文件中编写一个<bean></bean>标签实现的功能是一样的\n *          @Component:\n *              作用: 用于把当前类作为对象,存入spring容器中\n *              属性:\n *                  value: 用于指定bean的id.当我们不写时,它默认是当前类名,且首字母改小写\n *              衍生注解: 下面三个 与 @Component 的作用和属性一模一样,是spring框架为我们提供明确的三层使用的注解,使用我们的三层对象更加清晰\n *                  @Controller: 一般用于表现层\n *                  @Service: 一般用于业务层\n *                  @Repository: 一般用于持久层\n *\n *      2. 用于注入数据的\n *          它们的作用就和XML配置文件中编写一个bean标签写一个<property></property>的标签是一样的\n *          @Autowired\n *              作用: 自动按照类型注入.\n *                    1. 容器中有唯一的一个bean对象类型和要注入的变量类型匹配,就可以注入成功\n *                    2. 如果ioc容器中没有任何bean的类型和要注入变量类型匹配,则报错(不能注入)\n *                    3. 如果ioc容器中有多个类型匹配时,报错,引出新的注解 @Qualifier\n *              出现位置: 可以是变量上,也可以是方法上\n *              细节: 使用注解注入时,set方法不是必须的\n *          @Qualifier:\n *              作用: 在自动按照类中注入的基础之上,在按照名称注入.\n *                    它在给类成员注入时不能单独使用.但是在给方法参数注入时可以\n *              属性:\n *                  value: 用于指定注入bean的id\n *          @Resource:\n *              作用: 直接按照bean的id注入.可以单独使用\n *              属性:\n *                 name: 用于指定bean的id\n *          总结: 以上三个注解只能注入其他bean类型,而基本类型和String类型无法使用上述注解实现.\n *                另外,集合类型的注入只能通过xml来实现\n *          @Value:\n *              作用: 用于注入基本类型和String类型的数据\n *              属性:\n *                 value: 用于指定数据的值,可以使用spring中SpEL(也就是spring的el表达式)\n *                        SpEL写法: ${表达式}\n *\n *      3. 用于改变作用范围的\n *          它们的作用就和XML配置文件中编写一个bean标签使用scope属性实现的功能是一样的\n *          @Scope:\n *              作用: 用于指定bean的作用范围\n *              属性:\n *                  value: 指定范围的取值,常用取值: singleton(默认),property\n *\n *      4. 和生命周期有关的 [了解]\n *          它们的作用就和XML配置文件中编写一个bean标签使用init-method,destroy-method的作用是一样的\n *          @PreDestroy:\n *              作用: 用于指定销毁方法\n *          @PostConstruct:\n *              作用: 用于指定初始化方法\n */\n@Service(value="accountService")\n@Scope(value = "singleton")\npublic class AccountServiceImpl implements AccountService {\n\n//    @Autowired\n//    @Qualifier(value = "accountDao1")\n    @Resource(name = "accountDao1")\n    private AccountDao accountDao;\n\n//    public AccountServiceImpl() {\n//        System.out.println("AccountServiceImpl 对象创建了...");\n//    }\n\n    /**\n     * 初始化方法\n     */\n    @PostConstruct\n    public void init() {\n        System.out.println("init...");\n    }\n\n    /**\n     * 销毁方法\n     */\n    @PreDestroy\n    public void destroy() {\n        System.out.println("destroy...");\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @Override\n    public void saveAccount() {\n        accountDao.saveAccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n * 调用\n\npublic class AccountController {\n\n    public static void main(String[] args) {\n        // ============= ApplicationContext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 ClassPathXmlApplicationContext方式创建]\n//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        AccountService accountService = (AccountService) ac.getBean("accountService");\n//        System.out.println(accountService);\n//        AccountDao accountDao = ac.getBean("accountDao", AccountDao.class);\n//        System.out.println(accountDao);\n        // 3. 调用方法\n        accountService.saveAccount();\n        // 4. 销毁\n        ac.close();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\ninit...\nsave success 111...\ndestroy...\n\n\n1\n2\n3\n\n\n\n# 3. spring的新注解\n\n\n# 1. 新注解\n\n注解                作用                                   取代BEAN.XML                                           属性\n@Configuration    指定一个配置类                                                                                   \n@ComponentScan    用于通过注解指定spring在创建容器时要扫描的包            <context:component-scan base-package="com.chggx"/>   basePackages(value)\n@Bean             用于把当前方法的返回值作为bean对象存入spring的ioc容器中                                                        name(默认值: 当前方法名称)\n@Import           用于导入其他的配置类                                                                                value: 1. 用于指定其他配置类的字节码 2.\n                                                                                                            当我们使用@Import的注解之后,有Import注解的类就是父配置类,而导入的都是子配置类\n@PropertySource   用于指定文件的名称和路径                                                                              value: 指定文件的名称和路径 关键字: classpath,表示类路径下\n\n\n# 2. 新注解取代xml\n\n# 1. xml形式\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    \x3c!--配置包扫描--\x3e\n    \x3c!--告知spring在创建容器时要包扫描--\x3e\n    <context:component-scan base-package="com.chggx"/>\n\n    \x3c!--配置QueryRunner: 改为多例 property--\x3e\n    <bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype">\n        \x3c!--注入数据源--\x3e\n        <constructor-arg name="ds" ref="dataSource"/>\n    </bean>\n\n    \x3c!--配置数据源 C3p0数据源--\x3e\n    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">\n        \x3c!--注入连接数据库的必备信息--\x3e\n        <property name="driverClass" value="com.mysql.jdbc.Driver"/>\n        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_jdbc"/>\n        <property name="user" value="root"/>\n        <property name="password" value="326868"/>\n    </bean>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 2. 注解形式\n\n * 父配置类\n\n/**\n * @Description: <h1> spring配置类,作用和bean.xml一样 </h1>\n * spring中的新注解:\n *      @Configuration:\n *          作用: 指定一个配置类\n *          细节:\n *              当配置类作为 new AnnotationConfigApplicationContext(SpringConfiguration.class) 对象创建的参数时,该注解可以不写,否则还是要写\n *      @ComponentScan:\n *          作用: 用于通过注解指定spring在创建容器时要扫描的包\n *                            同bean.xml中的\n *          属性:\n *               basePackages: 指定创建容器时要扫描的包\n *               value: 1). 它和 basePackages 的作用是一样的,都是用于指定创建容器时要扫描的包\n *                      2). 我们使用次注解就等同于在xml中配置了:\n *                                  <context:component-scan base-package="com.chggx"/>\n *      @Bean:\n *           作用: 用于把当前方法的返回值作为bean对象存入spring的ioc容器中\n *           属性:\n *               name: 用于指定bean的id. 当不写时.默认值就是当前方法名称\n *           细节:\n *               当我们使用注解方式时,如果方法有参数: spring框架会去容器中查找有没有可用的bean对象.\n *               查找的方式和@Autowired注解的作用是一样的\n *      @Import:\n *           作用: 用于导入其他的配置类\n *           属性:\n *              value: 1. 用于指定其他配置类的字节码\n *                     2. 当我们使用@Import的注解之后,有Import注解的类就是父配置类,而导入的都是子配置类,相当于new AnnotationConfigApplicationContext(SpringConfiguration.class);\n *      @PropertySource:\n *           作用: 用于指定文件的名称和路径\n *           属性:\n *              value: 指定文件的名称和路径\n *                      关键字: classpath,表示类路径下\n */\n//@Configuration\n@ComponentScan(basePackages = {"com.chggx","com.chggx.config"})\n@Import(value = {JdbcConfig.class})\n@PropertySource(value = "classpath:jdbcConfig.properties")\npublic class SpringConfiguration {\n\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n * 数据原配置 (自配置类)\n\n/**\n * @Description: <h1> 和spring连接数据库相关的配置类 </h1>\n */\n//@Configuration\npublic class JdbcConfig {\n\n    /**\n     * @Value: 注入数据(基本类型和String类型)\n     */\n    @Value("${jdbc.driver}")\n    private String driver;\n\n    @Value("${jdbc.url}")\n    private String url;\n\n    @Value("${jdbc.username}")\n    private String username;\n\n    @Value("${jdbc.password}")\n    private String password;\n\n    /**\n     * 用于创建一个 QueryRunner 对象\n     *  作用范围多例: prototype\n     * @param dataSource 数据源\n     * @return QueryRunner\n     */\n    @Bean(name = "runner")\n    @Scope(value = "prototype")\n    public QueryRunner createQueryRunner(DataSource dataSource) {\n        return new QueryRunner(dataSource);\n    }\n\n    /**\n     * 配置数据源\n     * @return DataSource\n     */\n    @Bean(name = "dataSource")\n    public DataSource createDataSource() {\n        try {\n            // C3p0数据源\n            ComboPooledDataSource dataSource = new ComboPooledDataSource();\n            dataSource.setDriverClass(driver);\n            dataSource.setJdbcUrl(url);\n            dataSource.setUser(username);\n            dataSource.setPassword(password);\n            return dataSource;\n        } catch (PropertyVetoException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n * 数据源配置文件 jdbcConfig.properties\n\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/spring_jdbc\njdbc.username=root\njdbc.password=326868\n\n\n1\n2\n3\n4\n\n\n\n# 3. @Qualifier另一种使用\n\n 1. 之前配合**@Autowired**来解决多类型注入问题.\n 2. 现在在Spring中另一种使用\n    * 解决与上边相似,如注入数据源是,数据源多个时,使用**@Qualifier**来确定\n\n/**\n * 用于创建一个 QueryRunner 对象\n *  1. 作用范围多例: prototype\n *  2. 当有DataSource 是有多个数据源(多类型)时,此外用@Qualifier("dataSource1"): 来确定注入的类型(同@Autowired)\n * @param dataSource 数据源\n * @return QueryRunner\n */\n@Bean(name = "runner")\n@Scope(value = "prototype")\npublic QueryRunner createQueryRunner(@Qualifier("dataSource1") DataSource dataSource) {\n    return new QueryRunner(dataSource);\n}\n\n/**\n * 配置数据源 1\n * @return DataSource\n */\n@Bean(name = "dataSource1")\npublic DataSource createDataSource() {\n    try {\n        // C3p0数据源\n        ComboPooledDataSource dataSource = new ComboPooledDataSource();\n        dataSource.setDriverClass(driver);\n        dataSource.setJdbcUrl(url);\n        dataSource.setUser(username);\n        dataSource.setPassword(password);\n        return dataSource;\n    } catch (PropertyVetoException e) {\n        throw new RuntimeException(e);\n    }\n}\n\n/**\n * 配置数据源 2\n * @return DataSource\n */\n@Bean(name = "dataSource2")\npublic DataSource createDataSource2() {\n    try {\n        // C3p0数据源\n        ComboPooledDataSource dataSource = new ComboPooledDataSource();\n        dataSource.setDriverClass(driver);\n        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mybatisdb");\n        dataSource.setUser(username);\n        dataSource.setPassword(password);\n        return dataSource;\n    } catch (PropertyVetoException e) {\n        throw new RuntimeException(e);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 4. junit\n\n# 1. 普通junit\n\n\x3c!--junit 测试--\x3e\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n * 问题\n\n1、应用程序的入口\n\tmain方法\n2、junit单元测试中，没有main方法也能执行\n\tjunit集成了一个main方法\n\t该方法就会判断当前测试类中哪些方法有 @Test注解\n\tjunit就让有Test注解的方法执行\n3、junit不会管我们是否采用spring框架\n\t在执行测试方法时，junit根本不知道我们是不是使用了spring框架\n\t所以也就不会为我们读取配置文件/配置类创建spring核心容器\n4、由以上三点可知\n\t当测试方法执行时，没有Ioc容器，就算写了Autowired注解，也无法实现注入\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 2. Spring集成junit\n\n * 依赖\n\n\x3c!--spring test--\x3e\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>5.2.6.RELEASE</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n * 配置\n\nSpring整合junit的配置:\n     1. 导入spring整合junit的jar包(即: 坐标)\n     2. 使用Junit提供的一个注解把所有的main方法提花了,替换成spring提供的\n         @RunWith: SpringJUnit4ClassRunner.class\n     3. 告知spring的运行器,spring的ioc创建是基于xml还是注解的,并且说明位置\n         @ContextConfiguration:\n              locations(value): 指定xml文件的位置,加上classpath关键字,表示在类路径下\n                 @ContextConfiguration(locations = "classpath:bean.xml")\n              classes: 指定注解(配置)类所在的位置\n                 @ContextConfiguration(classes = SpringConfiguration.class)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3. 案例 ==注解形式==\n\n@RunWith(SpringJUnit4ClassRunner.class)\n//@ContextConfiguration(locations = "classpath:bean.xml")\n@ContextConfiguration(classes = SpringConfiguration.class)\npublic class AccountServiceTest {\n\n    /**\n     * spring 整合 junit 方式: 可以使用 @Autowired 注入数据\n     */\n    @Autowired\n    private AccountService accountService;\n\n//    @Before\n//    public void before() {\n//        // =========== AnnotationConfigApplicationContext: 注解形式 ============\n//        // 1. 获取容器\n//        // 使用配置文件方式\n////        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");\n//        //  使用配置类方式 SpringConfiguration\n//        ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);\n//        // 得到业务对象\n//        accountService = ac.getBean("accountService", AccountService.class);\n//    }\n\n    @Test\n    public void testFindAllAccount() {\n        // 查询所有\n        List<Account> accounts = accountService.findAllAccount();\n        accounts.forEach(System.out::println);\n    }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n----------------------------------------\n\n\n# 4. 动态代理(proxy)\n\n * 概述\n\n动态代理:\n    特点: 字节码随用随创建,随用随加载\n    作用: 不修改源码的基础上对方法增强\n    分类:\n        1). 基于接口的动态代理\n            涉及的类: Proxy\n            提供者,JDK官方\n        2). 基于子类的动态代理\n            涉及的类: Enhancer\n            提供者: 第三方cglib库\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 1. 基于接口的动态代理\n\n# 1. 概述\n\n基于接口的动态代理\n     如何创建代理对象:\n         使用Proxy类中的newProxyInstance方法\n     创建代理对象的要求:\n         被代理的类最少实现一个接口,如果没有则不能使用\n     newProxyInstance方法的参数:\n        1). ClassLoader loader: 类加载器\n                它是用于加载代理对象字节码的.和被代理对象使用相同的类加载器.[固定写法]\n        2). Class<?>[] interfaces: 字节码数组\n                它是用于让代理对象和被代理对象有相同方法.[固定写法]\n        3). InvocationHandler h: 用于提供者增强的代码\n                 它是让我们写如何代理.我们一般都是写一个该接口的实现类.通常情况下都是匿名内部类,但不是必须的.\n                  此接口谁用谁写\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 2. 代码实现\n\n * 生产者接口类\n\npublic interface ProducerInterface {\n\n    /**\n     * 销售\n     *\n     * @param money money\n     */\n    public void saleProducer(float money);\n\n    /**\n     * 售后\n     *\n     * @param money money\n     */\n    public void afterService(float money);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 生产者接口类实现\n\npublic class Producer implements ProducerInterface {\n\n    /**\n     * 销售\n     * @param money money\n     */\n    public void saleProducer(float money) {\n        System.out.println("销售产品,并拿到钱" + money);\n    }\n\n    /**\n     * 售后\n     * @param money money\n     */\n    public void afterService(float money) {\n        System.out.println("提供售后服务,并拿到钱" + money);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 消费者\n\npublic class Client {\n\n    public static void main(String[] args) {\n        // 1. 原来\n//        Producer producer = new Producer();\n//        producer.saleProducer(10000f);\n        // 2. 动态代理\n        final Producer producer = new Producer();\n\n        // 有反射\n        ProducerInterface proxyProducer = (ProducerInterface) Proxy.newProxyInstance(\n                // 1. 类加载器 [固定写法]\n                producer.getClass().getClassLoader(),\n                // 2. 字节码数组 [固定写法]\n                producer.getClass().getInterfaces(),\n                // 3. 用于提供者增强的代码 [匿名内部类]\n                new InvocationHandler() {\n                    /**\n                     * 作用: 执行被代理对象的任何接口方法都会经过该方法[拦截作用]\n                     * @param proxy     代理对象\n                     * @param method    当前执行的方法\n                     * @param args      当前执行方法所需的参数\n                     * @return 和被代理对象方法有相同的方绘制\n                     * @throws Throwable 异常\n                     */\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        // 提供增强的代码\n                        Object returnValue = null;\n                        // 1. 获取方法执行的参数\n                        Float money = (Float) args[0];\n                        // 2. 判断当前方法是不是销售\n                        // 要代理方法名\n                        String methodName = "saleProducer";\n                        if (methodName.endsWith(method.getName())) {\n                            returnValue = method.invoke(producer, money * 0.8f);\n                        }\n                        return returnValue;\n                    }\n                });\n        proxyProducer.saleProducer(10000f);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 2. 基于子类的动态代理\n\n * 依赖\n\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib</artifactId>\n    <version>3.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 1. 概述\n\n动态代理:\n    特点: 字节码随用随创建,随用随加载\n    作用: 不修改源码的基础上对方法增强\n    分类:\n        1). 基于接口的动态代理\n            涉及的类: Proxy\n            提供者,JDK官方\n        2). 基于子类的动态代理\n            涉及的类: Enhancer\n            提供者: 第三方cglib库\n    基于子类的动态代理\n         如何创建代理对象:\n             使用Enhancer类中的create方法\n         创建代理对象的要求:\n             被代理的类不是最终类\n         create方法的参数:\n            1). class: 字节码\n                    它是用于加载代理对象字节码的.和被代理对象使用相同的类加载器.[固定写法]\n            2). Class<?>[] interfaces: 字节码数组\n                    它是用于让代理对象和被代理对象有相同方法.[固定写法]\n            3). InvocationHandler h: 用于提供者增强的代码\n                     它是让我们写如何代理.我们一般都是写一个该接口的实现类.通常情况下都是匿名内部类,但不是必须的.\n                      此接口谁用谁写\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 2. 实现\n\n * 生产者\n\npublic class Producer{\n\n    /**\n     * 销售\n     * @param money money\n     */\n    public void saleProducer(float money) {\n        System.out.println("销售产品,并拿到钱" + money);\n    }\n\n    /**\n     * 售后\n     * @param money money\n     */\n    public void afterService(float money) {\n        System.out.println("提供售后服务,并拿到钱" + money);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 消费者\n\n   public static void main(String[] args) {\n        // 1. 原来\n//        Producer producer = new Producer();\n//        producer.saleProducer(10000f);\n        // 2. 动态代理\n        final Producer producer = new Producer();\n\n        // 有反射\n        Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() {\n            /**\n             * 执行被代理对象的任何方法都会经过该方法\n             * @param o              代理对象\n             * @param method         当前执行的方法\n             * @param objects        当前执行方法所需的参数\n             * @param methodProxy    当前执行方法的代理对象\n             * @return\n             * @throws Throwable\n             */\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                // 提供增强的代码\n                Object returnValue = null;\n                // 1. 获取方法执行的参数\n                Float money = (Float) objects[0];\n                // 2. 判断当前方法是不是销售\n                // 要代理方法名\n                String methodName = "saleProducer";\n                if (methodName.endsWith(method.getName())) {\n                    returnValue = method.invoke(producer, money * 0.8f);\n                }\n                return returnValue;\n            }\n        });\n        cglibProducer.saleProducer(10000f);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3. 案例\n\n * 参考spring_10_case\n\n# 1. 事务问题\n\n * 自定义事务\n\npublic class TransactionManager {\n\n    private ConnectionUtils connectionUtils;\n\n    public void setConnectionUtils(ConnectionUtils connectionUtils) {\n        this.connectionUtils = connectionUtils;\n    }\n\n    /**\n     * 开启事务\n     */\n    public void beginTransaction(){\n        try {\n            connectionUtils.getThreadConnection().setAutoCommit(false);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 提交事务\n     */\n    public void commit(){\n        try {\n            connectionUtils.getThreadConnection().commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 回滚事务\n     */\n    public void rollback(){\n        try {\n            connectionUtils.getThreadConnection().rollback();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 释放事务\n     */\n    public void release(){\n        try {\n            // 还回连接池中,线程还回,不是关闭\n            connectionUtils.getThreadConnection().close();\n            // 把连接和线程解绑\n            connectionUtils.removeConnection();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n * 使用\n\npublic Account findAccountById(Integer accountId) {\n    try {\n        // 1. 开启事务\n        transactionManager.beginTransaction();\n        // 2. 执行操作\n        Account account = accountDao.findAccountById(accountId);\n        // 3. 提交事务\n        transactionManager.commit();\n        // 4. 返回结果\n        return account;\n    } catch (Exception e) {\n        // 5. 回滚操作\n        transactionManager.rollback();\n        throw new RuntimeException(e);\n    } finally {\n        // 6. 释放连接\n        transactionManager.release();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 引发的问题: 每个方法都需要值执行上面的6步骤(代码冗余),有什么方法可以解决.?\n\n# 2. 基于接口的动态地理方式处理\n\n# 1. 创建代理工厂\n\n * 代理Server增强方法\n\npublic class BeanFactory {\n\n    private AccountService accountService;\n    /**\n     * 事务工具类\n     */\n    private TransactionManager transactionManager;\n\n    /**\n     * set方式注入\n     *\n     * @param accountService\n     */\n    public void setAccountService(AccountService accountService) {\n        this.accountService = accountService;\n    }\n\n    public final void setTransactionManager(TransactionManager transactionManager) {\n        this.transactionManager = transactionManager;\n    }\n\n    /**\n     * 获取Service代理对象\n     *\n     * @return\n     */\n    public AccountService getAccountService() {\n        return (AccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),\n                accountService.getClass().getInterfaces(),\n                new InvocationHandler() {\n                    /**\n                     * 添加事务支持\n                     * @param proxy\n                     * @param method\n                     * @param args\n                     * @return\n                     * @throws Throwable\n                     */\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        Object reValue = null;\n                        try {\n                            // 1. 开启事务\n                            transactionManager.beginTransaction();\n                            // 2. 执行操作\n                            reValue = method.invoke(accountService, args);\n                            // 3. 提交事务\n                            transactionManager.commit();\n                            // 4. 返回结果\n                            return reValue;\n                        } catch (Exception e) {\n                            // 5. 回滚操作\n                            transactionManager.rollback();\n                            throw new RuntimeException(e);\n                        } finally {\n                            // 6. 释放连接\n                            transactionManager.release();\n                        }\n                    }\n                });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n * 配置文件\n\n\x3c!--配置代理Service--\x3e\n<bean id="proxyAccountService" factory-bean="beanFactory" factory-method="getAccountService"/>\n\n\x3c!--配置beanFactory--\x3e\n<bean id="beanFactory" class="com.chggx.factory.BeanFactory">\n    \x3c!--注入Dao对象--\x3e\n    <property name="accountService" ref="accountService"/>\n    \x3c!--注入事务管理--\x3e\n    <property name="transactionManager" ref="transactionManager"/>\n</bean>\n\n\x3c!--配置Service--\x3e\n<bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl">\n    \x3c!--注入Dao对象--\x3e\n    <property name="accountDao" ref="accountDao"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n通过代理的方式我们解决了上面出现的代码冗余问题,此时同样也出现的了一个问题.配置过于繁琐..... 我们可以利用Sprng AOP解决\n\n----------------------------------------\n\n\n# 5. Spring AOP\n\n\n# 1. 概述\n\n# 1. 什么是AOP\n\nAOP：全称是 Aspect Oriented Programming 即：面向切面编程。\n\n简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。\n\n\n1\n\n\n# 2. AOP优势\n\n作用：\n\t在程序运行期间，不修改源码对已有方法进行增强。\n优势：\n    减少重复代码\n    提高开发效率\n    维护方便\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 3. AOP 的实现方式\n\n使用动态代理技术\n\n\n# 2. AOP术语\n\n1. Joinpoint(连接点): 所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。 [业务层的方法]\n2. Pointcut(切入点): 所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。[切入点: 被增强的方法, 并不是所有的连接点都是,只有被增强的方法才称为"切入点" ]\n3. Advice(通知/增强): 所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。\n4. Introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。\n5. Target(目标对象): 代理的目标对象。\n6. Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。\n7. Proxy（代理）: 一个类被 AOP 织入增强后，就产生一个结果代理类。\n8. Aspect(切面): 是切入点和通知（引介）的结合。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3. AOP使用\n\n\x3c!--AspectJ: 解析切入点表达式--\x3e\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.9.5</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 1. 切入点表达式\n\n1). 关键字: execution(表达式)\n2). 表达式:\n        访问修饰符 返回值 包名.包名.包名...类名.方法名.(参数列表)\n3). 标准写法:\n        public void com.chggx.service.impl.AccountServiceImpl.saveAccount()\n        PS: 1. 访问修饰符省略:  void com.chggx.service.impl.AccountServiceImpl.saveAccount()\n            2. 返回值可以使用任意通配符,表示任意返回值:  * com.chggx.service.impl.AccountServiceImpl.saveAccount()\n            3. 包名可以使用统配符,表示任意包(注意: 有几级包,就写几个"*"):  * *.*.*.AccountServiceImpl.saveAccount()\n            4. 可以使用 "..": 表示当前包及其子包:  * *..AccountServiceImpl.saveAccount()\n            5. 类名和方法名都可以使用 "*" 来实现通配 * *..*.*()\n            6. 参数列表:\n                    1. 可以直接写数据类型\n                        1. 基本类型: 直接写名称  [int]: * *..*.*(int)\n                        2. 引用类型: "包名.类名" 方式  [java.lang.String]\n                    2. 可以直接使用统配符 "*" 表示任意类型,但必须有参数:  * *..*.*(*)\n                    3. 可以使用 "..": 表示有无参数均可,有参数可以是任意类型: * *..*(..)\n4). 全通配符写法\n        * *..*(..)\n5). 实际开发过程中切入点表达式的通常写法:\n        切到业务层实现类下的所有方法:  * com.chggx.service.impl.*.*(..)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 2. spring基于XML的AOP配置\n\n1. 把通知Bean也交给spring来管理\n2. 使用 aop:config 标签表名开始AOP的配置\n3. 使用 aop:aspect 标签表名配置切面\n        id属性: 给切面提供一个唯一ID\n        ref属性: 是指定通知类bean的id\n4. 在 aop:aspect 标签的内部使用对应标签来配置通知类型\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 1. 入门\n\n\n\n * 配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!--配置spring ioc: 把service对象配置进来 连接点: 业务层的方法--\x3e\n    <bean id="accountService" class="com.chggx.service.impl.AccountServiceImpl"/>\n\n    \x3c!--配置Logger类: 用于增强业务层的方法(记录日志)--\x3e\n    <bean id="logger" class="com.chggx.utils.Logger"/>\n\n    \x3c!--配置AOP--\x3e\n    <aop:config>\n        \x3c!--配置切面--\x3e\n        <aop:aspect id="logAdvice" ref="logger">\n            \x3c!--\n                1. 配置通知类型: 前置通知\n                2. 通知方法: printLog() Logger类中的方法\n                3. 切入点表达式: execution(public void com.chggx.service.impl.AccountServiceImpl.saveAccount()): 用于增强的方法\n            --\x3e\n            <aop:before method="printLog"\n                        pointcut="execution(public void com.chggx.service.impl.AccountServiceImpl.saveAccount())"/>\n        </aop:aspect>\n    </aop:config>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 2. 通知类型\n\n通知类型   作用                                   \n前置通知   在切入点方法执行之前执行                         before\n后置通知   在切入点方法正常执行之后执行. (它和异常通知永远只会执行一个)     after-returning\n异常通知   在切入点方法执行产生异常之后执行. (它和后置通知永远只会执行一个)   after-throwing\n最终通知   无论切入点方法是否正常执行,它都会在其后面执行              after\n环绕通知   一种可以在代码中手动控制增强方法何时执行的方式。[推荐}         around\n\n# 1. xml写法\n\n\n\n\x3c!--配置AOP--\x3e\n<aop:config>\n    \x3c!--配置切面--\x3e\n    <aop:aspect id="logAdvice" ref="logger">\n        \x3c!--前置通知: 在切入点方法执行之前执行--\x3e\n        <aop:before method="beforePrintLog" pointcut="execution(public void com.chggx.service.impl.AccountServiceImpl.saveAccount())"/>\n        \x3c!--后置通知: 在切入点方法正常执行之后执行. (它和异常通知永远只会执行一个)--\x3e\n        <aop:after-returning method="afterReturningPrintLog" pointcut="execution(public void com.chggx.service.impl.AccountServiceImpl.saveAccount())"/>\n        \x3c!--异常通知: 在切入点方法执行产生异常之后执行. (它和后置通知永远只会执行一个)--\x3e\n        <aop:after-throwing method="afterThrowPrintLog" pointcut="execution(public void com.chggx.service.impl.AccountServiceImpl.saveAccount())"/>\n        \x3c!--最终通知: 无论切入点方法是否正常执行,它都会在其后面执行--\x3e\n        <aop:after method="afterPrintLog" pointcut="execution(public void com.chggx.service.impl.AccountServiceImpl.saveAccount())"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2. 优化代码\n\n * 在标签</aop:aspect>内\n\n\n\n * 在标签 </aop:aspect>外\n\n\n\n# 3. 环绕通知 😄\n\n# 1. 环绕通知问题\n\n * 配置文件\n\n\x3c!--配置AOP--\x3e\n<aop:config>\n    \x3c!--\n         配置切入点表达式:\n      --\x3e\n    <aop:pointcut id="ptl" expression="execution(* com.chggx.service.impl.*.*(..))"/>\n    \x3c!--配置切面--\x3e\n    \x3c!-- pointcut-ref属性: 用于配置切入点表达式--\x3e\n    <aop:aspect id="logAdvice" ref="logger">\n        \x3c!--配置环绕通知: 详细注释(Logger类)--\x3e\n        <aop:around method="aroundPrintLog" pointcut-ref="ptl"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 方法\n\n/**\n * 环绕通知方法\n */\npublic void aroundPrintLog(){\n    System.out.println("环绕通知log中的before...");\n}\n\n\n// 被增强的方法\n    @Override\n    public void saveAccount() {\n        System.out.println("save...");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 结果\n\nE:\\develop\\Java\\jdk1.8.0_91\\bin\\java.exe -\n环绕通知log中的before...\n\n\n1\n2\n\n * 问题: 当我们配置了环绕通知之后,切入点方法没有执行,而通知方法执行了?\n\n# 2. 解决\n\n通过代理的方式实现事务控制分析\n\n\n\n1. 分析：\n       通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。\n2. 解决：\n       Spring框架为我们提供了一个接口："ProceedingJoinPoint"。"该接口有一个方法proceed()"，此方法就相当于明确调用"切入点方法"。\n       该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。\n3. spring中的环绕通知：\n       它是spring框架为我们提供的"一种可以在代码中手动控制增强方法何时执行的方式。"\n       可以使用代码的方式实现其余4中通知\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\npublic Object aroundPrintLog(ProceedingJoinPoint point) {\n    Object reValue = null;\n    try {\n        // 得到方法执行所需要的参数\n        Object[] args = point.getArgs();\n        System.out.println("环绕通知log中的...前置通知");\n        // 明确调用业务层方法(切入点方法)\n        reValue = point.proceed(args);\n        System.out.println("环绕通知log中的...后置通知");\n\n        return reValue;\n    } catch (Throwable throwable) {\n        System.out.println("环绕通知log中的...异常通知");\n        throw new RuntimeException(throwable);\n    } finally {\n        System.out.println("环绕通知log中的...最终通知");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3. 基于注解AOP配置 推荐环绕通知\n\n通知类型   作用                                   \n前置通知   在切入点方法执行之前执行                         @Before\n后置通知   在切入点方法正常执行之后执行. (它和异常通知永远只会执行一个)     @AfterReturning\n异常通知   在切入点方法执行产生异常之后执行. (它和后置通知永远只会执行一个)   @AfterThrowing\n最终通知   无论切入点方法是否正常执行,它都会在其后面执行              @Ater\n环绕通知   一种可以在代码中手动控制增强方法何时执行的方式。[推荐]         @Around\n\n# 1. 配置\n\n * XML配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd">\n\n    \x3c!--配置spring创建容器时要扫描的包--\x3e\n    <context:component-scan base-package="com.chggx"/>\n\n    \x3c!--配置spring开启注解AOP的支持--\x3e\n    <aop:aspectj-autoproxy/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 注解配置\n\n@Configuration\n@ComponentScan(basePackages="com.itheima")\n@EnableAspectJAutoProxy\npublic class SpringConfiguration {\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 2. 通知类\n\n@Component("logger")\n@Aspect // 当前类是一个切面类\npublic class Logger {\n\n    @Pointcut("execution(* com.chggx.service.impl.*.*(..))")\n    private void ptl(){\n\n    }\n\n    /**\n     * 前置通知\n     */\n    @Before("ptl()")\n    public void beforePrintLog() {\n        System.out.println("前置通知log中的before...");\n    }\n\n    /**\n     * 后置通知\n     */\n    @AfterReturning("ptl()")\n    public void afterReturningPrintLog() {\n        System.out.println("后置通知log中的afterReturning...");\n    }\n\n    /**\n     * 异常通知\n     */\n    @AfterThrowing("ptl()")\n    public void afterThrowPrintLog() {\n        System.out.println("异常通知log中的afterThrow...");\n    }\n\n    /**\n     * 最终通知\n     */\n    @After("ptl()")\n    public void afterPrintLog() {\n        System.out.println("最终通知log中的after...");\n    }\n\n    /**\n     * 环绕通知\n     * 1. 问题:\n     * 当我们配置了环绕通知之后,切入点方法没有执行,而通知方法执行了\n     * 2. 分析：\n     * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。\n     * 3. 解决：\n     * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。\n     * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。\n     * <p>\n     * 4. spring中的环绕通知：\n     * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。\n     */\n    @Around("ptl()")\n    public Object aroundPrintLog(ProceedingJoinPoint point) {\n        Object reValue = null;\n        try {\n            // 得到方法执行所需要的参数\n            Object[] args = point.getArgs();\n            System.out.println("环绕通知log中的...前置通知");\n            // 明确调用业务层方法(切入点方法)\n            reValue = point.proceed(args);\n            System.out.println("环绕通知log中的...后置通知");\n\n            return reValue;\n        } catch (Throwable throwable) {\n            System.out.println("环绕通知log中的...异常通知");\n            throw new RuntimeException(throwable);\n        } finally {\n            System.out.println("环绕通知log中的...最终通知");\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n当我们使用.我们推荐使用环绕通知,因为其余4个通知在使用时,最终通知在后置通知之前执行\n\n前置通知log中的before...\nsave...\n最终通知log中的after...\n后置通知log中的afterReturning...\n\n\n1\n2\n3\n4\n\n\n\n# 6. Spring中的JdbcTemplate',normalizedContent:'# spring基础\n\n\n# 1. spring优势\n\n 1. 方便解耦，简化开发\n    * 通过 spring 提供的 ioc 容器，可以将对象间的依赖关系交由 spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。\n 2. aop 编程的支持\n 3. 声明式事务的支持\n 4. 方便程序的测试\n 5. 方便集成各种优秀框架\n 6. 降低 javaee api 的使用难度\n\n\n# 2. spring体系结构\n\n> # 1. spring5模快结构图\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 3. 入门jdbc操作 程序解耦\n\n/**\n * @author: chggx\n * @description: <h1> 程序耦合 </h1>\n * 耦合: 程序间的依赖关系\n *      1. 类之间依赖\n *      2. 方法之间的依赖\n *  解耦: 降低程序间的依赖\n *\n *  开发过程应做到:\n *      编译期不依赖,运行期才依赖\n *  解耦思路:\n *      1. 使用反射来创建对象,避免使用new关键字\n *      2. 通过读取配置文件来获取要创建的对象全权限定类名\n *\n */\npublic class jdbcdemo01 {\n\n    public static void main(string[] args) throws exception {\n\n        // 1. 注册驱动\n//        drivermanager.registerdriver(new com.mysql.jdbc.driver());\n\n       class.forname("new com.mysql.jdbc.driver()");\n        // 2. 获取连接\n        connection conn = drivermanager.getconnection(\n                "jdbc:mysql://localhost:3306/spring_jdbc",\n                "root",\n                "root"\n        );\n        // 3. 获取操作数据库的与处理对象\n        preparedstatement pstm = conn.preparestatement("select * from account");\n        // 4. 执行sql,得到结果\n        resultset resultset = pstm.executequery();\n        // 5. 遍历结果\n        while (resultset.next()) {\n            system.out.println(resultset.getstring("name"));\n        }\n        // 6. 关闭流\n        resultset.close();\n        pstm.close();\n        conn.close();\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 4. 解耦合\n\n# 1. 配置文件\n\n * bean.properties\n\naccountservice=com.chggx.service.impl.accountserviceimpl\naccountdao=com.chggx.dao.impl.accountdaoimpl\n\n\n1\n2\n\n\n# 2. 业务逻辑\n\n# 1. dao层\n\n * accountdao\n\npublic interface accountdao {\n\n    /**\n     * 模拟保存账户\n     */\n    void saveaccount();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * accountdaoimpl\n\npublic class accountdaoimpl implements accountdao {\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        system.out.println("save success...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2. service\n\n * accountservice\n\npublic interface accountservice {\n\n    /**\n     * 模拟保存账户\n     */\n    void saveaccount();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n * accountserviceimpl\n   \n   使用factory工厂的方式获取对象\n\npublic class accountserviceimpl implements accountservice {\n\n    /**\n     * 普通方式 (耦合度高)\n     */\n//    private final accountdao accountdao = new accountdaoimpl();\n\n    /**\n     * 解耦合\n     */\n    private final accountdao accountdao = (accountdao) beanfactory.getbean("accountdao");\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        accountdao.saveaccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 3. accountcontroller\n\n * 解耦合 通过工厂的方式创建对象,实现程序间的解耦合\n\npublic class accountcontroller {\n\n    /**\n     * 模拟保存账户\n     */\n    public static void main(string[] args) {\n        // 普通方式 (耦合度高)\n      /*  accountservice service = new accountserviceimpl();\n        service.saveaccount();*/\n\n        // 解耦合\n        accountservice service = (accountservice) beanfactory.getbean("accountservice");\n        service.saveaccount();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 3. 工厂模式解耦\n\n * 使用单例,每个对象只创建一次\n\n/**\n * @author: chggx\n * @date: 2020/04/28 22:14\n * @description: <h1> 一个创建bean对象的工厂(解耦合) </h1>\n * bean: 在计算机英语中,有可重用组件的含义\n * javabean: java语言编写的可重用组件\n * 1. javabean > 实体类\n * 2. 它就是创建我们的service和dao对象的\n * 解决:\n * 1. 需要一个配置文件来配置我们的service和dao\n * 配置内容: 1) 唯一标识=权限定类名\n * 2. 通过读取配置文件中的内容,反射创建对象\n * <p>\n * 配置文件形式:\n * 1. xml\n * 2. properties: 推荐\n */\npublic class beanfactory {\n\n    /**\n     * 定义一个properties对象\n     */\n    private static properties props;\n\n    /**\n     * 定义一个map,用于存放我们要创建的对象,我们称之为容器\n     */\n    private static map<string, object> beans;\n\n    // 使用静态代码块properties对象赋值\n    static {\n        try {\n            // 1. 实例化对象\n            props = new properties();\n            // 获取"bean.properties"文件的流对象\n            // 获取class对象 类名.class\n            inputstream is = beanfactory.class.getclassloader().getresourceasstream("bean.properties");\n            // 加载配置文件\n            props.load(is);\n\n            //2. 实例化容器 [单例.只创建一次]\n            beans = new hashmap<string, object>();\n            // 2.1 取出配置文件中所有的key\n            enumeration<object> keys = props.keys();\n            // 2.2 遍历枚举\n            while (keys.hasmoreelements()) {\n                // 2.2.1 去除每个key\n                string key = (string) keys.nextelement();\n                // 2.2.2 根据key获取值(类的权限定类名)\n                string beanpath = (string) props.get(key);\n                // 2.3 反射创建对象\n                object value = class.forname(beanpath).newinstance();\n                // 2.4 把key和value存入容器中(map集合)\n                beans.put(key, value);\n            }\n        } catch (exception e) {\n            // 错误 error子类\n            throw new exceptionininitializererror("properties init error !");\n        }\n    }\n\n    /**\n     * 改进: bean只创建一次,(创建的对象存入容器中.此处指map集合)\n     *\n     * @param beanname bean的名称\n     * @return bean的对象\n     */\n    public static object getbean(string beanname) {\n        // 根据bean的名称从容器中获取bean的对象\n        return beans.get(beanname);\n    }\n\n    /**\n     * 根据bean的名称获取bean的对象 [此处是多例,每次都创建对象]\n     *\n     * @param beanname bean的名称\n     * @return bean的对象\n     */\n//    public static object getbean(string beanname) {\n//        object bean = null;\n//        try {\n//            string beanpath = props.getproperty(beanname);\n//            // 获取class对象 class.forname("权限定类名")\n//            // constructor创建对象  t newinstance(object... initargs)\n//            bean = class.forname(beanpath).newinstance();\n//        } catch (exception e) {\n//            e.printstacktrace();\n//        }\n//        return bean;\n//    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n----------------------------------------\n\n\n# 2. spring ioc 与 di\n\n\n# 1. ioc 控制反转 [inversion of control]\n\n# 1. 控制反转解决色问题\n\n\n\n原来： 我们在获取对象时，都是采用 new 的方式。是主动的。\n\n\n\n现在：我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。\n\n这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。\n\n> 我的理解:\n> \n> 1.之前有自己new创建对象 [主动]\n> \n> 2.先在由媒人帮我找对象 [被动]\n\n# 2. ioc的概述 解耦合\n\n 1. 控制反转: 把创建的对象权利交给框架(工厂),是框架的重要特性,并非面向对象编程的专用术语,它包含**依赖注入(di)**和依赖查询\n\n 2. 明确 ioc 的作用：削减计算机程序的耦合(解除我们代码中的依赖关系)。降低程序间的耦合(依赖关系)\n\n\n# 2. ioc入门应用\n\n# 1. 依赖\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-context</artifactid>\n        <version>5.2.6.release</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2. 配置文件\n\n * bean.xml\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给spring来管理--\x3e\n    \x3c!--accountservice--\x3e\n    <bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"/>\n    \x3c!--accountdao--\x3e\n    <bean id="accountdao" class="com.chggx.dao.impl.accountdaoimpl"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 3. applicationcontext操作\n\n\n\napplicationcontext接口\n\n 1. classpathxmlapplicationcontext\n    \n    * 可以加载类路径下的配置文件,要求配置文件必须在类路径下,不在的话,加载不了.[推荐]\n\n 2. filesystemxmlapplicationcontext\n    \n    * 它可以加载磁盘任意路径下的配置文件(必须有访问权限)\n\n 3. annotationconfigapplicationcontext\n    \n    * 它是用于读取注解创建容器的.\n\n   /**\n     * 获取spring的ioc核心容器,并根据id获取对象\n     * applicationcontext:\n     *  1. classpathxmlapplicationcontext: 可以加载类路径下的配置文件,要求配置文件必须在类路径下,不在的话,加载不了.[推荐]\n     *  2. filesystemxmlapplicationcontext: 它可以加载磁盘任意路径下的配置文件(必须有访问权限)\n     *  3. annotationconfigapplicationcontext: 它是用于读取注解创建容器的.\n     */\n    public static void main(string[] args) {\n        // 1. 获取核心容器兑现\n//        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        applicationcontext ac = new filesystemxmlapplicationcontext("d:\\\\java-code\\\\kuangjia\\\\spring\\\\spring\\\\spring_03_ioc\\\\src\\\\main\\\\resources\\\\bean.xml");\n        // 2. 根据id获取bean对象\n        accountservice accountservice = (accountservice) ac.getbean("accountservice");\n        accountdao accountdao = ac.getbean("accountdao", accountdao.class);\n\n        system.out.println(accountservice);\n        system.out.println(accountdao);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3. ioc核心容器的两个接口\n\n# 1. applicationcontext 单例对象使用\n\napplicationcontext: [单例对象使用 如: service,dao]\n    它在构建核心容器时,创建对象策略是采用立即加载的方式,也就是说,只要一读取完配置文件(bean.xml)马上就创建配置文件中配置的对象(通过反射实现)\n    如: 以下代码 [立即加载]\n        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml"); 读取配置文件时候,通过反射就创建对象了\n\n\n1\n2\n3\n4\n\n\n# 2. beanfactory 多例对象使用\n\nbeanfactory: [多例对象使用]\n    它在构建核心容器时,创建对象的策略采用延迟加载的方式,也就是说,什么时候根据id(bean容器对象的唯一标识)获取对象了,什么时候才真正的创建对象.\n    如: 以下代码 [延迟加载]\n        beanfactory factory = new xmlbeanfactory(resource); 读取配置文件\n        accountservice accountservice = (accountservice) factory.getbean("accountservice"); 根据id调用对象时候,才创建对象\n\n\n1\n2\n3\n4\n5\n\n\n# 3. 使用\n\n/**\n     * 1. 获取spring的ioc核心容器,并根据id获取对象\n     *  applicationcontext:\n     *      1). classpathxmlapplicationcontext: 可以加载类路径下的配置文件,要求配置文件必须在类路径下,不在的话,加载不了.[推荐]\n     *      2). filesystemxmlapplicationcontext: 它可以加载磁盘任意路径下的配置文件(必须有访问权限)\n     *      3). annotationconfigapplicationcontext: 它是用于读取注解创建容器的.\n     *  2. 核心容器的两个接口引发出的问题:\n     *  applicationcontext: [单例对象使用 如: service,dao]\n     *      它在构建核心容器时,创建对象策略是采用立即加载的方式,也就是说,只要一读取完配置文件(bean.xml)马上就创建配置文件中配置的对象(通过反射实现)\n     *      如: 以下代码 [立即加载]\n     *          applicationcontext ac = new classpathxmlapplicationcontext("bean.xml"); 读取配置文件时候,通过反射就创建对象了\n     *  beanfactory: [多例对象使用]\n     *      它在构建核心容器时,创建对象的策略采用延迟加载的方式,也就是说,什么时候根据id(bean容器对象的唯一标识)获取对象了,什么时候才真正的创建对象.\n     *      如: 以下代码 [延迟加载]\n     *          beanfactory factory = new xmlbeanfactory(resource); 读取配置文件\n     *          accountservice accountservice = (accountservice) factory.getbean("accountservice"); 根据id调用对象时候,才创建对象\n     */\n    public static void main(string[] args) {\n\n        // ============= applicationcontext [立即加载] =============\n\n//        // 1. 获取核心容器对象 [推荐 classpathxmlapplicationcontext方式创建]\n//        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n////        applicationcontext ac = new filesystemxmlapplicationcontext("d:\\\\java-code\\\\kuangjia\\\\spring\\\\spring\\\\spring_03_ioc\\\\src\\\\main\\\\resources\\\\bean.xml");\n//        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n//        accountservice accountservice = (accountservice) ac.getbean("accountservice");\n//        accountdao accountdao = ac.getbean("accountdao", accountdao.class);\n//\n//        system.out.println(accountservice);\n//        system.out.println(accountdao);\n\n        // ============= beanfactory [延迟加载] =============\n        // 1. 加载配置文件"bean.xml"\n        classpathresource resource = new classpathresource("bean.xml");\n        // 2. 读取配置文件\n        beanfactory factory = new xmlbeanfactory(resource);\n        // 3. 根据id创建bean对象\n        accountservice accountservice = (accountservice) factory.getbean("accountservice");\n        system.out.println(accountservice);\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 4. spring对bean的管理细节\n\n# 1. 创建bean的三种方式\n\n# 1. 构造函数创建对象\n\n第一种方式: 在spring的配置文件中使用bean标签,配以id和class属性之后,且没有其他属性和标签时,采用的就是默认构造函数创建bean对象,此时如果类中没有默认的构造函数,则对象无法创建\n\n\n1\n\n * 配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--\n         spring对bean的管理细节:\n             1. 创建bean的三种方式\n             2. bean对象的作用范围\n             3. bean对象的生命周期\n    --\x3e\n    \x3c!--创建bean的三种方式--\x3e\n    \x3c!--\n        第一种方式: 使用默认的构造函数创建\n                    在spring的配置文件中使用bean标签,配以id和class属性之后,且没有其他属性和标签时,采用的就是默认构造函数创建bean对象,此时如果类中没有默认的构造函数,则对象无法创建\n     --\x3e\n    <bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"/>\n\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 类 [构造函数]\n\npublic class accountserviceimpl implements accountservice {\n\n    /**\n     * 创建bean的方式: 构造函数\n     */\n    public accountserviceimpl() {\n        system.out.println("accountserviceimpl 对象创建了...");\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount(){\n        system.out.println("service saveaccount() ......");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 2. 普通工厂的方法创建对象\n\n第二种方式: 使用普通工厂中的方法创建对象(使用某个类中的方法创建对象,并存入spring容器)\n\n\n1\n\n * 工厂类\n\npackage com.chggx.factory;\n\nimport com.chggx.service.accountservice;\nimport com.chggx.service.impl.accountserviceimpl;\n\n/**\n * @description: <h1> 模拟一个工厂类 </h1>\n * 该类可能存在于jar包中的,我们无法通过修改源码的方式来提供默认构造函数\n */\npublic class instancefactory {\n\n    /**\n     * 构造函数\n     * @return accountservice\n     */\n    public accountservice getaccountservice(){\n        return new accountserviceimpl();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给spring来管理--\x3e\n    \x3c!--\n         spring对bean的管理细节:\n             1. 创建bean的三种方式\n             2. bean对象的作用范围\n             3. bean对象的生命周期\n    --\x3e\n    \x3c!--创建bean的三种方式--\x3e\n    \x3c!--\n        第一种方式: 使用默认的构造函数创建\n                    在spring的配置文件中使用bean标签,配以id和class属性之后,且没有其他属性和标签时,\n                    采用的就是默认构造函数创建bean对象,此时如果类中没有默认的构造函数,则对象无法创建\n    <bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"/>\n     --\x3e\n    \x3c!--第二种方式: 使用普通工厂中的方法创建对象(使用某个类中的方法创建对象,并存入spring容器)--\x3e\n    <bean id="instancefactory" class="com.chggx.factory.instancefactory"/>\n    <bean id="accountservice" factory-bean="instancefactory" factory-method="getaccountservice"/>\n\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 3. 工厂中的静态方法创建对象\n\n第三种方式: 使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象,并存入spring容器)\n\n\n1\n\n * 工厂类\n\npackage com.chggx.factory;\n\nimport com.chggx.service.accountservice;\nimport com.chggx.service.impl.accountserviceimpl;\n\n/**\n * @description: <h1> 模拟一个工厂类 </h1>\n * 该类可能存在于jar包中的,我们无法通过修改源码的方式来提供默认构造函数\n */\npublic class staticfactory {\n\n    /**\n     * 构造函数\n     * @return accountservice\n     */\n    public static accountservice getaccountservice(){\n        return new accountserviceimpl();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给spring来管理--\x3e\n    \x3c!--\n         spring对bean的管理细节:\n             1. 创建bean的三种方式\n             2. bean对象的作用范围\n             3. bean对象的生命周期\n    --\x3e\n    \x3c!--创建bean的三种方式--\x3e\n    \x3c!--\n        第一种方式: 使用默认的构造函数创建\n                    在spring的配置文件中使用bean标签,配以id和class属性之后,且没有其他属性和标签时,\n                    采用的就是默认构造函数创建bean对象,此时如果类中没有默认的构造函数,则对象无法创建\n    <bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"/>\n     --\x3e\n\n    \x3c!--第二种方式: 使用普通工厂中的方法创建对象(使用某个类中的方法创建对象,并存入spring容器)--\x3e\n   \x3c!--\n    <bean id="instancefactory" class="com.chggx.factory.instancefactory"/>\n    <bean id="accountservice" factory-bean="instancefactory" factory-method="getaccountservice"/>\n    --\x3e\n\n    \x3c!--第三种方式: 使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象,并存入spring容器)--\x3e\n    <bean id="accountservice" class="com.chggx.factory.staticfactory" factory-method="getaccountservice"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 2. bean对象的作用范围 scope\n\nbean的scope属性:\n\n作用: 用于指定bean的作用范围\n取值: [常用单例的和多例的]\n\n\n1\n2\n\n\n类型               描述\nsingleton        单例的(默认值)\nprototype        多例的\nrequest          作用于web应用的请求范围\nsession          作用于web应用的会话范围\nglobal-session   作用于集群环境的会话范围(全局会话范围),当不是集群环境时,它就是session\n\n * 应用\n\n<bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl" scope="prototype"/>\n\n\n1\n\n\n# 3. bean对象的生命周期\n\n * 单例对象的生命周期和容器相同\n\n# 1. 单例 ==立即加载==\n\n * 配置文件\n\n\x3c!--bean对象生命周期--\x3e\n\x3c!--\n    单例对象: [立即加载]\n        出生: 当容器创建时对象创建\n        活着: 只要容器还在,对象一直存在\n        死亡: 容器销毁,对象消亡\n       总结: 单例对象的生命周期和容器相同\n --\x3e\n\x3c!--init-method="init": 初始化 destroy-method="destroy": 销毁--\x3e\n<bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"\n      scope="singleton" init-method="init" destroy-method="destroy" />\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 业务方法\n\npublic class accountserviceimpl implements accountservice {\n\n    /**\n     * 创建bean的方式: 构造函数\n     */\n    public accountserviceimpl() {\n        system.out.println("accountserviceimpl 对象创建了...");\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount(){\n        system.out.println("service saveaccount() ......");\n    }\n\n    /**\n     * 初始化\n     */\n    public void init(){\n        system.out.println("object init...");\n    }\n\n    /**\n     * 结束销毁\n     */\n    public void destroy(){\n        system.out.println("object destroy...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * 调用方法\n\npublic class accountcontroller {\n    \n    public static void main(string[] args) {\n\n        // ============= applicationcontext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 classpathxmlapplicationcontext方式创建]\n        // 多态\n//        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        classpathxmlapplicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        accountservice accountservice = (accountservice) ac.getbean("accountservice");\n        // 3. 调用方法\n        accountservice.saveaccount();\n\n        // 手动关闭容器destroy\n        ac.close();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 执行结果\n\naccountserviceimpl 对象创建了...\nobject init...\nservice saveaccount() ......\nobject destroy...\n\n\n1\n2\n3\n4\n\n\n# 2. 多例 ==懒加载==\n\n * 配置文件\n\n\x3c!--bean对象生命周期--\x3e\n\x3c!--\n    单例对象: [立即加载]\n        出生: 当容器创建时对象创建\n        活着: 只要容器还在,对象一直存在\n        死亡: 容器销毁,对象消亡\n       总结: 单例对象的生命周期和容器相同\n    多例对象: [懒加载]\n        出生: 当我们使用对象时spring框架为我们创建\n        活着: 对象只要是在使用过程中就一直存在\n        死亡: 当对象长时间不用,且没有别的对象引用时,有java的垃圾回收器回收\n --\x3e\n\x3c!--init-method="init": 初始化 destroy-method="destroy": 销毁--\x3e\n\x3c!--单例: 立即加载--\x3e\n\x3c!--    <bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"\n        scope="singleton" init-method="init" destroy-method="destroy" />--\x3e\n\x3c!--多例: 懒加载--\x3e\n<bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"\n      scope="prototype" init-method="init" destroy-method="destroy"/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 结果\n\naccountserviceimpl 对象创建了...\nobject init...\nservice saveaccount() ......\n\n\n1\n2\n3\n\n\n\n# 5. 依赖注入 di\n\n# 1. 概述\n\n * 依赖注入: dependency injection\n\n * ioc作用: 降低程序间的耦合(依赖关系)\n\n * 依赖关系管理: 以后都交给spring维护\n\n * 在当前类需要用到其类的对象,有spring为我们提供,我们只需要在配置文件中说明\n\n\n1\n\n * 依赖关系的维护: 称之为 依赖注入.\n\n# 2. 注入方式\n\n# 1. 构造方法\n\n 1. 使用标签: constructor-arg\n 2. 标签出现位置: bean标签的内部\n 3. 标签中的属性\n\n属性      描述\ntype    用于指定要注入的数据的数据类型,该数据类型也是构造函数中某个或某些参数类型\nindex   用于指定要注入的数据给构造函数中指定指定索引位置的参数赋值,所以得位置从0开始\nname    用于指定给构造函数中名称的参数赋值 [推荐]\nvalue   用于基本类型和string类型的数据\nref     用于指定其他的bean类型数据.它指的就是spring的ioc核心容器中出现过的bean对象\n\n 4. 优势\n    * 在获取bean对象时,注入数据是必须操作.否则对象无法创建成功\n 5. 弊端\n    * 改变了bean对象的实例化方式,使我们创建对象时,如果用不到这些数据,也必须提供\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给spring来管理--\x3e\n    \x3c!--\n     spring中的依赖注入 di:\n        1. 依赖注入: dependency injection\n        2. ioc作用: 降低程序间的耦合(依赖关系)\n        3. 依赖关系管理: 以后都交给spring维护\n         * 在当前类需要用到其类的对象,有spring为我们提供,我们只需要在配置文件中说明\n        4. 依赖关系的维护: 称之为 依赖注入.\n        5. 依赖注入:\n            5.1 能注入的数据: [3类]\n                基本类型\n                其他bean类型(在配置文件中或者注解配置过得bean)\n                复杂类型/集合类型\n            5.2 注入的方式: [3种]\n                第一种: 使用构造方法\n                第二种: 使用set方法提供\n                第三种: 使用注解提供\n    --\x3e\n\n    \x3c!--\n    构造函数注入\n        使用标签: constructor-arg\n        标签出现位置: bean标签的内部\n        标签中的属性\n            type: 用于指定要注入的数据的数据类型,该数据类型也是构造函数中某个或某些参数类型\n            index: 用于指定要注入的数据给构造函数中指定指定索引位置的参数赋值,所以得位置从0开始\n            name: 用于指定给构造函数中名称的参数赋值 [推荐]\n            ============= 以上三个用于指定给构造函数中哪个参数赋值 ===========\n            value: 用于基本类型和string类型的数据\n            ref: 用于指定其他的bean类型数据.它指的就是spring的ioc核心容器中出现过的bean对象\n        优势:\n            在获取bean对象时,注入数据是必须操作.否则对象无法创建成功\n        弊端:\n            改变了bean对象的实例化方式,使我们创建对象时,如果用不到这些数据,也必须提供\n    --\x3e\n    <bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl">\n        <constructor-arg name="name" value="构造函数注入"/>\n        \x3c!--string可自动转换为integer--\x3e\n        <constructor-arg name="age" value="18"/>\n        \x3c!--date: 需要配置日期对象--\x3e\n        <constructor-arg name="birthday" ref="now"/>\n    </bean>\n\n    \x3c!--配置一个日期对象--\x3e\n    <bean id="now"  class="java.util.date"/>\n\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n * 构造方法类\n\npublic class accountserviceimpl implements accountservice {\n\n    /**\n     * 如果是经常变化的数据,并不适用与注入方式\n     */\n    private string name;\n    private integer age;\n    private date birthday;\n\n    /**\n     * 依赖注入: 使用构造方法\n     */\n    public accountserviceimpl(string name, integer age, date birthday) {\n        this.name = name;\n        this.age = age;\n        this.birthday = birthday;\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        system.out.println("service saveaccount() ......" + name + "," + age + "," + birthday);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 应用\n\npublic class accountcontroller {\n\n    public static void main(string[] args) {\n\n        // ============= applicationcontext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 classpathxmlapplicationcontext方式创建]\n        // 多态\n//        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        classpathxmlapplicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n\n        // ============= 依赖注入方式: 构造方法 ==============\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        accountservice accountservice = (accountservice) ac.getbean("accountservice");\n        // 3. 调用方法\n        accountservice.saveaccount();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 2. set方法 [推荐: 可以使用默认的构造方法]\n\n 1. 使用标签: property\n 2. 标签出现位置: bean标签的内部\n 3. 标签中的属性\n\n属性      描述\nname    用于指定给构造函数中名称的参数赋值\nvalue   用于基本类型和string类型的数据\nref     用于指定其他的bean类型数据.它指的就是spring的ioc核心容器中出现过的bean对象\n\n 4. 优势\n    \n    * 创建对象时没有明确的限制,可以直接使用默认的构造函数\n\n 5. 弊端\n    \n    * 如果有某个成员那必须有值,则获取对象是有可能set方法没有执行\n\n * 配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--1. 把对象的创建交给spring来管理--\x3e\n    \x3c!--\n     spring中的依赖注入 di:\n        1. 依赖注入: dependency injection\n        2. ioc作用: 降低程序间的耦合(依赖关系)\n        3. 依赖关系管理: 以后都交给spring维护\n         * 在当前类需要用到其类的对象,有spring为我们提供,我们只需要在配置文件中说明\n        4. 依赖关系的维护: 称之为 依赖注入.\n        5. 依赖注入:\n            5.1 能注入的数据: [3类]\n                基本类型\n                其他bean类型(在配置文件中或者注解配置过得bean)\n                复杂类型/集合类型\n            5.2 注入的方式: [3种]\n                第一种: 使用构造方法\n                第二种: 使用set方法提供\n                第三种: 使用注解提供\n    --\x3e\n    \x3c!--配置一个日期对象--\x3e\n    <bean id="now"  class="java.util.date"/>\n\n    \x3c!--\n    set方法注入 [推荐]\n        使用标签: property\n        标签出现位置: bean标签的内部\n        标签中的属性\n            name: 用于指定注入是所调用的set方法名称\n                set方法名称: setname ==== name\n            value: 用于基本类型和string类型的数据\n            ref: 用于指定其他的bean类型数据.它指的就是spring的ioc核心容器中出现过的bean对象\n        优势:\n            创建对象时没有明确的限制,可以直接使用默认的构造函数\n        弊端:\n            如果有某个成员那必须有值,则获取对象是有可能set方法没有执行\n    --\x3e\n    <bean id="accountservice2" class="com.chggx.service.impl.accountservice2impl">\n        <property name="name" value="set方法注入"/>\n        <property name="age" value="21"/>\n        <property name="birthday" ref="now"/>\n    </bean>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n * set方法类\n\npublic class accountservice2impl implements accountservice {\n\n    /**\n     * 如果是经常变化的数据,并不适用与注入方式\n     */\n    private string name;\n    private integer age;\n    private date birthday;\n\n    /**\n     * 依赖注入: 使用set方法\n     */\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public void setage(integer age) {\n        this.age = age;\n    }\n\n    public void setbirthday(date birthday) {\n        this.birthday = birthday;\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        system.out.println("service saveaccount() ......" + name + "," + age + "," + birthday);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 应用\n\npublic class accountcontroller {\n\n    public static void main(string[] args) {\n\n        // ============= applicationcontext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 classpathxmlapplicationcontext方式创建]\n        // 多态\n//        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        classpathxmlapplicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n\n        // ============= 依赖注入方式: set方法 ==============\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        accountservice accountservice2 = (accountservice) ac.getbean("accountservice2");\n        // 3. 调用方法\n        accountservice2.saveaccount();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 3. 注解方式\n\n * 详细参考 ioc 注解\n\n# 3. 能注入的数据\n\n# 1. 基本类型\n\n * 参考 注入方式 中的使用\n\n# 2. 其他bean类型(在配置文件中或者注解配置过得bean)\n\n * 参考 注入方式 中的使用\n\n# 3. 复杂类型/集合类型\n\n * 结论: 结构相同,标签可以互换\n\n 1. 配置文件\n\n\x3c!--复杂类型的注入/集合类型的注入--\x3e\n\x3c!--\n    用于list结构集合注入的标签: list,array,set\n    用于map结构集合注入的标签: map,prop\n    * 结论: 结构相同,标签可以互换\n--\x3e\n<bean name="accountservice3" class="com.chggx.service.impl.accountservice3impl">\n    \x3c!--1. 数组--\x3e\n    <property name="mystr">\n        <array>\n            <value>array1</value>\n            <value>array2</value>\n            <value>array3</value>\n        </array>\n    </property>\n    \x3c!--2. list集合--\x3e\n    <property name="mylist">\n        <list>\n            <value>list1</value>\n            <value>list2</value>\n            <value>list3</value>\n        </list>\n    </property>\n    \x3c!--3. set集合--\x3e\n    <property name="myset">\n        <set>\n            <value>set1</value>\n            <value>set2</value>\n            <value>set3</value>\n        </set>\n    </property>\n    \x3c!--4. map集合--\x3e\n    <property name="mymap">\n        <map>\n            <entry key="map1" value="aaa"/>\n            <entry key="map2" value="bbb"/>\n        </map>\n    </property>\n    \x3c!--5. map集合--\x3e\n    <property name="myprops">\n        <props>\n            <prop key="prop1">111</prop>\n            <prop key="prop2">222</prop>\n        </props>\n    </property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n 2. 类\n\npublic class accountservice3impl implements accountservice {\n\n    /**\n     * 能注入的数据类型:  复杂类型/集合类型\n     */\n    private string[] mystr;\n    private list<string> mylist;\n    private set<string> myset;\n    private map<string,string> mymap;\n    private properties myprops;\n\n    /**\n     * 依赖注入: 使用set方法\n     */\n    public void setmystr(string[] mystr) {\n        this.mystr = mystr;\n    }\n\n    public void setmylist(list<string> mylist) {\n        this.mylist = mylist;\n    }\n\n    public void setmyset(set<string> myset) {\n        this.myset = myset;\n    }\n\n    public void setmymap(map<string, string> mymap) {\n        this.mymap = mymap;\n    }\n\n    public void setmyprops(properties myprops) {\n        this.myprops = myprops;\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        system.out.println(arrays.tostring(mystr));\n        system.out.println(mylist);\n        system.out.println(myset);\n        system.out.println(mymap);\n        system.out.println(myprops);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n 3. 应用\n\npublic class accountcontroller {\n\n    public static void main(string[] args) {\n\n        // ============= applicationcontext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 classpathxmlapplicationcontext方式创建]\n        // 多态\n//        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        classpathxmlapplicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n\n        // ============= 能注入的数据类型: 复杂类型/集合类型 set方法注入 ==============\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        accountservice accountservice3 = (accountservice) ac.getbean("accountservice3");\n        // 3. 调用方法\n        accountservice3.saveaccount();\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 6. ioc注解\n\n# 1. 用于创建对象的注解\n\n * 它们的作用就和xml配置文件中编写一个标签实现的功能是一样的\n\n注解            作用                       属性\n@component    用于把当前类作为对象,存入spring容器中   value:用于指定bean的id.当我们不写时,它默认是当前类名,且首字母改小写\n@controller   一般用于表现层                  属性/作用同上\n@service      一般用于业务层                  属性/作用同上\n@repository   一般用于持久层                  属性/作用同上\n\n# 1. @component\n\n/**\n * @description: <h1> 账户业务层实现类 </h1>\n * xml配置\n *     <bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"/>\n *     属性： id,class,scope,init-method,destroy-method,property,name,value|ref\n *  注解\n *      1. 用于创建对象的注解:\n *          它们的作用就和xml配置文件中编写一个<bean></bean>标签实现的功能是一样的\n *          @component:\n *              作用: 用于把当前类作为对象,存入spring容器中\n *              属性:\n *                  value: 用于指定bean的id.当我们不写时,它默认是当前类名,且首字母改小写\n \t\t\t\t衍生注解: 下面三个 与 @component 的作用和属性一模一样,是spring框架为我们提供明确的三层使用的注解,使用我们的三层对象更加清晰\n *                  @controller: 一般用于表现层\n *                  @service: 一般用于业务层\n *                  @repository: 一般用于持久层\n \n *      2. 用于注入数据的\n *          它们的作用就和xml配置文件中编写一个bean标签写一个<property></property>的标签是一样的\n *      3. 用于改变作用范围的\n *          它们的作用就和xml配置文件中编写一个bean标签使用scope属性实现的功能是一样的\n *      4. 和生命周期有关的\n *          它们的作用就和xml配置文件中编写一个bean标签使用init-method,destroy-method的作用是一样的\n */\n@component(value="accountserviceimpl")\npublic class accountserviceimpl implements accountservice {\n\n    /**\n     * 普通方式 (耦合度高)\n     */\n    private accountdao accountdao;\n\n    public accountserviceimpl() {\n        system.out.println("accountserviceimpl 对象创建了...");\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        accountdao.saveaccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n * 配置文件 (开启包扫描,使用注解)\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    \x3c!--把对象的创建交给spring来管理--\x3e\n    \x3c!--1. xml方式实现--\x3e\n    \x3c!--accountservice--\x3e\n    \x3c!--<bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"/>--\x3e\n    \x3c!--accountdao--\x3e\n    \x3c!--<bean id="accountdao" class="com.chggx.dao.impl.accountdaoimpl"/>--\x3e\n\n    \x3c!--2. 注解方式实现--\x3e\n    \x3c!--\n    告知spring在创建容器时要扫描的包,配置所需要的标签不是在beans的约束中,而是一个名称为content名称空间和约束中\n    --\x3e\n    \x3c!--包扫描--\x3e\n    <context:component-scan base-package="com.chggx"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 应用\n\npublic class accountcontroller {\n\n    public static void main(string[] args) {\n        // ============= applicationcontext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 classpathxmlapplicationcontext方式创建]\n        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        accountservice accountservice = (accountservice) ac.getbean("accountserviceimpl");\n\n        system.out.println(accountservice);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2. 衍生注解使用\n\n * dao\n\n@repository(value = "accountdao")\npublic class accountdaoimpl implements accountdao {\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        system.out.println("save success...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * service\n\n@service(value="accountservice")\npublic class accountserviceimpl implements accountservice {\n\n    private accountdao accountdao;\n\n//    public accountserviceimpl() {\n//        system.out.println("accountserviceimpl 对象创建了...");\n//    }\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        accountdao.saveaccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 应用\n\npublic class accountcontroller {\n\n    public static void main(string[] args) {\n        // ============= applicationcontext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 classpathxmlapplicationcontext方式创建]\n        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        accountservice accountservice = (accountservice) ac.getbean("accountservice");\n        system.out.println(accountservice);\n\n        accountdao accountdao = ac.getbean("accountdao", accountdao.class);\n        system.out.println(accountdao);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 2. 用于注入数据的\n\n * 它们的作用就和xml配置文件中编写一个bean标签写一个的标签是一样的\n\n注解           作用                            类型\n@autowired   注入数据(按照类型)                    注入其他bean类型\n@qualifier   注入数据(配置和@autowired解决多类型注入问题   注入其他bean类型\n@resource    注入数据(取代上面两个注解,根据bean的id注入)    注入其他bean类型\n@value       注入基本数据类型和string类型             基本类型和string类型\n\n# 1. @autowired ==自动按照类型注入==\n\n作用: 自动按照类型注入.\n\t  1. 容器中有唯一的一个bean对象类型和要注入的变量类型匹配,就可以注入成功\n      2. 如果ioc容器中没有任何bean的类型和要注入变量类型匹配,则报错(不能注入)\n      3. 如果ioc容器中有多个类型匹配时,报错,引出新的注解: @qualifier\n出现位置: 可以是变量上,也可以是方法上\n细节: 使用注解注入时,set方法不是必须的\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 问题\n\n如果ioc容器中有多个类型匹配时 使用@autowired怎样操作?\n\n# 2. @qualifier ==解决@autowired多类型匹配==\n\n作用: 在自动按照类中注入的基础之上,在按照名称注入.\n      它在给类成员注入时不能单独使用.但是在给方法参数注入时可以\n属性:\n    value: 用于指定注入bean的id\n\n\n1\n2\n3\n4\n\n * dao\n\n@repository(value = "accountdao2")\npublic class accountdao2impl implements accountdao {\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        system.out.println("save success 222...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n@repository(value = "accountdao1")\npublic class accountdaoimpl implements accountdao {\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        system.out.println("save success 111...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * service调用\n\n@service(value="accountservice")\npublic class accountserviceimpl implements accountservice {\n\n    @autowired\n    @qualifier(value = "accountdao1")\n    private accountdao accountdao;\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        accountdao.saveaccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 3. @resource ==替换上边两个==\n\n 作用: 直接按照bean的id注入.可以单独使用\n 属性:\n    name: 用于指定bean的id\n\n\n1\n2\n3\n\n\n@service(value="accountservice")\npublic class accountserviceimpl implements accountservice {\n\n//    @autowired\n//    @qualifier(value = "accountdao1")\n    @resource(name = "accountdao1")\n    private accountdao accountdao;\n\n//    public accountserviceimpl() {\n//        system.out.println("accountserviceimpl 对象创建了...");\n//    }\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        accountdao.saveaccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 4. @value ==注入基本类型和string类型==\n\n作用: 用于注入基本类型和string类型的数据\n属性:\n   value: 用于指定数据的值,可以使用spring中spel(也就是spring的el表达式)\n          spel写法: ${表达式}\n\n\n1\n2\n3\n4\n\n\n# 5. 总结\n\n 1. @autowired,@qualifier,@resource: 只能注入其他bean类型,而基本类型和string类型无法使用上述注解实现,另外,集合类型的注入只能通过xml来实现\n\n 2. @value 解决了 ==基本类型和string类型== 的注入\n\n# 3. 用于改变作用范围的\n\n * 它们的作用就和xml配置文件中编写一个bean标签使用scope属性实现的功能是一样的\n\n@scope\n\n作用: 用于指定bean的作用范围\n属性:\n    value: 指定范围的取值,常用取值: singleton(默认),property\n\n\n1\n2\n3\n\n\n@scope(value = "singleton") // 方法时\n\n\n1\n\n\n# 4. 和生命周期有关的\n\n * 它们的作用就和xml配置文件中编写一个bean标签使用init-method,destroy-method的作用是一样的\n\n# 1. @predestroy ==销毁==\n\n * 作用: 用于指定销毁方法\n\n# 2. @postconstruct ==初始胡==\n\n * 用于指定初始化方法\n\n# 3. 应用\n\n * 方法\n\n/**\n * @description: <h1> 账户业务层实现类 </h1>\n * xml配置\n *     <bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"/>\n *     属性： id,class,scope,init-method,destroy-method,property,name,value|ref\n *  注解\n *      1. 用于创建对象的注解:\n *          它们的作用就和xml配置文件中编写一个<bean></bean>标签实现的功能是一样的\n *          @component:\n *              作用: 用于把当前类作为对象,存入spring容器中\n *              属性:\n *                  value: 用于指定bean的id.当我们不写时,它默认是当前类名,且首字母改小写\n *              衍生注解: 下面三个 与 @component 的作用和属性一模一样,是spring框架为我们提供明确的三层使用的注解,使用我们的三层对象更加清晰\n *                  @controller: 一般用于表现层\n *                  @service: 一般用于业务层\n *                  @repository: 一般用于持久层\n *\n *      2. 用于注入数据的\n *          它们的作用就和xml配置文件中编写一个bean标签写一个<property></property>的标签是一样的\n *          @autowired\n *              作用: 自动按照类型注入.\n *                    1. 容器中有唯一的一个bean对象类型和要注入的变量类型匹配,就可以注入成功\n *                    2. 如果ioc容器中没有任何bean的类型和要注入变量类型匹配,则报错(不能注入)\n *                    3. 如果ioc容器中有多个类型匹配时,报错,引出新的注解 @qualifier\n *              出现位置: 可以是变量上,也可以是方法上\n *              细节: 使用注解注入时,set方法不是必须的\n *          @qualifier:\n *              作用: 在自动按照类中注入的基础之上,在按照名称注入.\n *                    它在给类成员注入时不能单独使用.但是在给方法参数注入时可以\n *              属性:\n *                  value: 用于指定注入bean的id\n *          @resource:\n *              作用: 直接按照bean的id注入.可以单独使用\n *              属性:\n *                 name: 用于指定bean的id\n *          总结: 以上三个注解只能注入其他bean类型,而基本类型和string类型无法使用上述注解实现.\n *                另外,集合类型的注入只能通过xml来实现\n *          @value:\n *              作用: 用于注入基本类型和string类型的数据\n *              属性:\n *                 value: 用于指定数据的值,可以使用spring中spel(也就是spring的el表达式)\n *                        spel写法: ${表达式}\n *\n *      3. 用于改变作用范围的\n *          它们的作用就和xml配置文件中编写一个bean标签使用scope属性实现的功能是一样的\n *          @scope:\n *              作用: 用于指定bean的作用范围\n *              属性:\n *                  value: 指定范围的取值,常用取值: singleton(默认),property\n *\n *      4. 和生命周期有关的 [了解]\n *          它们的作用就和xml配置文件中编写一个bean标签使用init-method,destroy-method的作用是一样的\n *          @predestroy:\n *              作用: 用于指定销毁方法\n *          @postconstruct:\n *              作用: 用于指定初始化方法\n */\n@service(value="accountservice")\n@scope(value = "singleton")\npublic class accountserviceimpl implements accountservice {\n\n//    @autowired\n//    @qualifier(value = "accountdao1")\n    @resource(name = "accountdao1")\n    private accountdao accountdao;\n\n//    public accountserviceimpl() {\n//        system.out.println("accountserviceimpl 对象创建了...");\n//    }\n\n    /**\n     * 初始化方法\n     */\n    @postconstruct\n    public void init() {\n        system.out.println("init...");\n    }\n\n    /**\n     * 销毁方法\n     */\n    @predestroy\n    public void destroy() {\n        system.out.println("destroy...");\n    }\n\n    /**\n     * 模拟保存账户\n     */\n    @override\n    public void saveaccount() {\n        accountdao.saveaccount();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n * 调用\n\npublic class accountcontroller {\n\n    public static void main(string[] args) {\n        // ============= applicationcontext [立即加载] =============\n\n        // 1. 获取核心容器对象 [推荐 classpathxmlapplicationcontext方式创建]\n//        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        classpathxmlapplicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n        // 2. 根据id获取bean对象 [service,dao都只创建一次,单例模式]\n        accountservice accountservice = (accountservice) ac.getbean("accountservice");\n//        system.out.println(accountservice);\n//        accountdao accountdao = ac.getbean("accountdao", accountdao.class);\n//        system.out.println(accountdao);\n        // 3. 调用方法\n        accountservice.saveaccount();\n        // 4. 销毁\n        ac.close();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\ninit...\nsave success 111...\ndestroy...\n\n\n1\n2\n3\n\n\n\n# 3. spring的新注解\n\n\n# 1. 新注解\n\n注解                作用                                   取代bean.xml                                           属性\n@configuration    指定一个配置类                                                                                   \n@componentscan    用于通过注解指定spring在创建容器时要扫描的包            <context:component-scan base-package="com.chggx"/>   basepackages(value)\n@bean             用于把当前方法的返回值作为bean对象存入spring的ioc容器中                                                        name(默认值: 当前方法名称)\n@import           用于导入其他的配置类                                                                                value: 1. 用于指定其他配置类的字节码 2.\n                                                                                                            当我们使用@import的注解之后,有import注解的类就是父配置类,而导入的都是子配置类\n@propertysource   用于指定文件的名称和路径                                                                              value: 指定文件的名称和路径 关键字: classpath,表示类路径下\n\n\n# 2. 新注解取代xml\n\n# 1. xml形式\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    \x3c!--配置包扫描--\x3e\n    \x3c!--告知spring在创建容器时要包扫描--\x3e\n    <context:component-scan base-package="com.chggx"/>\n\n    \x3c!--配置queryrunner: 改为多例 property--\x3e\n    <bean id="runner" class="org.apache.commons.dbutils.queryrunner" scope="prototype">\n        \x3c!--注入数据源--\x3e\n        <constructor-arg name="ds" ref="datasource"/>\n    </bean>\n\n    \x3c!--配置数据源 c3p0数据源--\x3e\n    <bean id="datasource" class="com.mchange.v2.c3p0.combopooleddatasource">\n        \x3c!--注入连接数据库的必备信息--\x3e\n        <property name="driverclass" value="com.mysql.jdbc.driver"/>\n        <property name="jdbcurl" value="jdbc:mysql://localhost:3306/spring_jdbc"/>\n        <property name="user" value="root"/>\n        <property name="password" value="326868"/>\n    </bean>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 2. 注解形式\n\n * 父配置类\n\n/**\n * @description: <h1> spring配置类,作用和bean.xml一样 </h1>\n * spring中的新注解:\n *      @configuration:\n *          作用: 指定一个配置类\n *          细节:\n *              当配置类作为 new annotationconfigapplicationcontext(springconfiguration.class) 对象创建的参数时,该注解可以不写,否则还是要写\n *      @componentscan:\n *          作用: 用于通过注解指定spring在创建容器时要扫描的包\n *                            同bean.xml中的\n *          属性:\n *               basepackages: 指定创建容器时要扫描的包\n *               value: 1). 它和 basepackages 的作用是一样的,都是用于指定创建容器时要扫描的包\n *                      2). 我们使用次注解就等同于在xml中配置了:\n *                                  <context:component-scan base-package="com.chggx"/>\n *      @bean:\n *           作用: 用于把当前方法的返回值作为bean对象存入spring的ioc容器中\n *           属性:\n *               name: 用于指定bean的id. 当不写时.默认值就是当前方法名称\n *           细节:\n *               当我们使用注解方式时,如果方法有参数: spring框架会去容器中查找有没有可用的bean对象.\n *               查找的方式和@autowired注解的作用是一样的\n *      @import:\n *           作用: 用于导入其他的配置类\n *           属性:\n *              value: 1. 用于指定其他配置类的字节码\n *                     2. 当我们使用@import的注解之后,有import注解的类就是父配置类,而导入的都是子配置类,相当于new annotationconfigapplicationcontext(springconfiguration.class);\n *      @propertysource:\n *           作用: 用于指定文件的名称和路径\n *           属性:\n *              value: 指定文件的名称和路径\n *                      关键字: classpath,表示类路径下\n */\n//@configuration\n@componentscan(basepackages = {"com.chggx","com.chggx.config"})\n@import(value = {jdbcconfig.class})\n@propertysource(value = "classpath:jdbcconfig.properties")\npublic class springconfiguration {\n\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n * 数据原配置 (自配置类)\n\n/**\n * @description: <h1> 和spring连接数据库相关的配置类 </h1>\n */\n//@configuration\npublic class jdbcconfig {\n\n    /**\n     * @value: 注入数据(基本类型和string类型)\n     */\n    @value("${jdbc.driver}")\n    private string driver;\n\n    @value("${jdbc.url}")\n    private string url;\n\n    @value("${jdbc.username}")\n    private string username;\n\n    @value("${jdbc.password}")\n    private string password;\n\n    /**\n     * 用于创建一个 queryrunner 对象\n     *  作用范围多例: prototype\n     * @param datasource 数据源\n     * @return queryrunner\n     */\n    @bean(name = "runner")\n    @scope(value = "prototype")\n    public queryrunner createqueryrunner(datasource datasource) {\n        return new queryrunner(datasource);\n    }\n\n    /**\n     * 配置数据源\n     * @return datasource\n     */\n    @bean(name = "datasource")\n    public datasource createdatasource() {\n        try {\n            // c3p0数据源\n            combopooleddatasource datasource = new combopooleddatasource();\n            datasource.setdriverclass(driver);\n            datasource.setjdbcurl(url);\n            datasource.setuser(username);\n            datasource.setpassword(password);\n            return datasource;\n        } catch (propertyvetoexception e) {\n            throw new runtimeexception(e);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n * 数据源配置文件 jdbcconfig.properties\n\njdbc.driver=com.mysql.jdbc.driver\njdbc.url=jdbc:mysql://localhost:3306/spring_jdbc\njdbc.username=root\njdbc.password=326868\n\n\n1\n2\n3\n4\n\n\n\n# 3. @qualifier另一种使用\n\n 1. 之前配合**@autowired**来解决多类型注入问题.\n 2. 现在在spring中另一种使用\n    * 解决与上边相似,如注入数据源是,数据源多个时,使用**@qualifier**来确定\n\n/**\n * 用于创建一个 queryrunner 对象\n *  1. 作用范围多例: prototype\n *  2. 当有datasource 是有多个数据源(多类型)时,此外用@qualifier("datasource1"): 来确定注入的类型(同@autowired)\n * @param datasource 数据源\n * @return queryrunner\n */\n@bean(name = "runner")\n@scope(value = "prototype")\npublic queryrunner createqueryrunner(@qualifier("datasource1") datasource datasource) {\n    return new queryrunner(datasource);\n}\n\n/**\n * 配置数据源 1\n * @return datasource\n */\n@bean(name = "datasource1")\npublic datasource createdatasource() {\n    try {\n        // c3p0数据源\n        combopooleddatasource datasource = new combopooleddatasource();\n        datasource.setdriverclass(driver);\n        datasource.setjdbcurl(url);\n        datasource.setuser(username);\n        datasource.setpassword(password);\n        return datasource;\n    } catch (propertyvetoexception e) {\n        throw new runtimeexception(e);\n    }\n}\n\n/**\n * 配置数据源 2\n * @return datasource\n */\n@bean(name = "datasource2")\npublic datasource createdatasource2() {\n    try {\n        // c3p0数据源\n        combopooleddatasource datasource = new combopooleddatasource();\n        datasource.setdriverclass(driver);\n        datasource.setjdbcurl("jdbc:mysql://localhost:3306/mybatisdb");\n        datasource.setuser(username);\n        datasource.setpassword(password);\n        return datasource;\n    } catch (propertyvetoexception e) {\n        throw new runtimeexception(e);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 4. junit\n\n# 1. 普通junit\n\n\x3c!--junit 测试--\x3e\n<dependency>\n    <groupid>junit</groupid>\n    <artifactid>junit</artifactid>\n    <version>4.12</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n * 问题\n\n1、应用程序的入口\n\tmain方法\n2、junit单元测试中，没有main方法也能执行\n\tjunit集成了一个main方法\n\t该方法就会判断当前测试类中哪些方法有 @test注解\n\tjunit就让有test注解的方法执行\n3、junit不会管我们是否采用spring框架\n\t在执行测试方法时，junit根本不知道我们是不是使用了spring框架\n\t所以也就不会为我们读取配置文件/配置类创建spring核心容器\n4、由以上三点可知\n\t当测试方法执行时，没有ioc容器，就算写了autowired注解，也无法实现注入\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 2. spring集成junit\n\n * 依赖\n\n\x3c!--spring test--\x3e\n<dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-test</artifactid>\n    <version>5.2.6.release</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n * 配置\n\nspring整合junit的配置:\n     1. 导入spring整合junit的jar包(即: 坐标)\n     2. 使用junit提供的一个注解把所有的main方法提花了,替换成spring提供的\n         @runwith: springjunit4classrunner.class\n     3. 告知spring的运行器,spring的ioc创建是基于xml还是注解的,并且说明位置\n         @contextconfiguration:\n              locations(value): 指定xml文件的位置,加上classpath关键字,表示在类路径下\n                 @contextconfiguration(locations = "classpath:bean.xml")\n              classes: 指定注解(配置)类所在的位置\n                 @contextconfiguration(classes = springconfiguration.class)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3. 案例 ==注解形式==\n\n@runwith(springjunit4classrunner.class)\n//@contextconfiguration(locations = "classpath:bean.xml")\n@contextconfiguration(classes = springconfiguration.class)\npublic class accountservicetest {\n\n    /**\n     * spring 整合 junit 方式: 可以使用 @autowired 注入数据\n     */\n    @autowired\n    private accountservice accountservice;\n\n//    @before\n//    public void before() {\n//        // =========== annotationconfigapplicationcontext: 注解形式 ============\n//        // 1. 获取容器\n//        // 使用配置文件方式\n////        applicationcontext ac = new classpathxmlapplicationcontext("bean.xml");\n//        //  使用配置类方式 springconfiguration\n//        applicationcontext ac = new annotationconfigapplicationcontext(springconfiguration.class);\n//        // 得到业务对象\n//        accountservice = ac.getbean("accountservice", accountservice.class);\n//    }\n\n    @test\n    public void testfindallaccount() {\n        // 查询所有\n        list<account> accounts = accountservice.findallaccount();\n        accounts.foreach(system.out::println);\n    }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n----------------------------------------\n\n\n# 4. 动态代理(proxy)\n\n * 概述\n\n动态代理:\n    特点: 字节码随用随创建,随用随加载\n    作用: 不修改源码的基础上对方法增强\n    分类:\n        1). 基于接口的动态代理\n            涉及的类: proxy\n            提供者,jdk官方\n        2). 基于子类的动态代理\n            涉及的类: enhancer\n            提供者: 第三方cglib库\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 1. 基于接口的动态代理\n\n# 1. 概述\n\n基于接口的动态代理\n     如何创建代理对象:\n         使用proxy类中的newproxyinstance方法\n     创建代理对象的要求:\n         被代理的类最少实现一个接口,如果没有则不能使用\n     newproxyinstance方法的参数:\n        1). classloader loader: 类加载器\n                它是用于加载代理对象字节码的.和被代理对象使用相同的类加载器.[固定写法]\n        2). class<?>[] interfaces: 字节码数组\n                它是用于让代理对象和被代理对象有相同方法.[固定写法]\n        3). invocationhandler h: 用于提供者增强的代码\n                 它是让我们写如何代理.我们一般都是写一个该接口的实现类.通常情况下都是匿名内部类,但不是必须的.\n                  此接口谁用谁写\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 2. 代码实现\n\n * 生产者接口类\n\npublic interface producerinterface {\n\n    /**\n     * 销售\n     *\n     * @param money money\n     */\n    public void saleproducer(float money);\n\n    /**\n     * 售后\n     *\n     * @param money money\n     */\n    public void afterservice(float money);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 生产者接口类实现\n\npublic class producer implements producerinterface {\n\n    /**\n     * 销售\n     * @param money money\n     */\n    public void saleproducer(float money) {\n        system.out.println("销售产品,并拿到钱" + money);\n    }\n\n    /**\n     * 售后\n     * @param money money\n     */\n    public void afterservice(float money) {\n        system.out.println("提供售后服务,并拿到钱" + money);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 消费者\n\npublic class client {\n\n    public static void main(string[] args) {\n        // 1. 原来\n//        producer producer = new producer();\n//        producer.saleproducer(10000f);\n        // 2. 动态代理\n        final producer producer = new producer();\n\n        // 有反射\n        producerinterface proxyproducer = (producerinterface) proxy.newproxyinstance(\n                // 1. 类加载器 [固定写法]\n                producer.getclass().getclassloader(),\n                // 2. 字节码数组 [固定写法]\n                producer.getclass().getinterfaces(),\n                // 3. 用于提供者增强的代码 [匿名内部类]\n                new invocationhandler() {\n                    /**\n                     * 作用: 执行被代理对象的任何接口方法都会经过该方法[拦截作用]\n                     * @param proxy     代理对象\n                     * @param method    当前执行的方法\n                     * @param args      当前执行方法所需的参数\n                     * @return 和被代理对象方法有相同的方绘制\n                     * @throws throwable 异常\n                     */\n                    @override\n                    public object invoke(object proxy, method method, object[] args) throws throwable {\n                        // 提供增强的代码\n                        object returnvalue = null;\n                        // 1. 获取方法执行的参数\n                        float money = (float) args[0];\n                        // 2. 判断当前方法是不是销售\n                        // 要代理方法名\n                        string methodname = "saleproducer";\n                        if (methodname.endswith(method.getname())) {\n                            returnvalue = method.invoke(producer, money * 0.8f);\n                        }\n                        return returnvalue;\n                    }\n                });\n        proxyproducer.saleproducer(10000f);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 2. 基于子类的动态代理\n\n * 依赖\n\n<dependency>\n    <groupid>cglib</groupid>\n    <artifactid>cglib</artifactid>\n    <version>3.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 1. 概述\n\n动态代理:\n    特点: 字节码随用随创建,随用随加载\n    作用: 不修改源码的基础上对方法增强\n    分类:\n        1). 基于接口的动态代理\n            涉及的类: proxy\n            提供者,jdk官方\n        2). 基于子类的动态代理\n            涉及的类: enhancer\n            提供者: 第三方cglib库\n    基于子类的动态代理\n         如何创建代理对象:\n             使用enhancer类中的create方法\n         创建代理对象的要求:\n             被代理的类不是最终类\n         create方法的参数:\n            1). class: 字节码\n                    它是用于加载代理对象字节码的.和被代理对象使用相同的类加载器.[固定写法]\n            2). class<?>[] interfaces: 字节码数组\n                    它是用于让代理对象和被代理对象有相同方法.[固定写法]\n            3). invocationhandler h: 用于提供者增强的代码\n                     它是让我们写如何代理.我们一般都是写一个该接口的实现类.通常情况下都是匿名内部类,但不是必须的.\n                      此接口谁用谁写\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 2. 实现\n\n * 生产者\n\npublic class producer{\n\n    /**\n     * 销售\n     * @param money money\n     */\n    public void saleproducer(float money) {\n        system.out.println("销售产品,并拿到钱" + money);\n    }\n\n    /**\n     * 售后\n     * @param money money\n     */\n    public void afterservice(float money) {\n        system.out.println("提供售后服务,并拿到钱" + money);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 消费者\n\n   public static void main(string[] args) {\n        // 1. 原来\n//        producer producer = new producer();\n//        producer.saleproducer(10000f);\n        // 2. 动态代理\n        final producer producer = new producer();\n\n        // 有反射\n        producer cglibproducer = (producer) enhancer.create(producer.getclass(), new methodinterceptor() {\n            /**\n             * 执行被代理对象的任何方法都会经过该方法\n             * @param o              代理对象\n             * @param method         当前执行的方法\n             * @param objects        当前执行方法所需的参数\n             * @param methodproxy    当前执行方法的代理对象\n             * @return\n             * @throws throwable\n             */\n            @override\n            public object intercept(object o, method method, object[] objects, methodproxy methodproxy) throws throwable {\n                // 提供增强的代码\n                object returnvalue = null;\n                // 1. 获取方法执行的参数\n                float money = (float) objects[0];\n                // 2. 判断当前方法是不是销售\n                // 要代理方法名\n                string methodname = "saleproducer";\n                if (methodname.endswith(method.getname())) {\n                    returnvalue = method.invoke(producer, money * 0.8f);\n                }\n                return returnvalue;\n            }\n        });\n        cglibproducer.saleproducer(10000f);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3. 案例\n\n * 参考spring_10_case\n\n# 1. 事务问题\n\n * 自定义事务\n\npublic class transactionmanager {\n\n    private connectionutils connectionutils;\n\n    public void setconnectionutils(connectionutils connectionutils) {\n        this.connectionutils = connectionutils;\n    }\n\n    /**\n     * 开启事务\n     */\n    public void begintransaction(){\n        try {\n            connectionutils.getthreadconnection().setautocommit(false);\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n\n    /**\n     * 提交事务\n     */\n    public void commit(){\n        try {\n            connectionutils.getthreadconnection().commit();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n\n    /**\n     * 回滚事务\n     */\n    public void rollback(){\n        try {\n            connectionutils.getthreadconnection().rollback();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n\n    /**\n     * 释放事务\n     */\n    public void release(){\n        try {\n            // 还回连接池中,线程还回,不是关闭\n            connectionutils.getthreadconnection().close();\n            // 把连接和线程解绑\n            connectionutils.removeconnection();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n * 使用\n\npublic account findaccountbyid(integer accountid) {\n    try {\n        // 1. 开启事务\n        transactionmanager.begintransaction();\n        // 2. 执行操作\n        account account = accountdao.findaccountbyid(accountid);\n        // 3. 提交事务\n        transactionmanager.commit();\n        // 4. 返回结果\n        return account;\n    } catch (exception e) {\n        // 5. 回滚操作\n        transactionmanager.rollback();\n        throw new runtimeexception(e);\n    } finally {\n        // 6. 释放连接\n        transactionmanager.release();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 引发的问题: 每个方法都需要值执行上面的6步骤(代码冗余),有什么方法可以解决.?\n\n# 2. 基于接口的动态地理方式处理\n\n# 1. 创建代理工厂\n\n * 代理server增强方法\n\npublic class beanfactory {\n\n    private accountservice accountservice;\n    /**\n     * 事务工具类\n     */\n    private transactionmanager transactionmanager;\n\n    /**\n     * set方式注入\n     *\n     * @param accountservice\n     */\n    public void setaccountservice(accountservice accountservice) {\n        this.accountservice = accountservice;\n    }\n\n    public final void settransactionmanager(transactionmanager transactionmanager) {\n        this.transactionmanager = transactionmanager;\n    }\n\n    /**\n     * 获取service代理对象\n     *\n     * @return\n     */\n    public accountservice getaccountservice() {\n        return (accountservice) proxy.newproxyinstance(accountservice.getclass().getclassloader(),\n                accountservice.getclass().getinterfaces(),\n                new invocationhandler() {\n                    /**\n                     * 添加事务支持\n                     * @param proxy\n                     * @param method\n                     * @param args\n                     * @return\n                     * @throws throwable\n                     */\n                    @override\n                    public object invoke(object proxy, method method, object[] args) throws throwable {\n                        object revalue = null;\n                        try {\n                            // 1. 开启事务\n                            transactionmanager.begintransaction();\n                            // 2. 执行操作\n                            revalue = method.invoke(accountservice, args);\n                            // 3. 提交事务\n                            transactionmanager.commit();\n                            // 4. 返回结果\n                            return revalue;\n                        } catch (exception e) {\n                            // 5. 回滚操作\n                            transactionmanager.rollback();\n                            throw new runtimeexception(e);\n                        } finally {\n                            // 6. 释放连接\n                            transactionmanager.release();\n                        }\n                    }\n                });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n * 配置文件\n\n\x3c!--配置代理service--\x3e\n<bean id="proxyaccountservice" factory-bean="beanfactory" factory-method="getaccountservice"/>\n\n\x3c!--配置beanfactory--\x3e\n<bean id="beanfactory" class="com.chggx.factory.beanfactory">\n    \x3c!--注入dao对象--\x3e\n    <property name="accountservice" ref="accountservice"/>\n    \x3c!--注入事务管理--\x3e\n    <property name="transactionmanager" ref="transactionmanager"/>\n</bean>\n\n\x3c!--配置service--\x3e\n<bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl">\n    \x3c!--注入dao对象--\x3e\n    <property name="accountdao" ref="accountdao"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n通过代理的方式我们解决了上面出现的代码冗余问题,此时同样也出现的了一个问题.配置过于繁琐..... 我们可以利用sprng aop解决\n\n----------------------------------------\n\n\n# 5. spring aop\n\n\n# 1. 概述\n\n# 1. 什么是aop\n\naop：全称是 aspect oriented programming 即：面向切面编程。\n\n简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。\n\n\n1\n\n\n# 2. aop优势\n\n作用：\n\t在程序运行期间，不修改源码对已有方法进行增强。\n优势：\n    减少重复代码\n    提高开发效率\n    维护方便\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 3. aop 的实现方式\n\n使用动态代理技术\n\n\n# 2. aop术语\n\n1. joinpoint(连接点): 所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。 [业务层的方法]\n2. pointcut(切入点): 所谓切入点是指我们要对哪些 joinpoint 进行拦截的定义。[切入点: 被增强的方法, 并不是所有的连接点都是,只有被增强的方法才称为"切入点" ]\n3. advice(通知/增强): 所谓通知是指拦截到 joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。\n4. introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, introduction 可以在运行期为类动态地添加一些方法或 field。\n5. target(目标对象): 代理的目标对象。\n6. weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 aspectj 采用编译期织入和类装载期织入。\n7. proxy（代理）: 一个类被 aop 织入增强后，就产生一个结果代理类。\n8. aspect(切面): 是切入点和通知（引介）的结合。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3. aop使用\n\n\x3c!--aspectj: 解析切入点表达式--\x3e\n<dependency>\n    <groupid>org.aspectj</groupid>\n    <artifactid>aspectjweaver</artifactid>\n    <version>1.9.5</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 1. 切入点表达式\n\n1). 关键字: execution(表达式)\n2). 表达式:\n        访问修饰符 返回值 包名.包名.包名...类名.方法名.(参数列表)\n3). 标准写法:\n        public void com.chggx.service.impl.accountserviceimpl.saveaccount()\n        ps: 1. 访问修饰符省略:  void com.chggx.service.impl.accountserviceimpl.saveaccount()\n            2. 返回值可以使用任意通配符,表示任意返回值:  * com.chggx.service.impl.accountserviceimpl.saveaccount()\n            3. 包名可以使用统配符,表示任意包(注意: 有几级包,就写几个"*"):  * *.*.*.accountserviceimpl.saveaccount()\n            4. 可以使用 "..": 表示当前包及其子包:  * *..accountserviceimpl.saveaccount()\n            5. 类名和方法名都可以使用 "*" 来实现通配 * *..*.*()\n            6. 参数列表:\n                    1. 可以直接写数据类型\n                        1. 基本类型: 直接写名称  [int]: * *..*.*(int)\n                        2. 引用类型: "包名.类名" 方式  [java.lang.string]\n                    2. 可以直接使用统配符 "*" 表示任意类型,但必须有参数:  * *..*.*(*)\n                    3. 可以使用 "..": 表示有无参数均可,有参数可以是任意类型: * *..*(..)\n4). 全通配符写法\n        * *..*(..)\n5). 实际开发过程中切入点表达式的通常写法:\n        切到业务层实现类下的所有方法:  * com.chggx.service.impl.*.*(..)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 2. spring基于xml的aop配置\n\n1. 把通知bean也交给spring来管理\n2. 使用 aop:config 标签表名开始aop的配置\n3. 使用 aop:aspect 标签表名配置切面\n        id属性: 给切面提供一个唯一id\n        ref属性: 是指定通知类bean的id\n4. 在 aop:aspect 标签的内部使用对应标签来配置通知类型\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 1. 入门\n\n\n\n * 配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!--配置spring ioc: 把service对象配置进来 连接点: 业务层的方法--\x3e\n    <bean id="accountservice" class="com.chggx.service.impl.accountserviceimpl"/>\n\n    \x3c!--配置logger类: 用于增强业务层的方法(记录日志)--\x3e\n    <bean id="logger" class="com.chggx.utils.logger"/>\n\n    \x3c!--配置aop--\x3e\n    <aop:config>\n        \x3c!--配置切面--\x3e\n        <aop:aspect id="logadvice" ref="logger">\n            \x3c!--\n                1. 配置通知类型: 前置通知\n                2. 通知方法: printlog() logger类中的方法\n                3. 切入点表达式: execution(public void com.chggx.service.impl.accountserviceimpl.saveaccount()): 用于增强的方法\n            --\x3e\n            <aop:before method="printlog"\n                        pointcut="execution(public void com.chggx.service.impl.accountserviceimpl.saveaccount())"/>\n        </aop:aspect>\n    </aop:config>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 2. 通知类型\n\n通知类型   作用                                   \n前置通知   在切入点方法执行之前执行                         before\n后置通知   在切入点方法正常执行之后执行. (它和异常通知永远只会执行一个)     after-returning\n异常通知   在切入点方法执行产生异常之后执行. (它和后置通知永远只会执行一个)   after-throwing\n最终通知   无论切入点方法是否正常执行,它都会在其后面执行              after\n环绕通知   一种可以在代码中手动控制增强方法何时执行的方式。[推荐}         around\n\n# 1. xml写法\n\n\n\n\x3c!--配置aop--\x3e\n<aop:config>\n    \x3c!--配置切面--\x3e\n    <aop:aspect id="logadvice" ref="logger">\n        \x3c!--前置通知: 在切入点方法执行之前执行--\x3e\n        <aop:before method="beforeprintlog" pointcut="execution(public void com.chggx.service.impl.accountserviceimpl.saveaccount())"/>\n        \x3c!--后置通知: 在切入点方法正常执行之后执行. (它和异常通知永远只会执行一个)--\x3e\n        <aop:after-returning method="afterreturningprintlog" pointcut="execution(public void com.chggx.service.impl.accountserviceimpl.saveaccount())"/>\n        \x3c!--异常通知: 在切入点方法执行产生异常之后执行. (它和后置通知永远只会执行一个)--\x3e\n        <aop:after-throwing method="afterthrowprintlog" pointcut="execution(public void com.chggx.service.impl.accountserviceimpl.saveaccount())"/>\n        \x3c!--最终通知: 无论切入点方法是否正常执行,它都会在其后面执行--\x3e\n        <aop:after method="afterprintlog" pointcut="execution(public void com.chggx.service.impl.accountserviceimpl.saveaccount())"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2. 优化代码\n\n * 在标签</aop:aspect>内\n\n\n\n * 在标签 </aop:aspect>外\n\n\n\n# 3. 环绕通知 😄\n\n# 1. 环绕通知问题\n\n * 配置文件\n\n\x3c!--配置aop--\x3e\n<aop:config>\n    \x3c!--\n         配置切入点表达式:\n      --\x3e\n    <aop:pointcut id="ptl" expression="execution(* com.chggx.service.impl.*.*(..))"/>\n    \x3c!--配置切面--\x3e\n    \x3c!-- pointcut-ref属性: 用于配置切入点表达式--\x3e\n    <aop:aspect id="logadvice" ref="logger">\n        \x3c!--配置环绕通知: 详细注释(logger类)--\x3e\n        <aop:around method="aroundprintlog" pointcut-ref="ptl"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 方法\n\n/**\n * 环绕通知方法\n */\npublic void aroundprintlog(){\n    system.out.println("环绕通知log中的before...");\n}\n\n\n// 被增强的方法\n    @override\n    public void saveaccount() {\n        system.out.println("save...");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 结果\n\ne:\\develop\\java\\jdk1.8.0_91\\bin\\java.exe -\n环绕通知log中的before...\n\n\n1\n2\n\n * 问题: 当我们配置了环绕通知之后,切入点方法没有执行,而通知方法执行了?\n\n# 2. 解决\n\n通过代理的方式实现事务控制分析\n\n\n\n1. 分析：\n       通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。\n2. 解决：\n       spring框架为我们提供了一个接口："proceedingjoinpoint"。"该接口有一个方法proceed()"，此方法就相当于明确调用"切入点方法"。\n       该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。\n3. spring中的环绕通知：\n       它是spring框架为我们提供的"一种可以在代码中手动控制增强方法何时执行的方式。"\n       可以使用代码的方式实现其余4中通知\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\npublic object aroundprintlog(proceedingjoinpoint point) {\n    object revalue = null;\n    try {\n        // 得到方法执行所需要的参数\n        object[] args = point.getargs();\n        system.out.println("环绕通知log中的...前置通知");\n        // 明确调用业务层方法(切入点方法)\n        revalue = point.proceed(args);\n        system.out.println("环绕通知log中的...后置通知");\n\n        return revalue;\n    } catch (throwable throwable) {\n        system.out.println("环绕通知log中的...异常通知");\n        throw new runtimeexception(throwable);\n    } finally {\n        system.out.println("环绕通知log中的...最终通知");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3. 基于注解aop配置 推荐环绕通知\n\n通知类型   作用                                   \n前置通知   在切入点方法执行之前执行                         @before\n后置通知   在切入点方法正常执行之后执行. (它和异常通知永远只会执行一个)     @afterreturning\n异常通知   在切入点方法执行产生异常之后执行. (它和后置通知永远只会执行一个)   @afterthrowing\n最终通知   无论切入点方法是否正常执行,它都会在其后面执行              @ater\n环绕通知   一种可以在代码中手动控制增强方法何时执行的方式。[推荐]         @around\n\n# 1. 配置\n\n * xml配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd">\n\n    \x3c!--配置spring创建容器时要扫描的包--\x3e\n    <context:component-scan base-package="com.chggx"/>\n\n    \x3c!--配置spring开启注解aop的支持--\x3e\n    <aop:aspectj-autoproxy/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 注解配置\n\n@configuration\n@componentscan(basepackages="com.itheima")\n@enableaspectjautoproxy\npublic class springconfiguration {\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 2. 通知类\n\n@component("logger")\n@aspect // 当前类是一个切面类\npublic class logger {\n\n    @pointcut("execution(* com.chggx.service.impl.*.*(..))")\n    private void ptl(){\n\n    }\n\n    /**\n     * 前置通知\n     */\n    @before("ptl()")\n    public void beforeprintlog() {\n        system.out.println("前置通知log中的before...");\n    }\n\n    /**\n     * 后置通知\n     */\n    @afterreturning("ptl()")\n    public void afterreturningprintlog() {\n        system.out.println("后置通知log中的afterreturning...");\n    }\n\n    /**\n     * 异常通知\n     */\n    @afterthrowing("ptl()")\n    public void afterthrowprintlog() {\n        system.out.println("异常通知log中的afterthrow...");\n    }\n\n    /**\n     * 最终通知\n     */\n    @after("ptl()")\n    public void afterprintlog() {\n        system.out.println("最终通知log中的after...");\n    }\n\n    /**\n     * 环绕通知\n     * 1. 问题:\n     * 当我们配置了环绕通知之后,切入点方法没有执行,而通知方法执行了\n     * 2. 分析：\n     * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。\n     * 3. 解决：\n     * spring框架为我们提供了一个接口：proceedingjoinpoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。\n     * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。\n     * <p>\n     * 4. spring中的环绕通知：\n     * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。\n     */\n    @around("ptl()")\n    public object aroundprintlog(proceedingjoinpoint point) {\n        object revalue = null;\n        try {\n            // 得到方法执行所需要的参数\n            object[] args = point.getargs();\n            system.out.println("环绕通知log中的...前置通知");\n            // 明确调用业务层方法(切入点方法)\n            revalue = point.proceed(args);\n            system.out.println("环绕通知log中的...后置通知");\n\n            return revalue;\n        } catch (throwable throwable) {\n            system.out.println("环绕通知log中的...异常通知");\n            throw new runtimeexception(throwable);\n        } finally {\n            system.out.println("环绕通知log中的...最终通知");\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n当我们使用.我们推荐使用环绕通知,因为其余4个通知在使用时,最终通知在后置通知之前执行\n\n前置通知log中的before...\nsave...\n最终通知log中的after...\n后置通知log中的afterreturning...\n\n\n1\n2\n3\n4\n\n\n\n# 6. spring中的jdbctemplate',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"SpringBoot整合RabbitMQ",frontmatter:{title:"SpringBoot整合RabbitMQ",date:"2023-02-25T21:36:59.000Z",permalink:"/pages/9c9eda/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/01.Spring%E5%AE%B6%E6%97%8F/03.SpringBoot/2.SpringBoot%E6%95%B4%E5%90%88RabbitMQ.html",relativePath:"04.后端应用框架/01.Spring家族/03.SpringBoot/2.SpringBoot整合RabbitMQ.md",key:"v-fd1a5854",path:"/pages/9c9eda/",headers:[{level:2,title:"1. 搭建环境",slug:"_1-搭建环境",normalizedTitle:"1. 搭建环境",charIndex:27},{level:4,title:"1.1 依赖",slug:"_1-1-依赖",normalizedTitle:"1.1 依赖",charIndex:38},{level:4,title:"1.2 配置文件(yml)",slug:"_1-2-配置文件-yml",normalizedTitle:"1.2 配置文件(yml)",charIndex:209},{level:4,title:"1.3 模板",slug:"_1-3-模板",normalizedTitle:"1.3 模板",charIndex:499},{level:2,title:"2. hello world模型 (简单队列)",slug:"_2-hello-world模型-简单队列",normalizedTitle:"2. hello world模型 (简单队列)",charIndex:570},{level:4,title:"生产者",slug:"生产者",normalizedTitle:"生产者",charIndex:597},{level:4,title:"消费者",slug:"消费者",normalizedTitle:"消费者",charIndex:549},{level:2,title:"3. work模型使用(工作队列)",slug:"_3-work模型使用-工作队列",normalizedTitle:"3. work模型使用(工作队列)",charIndex:1673},{level:3,title:"3.1 轮询模式",slug:"_3-1-轮询模式",normalizedTitle:"3.1 轮询模式",charIndex:1695},{level:4,title:"生产者",slug:"生产者-2",normalizedTitle:"生产者",charIndex:597},{level:4,title:"消费者",slug:"消费者-2",normalizedTitle:"消费者",charIndex:549},{level:3,title:"2. fair dipatch模式",slug:"_2-fair-dipatch模式",normalizedTitle:"2. fair dipatch模式",charIndex:3144},{level:2,title:"4. Fanout 广播模型 (Publish/Subscribe)",slug:"_4-fanout-广播模型-publish-subscribe",normalizedTitle:"4. fanout 广播模型 (publish/subscribe)",charIndex:3175},{level:4,title:"生产者",slug:"生产者-3",normalizedTitle:"生产者",charIndex:597},{level:4,title:"消费者",slug:"消费者-3",normalizedTitle:"消费者",charIndex:549},{level:2,title:"5. Direct 路由模型 (Routing)",slug:"_5-direct-路由模型-routing",normalizedTitle:"5. direct 路由模型 (routing)",charIndex:4983},{level:4,title:"生产者",slug:"生产者-4",normalizedTitle:"生产者",charIndex:597},{level:4,title:"消费者",slug:"消费者-4",normalizedTitle:"消费者",charIndex:549},{level:2,title:"6. Topic 主题模式 (Topics)",slug:"_6-topic-主题模式-topics",normalizedTitle:"6. topic 主题模式 (topics)",charIndex:6968},{level:4,title:"生产者",slug:"生产者-5",normalizedTitle:"生产者",charIndex:597},{level:4,title:"消费者",slug:"消费者-5",normalizedTitle:"消费者",charIndex:549}],headersStr:"1. 搭建环境 1.1 依赖 1.2 配置文件(yml) 1.3 模板 2. hello world模型 (简单队列) 生产者 消费者 3. work模型使用(工作队列) 3.1 轮询模式 生产者 消费者 2. fair dipatch模式 4. Fanout 广播模型 (Publish/Subscribe) 生产者 消费者 5. Direct 路由模型 (Routing) 生产者 消费者 6. Topic 主题模式 (Topics) 生产者 消费者",content:'# SpringBoot整合RabbitMQ\n\n\n# 1. 搭建环境\n\n# 1.1 依赖\n\n\x3c!--RabbitMQ依赖--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 1.2 配置文件(yml)\n\nspring:\n  application:\n    # 项目名称\n    name: rabbitmq-springboot\n\n  # 配置RabbitMQ\n  rabbitmq:\n    host: 116.196.118.167 # 主机\n    port: 5672 # 端口号\n    username: chggx # 用户名\n    password: Llxc326868 # 密码\n    virtual-host: /virtual_chggx # 类似于数据库\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 1.3 模板\n\nRabbitTemplate 用来简化操作 使用时候直接在项目中注入即可使用\n\n只有消费者存在时,才创建队列,交换机\n\n\n# 2. hello world模型 (简单队列)\n\n# 生产者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 简单队列生产者 </h1>\n */\n@SpringBootTest(classes = RabbitmaSpringbootApplication.class)\n@RunWith(SpringRunner.class)\npublic class SpProducer {\n\n    /**\n     * 注入RabbitTemplate\n     */\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * 队列\n     */\n    private static final String QUEUE_NAME = "sp_queue";\n\n    /**\n     * 简单队列生产者\n     */\n    @Test\n    public void Send() {\n        // 发送的消息\n        String msg = "hello simple !";\n        rabbitTemplate.convertAndSend(QUEUE_NAME, msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 消费者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 简单队列消费者 </h1>\n */\n@Component\n@RabbitListener(queuesToDeclare = @Queue(value = "sp_queue"))\npublic class SpConsumer {\n\n    /**\n     * @param message 监听的消息\n     */\n    @RabbitHandler\n    public void receive(String message) {\n        System.out.println("sp receive msg:" + message);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> @RabbitListener: 作用在类上.方法上添加@RabbitHandler\n\n\n# 3. work模型使用(工作队列)\n\n\n# 3.1 轮询模式\n\n * 你一个我一个,平均分发\n\n# 生产者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 工作队列生产者(轮询分发) </h1>\n */\n@SpringBootTest(classes = RabbitmaSpringbootApplication.class)\n@RunWith(SpringRunner.class)\npublic class WorkProducer {\n\n    /**\n     * 注入RabbitTemplate\n     */\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * 队列\n     */\n    private static final String QUEUE_NAME = "work_queue";\n\n    /**\n     * 简单队列生产者\n     */\n    @Test\n    public void Send() {\n        for (int i = 0; i < 10; i++) {\n            // 发送的消息\n            String msg = "hello work robin !" + i;\n            rabbitTemplate.convertAndSend(QUEUE_NAME, msg);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# 消费者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 工作队列消费者(轮询分发) </h1>\n */\n@Component\npublic class WorkConsumer {\n\n    /**\n     * 消费者\n     * @param message 监听的消息\n     */\n    @RabbitListener(queuesToDeclare = @Queue(value = "work_queue"))\n    public void receive01(String message) {\n        System.out.println("[1] work receive msg:" + message);\n    }\n\n    /**\n     * 消费者\n     * @param message 监听的消息\n     */\n    @RabbitListener(queuesToDeclare = @Queue(value = "work_queue"))\n    public void receive02(String message) {\n        System.out.println("[2] work receive msg:" + message); \n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> @RabbitListener: 作用在方法上\n\n\n# 2. fair dipatch模式\n\n * 能者多劳\n\n\n# 4. Fanout 广播模型 (Publish/Subscribe)\n\n# 生产者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 发布订阅队列生产者(广播模型 fanout分发) </h1>\n */\n@SpringBootTest(classes = RabbitmaSpringbootApplication.class)\n@RunWith(SpringRunner.class)\npublic class PsProducer {\n\n    /**\n     * 注入RabbitTemplate\n     */\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * 交换机\n     */\n    private static final String EXCHANGE_NAME = "ps_exchange";\n\n    /**\n     * 发布订阅队列生产者\n     */\n    @Test\n    public void Send() {\n        // 发送的消息\n        String msg = "hello ps fanout !";\n        rabbitTemplate.convertAndSend(EXCHANGE_NAME, "", msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 消费者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 发布订阅队列消费者 </h1>\n */\n@Component\npublic class PsConsumer {\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @RabbitListener(bindings = {\n            @QueueBinding(\n                    value = @Queue, // 创建临时队列\n                    exchange = @Exchange(value = "ps_exchange", type = "fanout") // 要绑定的交换机名称,类型fanout分发\n            )\n    })\n    public void receive01(String message) {\n        System.out.println("[1] ps receive msg:" + message);\n    }\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @RabbitListener(bindings = {\n            @QueueBinding(\n                    value = @Queue, // 创建临时队列\n                    exchange = @Exchange(value = "ps_exchange", type = "fanout") // 要绑定的交换机名称,类型fanout分发\n            )\n    })\n    public void receive02(String message) {\n        System.out.println("[2] ps receive msg:" + message);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 5. Direct 路由模型 (Routing)\n\n# 生产者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> Route模式生产者(direct) </h1>\n */\n@SpringBootTest(classes = RabbitmaSpringbootApplication.class)\n@RunWith(SpringRunner.class)\npublic class RtProducer {\n\n    /**\n     * 注入RabbitTemplate\n     */\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * 交换机\n     */\n    private static final String EXCHANGE_NAME = "rt_exchange";\n\n    /**\n     * 发布订阅队列生产者\n     */\n    @Test\n    public void Send() {\n        // 发送的消息\n        String msg = "hello ps info route direct !";\n        rabbitTemplate.convertAndSend(EXCHANGE_NAME, "waring", msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 消费者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> Route模式消费者(direct) </h1>\n */\n@Component\npublic class RtConsumer {\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @RabbitListener(bindings = {\n            @QueueBinding(\n                    value = @Queue, // 创建临时队列\n                    exchange = @Exchange(value = "rt_exchange", type = "direct"), // 要绑定的交换机名称,类型direct\n                    key = {"waring", "error"}\n            )\n    })\n    public void receive01(String message) {\n        System.out.println("[1] ps receive msg:" + message);\n    }\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @RabbitListener(bindings = {\n            @QueueBinding(\n                    value = @Queue, // 创建临时队列\n                    exchange = @Exchange(value = "rt_exchange", type = "direct"), // 要绑定的交换机名称,类型direct\n                    key = {"info", "waring", "error"}\n            )\n    })\n    public void receive02(String message) {\n        System.out.println("[2] ps receive msg:" + message);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n> 生产者的routeKey设置的key,当消费者中的key中不包含routekey的key时,消费者接受消息,反之不接受\n\n\n# 6. Topic 主题模式 (Topics)\n\n * 通配符\n   \n   *: 匹配单个\n   \n   a.* a.save/a.b\n   \n   #: 匹配多个\n   \n   a.# a.b/a.b.c/a.b.c.d\n\n# 生产者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 订阅模式生产者(topic) </h1>\n */\n@SpringBootTest(classes = RabbitmaSpringbootApplication.class)\n@RunWith(SpringRunner.class)\npublic class TpProducer {\n\n    /**\n     * 注入RabbitTemplate\n     */\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * 交换机\n     */\n    private static final String EXCHANGE_NAME = "tp_exchange";\n\n    /**\n     * 生产者队列生产者\n     */\n    @Test\n    public void Send() {\n        // 发送的消息\n        String msg = "hello ps user.save topic !";\n        rabbitTemplate.convertAndSend(EXCHANGE_NAME, "user.save", msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 消费者\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 订阅模式消费者(topic) </h1>\n */\n@Component\npublic class TpConsumer {\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @RabbitListener(bindings = {\n            @QueueBinding(\n                    value = @Queue, // 创建临时队列\n                    exchange = @Exchange(value = "tp_exchange", type = "topic"), // 要绑定的交换机名称,类型topic\n                    key = {"order.#", "produce.#","user.*"}\n            )\n    })\n    public void receive01(String message) {\n        System.out.println("[1] tp receive msg:" + message);\n    }\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @RabbitListener(bindings = {\n            @QueueBinding(\n                    value = @Queue, // 创建临时队列\n                    exchange = @Exchange(value = "tp_exchange", type = "topic"), // 要绑定的交换机名称,类型topic\n                    key = {"user.save","user.*"}\n            )\n    })\n    public void receive02(String message) {\n        System.out.println("[2] tp receive msg:" + message);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n> 以上所有的队列基于注解开发',normalizedContent:'# springboot整合rabbitmq\n\n\n# 1. 搭建环境\n\n# 1.1 依赖\n\n\x3c!--rabbitmq依赖--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-amqp</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 1.2 配置文件(yml)\n\nspring:\n  application:\n    # 项目名称\n    name: rabbitmq-springboot\n\n  # 配置rabbitmq\n  rabbitmq:\n    host: 116.196.118.167 # 主机\n    port: 5672 # 端口号\n    username: chggx # 用户名\n    password: llxc326868 # 密码\n    virtual-host: /virtual_chggx # 类似于数据库\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 1.3 模板\n\nrabbittemplate 用来简化操作 使用时候直接在项目中注入即可使用\n\n只有消费者存在时,才创建队列,交换机\n\n\n# 2. hello world模型 (简单队列)\n\n# 生产者\n\n/**\n * @author: chggx\n * @description: <h1> 简单队列生产者 </h1>\n */\n@springboottest(classes = rabbitmaspringbootapplication.class)\n@runwith(springrunner.class)\npublic class spproducer {\n\n    /**\n     * 注入rabbittemplate\n     */\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    /**\n     * 队列\n     */\n    private static final string queue_name = "sp_queue";\n\n    /**\n     * 简单队列生产者\n     */\n    @test\n    public void send() {\n        // 发送的消息\n        string msg = "hello simple !";\n        rabbittemplate.convertandsend(queue_name, msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 消费者\n\n/**\n * @author: chggx\n * @description: <h1> 简单队列消费者 </h1>\n */\n@component\n@rabbitlistener(queuestodeclare = @queue(value = "sp_queue"))\npublic class spconsumer {\n\n    /**\n     * @param message 监听的消息\n     */\n    @rabbithandler\n    public void receive(string message) {\n        system.out.println("sp receive msg:" + message);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> @rabbitlistener: 作用在类上.方法上添加@rabbithandler\n\n\n# 3. work模型使用(工作队列)\n\n\n# 3.1 轮询模式\n\n * 你一个我一个,平均分发\n\n# 生产者\n\n/**\n * @author: chggx\n * @description: <h1> 工作队列生产者(轮询分发) </h1>\n */\n@springboottest(classes = rabbitmaspringbootapplication.class)\n@runwith(springrunner.class)\npublic class workproducer {\n\n    /**\n     * 注入rabbittemplate\n     */\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    /**\n     * 队列\n     */\n    private static final string queue_name = "work_queue";\n\n    /**\n     * 简单队列生产者\n     */\n    @test\n    public void send() {\n        for (int i = 0; i < 10; i++) {\n            // 发送的消息\n            string msg = "hello work robin !" + i;\n            rabbittemplate.convertandsend(queue_name, msg);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# 消费者\n\n/**\n * @author: chggx\n * @description: <h1> 工作队列消费者(轮询分发) </h1>\n */\n@component\npublic class workconsumer {\n\n    /**\n     * 消费者\n     * @param message 监听的消息\n     */\n    @rabbitlistener(queuestodeclare = @queue(value = "work_queue"))\n    public void receive01(string message) {\n        system.out.println("[1] work receive msg:" + message);\n    }\n\n    /**\n     * 消费者\n     * @param message 监听的消息\n     */\n    @rabbitlistener(queuestodeclare = @queue(value = "work_queue"))\n    public void receive02(string message) {\n        system.out.println("[2] work receive msg:" + message); \n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> @rabbitlistener: 作用在方法上\n\n\n# 2. fair dipatch模式\n\n * 能者多劳\n\n\n# 4. fanout 广播模型 (publish/subscribe)\n\n# 生产者\n\n/**\n * @author: chggx\n * @description: <h1> 发布订阅队列生产者(广播模型 fanout分发) </h1>\n */\n@springboottest(classes = rabbitmaspringbootapplication.class)\n@runwith(springrunner.class)\npublic class psproducer {\n\n    /**\n     * 注入rabbittemplate\n     */\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    /**\n     * 交换机\n     */\n    private static final string exchange_name = "ps_exchange";\n\n    /**\n     * 发布订阅队列生产者\n     */\n    @test\n    public void send() {\n        // 发送的消息\n        string msg = "hello ps fanout !";\n        rabbittemplate.convertandsend(exchange_name, "", msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 消费者\n\n/**\n * @author: chggx\n * @description: <h1> 发布订阅队列消费者 </h1>\n */\n@component\npublic class psconsumer {\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @rabbitlistener(bindings = {\n            @queuebinding(\n                    value = @queue, // 创建临时队列\n                    exchange = @exchange(value = "ps_exchange", type = "fanout") // 要绑定的交换机名称,类型fanout分发\n            )\n    })\n    public void receive01(string message) {\n        system.out.println("[1] ps receive msg:" + message);\n    }\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @rabbitlistener(bindings = {\n            @queuebinding(\n                    value = @queue, // 创建临时队列\n                    exchange = @exchange(value = "ps_exchange", type = "fanout") // 要绑定的交换机名称,类型fanout分发\n            )\n    })\n    public void receive02(string message) {\n        system.out.println("[2] ps receive msg:" + message);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 5. direct 路由模型 (routing)\n\n# 生产者\n\n/**\n * @author: chggx\n * @description: <h1> route模式生产者(direct) </h1>\n */\n@springboottest(classes = rabbitmaspringbootapplication.class)\n@runwith(springrunner.class)\npublic class rtproducer {\n\n    /**\n     * 注入rabbittemplate\n     */\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    /**\n     * 交换机\n     */\n    private static final string exchange_name = "rt_exchange";\n\n    /**\n     * 发布订阅队列生产者\n     */\n    @test\n    public void send() {\n        // 发送的消息\n        string msg = "hello ps info route direct !";\n        rabbittemplate.convertandsend(exchange_name, "waring", msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 消费者\n\n/**\n * @author: chggx\n * @description: <h1> route模式消费者(direct) </h1>\n */\n@component\npublic class rtconsumer {\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @rabbitlistener(bindings = {\n            @queuebinding(\n                    value = @queue, // 创建临时队列\n                    exchange = @exchange(value = "rt_exchange", type = "direct"), // 要绑定的交换机名称,类型direct\n                    key = {"waring", "error"}\n            )\n    })\n    public void receive01(string message) {\n        system.out.println("[1] ps receive msg:" + message);\n    }\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @rabbitlistener(bindings = {\n            @queuebinding(\n                    value = @queue, // 创建临时队列\n                    exchange = @exchange(value = "rt_exchange", type = "direct"), // 要绑定的交换机名称,类型direct\n                    key = {"info", "waring", "error"}\n            )\n    })\n    public void receive02(string message) {\n        system.out.println("[2] ps receive msg:" + message);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n> 生产者的routekey设置的key,当消费者中的key中不包含routekey的key时,消费者接受消息,反之不接受\n\n\n# 6. topic 主题模式 (topics)\n\n * 通配符\n   \n   *: 匹配单个\n   \n   a.* a.save/a.b\n   \n   #: 匹配多个\n   \n   a.# a.b/a.b.c/a.b.c.d\n\n# 生产者\n\n/**\n * @author: chggx\n * @description: <h1> 订阅模式生产者(topic) </h1>\n */\n@springboottest(classes = rabbitmaspringbootapplication.class)\n@runwith(springrunner.class)\npublic class tpproducer {\n\n    /**\n     * 注入rabbittemplate\n     */\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    /**\n     * 交换机\n     */\n    private static final string exchange_name = "tp_exchange";\n\n    /**\n     * 生产者队列生产者\n     */\n    @test\n    public void send() {\n        // 发送的消息\n        string msg = "hello ps user.save topic !";\n        rabbittemplate.convertandsend(exchange_name, "user.save", msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 消费者\n\n/**\n * @author: chggx\n * @description: <h1> 订阅模式消费者(topic) </h1>\n */\n@component\npublic class tpconsumer {\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @rabbitlistener(bindings = {\n            @queuebinding(\n                    value = @queue, // 创建临时队列\n                    exchange = @exchange(value = "tp_exchange", type = "topic"), // 要绑定的交换机名称,类型topic\n                    key = {"order.#", "produce.#","user.*"}\n            )\n    })\n    public void receive01(string message) {\n        system.out.println("[1] tp receive msg:" + message);\n    }\n\n    /**\n     * 消费者\n     * bindings: 绑定交换机和队列\n     *\n     * @param message 监听的消息\n     */\n    @rabbitlistener(bindings = {\n            @queuebinding(\n                    value = @queue, // 创建临时队列\n                    exchange = @exchange(value = "tp_exchange", type = "topic"), // 要绑定的交换机名称,类型topic\n                    key = {"user.save","user.*"}\n            )\n    })\n    public void receive02(string message) {\n        system.out.println("[2] tp receive msg:" + message);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n> 以上所有的队列基于注解开发',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Redis入门",frontmatter:{title:"Redis入门",date:"2023-02-27T11:23:36.000Z",permalink:"/pages/1db5d1/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E7%BC%93%E5%AD%98/1.Redis%E5%85%A5%E9%97%A8.html",relativePath:"04.后端应用框架/03.中间件/01.缓存/1.Redis入门.md",key:"v-d8e4d184",path:"/pages/1db5d1/",headers:[{level:2,title:"1. Redis概述",slug:"_1-redis概述",normalizedTitle:"1. redis概述",charIndex:14},{level:3,title:"1.1 Redis 是什么",slug:"_1-1-redis-是什么",normalizedTitle:"1.1 redis 是什么",charIndex:29},{level:3,title:"1.2 Redis能干什么",slug:"_1-2-redis能干什么",normalizedTitle:"1.2 redis能干什么",charIndex:205},{level:3,title:"1.3 特性",slug:"_1-3-特性",normalizedTitle:"1.3 特性",charIndex:326},{level:3,title:"1.4 redis下载地址",slug:"_1-4-redis下载地址",normalizedTitle:"1.4 redis下载地址",charIndex:372},{level:2,title:"2. Redis安装",slug:"_2-redis安装",normalizedTitle:"2. redis安装",charIndex:465},{level:3,title:"2.1 Windows安装",slug:"_2-1-windows安装",normalizedTitle:"2.1 windows安装",charIndex:480},{level:3,title:"2.2 Linux安装",slug:"_2-2-linux安装",normalizedTitle:"2.2 linux安装",charIndex:687},{level:2,title:"3. 性能测试",slug:"_3-性能测试",normalizedTitle:"3. 性能测试",charIndex:2518},{level:2,title:"4. redis的基础知识",slug:"_4-redis的基础知识",normalizedTitle:"4. redis的基础知识",charIndex:3871},{level:3,title:"4.1 select 进行切换数据库！",slug:"_4-1-select-进行切换数据库",normalizedTitle:"4.1 select 进行切换数据库！",charIndex:3929},{level:3,title:"4.2 为什么redis是 6379！",slug:"_4-2-为什么redis是-6379",normalizedTitle:"4.2 为什么redis是 6379！",charIndex:5020},{level:3,title:"4.3 Redis 为什么单线程还这么快？",slug:"_4-3-redis-为什么单线程还这么快",normalizedTitle:"4.3 redis 为什么单线程还这么快？",charIndex:5085}],headersStr:"1. Redis概述 1.1 Redis 是什么 1.2 Redis能干什么 1.3 特性 1.4 redis下载地址 2. Redis安装 2.1 Windows安装 2.2 Linux安装 3. 性能测试 4. redis的基础知识 4.1 select 进行切换数据库！ 4.2 为什么redis是 6379！ 4.3 Redis 为什么单线程还这么快？",content:'# Redis入门\n\n\n# 1. Redis概述\n\n\n# 1.1 Redis 是什么\n\n> Redis（Remote Dictionary Server )，即远程字典服务 !\n\nRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n\n免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！\n\n\n# 1.2 Redis能干什么\n\n 1. 内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）\n\n 2. 效率高，可以用于高速缓存\n\n 3. 发布订阅系统\n\n 4. 地图信息分析\n\n 5. 计时器、计数器（浏览量！）\n\n\n# 1.3 特性\n\n 1. 多样的数据类型\n 2. 持久化\n 3. 集群\n 4. 事务\n\n\n# 1.4 redis下载地址\n\n> Redis推荐都是在Linux服务器上搭建的.\n\n官网：https://redis.io/\n\n中文网：http://www.redis.cn/\n\n\n# 2. Redis安装\n\n\n# 2.1 Windows安装\n\n 1. 下载安装包：https://github.com/microsoftarchive/redis/releases\n\n 2. 下载完毕得到压缩包：\n\n\n\n 3. 解压到自己电脑上的环境目录下的就可以的！Redis 十分的小，只有5M\n\n\n\n 4. 开启Redis，双击运行服务即可！\n\n\n\n 5. 使用redis客户单来来连接redis\n\n\n\n> 推荐使用Linux版\n\n\n# 2.2 Linux安装\n\n 1. 下载安装包\n\n\n\n 2. 解压Redis的安装包！\n\ntar -zxvf redis-5.0.8.tar.gz\n\n\n1\n\n\n\n\n 3. 进入解压后的文件，可以看到我们redis的配置文件\n\n\n\n 4. 基本的环境安装\n\n# 安装gcc\nyum install gcc-c++ \nmake \nmake install\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n 5. redis的默认安装路径 /usr/local/bin\n\n\n\n 6. 将redis配置文件。复制到我们当前目录下 /usr/local/bin/redis-config\n\n\n\n> 我们之后就使用这个文件进行启动\n\n 7. redis默认不是后台启动的,修改配置文件\n\nvim redis.conf\n\n\n1\n\n\n\n\n 8. 启动redis服务\n\n[root@VM_0_14_centos bin]# pwd\n/usr/local/bin\n[root@VM_0_14_centos bin]# redis-server redis-config/redis.conf\n31371:C 10 Jul 2020 16:29:52.963 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n31371:C 10 Jul 2020 16:29:52.963 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=31371, just started\n31371:C 10 Jul 2020 16:29:52.963 # Configuration loaded\n[root@VM_0_14_centos bin]# \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> redis-server redis-config/redis.conf: 启动redis 配置文件使用 redis-config/redis.conf\n\n 9. redis客户端连接 redis-cli -p 6379\n\n[root@VM_0_14_centos bin]#  ls\nredis-benchmark  redis-check-aof  redis-check-rdb  redis-cli  redis-config  redis-sentinel  redis-server    \n[root@VM_0_14_centos bin]# redis-cli -p 6379\n127.0.0.1:6379> ping\nPONG\n127.0.0.1:6379> set name chggx\nOK\n127.0.0.1:6379> get name\n"chggx"\n127.0.0.1:6379> get age\n(nil)\n127.0.0.1:6379> keys *\n1) "name"\n127.0.0.1:6379> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 10. 查看redis的进程是否开启！ps -ef | grep redis\n\n[root@VM_0_14_centos ~]#  ps -ef | grep redis\nroot     31372     1  0 16:29 ?        00:00:00 redis-server 127.0.0.1:6379\nroot     32639  5035  0 16:35 pts/0    00:00:00 redis-cli -p 6379\nroot     32714 32652  0 16:36 pts/2    00:00:00 grep --color=auto redis\n[root@VM_0_14_centos ~]# \n\n\n1\n2\n3\n4\n5\n\n 11. 如何关闭Redis服务呢？ shutdown\n\n\n\n 12. 再次查看进程是否存在\n\n[root@VM_0_14_centos ~]#  ps -ef | grep redis\nroot      1098 32652  0 16:40 pts/2    00:00:00 grep --color=auto redis\n[root@VM_0_14_centos ~]# \n\n\n1\n2\n3\n\n\n\n# 3. 性能测试\n\n> redis-benchmark 是一个压力测试工具！\n\n\n\n> 图片来源与菜鸟教程\n\n# 测试：100个并发连接 100000请求 \nredis-benchmark -h localhost -p 6379 -c 100 -n 100000\n\n\n1\n2\n\n\n[root@VM_0_14_centos bin]# redis-benchmark -h localhost -p 6379 -c 100 -n 100000\n====== PING_INLINE ======\n  100000 requests completed in 2.06 seconds\n  100 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n17.62% <= 1 milliseconds\n94.30% <= 2 milliseconds\n99.15% <= 3 milliseconds\n99.38% <= 4 milliseconds\n99.40% <= 5 milliseconds\n99.40% <= 7 milliseconds\n99.45% <= 8 milliseconds\n\n......\n\n====== SET ======\n  100000 requests completed in 2.16 seconds\n  100 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n12.27% <= 1 milliseconds\n88.90% <= 2 milliseconds\n99.16% <= 3 milliseconds\n99.75% <= 4 milliseconds\n99.78% <= 5 milliseconds\n99.85% <= 6 milliseconds\n99.96% <= 10 milliseconds\n99.98% <= 11 milliseconds\n100.00% <= 11 milliseconds\n46317.74 requests per second\n\n====== GET ======\n  100000 requests completed in 2.06 seconds\n  100 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n14.48% <= 1 milliseconds\n92.72% <= 2 milliseconds\n99.81% <= 3 milliseconds\n99.90% <= 7 milliseconds\n99.97% <= 8 milliseconds\n100.00% <= 8 milliseconds\n48543.69 requests per second\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n\n\n# 4. redis的基础知识\n\n> redis默认有 16 个数据库. 我们默认使用的是 0 个数据库.\n\n\n\n\n# 4.1 select 进行切换数据库！\n\n127.0.0.1:6379> select 3 # 切换数据库 3号\nOK\n127.0.0.1:6379[3]> DBSIZE # 查看数据库大小\n(integer) 0\n127.0.0.1:6379[3]> set name xiaohong\nOK\n127.0.0.1:6379[3]> DBSIZE\n(integer) 1\n127.0.0.1:6379> select 7 # 切换到别的数据库,查看是否有数据\nOK\n127.0.0.1:6379[7]> DBSIZE\n(integer) 0\n127.0.0.1:6379[7]> get name\n(nil)\n127.0.0.1:6379[7]> select 3 # 重新切换回3号数据库\nOK\n127.0.0.1:6379[3]> DBSIZE\n(integer) 1\n127.0.0.1:6379[3]> get name\n"xiaohong" \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 查看数据库所有key\n\n127.0.0.1:6379[3]> keys * # 查看数据库所有key\n1) "name"\n\n\n1\n2\n\n * 清空当前库所有数据: flushdb\n\n127.0.0.1:6379[3]> flushdb # 清空当前库所有数据\nOK \n127.0.0.1:6379[3]> keys *\n(empty list or set)\n\n\n1\n2\n3\n4\n\n * 清空所有库数据 flushall\n\n127.0.0.1:6379[3]> select 0 # 切换到0号库\nOK\n127.0.0.1:6379> keys * # 查看所有key\n1) "mylist"\n2) "myset:__rand_int__"\n3) "counter:__rand_int__"\n4) "name"\n5) "key:__rand_int__"\n127.0.0.1:6379> select 3 # 重新切换到3号数据库\nOK\n127.0.0.1:6379[3]> flushall # 清空所有库信息\nOK\n127.0.0.1:6379[3]> select 0 # 切换到0号库\nOK\n127.0.0.1:6379> keys * # 查看信息是否存在\n(empty list or set) # 不存在\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.2 为什么redis是 6379！\n\nhttps://www.zhihu.com/question/20084750\n\n\n# 4.3 Redis 为什么单线程还这么快？\n\n> Redis 是单线程的！\n\n1、误区1：高性能的服务器一定是多线程的？\n\n2、误区2：多线程（CPU上下文会切换！）一定比单线程效率高！\n\n先去CPU>内存>硬盘的速度要有所了解！\n\n核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！',normalizedContent:'# redis入门\n\n\n# 1. redis概述\n\n\n# 1.1 redis 是什么\n\n> redis（remote dictionary server )，即远程字典服务 !\n\nredis是一个开源的使用ansi c语言编写、支持网络、可基于内存亦可持久化的日志型、key-value数据库，并提供多种语言的api。\n\n免费和开源！是当下最热门的 nosql 技术之一！也被人们称之为结构化数据库！\n\n\n# 1.2 redis能干什么\n\n 1. 内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）\n\n 2. 效率高，可以用于高速缓存\n\n 3. 发布订阅系统\n\n 4. 地图信息分析\n\n 5. 计时器、计数器（浏览量！）\n\n\n# 1.3 特性\n\n 1. 多样的数据类型\n 2. 持久化\n 3. 集群\n 4. 事务\n\n\n# 1.4 redis下载地址\n\n> redis推荐都是在linux服务器上搭建的.\n\n官网：https://redis.io/\n\n中文网：http://www.redis.cn/\n\n\n# 2. redis安装\n\n\n# 2.1 windows安装\n\n 1. 下载安装包：https://github.com/microsoftarchive/redis/releases\n\n 2. 下载完毕得到压缩包：\n\n\n\n 3. 解压到自己电脑上的环境目录下的就可以的！redis 十分的小，只有5m\n\n\n\n 4. 开启redis，双击运行服务即可！\n\n\n\n 5. 使用redis客户单来来连接redis\n\n\n\n> 推荐使用linux版\n\n\n# 2.2 linux安装\n\n 1. 下载安装包\n\n\n\n 2. 解压redis的安装包！\n\ntar -zxvf redis-5.0.8.tar.gz\n\n\n1\n\n\n\n\n 3. 进入解压后的文件，可以看到我们redis的配置文件\n\n\n\n 4. 基本的环境安装\n\n# 安装gcc\nyum install gcc-c++ \nmake \nmake install\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n 5. redis的默认安装路径 /usr/local/bin\n\n\n\n 6. 将redis配置文件。复制到我们当前目录下 /usr/local/bin/redis-config\n\n\n\n> 我们之后就使用这个文件进行启动\n\n 7. redis默认不是后台启动的,修改配置文件\n\nvim redis.conf\n\n\n1\n\n\n\n\n 8. 启动redis服务\n\n[root@vm_0_14_centos bin]# pwd\n/usr/local/bin\n[root@vm_0_14_centos bin]# redis-server redis-config/redis.conf\n31371:c 10 jul 2020 16:29:52.963 # oo0ooo0ooo0oo redis is starting oo0ooo0ooo0oo\n31371:c 10 jul 2020 16:29:52.963 # redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=31371, just started\n31371:c 10 jul 2020 16:29:52.963 # configuration loaded\n[root@vm_0_14_centos bin]# \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> redis-server redis-config/redis.conf: 启动redis 配置文件使用 redis-config/redis.conf\n\n 9. redis客户端连接 redis-cli -p 6379\n\n[root@vm_0_14_centos bin]#  ls\nredis-benchmark  redis-check-aof  redis-check-rdb  redis-cli  redis-config  redis-sentinel  redis-server    \n[root@vm_0_14_centos bin]# redis-cli -p 6379\n127.0.0.1:6379> ping\npong\n127.0.0.1:6379> set name chggx\nok\n127.0.0.1:6379> get name\n"chggx"\n127.0.0.1:6379> get age\n(nil)\n127.0.0.1:6379> keys *\n1) "name"\n127.0.0.1:6379> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 10. 查看redis的进程是否开启！ps -ef | grep redis\n\n[root@vm_0_14_centos ~]#  ps -ef | grep redis\nroot     31372     1  0 16:29 ?        00:00:00 redis-server 127.0.0.1:6379\nroot     32639  5035  0 16:35 pts/0    00:00:00 redis-cli -p 6379\nroot     32714 32652  0 16:36 pts/2    00:00:00 grep --color=auto redis\n[root@vm_0_14_centos ~]# \n\n\n1\n2\n3\n4\n5\n\n 11. 如何关闭redis服务呢？ shutdown\n\n\n\n 12. 再次查看进程是否存在\n\n[root@vm_0_14_centos ~]#  ps -ef | grep redis\nroot      1098 32652  0 16:40 pts/2    00:00:00 grep --color=auto redis\n[root@vm_0_14_centos ~]# \n\n\n1\n2\n3\n\n\n\n# 3. 性能测试\n\n> redis-benchmark 是一个压力测试工具！\n\n\n\n> 图片来源与菜鸟教程\n\n# 测试：100个并发连接 100000请求 \nredis-benchmark -h localhost -p 6379 -c 100 -n 100000\n\n\n1\n2\n\n\n[root@vm_0_14_centos bin]# redis-benchmark -h localhost -p 6379 -c 100 -n 100000\n====== ping_inline ======\n  100000 requests completed in 2.06 seconds\n  100 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n17.62% <= 1 milliseconds\n94.30% <= 2 milliseconds\n99.15% <= 3 milliseconds\n99.38% <= 4 milliseconds\n99.40% <= 5 milliseconds\n99.40% <= 7 milliseconds\n99.45% <= 8 milliseconds\n\n......\n\n====== set ======\n  100000 requests completed in 2.16 seconds\n  100 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n12.27% <= 1 milliseconds\n88.90% <= 2 milliseconds\n99.16% <= 3 milliseconds\n99.75% <= 4 milliseconds\n99.78% <= 5 milliseconds\n99.85% <= 6 milliseconds\n99.96% <= 10 milliseconds\n99.98% <= 11 milliseconds\n100.00% <= 11 milliseconds\n46317.74 requests per second\n\n====== get ======\n  100000 requests completed in 2.06 seconds\n  100 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n14.48% <= 1 milliseconds\n92.72% <= 2 milliseconds\n99.81% <= 3 milliseconds\n99.90% <= 7 milliseconds\n99.97% <= 8 milliseconds\n100.00% <= 8 milliseconds\n48543.69 requests per second\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n\n\n# 4. redis的基础知识\n\n> redis默认有 16 个数据库. 我们默认使用的是 0 个数据库.\n\n\n\n\n# 4.1 select 进行切换数据库！\n\n127.0.0.1:6379> select 3 # 切换数据库 3号\nok\n127.0.0.1:6379[3]> dbsize # 查看数据库大小\n(integer) 0\n127.0.0.1:6379[3]> set name xiaohong\nok\n127.0.0.1:6379[3]> dbsize\n(integer) 1\n127.0.0.1:6379> select 7 # 切换到别的数据库,查看是否有数据\nok\n127.0.0.1:6379[7]> dbsize\n(integer) 0\n127.0.0.1:6379[7]> get name\n(nil)\n127.0.0.1:6379[7]> select 3 # 重新切换回3号数据库\nok\n127.0.0.1:6379[3]> dbsize\n(integer) 1\n127.0.0.1:6379[3]> get name\n"xiaohong" \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 查看数据库所有key\n\n127.0.0.1:6379[3]> keys * # 查看数据库所有key\n1) "name"\n\n\n1\n2\n\n * 清空当前库所有数据: flushdb\n\n127.0.0.1:6379[3]> flushdb # 清空当前库所有数据\nok \n127.0.0.1:6379[3]> keys *\n(empty list or set)\n\n\n1\n2\n3\n4\n\n * 清空所有库数据 flushall\n\n127.0.0.1:6379[3]> select 0 # 切换到0号库\nok\n127.0.0.1:6379> keys * # 查看所有key\n1) "mylist"\n2) "myset:__rand_int__"\n3) "counter:__rand_int__"\n4) "name"\n5) "key:__rand_int__"\n127.0.0.1:6379> select 3 # 重新切换到3号数据库\nok\n127.0.0.1:6379[3]> flushall # 清空所有库信息\nok\n127.0.0.1:6379[3]> select 0 # 切换到0号库\nok\n127.0.0.1:6379> keys * # 查看信息是否存在\n(empty list or set) # 不存在\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.2 为什么redis是 6379！\n\nhttps://www.zhihu.com/question/20084750\n\n\n# 4.3 redis 为什么单线程还这么快？\n\n> redis 是单线程的！\n\n1、误区1：高性能的服务器一定是多线程的？\n\n2、误区2：多线程（cpu上下文会切换！）一定比单线程效率高！\n\n先去cpu>内存>硬盘的速度要有所了解！\n\n核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（cpu上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案！',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Redis事务",frontmatter:{title:"Redis事务",date:"2023-02-27T11:23:36.000Z",permalink:"/pages/83c6d3/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E7%BC%93%E5%AD%98/3.Redis%E4%BA%8B%E5%8A%A1.html",relativePath:"04.后端应用框架/03.中间件/01.缓存/3.Redis事务.md",key:"v-57027c60",path:"/pages/83c6d3/",headers:[{level:2,title:"1.  参考",slug:"_1-参考",normalizedTitle:"1.  参考",charIndex:null},{level:2,title:"2. 特性",slug:"_2-特性",normalizedTitle:"2. 特性",charIndex:80},{level:2,title:"3. redis的事务：",slug:"_3-redis的事务",normalizedTitle:"3. redis的事务：",charIndex:221},{level:3,title:"1. 正常执行事务",slug:"_1-正常执行事务",normalizedTitle:"1. 正常执行事务",charIndex:284},{level:3,title:"2. 放弃事务！",slug:"_2-放弃事务",normalizedTitle:"2. 放弃事务！",charIndex:631},{level:3,title:"3. 异常",slug:"_3-异常",normalizedTitle:"3. 异常",charIndex:971}],headersStr:"1.  参考 2. 特性 3. redis的事务： 1. 正常执行事务 2. 放弃事务！ 3. 异常",content:'# Redis事务\n\n\n# 1. 参考\n\nRedis 事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！\n\n\n# 2. 特性\n\n * 一次性、顺序性、排他性！执行一些列的命令！\n\n * Redis事务没有没有 "隔离级别" 的概念！\n\n * 所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec\n\n * Redis单条命令式保存原子性的，但是事务不保证原子性！\n\n\n# 3. redis的事务：\n\n * 开启事务（multi）\n * 命令入队（......）\n * 执行事务（exec）\n\n\n# 1. 正常执行事务\n\n * 开启事务: multi\n * 执行事务: exec\n\n127.0.0.1:6379> multi # 开启事务\nOK\n# 命令入队 开始\n127.0.0.1:6379> set k1 v1\nQUEUED\n127.0.0.1:6379> set k2 v2\nQUEUED\n127.0.0.1:6379> get k2\nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n# 命令入队 结束\n127.0.0.1:6379> exec # 执行事务\n1) OK\n2) OK\n3) "v2"\n4) OK\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 使用在执行后,已经结束,需要重新开始\n\n\n# 2. 放弃事务！\n\n * 命令: discard\n\n127.0.0.1:6379> multi # 开启事务\nOK\n127.0.0.1:6379> set k1 v1\nQUEUED\n127.0.0.1:6379> set k2 v2\nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n127.0.0.1:6379> set k4 v4\nQUEUED\n127.0.0.1:6379> discard # 取消事务\nOK\n127.0.0.1:6379> get k4 # 取消事务后,事务队列中命令都不会被执行！\n(nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 取消事务后,事务队列中命令都不会被执行！\n\n\n# 3. 异常\n\n 1. 编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！\n\n127.0.0.1:6379> multi #  开启事务\nOK\n127.0.0.1:6379> set k1 v1\nQUEUED\n127.0.0.1:6379> set k2 v2\nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n127.0.0.1:6379> getset k3 # 错误的命令\n(error) ERR wrong number of arguments for \'getset\' command # 编译型异常\n127.0.0.1:6379> set k4 v4\nQUEUED\n127.0.0.1:6379> set k5 v5\nQUEUED\n127.0.0.1:6379> exec # 执行事务报错\n(error) EXECABORT Transaction discarded because of previous errors.\n127.0.0.1:6379> get k5 # 执行事务报错,事务队列的所有的命令都不会被执行\n(nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 执行事务报错,事务队列的所有的命令都不会被执行\n\n 2. 运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！\n\n127.0.0.1:6379> set k1 "v1" # k1 值为字符串\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> incr k1 # 自增+1\nQUEUED\n127.0.0.1:6379> set k2 v2\nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n127.0.0.1:6379> exec\n1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是 依旧正常执行成功了！\n2) OK\n3) OK\n127.0.0.1:6379> get k2\n"v2"\n127.0.0.1:6379> get k3\n"v3"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:'# redis事务\n\n\n# 1. 参考\n\nredis 事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！\n\n\n# 2. 特性\n\n * 一次性、顺序性、排他性！执行一些列的命令！\n\n * redis事务没有没有 "隔离级别" 的概念！\n\n * 所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！exec\n\n * redis单条命令式保存原子性的，但是事务不保证原子性！\n\n\n# 3. redis的事务：\n\n * 开启事务（multi）\n * 命令入队（......）\n * 执行事务（exec）\n\n\n# 1. 正常执行事务\n\n * 开启事务: multi\n * 执行事务: exec\n\n127.0.0.1:6379> multi # 开启事务\nok\n# 命令入队 开始\n127.0.0.1:6379> set k1 v1\nqueued\n127.0.0.1:6379> set k2 v2\nqueued\n127.0.0.1:6379> get k2\nqueued\n127.0.0.1:6379> set k3 v3\nqueued\n# 命令入队 结束\n127.0.0.1:6379> exec # 执行事务\n1) ok\n2) ok\n3) "v2"\n4) ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 使用在执行后,已经结束,需要重新开始\n\n\n# 2. 放弃事务！\n\n * 命令: discard\n\n127.0.0.1:6379> multi # 开启事务\nok\n127.0.0.1:6379> set k1 v1\nqueued\n127.0.0.1:6379> set k2 v2\nqueued\n127.0.0.1:6379> set k3 v3\nqueued\n127.0.0.1:6379> set k4 v4\nqueued\n127.0.0.1:6379> discard # 取消事务\nok\n127.0.0.1:6379> get k4 # 取消事务后,事务队列中命令都不会被执行！\n(nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n> 取消事务后,事务队列中命令都不会被执行！\n\n\n# 3. 异常\n\n 1. 编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！\n\n127.0.0.1:6379> multi #  开启事务\nok\n127.0.0.1:6379> set k1 v1\nqueued\n127.0.0.1:6379> set k2 v2\nqueued\n127.0.0.1:6379> set k3 v3\nqueued\n127.0.0.1:6379> getset k3 # 错误的命令\n(error) err wrong number of arguments for \'getset\' command # 编译型异常\n127.0.0.1:6379> set k4 v4\nqueued\n127.0.0.1:6379> set k5 v5\nqueued\n127.0.0.1:6379> exec # 执行事务报错\n(error) execabort transaction discarded because of previous errors.\n127.0.0.1:6379> get k5 # 执行事务报错,事务队列的所有的命令都不会被执行\n(nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 执行事务报错,事务队列的所有的命令都不会被执行\n\n 2. 运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！\n\n127.0.0.1:6379> set k1 "v1" # k1 值为字符串\nok\n127.0.0.1:6379> multi\nok\n127.0.0.1:6379> incr k1 # 自增+1\nqueued\n127.0.0.1:6379> set k2 v2\nqueued\n127.0.0.1:6379> set k3 v3\nqueued\n127.0.0.1:6379> exec\n1) (error) err value is not an integer or out of range # 虽然第一条命令报错了，但是 依旧正常执行成功了！\n2) ok\n3) ok\n127.0.0.1:6379> get k2\n"v2"\n127.0.0.1:6379> get k3\n"v3"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Redis数据类型",frontmatter:{title:"Redis数据类型",date:"2023-02-27T11:23:36.000Z",permalink:"/pages/f64944/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E7%BC%93%E5%AD%98/2.Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"04.后端应用框架/03.中间件/01.缓存/2.Redis数据类型.md",key:"v-0eceab46",path:"/pages/f64944/",headers:[{level:2,title:"1.  五大数据类型",slug:"_1-五大数据类型",normalizedTitle:"1.  五大数据类型",charIndex:null},{level:3,title:"1.0  Redis-Key",slug:"_1-0-redis-key",normalizedTitle:"1.0  redis-key",charIndex:null},{level:3,title:"1.1 String(字符串)",slug:"_1-1-string-字符串",normalizedTitle:"1.1 string(字符串)",charIndex:1570},{level:3,title:"1.2 List(列表)",slug:"_1-2-list-列表",normalizedTitle:"1.2 list(列表)",charIndex:6002},{level:3,title:"1.3 Set（集合）",slug:"_1-3-set-集合",normalizedTitle:"1.3 set（集合）",charIndex:12760},{level:3,title:"1.4 Hash",slug:"_1-4-hash",normalizedTitle:"1.4 hash",charIndex:17110},{level:3,title:"1.5 Zset(有序集合)",slug:"_1-5-zset-有序集合",normalizedTitle:"1.5 zset(有序集合)",charIndex:20016},{level:2,title:"2. 特殊数据类型",slug:"_2-特殊数据类型",normalizedTitle:"2. 特殊数据类型",charIndex:22554},{level:3,title:"2.1  Geospatial 地理位置",slug:"_2-1-geospatial-地理位置",normalizedTitle:"2.1  geospatial 地理位置",charIndex:null},{level:4,title:"2.1.1 介绍",slug:"_2-1-1-介绍",normalizedTitle:"2.1.1 介绍",charIndex:22591},{level:4,title:"2.2.2 命令",slug:"_2-2-2-命令",normalizedTitle:"2.2.2 命令",charIndex:22752},{level:4,title:"2.1.3 GEO 底层的实现原理",slug:"_2-1-3-geo-底层的实现原理",normalizedTitle:"2.1.3 geo 底层的实现原理",charIndex:27649},{level:3,title:"2.2 Hyperloglog",slug:"_2-2-hyperloglog",normalizedTitle:"2.2 hyperloglog",charIndex:28127},{level:4,title:"2.2.1 什么是基数？",slug:"_2-2-1-什么是基数",normalizedTitle:"2.2.1 什么是基数？",charIndex:28146},{level:4,title:"2.2.2 简介",slug:"_2-2-2-简介",normalizedTitle:"2.2.2 简介",charIndex:28225},{level:4,title:"2.2.3 优点",slug:"_2-2-3-优点",normalizedTitle:"2.2.3 优点",charIndex:28303},{level:4,title:"2.2.4 命令测试",slug:"_2-2-4-命令测试",normalizedTitle:"2.2.4 命令测试",charIndex:28538},{level:3,title:"2.3 Bitmap 位图",slug:"_2-3-bitmap-位图",normalizedTitle:"2.3 bitmap 位图",charIndex:29105},{level:4,title:"2.3.1  位存储",slug:"_2-3-1-位存储",normalizedTitle:"2.3.1  位存储",charIndex:null},{level:4,title:"2.3.2 测试",slug:"_2-3-2-测试",normalizedTitle:"2.3.2 测试",charIndex:29281}],headersStr:"1.  五大数据类型 1.0  Redis-Key 1.1 String(字符串) 1.2 List(列表) 1.3 Set（集合） 1.4 Hash 1.5 Zset(有序集合) 2. 特殊数据类型 2.1  Geospatial 地理位置 2.1.1 介绍 2.2.2 命令 2.1.3 GEO 底层的实现原理 2.2 Hyperloglog 2.2.1 什么是基数？ 2.2.2 简介 2.2.3 优点 2.2.4 命令测试 2.3 Bitmap 位图 2.3.1  位存储 2.3.2 测试",content:'# Redis数据类型\n\nRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。\n\n\n# 1. 五大数据类型\n\n\n# 1.0 Redis-Key\n\n127.0.0.1:6379> keys * # 查看所有key\n(empty list or set)\n127.0.0.1:6379> set name chggx # 设置key\nOK\n127.0.0.1:6379> keys *\n1) "name"\n127.0.0.1:6379> get name # 查看key\n"chggx"\n127.0.0.1:6379> set age 3\nOK\n127.0.0.1:6379> keys *\n1) "age"\n2) "name"\n127.0.0.1:6379> exists name # 判断当前的key是否存在\n(integer) 1\n127.0.0.1:6379> exists name1\n(integer) 0\n127.0.0.1:6379> move name 1 # 移除当前的key 1: 数据库号(16个数据库)\n(integer) 1\n127.0.0.1:6379> keys *\n1) "age"\n127.0.0.1:6379> set name chenguangxiang\nOK\n127.0.0.1:6379> keys *\n1) "age"\n2) "name"\n127.0.0.1:6379> get name\n"chenguangxiang"\n127.0.0.1:6379> expire name 10 # 设置key的过期时间，单位是秒\n(integer) 1\n127.0.0.1:6379> ttl name # 查看当前key的剩余时间\n(integer) 6\n127.0.0.1:6379> ttl name\n(integer) -2\n127.0.0.1:6379> keys *\n1) "age"\n127.0.0.1:6379> type age # 查看当前key的类型\nstring\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n> keys * : 查看所有key\n> \n> set name XX : 设置key\n> \n> get name: 查看key\n> \n> exists name : 判断当前的key是否存在\n> \n> move name 1 : 移除当前的key 1: 数据库号(16个数据库)\n> \n> expire name 10 : 设置key的过期时间，单位是秒\n> \n> ttl name : 查看当前key的剩余时间\n> \n> type age : 查看当前key的类型\n> \n> 注意: name为这里的key\n\n\n# 1.1 String(字符串)\n\n============================== 字符串拼接 ======================================\n# append: 拼接字符串,如果当前key不存在，就相当于setkey\n\n127.0.0.1:6379> set key1 v1 # 设置值\nOK\n127.0.0.1:6379> get key1 # 获取值\n"v1"\n127.0.0.1:6379> exists key1 # 判断某一个key是否存在\n(integer) 1\n127.0.0.1:6379> keys * # 获取所有key\n1) "key1"\n127.0.0.1:6379> append key1 "hello" # 追加字符串，如果当前key不存在，就相当于setkey\n(integer) 7\n127.0.0.1:6379> get key1 \n"v1hello"\n127.0.0.1:6379> strlen key1 # 获取字符串的长度！\n(integer) 7\n127.0.0.1:6379> append key1 ",chggx"\n(integer) 13\n127.0.0.1:6379> get key1\n"v1hello,chggx"\n===============================================================================\n\n=============================== 自增/自减 ======================================\n# 自增/自减 i++/i--\n# incr: 自增\n# decr: 自减\n# 步长 i+=\n# incrby: 设置步长，指定增量！\n# decrby: 设置步长，指定减量！\n\n127.0.0.1:6379> set views 0 # 初始浏览量0\nOK\n127.0.0.1:6379> get views\n"0"\n127.0.0.1:6379> incr views # 自增1 浏览量+1\n(integer) 1\n127.0.0.1:6379> incr views\n(integer) 2\n127.0.0.1:6379> get views\n"2"\n127.0.0.1:6379> decr views # 自减1 浏览量-1\n(integer) 1\n127.0.0.1:6379> decr views\n(integer) 0\n127.0.0.1:6379> incrby views 10 # 可以设置步长，指定增量！\n(integer) 10\n127.0.0.1:6379> incrby views 10\n(integer) 20\n127.0.0.1:6379> decrby views 10 # 可以设置步长，指定减量！\n(integer) 10\n127.0.0.1:6379> decrby views 10\n(integer) 0\n===============================================================================\n\n================================ 字符串范围 ====================================\n# range: 范围\n# getrange: 截取字符串\n# setrange: 替换指定位置开始的字符串！\n\n127.0.0.1:6379> set key1 "hello,redis" # 设置 key1 的值\nOK\n127.0.0.1:6379> get key1\n"hello,redis"\n127.0.0.1:6379> getrange key1 0 3 # 截取字符串 [0,3]\n"hell"\n127.0.0.1:6379> getrange key1 0 -1 # 获取全部的字符串 和 get key是一样的\n"hello,redis"\n\n# 替换\n127.0.0.1:6379> set key2 chengguangxiang\nOK\n127.0.0.1:6379> get key2\n"chengguangxiang"\n127.0.0.1:6379> setrange key2 1 xx # 替换指定位置开始的字符串！\n(integer) 15\n127.0.0.1:6379> get key2\n"cxxngguangxiang" \n===============================================================================\n\n===============================================================================\n# setex (set with expire) : 设置过期时间 \n# setnx (set if not exist) : 不存在在设置 （在分布式锁中会常常使用！）\n127.0.0.1:6379> setex key3 30 "hell" # 设置key3 的值为 hello,30秒后过期\nOK\n127.0.0.1:6379> ttl key3 \n(integer) 26\n127.0.0.1:6379> get key3\n"hell"\n127.0.0.1:6379> get key3\n(nil)\n127.0.0.1:6379> setnx mykey "redis" # 如果mykey 不存在，创建mykey 成功显示: 1 ,失败显示:0\n(integer) 1\n127.0.0.1:6379> keys *\n1) "mykey"\n127.0.0.1:6379> ttl key3\n(integer) -2\n127.0.0.1:6379> setnx mykey "mysql" # 如果mykey存在，创建失败！成功显示: 1 ,失败显示:0\n(integer) 0\n127.0.0.1:6379> get mykey\n"redis"\n===============================================================================\n\n============================== 批量设值 ========================================\n# mset: \n# mget: \n\n127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3 # 同时设置多个值\nOK\n127.0.0.1:6379> keys *\n1) "k2"\n2) "k3"\n3) "k1"\n127.0.0.1:6379> mget k1 k2 k3 # 同时获取多个值\n1) "v1"\n2) "v2"\n3) "v3"\n127.0.0.1:6379> msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起 失败！\n(integer) 0\n127.0.0.1:6379> get k4\n(nil)\n===============================================================================\n\n============================== 对象[重点] ======================================\n# set user:1 {name:zhangsan,age:5}: 这只一个user:1对象,值为json字符来保存一个对象\n\n# 这里的key是一个巧妙的设计： user:{id}:{filed} , 如此设计在Redis中是完全OK了！\n127.0.0.1:6379> mset user:1:name zhangsan user:1:age 2\nOK\n127.0.0.1:6379> mget user:1:name user:1:age\n1) "zhangsan"\n2) "2"\n\n# 场景: 可以用于文章浏览量\n=============================== getset ========================================\n# getset: 先get然后在set\n\n127.0.0.1:6379> getset db redis # 如果不存在值，则返回 nil\n(nil)\n127.0.0.1:6379> get db\n"redis"\n127.0.0.1:6379> getset db mysql # 如果存在值，获取原来的值，并设置新的值\n"redis"\n127.0.0.1:6379> get db\n"mysql"\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n\n\n数据结构是相同的！\n\nString类型的使用场景：value除了是我们的字符串还可以是我们的数字！\n\n * 计数器\n\n * 统计多单位的数量\n\n * 粉丝数\n\n * 对象缓存存储！\n\n\n# 1.2 List(列表)\n\n基本数据类型 列表\n\n\n\n> 在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！\n\n所有的list命令都是用 l开头的，Redis命令不区分大小\n\n================================= 左边/右边插入 ================================\n# lpush: 将一个值或者多个值，插入到列表头部 （左）\n# rpush: 将一个值或者多个值，插入到列表位部 （右）\n# lrange: 获取list中值！\n\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> lpush list one # 将一个值或者多个值，插入到列表头部 （左）\n(integer) 1\n127.0.0.1:6379> lpush list two\n(integer) 2\n127.0.0.1:6379> lpush list three\n(integer) 3\n127.0.0.1:6379> lrange list 0 -1 # 获取list中值！\n1) "three"\n2) "two"\n3) "one"\n127.0.0.1:6379> lrange list 0 1 # 通过区间获取具体的值！\n1) "three"\n2) "two"\n127.0.0.1:6379> rpush list chggx # 将一个值或者多个值，插入到列表位部 （右）\n(integer) 4\n127.0.0.1:6379> lrange list 0 1\n1) "three"\n2) "two"\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "two"\n3) "one"\n4) "chggx"\n===============================================================================\n\n================================= 移除 ========================================\n# lpop: 移除list的第一个元素 (左边)\n# rpop: 移除list的最后一个元素 (右边)\n\n127.0.0.1:6379> keys *\n1) "list"\n127.0.0.1:6379> lrange list 0 -1 \n1) "three"\n2) "two"\n3) "one"\n4) "chggx"\n127.0.0.1:6379> lpop list # 移除list的第一个元素 (左边)\n"three"\n127.0.0.1:6379> lrange list 0 -1\n1) "two"\n2) "one"\n3) "chggx"\n127.0.0.1:6379> rpop list  # 移除list的最后一个元素 (右边)\n"chggx"\n127.0.0.1:6379> lrange list 0 -1\n1) "two"\n2) "one"\n===============================================================================\n\n================================== 下标 =======================================\n# lindex: 通过下标获得 list 中的某一个值！\n\n127.0.0.1:6379> lrange list 0 -1 \n1) "two"\n2) "one"\n127.0.0.1:6379> lindex list 1 # 通过下标获得 list 中的某一个值！\n"one"\n127.0.0.1:6379> lindex list 0\n"two"\n===============================================================================\n\n================================== 长度 =======================================\nllen: 获取list列表长度\n\n127.0.0.1:6379> lpush list one \n(integer) 1\n127.0.0.1:6379> lpush list two\n(integer) 2\n127.0.0.1:6379> lpush list three\n(integer) 3\n127.0.0.1:6379> llen list # 返回列表的长度\n(integer) 3\n===============================================================================\n\n================================ 移除指定的值 ==================================\n# lrem : 移除指定的值！ 取关 uid\n\n127.0.0.1:6379> lpush list three\n(integer) 4\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "three"\n3) "two"\n4) "one"\n127.0.0.1:6379> lrem list 1 one  # 移除list集合中指定个数的value,精确匹配\n(integer) 1\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "three"\n3) "two"\n127.0.0.1:6379> lrem list 1 three\n(integer) 1\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "two"\n127.0.0.1:6379> lpush list three\n(integer) 3\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "three"\n3) "two"\n127.0.0.1:6379> lrem list 2 three\n(integer) 2\n127.0.0.1:6379> lrange list 0 -1\n1) "two"\n===============================================================================\n\n=============================== 修剪(截取)trim =================================\n# trim 修剪(截取指定值): list 截断 !\n\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> rpush mylist "hello" \n(integer) 1\n127.0.0.1:6379> rpush mylist "hello1"\n(integer) 2\n127.0.0.1:6379> rpush mylist "hello2"\n(integer) 3\n127.0.0.1:6379> rpush mylist "hello3"\n(integer) 4\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "hello1"\n3) "hello2"\n4) "hello3"\n127.0.0.1:6379> ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了 只剩下截取的元素\nOK\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello1"\n2) "hello2"\n===============================================================================\n\n=============================== rpoplpush =====================================\n# rpoplpush: 移除列表的最后一个元素，将他移动到新的列表中！\n\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> rpush mylist "hello"\n(integer) 1\n127.0.0.1:6379> rpush mylist "hell01"\n(integer) 2\n127.0.0.1:6379> rpush mylist "hell02"\n(integer) 3\n127.0.0.1:6379> rpush mylist "hell03"\n(integer) 4\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "hell01"\n3) "hell02"\n4) "hell03"\n127.0.0.1:6379> rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的 列表中！\n"hell03"\n127.0.0.1:6379> lrange mylist 0 -1 # 查看原来的列表\n1) "hello"\n2) "hell01"\n3) "hell02"\n127.0.0.1:6379> lrange myotherlist 0 -1 # 查看目标列表中，确实存在改值！\n1) "hell03"\n===============================================================================\n\n============================= exists/lset =====================================\n# exists: 判断list列表是否存在\n# lset: 将列表中指定下标的值替换为另外一个值，"更新操作"(key不存在时( ERR no such key),不能直接使用lset创建可以,需使用lpush/rpush. index下标不存在时(ERR index out of range),不能直接使用)\n\n127.0.0.1:6379> keys * \n(empty list or set)\n127.0.0.1:6379> exists list # 判断这个列表是否存在\n(integer) 0\n127.0.0.1:6379> lset list 0 item # 如果不存在列表,我们使用lset去更新就会报错\n(error) ERR no such key\n127.0.0.1:6379> lpush list value1 # 设置值 (左)\n(integer) 1\n127.0.0.1:6379> lrange list 0 0 # 获取下标"0"值\n1) "value1"\n127.0.0.1:6379> lset list 0 item # 下标"0", 如果存在，更新当前下标的值\nOK\n127.0.0.1:6379> lrange list 0 0 \n1) "item"\n127.0.0.1:6379> lset list 1 other\n(error) ERR index out of range\n===============================================================================\n\n=============================== linsert (插入) ================================\n# linsert: 将某个具体的value插入到列表中某个元素的前面或者后面！\n\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> rpush mylist "hello"\n(integer) 1\n127.0.0.1:6379> rpush mylist "world"\n(integer) 2\n127.0.0.1:6379> lrange mylist 0 -1 # 获取所有mylist值\n1) "hello"\n2) "world"\n127.0.0.1:6379> linsert mylist before "world" "other" # 将某个具体的value插入到列表中某个元素的前面！\n(integer) 3\n127.0.0.1:6379> lrange mylist 0 -1 # 获取所有mylist值\n1) "hello"\n2) "other"\n3) "world"\n127.0.0.1:6379> linsert mylist after world after # 将某个具体的value插入到列表中某个元素的后面！\n(integer) 4\n127.0.0.1:6379> lrange mylist 0 -1 # 获取所有mylist值\n1) "hello"\n2) "other"\n3) "world"\n4) "after"\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n\n\n> 小结:\n> \n> 他实际上是一个链表，before Node after ， left，right 都可以插入值\n> \n> 如果key 不存在，创建新的链表\n> \n> 如果key存在，新增内容\n> \n> 如果移除了所有值，空链表，也代表不存在！\n> \n> 在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~\n\nlist列表应用场景: 消息排队！消息队列 （Lpush Rpop），栈（ Lpush Lpop）！\n\n\n# 1.3 Set（集合）\n\nset中的值是不能重读的！ set是不重复的.\n\n============================= 基础 =======================================\n# sadd: set集合中添加元素\n# smembers: 查看指定set的所有值\n# sismember: 判断某一个值是不是在set集合中\n\n127.0.0.1:6379> sadd myset "hello" # set集合中添加元素\n(integer) 1\n127.0.0.1:6379> sadd myset "world" \n(integer) 1\n127.0.0.1:6379> sadd myset "chggx"\n(integer) 1\n127.0.0.1:6379> smembers myset # 查看指定set的所有值\n1) "chggx"\n2) "hello"\n3) "world"\n127.0.0.1:6379> sismember myset hello # 判断某一个值是不是在set集合中！\n(integer) 1\n127.0.0.1:6379> sismember myset redis\n(integer) 0\n===============================================================================\n\n============================= scard (元素个数) =================================\n# scard: 获取set集合中的内容元素个数！\n\n127.0.0.1:6379> scard myset # 获取set集合中的内容元素个数！\n(integer) 3\n127.0.0.1:6379> sadd myset "hello" # set集合中添加元素\n(integer) 0\n127.0.0.1:6379> sadd myset "redis" # 说明 set 集合 的元素是不重复的\n(integer) 1\n127.0.0.1:6379> scard myset # 获取set集合中的内容元素个数！\n(integer) 4\n============================= srem (移除元素) ================================\n# srem: 移除set集合中的指定元素\n\n127.0.0.1:6379> smembers myset\n1) "chggx"\n2) "hello"\n3) "redis"\n4) "world"\n127.0.0.1:6379> scard myset\n(integer) 4\n127.0.0.1:6379> srem myset chggx # 移除set集合中的指定元素\n(integer) 1\n127.0.0.1:6379> scard myset // 获取set集合中内容的元素个数\n(integer) 3\n127.0.0.1:6379> smembers myset // 查看set集合的值\n1) "hello"\n2) "redis"\n3) "world"\n===============================================================================\n\n============================== srandmember ====================================\n# set 无序不重复集合,抽随机\n# srandmember: 随机抽取出指定个数元素\n\n127.0.0.1:6379> smembers myset\n1) "hello"\n2) "redis"\n3) "world"\n127.0.0.1:6379> srandmember myset # 随机抽取出一个元素\n"hello"\n127.0.0.1:6379> srandmember myset \n"redis"\n127.0.0.1:6379> srandmember myset \n"world"\n127.0.0.1:6379> srandmember myset 2 # 随机抽取出指定个数元素\n1) "redis"\n2) "world"\n127.0.0.1:6379> srandmember myset 2\n1) "redis"\n2) "world"\n===============================================================================\n\n============================== spop (随机删key) ================================\n删除定的key，随机删除key！\n\n127.0.0.1:6379> smembers myset\n1) "hello"\n2) "redis"\n3) "world"\n127.0.0.1:6379> spop myset # 随机删除一些set集合中的元素(弹出set集合中的元素)\n"world"\n127.0.0.1:6379> spop myset\n"hello"\n127.0.0.1:6379> smembers myset\n1) "redis"\n================================ smove =======================================\n# smove: 将一个指定的值，移动到另外一个set集合！\n\n127.0.0.1:6379> sadd myset "hell0"\n(integer) 1\n127.0.0.1:6379> sadd myset "world"\n(integer) 1\n127.0.0.1:6379> sadd myset "chggx"\n(integer) 1\n127.0.0.1:6379> smembers myset\n1) "chggx"\n2) "hell0"\n3) "world"\n127.0.0.1:6379> sadd myset2 "set2"\n(integer) 1\n127.0.0.1:6379> smembers myset2\n1) "set2"\n127.0.0.1:6379> smove myset myset2 "chggx" #  将一个指定的值，移动到另外一个set集合！\n(integer) 1\n127.0.0.1:6379> smembers myset\n1) "hell0"\n2) "world"\n127.0.0.1:6379> smembers myset2\n1) "chggx"\n2) "set2"\n===============================================================================\n\n================================ 并集 =========================================\n # 数字集合类： \n# \t- 差集 sdiff \n# \t- 交集 sinter\n# \t- 并集 sunion\n\n127.0.0.1:6379> sadd key1 "a"\n(integer) 1\n127.0.0.1:6379> sadd key1 "b"\n(integer) 1\n127.0.0.1:6379> sadd key1 "c"\n(integer) 1\n127.0.0.1:6379> sadd key2 "c"\n(integer) 1\n127.0.0.1:6379> sadd key2 "d"\n(integer) 1\n127.0.0.1:6379> sadd key2 "e"\n(integer) 1\n127.0.0.1:6379> smembers key1\n1) "b"\n2) "c"\n3) "a"\n127.0.0.1:6379> smembers key2\n1) "d"\n2) "c"\n3) "e"\n127.0.0.1:6379> sdiff key1 key2 # 差集\n1) "b"\n2) "a"\n127.0.0.1:6379> sinter key1 key2 # 交集 共同好友就可以这样实现\n1) "c"\n127.0.0.1:6379> sunion key1 key2 # 并集\n1) "c"\n2) "a"\n3) "d"\n4) "b"\n5) "e"\n\n# 场景:\n# 微博，B站，共同关注！(并集)\n# 微博，A用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！\n# 共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n\n\n\n# 1.4 Hash\n\nMap集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的 key-vlaue！\n\n============================== 基础 ========================================\n# hset: set一个具体 key-vlaue\n# hget: 获取一个字段值\n# hmset: set多个 key-vlaue\n# hmget: 获取多个字段值\n# hgetall: 获取全部的数据(以ley-value形式展示)\n# hdel: 删除hash中指定key字段！对应的value值也就消失了！\n\n127.0.0.1:6379> hset myhash field1 chggx # set一个具体 key-vlaue\n(integer) 1\n127.0.0.1:6379> hget myhash field1 # 获取一个字段值\n"chggx"\n127.0.0.1:6379> hmset myhash field1 hello field2 world  # set多个 key-vlaue\nOK\n127.0.0.1:6379> hmget myhash field1 field2 # 获取多个字段值\n1) "hello"\n2) "world"\n127.0.0.1:6379> hgetall myhash # 获取全部的数据\n1) "field1"\n2) "hello"\n3) "field2"\n4) "world"\n127.0.0.1:6379> hdel myhash field1 # 删除hash中指定key字段！对应的value值也就消失了！\n(integer) 1\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "world"\n===============================================================================\n\n=============================== 长度(hlen) ====================================\n# hlen: 获取hash表的字段数量！\n\n127.0.0.1:6379> hmset myhash field1 hello field2 world\nOK\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "world"\n3) "field1"\n4) "hello"\n127.0.0.1:6379> hlen myhash # 获取hash表的字段数量！\n(integer) 2\n===============================================================================\n\n=============================== 指定字段是否存在 ================================\n# hexists: \n\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "world"\n3) "field1"\n4) "hello"\n127.0.0.1:6379> hexists myhash field1 # 判断hash中指定字段是否存在！\n(integer) 1\n127.0.0.1:6379> hexists myhash field3\n(integer) 0\n===============================================================================\n\n============================= 单独获取field/value ==============================\n# hkeys: 只获得所有field \n# hvals: 只获得所有value\n\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "world"\n3) "field1"\n4) "hello"\n127.0.0.1:6379> hkeys myhash # 只获得所有field\n1) "field2"\n2) "field1"\n127.0.0.1:6379> hvals myhash # 只获得所有value\n1) "world"\n2) "hello"\n===============================================================================\n\n================================ 自增/自减======================================\nincr/decr\n\n127.0.0.1:6379> hset myhash field3 5\n(integer) 1\n127.0.0.1:6379> hincrby myhash field3 1 # 指定增量\n(integer) 6\n127.0.0.1:6379> hincrby myhash field3 1\n(integer) 7\n127.0.0.1:6379> hincrby myhash field3 -1\n(integer) 6\n127.0.0.1:6379> hsetnx myhash field4 hello # 如果不存在则可以设置\n(integer) 1\n127.0.0.1:6379> hsetnx myhash field4 hello # 如果存在则不可以设置\n(integer) 0\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n> hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！\n> \n> hash 更适合于对象的存储，String更加适合字符串存储！\n\n\n# 1.5 Zset(有序集合)\n\n在set的基础上，增加了一个值，set k1 v1 zset k1 score1 v1\n\n================================ 基础 =========================================\n# zadd: 添加一个/多个值\n# zrange: 获取所有值\n\n127.0.0.1:6379> zadd myset 1 one # 添加一个值\n(integer) 1\n127.0.0.1:6379> zadd myset 2 two 3 three # 添加多个值\n(integer) 2\n127.0.0.1:6379> zrange myset 0 -1 # 获取所有值\n1) "one"\n2) "two"\n3) "three"\n===============================================================================\n\n=============================== 排序如何实现 ===================================\n# zrangebyscore: 由低到高排序\n# zrevrange: [反转] 倒序排列\n\n127.0.0.1:6379> zadd salary 2500 zhangsan # 添加三个用户\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 lisi\n(integer) 1\n127.0.0.1:6379> zadd salary 500 wangwu\n(integer) 1\n# 语法: ZRANGEBYSCORE key min max\n127.0.0.1:6379> zrangebyscore salary -inf +inf # 显示全部的用户 从小到大！(-∞,+∞) "wangwu"\n2) "zhangsan"\n3) "lisi"\n127.0.0.1:6379> zrevrange salary 0 -1  # 从大到进行排序！\n1) "lisi"\n2) "zhangsan"\n127.0.0.1:6379> zrangebyscore salary -inf +inf withscores # 显示全部的用户并且附带成绩\n1) "wangwu"\n2) "500"\n3) "zhangsan"\n4) "2500"\n5) "lisi"\n6) "5000"\n127.0.0.1:6379> zrangebyscore salary -inf 2500 withscores # 显示工资小于2500员工的升序排序！\n1) "wangwu"\n2) "500"\n3) "zhangsan"\n4) "2500"\n===============================================================================\n\n================================ 移除(zrem) ===================================\n# zrem: 移除有序集合中的指定元素\n# zcard: 获取有序集合中的个数\n\n127.0.0.1:6379> zrange salary 0 -1\n1) "wangwu"\n2) "zhangsan"\n3) "lisi"\n127.0.0.1:6379> zrem salary wangwu # 移除有序集合中的指定元素\n(integer) 1\n127.0.0.1:6379> zrange salary 0 -1\n1) "zhangsan"\n2) "lisi"\n127.0.0.1:6379> zcard salary # 获取有序集合中的个数\n(integer) 2\n===============================================================================\n\n=============================== zcount(统计) ==================================\n# zcount: 获取指定区间的成员数量！\n\n127.0.0.1:6379> zadd myset 1 hello\n(integer) 1\n127.0.0.1:6379> zadd myset 2 world 3 chggx\n(integer) 2\n127.0.0.1:6379> zrange myset 0 -1\n1) "hello"\n2) "world"\n3) "chggx"\n127.0.0.1:6379> zcount myset 1 3 # 获取指定区间的成员数量！\n(integer) 3\n127.0.0.1:6379> zcount myset 1 2\n(integer) 2\n127.0.0.1:6379> zcount myset 1 1\n(integer) 1\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n案例思路：set 排序 存储班级成绩表，工资表排序！\n\n普通消息，1， 重要消息 2，带权重进行判断！\n\n排行榜应用实现，取Top N 测试！\n\n\n# 2. 特殊数据类型\n\n\n# 2.1 Geospatial 地理位置\n\n# 2.1.1 介绍\n\n场景: 朋友的定位，附近的人，打车距离计算？\n\nRedis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！\n\n可以查询一些测试数据：http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/\n\n# 2.2.2 命令\n\nredis Geospatial 的6个命令\n\n官方文档：https://www.redis.net.cn/order/3685.html\n\n\n\n 1. geoadd\n\n * geoadd 添加地理位置\n\n# 参数 key 值（经度、纬度、名称）\n127.0.0.1:6379> geoadd china:city 116.40 39.90 beijing\n(integer) 1\n127.0.0.1:6379> geoadd china:city 121.47 31.23 shanghai \n(integer) 1\n127.0.0.1:6379> geoadd china:city 120.15 30.28 hangzhou\n(integer) 1\n127.0.0.1:6379> geoadd china:city 106.50 29.53 chongqing\n(integer) 1\n127.0.0.1:6379> geoadd china:city 114.08 22.54 shenzhen\n(integer) 1\n127.0.0.1:6379> geoadd china:city 113.66 34.75 zhengzhou\n(integer) 1\n127.0.0.1:6379> geoadd china:city 118.76 32.04 nanjing 118.11 24.49 xiamen\n(integer) 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> # 规则：两极无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！\n> \n> # 有效的经度从-180度到180度。\n> \n> # 有效的纬度从-85.05112878度到85.05112878度。\n> \n> # 当坐标位置超出上述指定范围时，该命令将会返回一个错误。\n\n 2. geopos\n\n获得当前定位：一定是一个坐标值！\n\n127.0.0.1:6379> geopos china:city beijing # 获取指定的城市的经度和纬度！\n1) 1) "116.39999896287918091"\n   2) "39.90000009167092543"\n127.0.0.1:6379> geopos china:city hangzhou\n1) 1) "120.15000075101852417"\n   2) "30.2800007575645509"\n127.0.0.1:6379> geopos china:city nanjing shenzhen\n1) 1) "118.75999957323074341"\n   2) "32.03999960287850968"\n2) 1) "114.08000081777572632"\n   2) "22.53999903789756587"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 3. geodist\n\n * 返回两个给定位置之间的距离。\n\n * 单位：\n   \n   m 表示单位为米。\n   \n   km 表示单位为千米。\n   \n   mi 表示单位为英里。\n   \n   ft 表示单位为英尺。\n\n127.0.0.1:6379> geodist china:city beijing shanghai km # 查看北京到上海的直线距离\n"1067.3788"\n127.0.0.1:6379> geodist china:city beijing hangzhou km # 查看北京到杭州的直线距离\n"1122.7998"\n127.0.0.1:6379> geodist china:city beijing chongqing km # 查看北京到重庆的直线距离\n"1464.0708"\n127.0.0.1:6379> geodist china:city beijing shenzhen km # 查看北京到深圳的直线距离\n"1943.2550"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. georadius\n\n * 以给定的经纬度为中心， 找出某一半径内的元素\n\n * 应用:\n   \n   我附近的人(找朋友)？ （获得所有附近的人的地址，定位！）通过半径来查询！\n\n127.0.0.1:6379> georadius china:city 110 30 500 km # 以110，30 这个经纬度为中心，寻 找方圆500km内的城市\n1) "chongqing"\n127.0.0.1:6379> georadius china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻 找方圆1000km内的城市\n1) "chongqing"\n2) "shenzhen"\n3) "hangzhou"\n4) "zhengzhou"\n5) "nanjing"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist # 显示到中间距离的位置\n1) 1) "chongqing"\n   2) "341.9374"\n2) 1) "shenzhen"\n   2) "923.9364"\n3) 1) "hangzhou"\n   2) "976.4868"\n4) 1) "zhengzhou"\n   2) "630.2160"\n5) 1) "nanjing"\n   2) "864.9816"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withcoord # 显示他人的定位信息\n1) 1) "chongqing"\n   2) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n2) 1) "shenzhen"\n   2) 1) "114.08000081777572632"\n      2) "22.53999903789756587"\n3) 1) "hangzhou"\n   2) 1) "120.15000075101852417"\n      2) "30.2800007575645509"\n4) 1) "zhengzhou"\n   2) 1) "113.65999907255172729"\n      2) "34.74999926510690784"\n5) 1) "nanjing"\n   2) 1) "118.75999957323074341"\n      2) "32.03999960287850968"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist withcoord count 1\n# 筛选出指定的结果！\n1) 1) "chongqing"\n   2) "341.9374"\n   3) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist withcoord count 2\n# 筛选出指定的结果！\n1) 1) "chongqing"\n   2) "341.9374"\n   3) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n2) 1) "zhengzhou"\n   2) "630.2160"\n   3) 1) "113.65999907255172729"\n      2) "34.74999926510690784"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist withcoord count 3\n# 筛选出指定的结果！\n1) 1) "chongqing"\n   2) "341.9374"\n   3) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n2) 1) "zhengzhou"\n   2) "630.2160"\n   3) 1) "113.65999907255172729"\n      2) "34.74999926510690784"\n3) 1) "nanjing"\n   2) "864.9816"\n   3) 1) "118.75999957323074341"\n      2) "32.03999960287850968"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist withcoord count 4\n# 筛选出指定的结果！\n1) 1) "chongqing"\n   2) "341.9374"\n   3) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n2) 1) "zhengzhou"\n   2) "630.2160"\n   3) 1) "113.65999907255172729"\n      2) "34.74999926510690784"\n3) 1) "nanjing"\n   2) "864.9816"\n   3) 1) "118.75999957323074341"\n      2) "32.03999960287850968"\n4) 1) "shenzhen"\n   2) "923.9364"\n   3) 1) "114.08000081777572632"\n      2) "22.53999903789756587"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n 5. georadiusbymember [定位]\n\n * 找出位于指定元素周围的其他元素！\n\n127.0.0.1:6379> georadiusbymember china:city beijjing 1000 km\n1) "zhengzhou"\n2) "nanjing"\n3) "beijjing"\n127.0.0.1:6379> georadiusbymember china:city shanghai 400 km\n1) "hangzhou"\n2) "shanghai"\n3) "nanjing"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 6. geohash\n\n * 命令 - 返回一个或多个位置元素的 Geohash 表示\n * 该命令将返回11个字符的Geohash字符串!\n\n# 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！\n127.0.0.1:6379> geohash china:city beijjing zhengzhou\n1) "wx4fbxxfke0"\n2) "ww0vdqh9mv0"\n\n\n1\n2\n3\n4\n\n\n# 2.1.3 GEO 底层的实现原理\n\nGEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！\n\n127.0.0.1:6379> zrange china:city 0 -1 # 查看地图中全部的元素\n1) "chongqing"\n2) "shenzhen"\n3) "xiamen"\n4) "hangzhou"\n5) "shanghai"\n6) "zhengzhou"\n7) "nanjing"\n8) "beijjing"\n127.0.0.1:6379> zrem china:city xiamen # 移除指定元素！\n(integer) 1\n127.0.0.1:6379> zrange china:city 0 -1\n1) "chongqing"\n2) "shenzhen"\n3) "hangzhou"\n4) "shanghai"\n5) "zhengzhou"\n6) "nanjing"\n7) "beijjing"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.2 Hyperloglog\n\n# 2.2.1 什么是基数？\n\n * A {1,3,5,7,8,7}\n * B {1,3,5,7,8}\n\n> 基数（不重复的元素） = 5，可以接受误差！\n\n# 2.2.2 简介\n\nRedis 2.8.9 版本就更新了 Hyperloglog 数据结构！\n\nRedis Hyperloglog 基数统计的算法！\n\n# 2.2.3 优点\n\n优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的话 Hyperloglog 首选！\n\n网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）\n\n传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !\n\n这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；\n\n0.81% 错误率！ 统计UV任务，可以忽略不计的！\n\n# 2.2.4 命令测试\n\n# pfadd: 创建\n# pfcount: 统计\n# pfmerge: 合并(获取一个并集)\n\n127.0.0.1:6379> pfadd mykey a b c d e f g h i j # 创建第一组元素 mykey\n(integer) 1\n127.0.0.1:6379> pfcount mykey  # 统计 mykey 元素的基数数量\n(integer) 10\n127.0.0.1:6379> pfadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2\t\n(integer) 1\n127.0.0.1:6379> pfcount mykey2\n(integer) 9\n127.0.0.1:6379> pfmerge mykey3 mykey mykey2 # 合并两组 mykey mykey2 => mykey3 并集\nOK\n127.0.0.1:6379> pfcount mykey3 # 看并集的数量！\n(integer) 15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 如果允许容错，那么一定可以使用 Hyperloglog ！\n> \n> 如果不允许容错，就使用 set 或者自己的数据类型即可！\n\n\n# 2.3 Bitmap 位图\n\n# 2.3.1 位存储\n\n场景: 统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用Bitmaps！\n\nBitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！\n\n> 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！\n\n# 2.3.2 测试\n\n 1. 使用bitmap 来记录 周一到周日的打卡！\n\n * 周一：1 周二：0 周三：0 周四：1 ......\n\n127.0.0.1:6379> setbit sign 0 1\n(integer) 0\n127.0.0.1:6379> setbit sign 1 0\n(integer) 0\n127.0.0.1:6379> setbit sign 2 0\n(integer) 0\n127.0.0.1:6379> setbit sign 3 1\n(integer) 0\n127.0.0.1:6379> setbit sign 4 1\n(integer) 0\n127.0.0.1:6379> setbit sign 5 0\n(integer) 0\n127.0.0.1:6379> setbit sign 6 0\n(integer) 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 2. 查看某一天是否有打卡！\n\n127.0.0.1:6379> getbit sign 3 # 查看周四是否打卡\n(integer) 1\n127.0.0.1:6379> getbit sign 6 # 查看周日是否打卡\n(integer) 0\n127.0.0.1:6379> getbit sign 0 # 查看周一是否打卡\n(integer) 1\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 统计操作，统计 打卡的天数！\n\n127.0.0.1:6379> bitcount sign # 统计这周的打卡记录,就可以查看是否全勤\n(integer) 3\n127.0.0.1:6379> bitcount sign 0 5 # 统计周一到周六打卡记录\n(integer) 3\n\n\n1\n2\n3\n4\n',normalizedContent:'# redis数据类型\n\nredis 是一个开源（bsd许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 redis 内置了 复制（replication），lua脚本（lua scripting）， lru驱动事件（lru eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 redis哨兵（sentinel）和自动 分区（cluster）提供高可用性（high availability）。\n\n\n# 1. 五大数据类型\n\n\n# 1.0 redis-key\n\n127.0.0.1:6379> keys * # 查看所有key\n(empty list or set)\n127.0.0.1:6379> set name chggx # 设置key\nok\n127.0.0.1:6379> keys *\n1) "name"\n127.0.0.1:6379> get name # 查看key\n"chggx"\n127.0.0.1:6379> set age 3\nok\n127.0.0.1:6379> keys *\n1) "age"\n2) "name"\n127.0.0.1:6379> exists name # 判断当前的key是否存在\n(integer) 1\n127.0.0.1:6379> exists name1\n(integer) 0\n127.0.0.1:6379> move name 1 # 移除当前的key 1: 数据库号(16个数据库)\n(integer) 1\n127.0.0.1:6379> keys *\n1) "age"\n127.0.0.1:6379> set name chenguangxiang\nok\n127.0.0.1:6379> keys *\n1) "age"\n2) "name"\n127.0.0.1:6379> get name\n"chenguangxiang"\n127.0.0.1:6379> expire name 10 # 设置key的过期时间，单位是秒\n(integer) 1\n127.0.0.1:6379> ttl name # 查看当前key的剩余时间\n(integer) 6\n127.0.0.1:6379> ttl name\n(integer) -2\n127.0.0.1:6379> keys *\n1) "age"\n127.0.0.1:6379> type age # 查看当前key的类型\nstring\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n> keys * : 查看所有key\n> \n> set name xx : 设置key\n> \n> get name: 查看key\n> \n> exists name : 判断当前的key是否存在\n> \n> move name 1 : 移除当前的key 1: 数据库号(16个数据库)\n> \n> expire name 10 : 设置key的过期时间，单位是秒\n> \n> ttl name : 查看当前key的剩余时间\n> \n> type age : 查看当前key的类型\n> \n> 注意: name为这里的key\n\n\n# 1.1 string(字符串)\n\n============================== 字符串拼接 ======================================\n# append: 拼接字符串,如果当前key不存在，就相当于setkey\n\n127.0.0.1:6379> set key1 v1 # 设置值\nok\n127.0.0.1:6379> get key1 # 获取值\n"v1"\n127.0.0.1:6379> exists key1 # 判断某一个key是否存在\n(integer) 1\n127.0.0.1:6379> keys * # 获取所有key\n1) "key1"\n127.0.0.1:6379> append key1 "hello" # 追加字符串，如果当前key不存在，就相当于setkey\n(integer) 7\n127.0.0.1:6379> get key1 \n"v1hello"\n127.0.0.1:6379> strlen key1 # 获取字符串的长度！\n(integer) 7\n127.0.0.1:6379> append key1 ",chggx"\n(integer) 13\n127.0.0.1:6379> get key1\n"v1hello,chggx"\n===============================================================================\n\n=============================== 自增/自减 ======================================\n# 自增/自减 i++/i--\n# incr: 自增\n# decr: 自减\n# 步长 i+=\n# incrby: 设置步长，指定增量！\n# decrby: 设置步长，指定减量！\n\n127.0.0.1:6379> set views 0 # 初始浏览量0\nok\n127.0.0.1:6379> get views\n"0"\n127.0.0.1:6379> incr views # 自增1 浏览量+1\n(integer) 1\n127.0.0.1:6379> incr views\n(integer) 2\n127.0.0.1:6379> get views\n"2"\n127.0.0.1:6379> decr views # 自减1 浏览量-1\n(integer) 1\n127.0.0.1:6379> decr views\n(integer) 0\n127.0.0.1:6379> incrby views 10 # 可以设置步长，指定增量！\n(integer) 10\n127.0.0.1:6379> incrby views 10\n(integer) 20\n127.0.0.1:6379> decrby views 10 # 可以设置步长，指定减量！\n(integer) 10\n127.0.0.1:6379> decrby views 10\n(integer) 0\n===============================================================================\n\n================================ 字符串范围 ====================================\n# range: 范围\n# getrange: 截取字符串\n# setrange: 替换指定位置开始的字符串！\n\n127.0.0.1:6379> set key1 "hello,redis" # 设置 key1 的值\nok\n127.0.0.1:6379> get key1\n"hello,redis"\n127.0.0.1:6379> getrange key1 0 3 # 截取字符串 [0,3]\n"hell"\n127.0.0.1:6379> getrange key1 0 -1 # 获取全部的字符串 和 get key是一样的\n"hello,redis"\n\n# 替换\n127.0.0.1:6379> set key2 chengguangxiang\nok\n127.0.0.1:6379> get key2\n"chengguangxiang"\n127.0.0.1:6379> setrange key2 1 xx # 替换指定位置开始的字符串！\n(integer) 15\n127.0.0.1:6379> get key2\n"cxxngguangxiang" \n===============================================================================\n\n===============================================================================\n# setex (set with expire) : 设置过期时间 \n# setnx (set if not exist) : 不存在在设置 （在分布式锁中会常常使用！）\n127.0.0.1:6379> setex key3 30 "hell" # 设置key3 的值为 hello,30秒后过期\nok\n127.0.0.1:6379> ttl key3 \n(integer) 26\n127.0.0.1:6379> get key3\n"hell"\n127.0.0.1:6379> get key3\n(nil)\n127.0.0.1:6379> setnx mykey "redis" # 如果mykey 不存在，创建mykey 成功显示: 1 ,失败显示:0\n(integer) 1\n127.0.0.1:6379> keys *\n1) "mykey"\n127.0.0.1:6379> ttl key3\n(integer) -2\n127.0.0.1:6379> setnx mykey "mysql" # 如果mykey存在，创建失败！成功显示: 1 ,失败显示:0\n(integer) 0\n127.0.0.1:6379> get mykey\n"redis"\n===============================================================================\n\n============================== 批量设值 ========================================\n# mset: \n# mget: \n\n127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3 # 同时设置多个值\nok\n127.0.0.1:6379> keys *\n1) "k2"\n2) "k3"\n3) "k1"\n127.0.0.1:6379> mget k1 k2 k3 # 同时获取多个值\n1) "v1"\n2) "v2"\n3) "v3"\n127.0.0.1:6379> msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起 失败！\n(integer) 0\n127.0.0.1:6379> get k4\n(nil)\n===============================================================================\n\n============================== 对象[重点] ======================================\n# set user:1 {name:zhangsan,age:5}: 这只一个user:1对象,值为json字符来保存一个对象\n\n# 这里的key是一个巧妙的设计： user:{id}:{filed} , 如此设计在redis中是完全ok了！\n127.0.0.1:6379> mset user:1:name zhangsan user:1:age 2\nok\n127.0.0.1:6379> mget user:1:name user:1:age\n1) "zhangsan"\n2) "2"\n\n# 场景: 可以用于文章浏览量\n=============================== getset ========================================\n# getset: 先get然后在set\n\n127.0.0.1:6379> getset db redis # 如果不存在值，则返回 nil\n(nil)\n127.0.0.1:6379> get db\n"redis"\n127.0.0.1:6379> getset db mysql # 如果存在值，获取原来的值，并设置新的值\n"redis"\n127.0.0.1:6379> get db\n"mysql"\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n\n\n数据结构是相同的！\n\nstring类型的使用场景：value除了是我们的字符串还可以是我们的数字！\n\n * 计数器\n\n * 统计多单位的数量\n\n * 粉丝数\n\n * 对象缓存存储！\n\n\n# 1.2 list(列表)\n\n基本数据类型 列表\n\n\n\n> 在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！\n\n所有的list命令都是用 l开头的，redis命令不区分大小\n\n================================= 左边/右边插入 ================================\n# lpush: 将一个值或者多个值，插入到列表头部 （左）\n# rpush: 将一个值或者多个值，插入到列表位部 （右）\n# lrange: 获取list中值！\n\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> lpush list one # 将一个值或者多个值，插入到列表头部 （左）\n(integer) 1\n127.0.0.1:6379> lpush list two\n(integer) 2\n127.0.0.1:6379> lpush list three\n(integer) 3\n127.0.0.1:6379> lrange list 0 -1 # 获取list中值！\n1) "three"\n2) "two"\n3) "one"\n127.0.0.1:6379> lrange list 0 1 # 通过区间获取具体的值！\n1) "three"\n2) "two"\n127.0.0.1:6379> rpush list chggx # 将一个值或者多个值，插入到列表位部 （右）\n(integer) 4\n127.0.0.1:6379> lrange list 0 1\n1) "three"\n2) "two"\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "two"\n3) "one"\n4) "chggx"\n===============================================================================\n\n================================= 移除 ========================================\n# lpop: 移除list的第一个元素 (左边)\n# rpop: 移除list的最后一个元素 (右边)\n\n127.0.0.1:6379> keys *\n1) "list"\n127.0.0.1:6379> lrange list 0 -1 \n1) "three"\n2) "two"\n3) "one"\n4) "chggx"\n127.0.0.1:6379> lpop list # 移除list的第一个元素 (左边)\n"three"\n127.0.0.1:6379> lrange list 0 -1\n1) "two"\n2) "one"\n3) "chggx"\n127.0.0.1:6379> rpop list  # 移除list的最后一个元素 (右边)\n"chggx"\n127.0.0.1:6379> lrange list 0 -1\n1) "two"\n2) "one"\n===============================================================================\n\n================================== 下标 =======================================\n# lindex: 通过下标获得 list 中的某一个值！\n\n127.0.0.1:6379> lrange list 0 -1 \n1) "two"\n2) "one"\n127.0.0.1:6379> lindex list 1 # 通过下标获得 list 中的某一个值！\n"one"\n127.0.0.1:6379> lindex list 0\n"two"\n===============================================================================\n\n================================== 长度 =======================================\nllen: 获取list列表长度\n\n127.0.0.1:6379> lpush list one \n(integer) 1\n127.0.0.1:6379> lpush list two\n(integer) 2\n127.0.0.1:6379> lpush list three\n(integer) 3\n127.0.0.1:6379> llen list # 返回列表的长度\n(integer) 3\n===============================================================================\n\n================================ 移除指定的值 ==================================\n# lrem : 移除指定的值！ 取关 uid\n\n127.0.0.1:6379> lpush list three\n(integer) 4\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "three"\n3) "two"\n4) "one"\n127.0.0.1:6379> lrem list 1 one  # 移除list集合中指定个数的value,精确匹配\n(integer) 1\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "three"\n3) "two"\n127.0.0.1:6379> lrem list 1 three\n(integer) 1\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "two"\n127.0.0.1:6379> lpush list three\n(integer) 3\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "three"\n3) "two"\n127.0.0.1:6379> lrem list 2 three\n(integer) 2\n127.0.0.1:6379> lrange list 0 -1\n1) "two"\n===============================================================================\n\n=============================== 修剪(截取)trim =================================\n# trim 修剪(截取指定值): list 截断 !\n\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> rpush mylist "hello" \n(integer) 1\n127.0.0.1:6379> rpush mylist "hello1"\n(integer) 2\n127.0.0.1:6379> rpush mylist "hello2"\n(integer) 3\n127.0.0.1:6379> rpush mylist "hello3"\n(integer) 4\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "hello1"\n3) "hello2"\n4) "hello3"\n127.0.0.1:6379> ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了 只剩下截取的元素\nok\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello1"\n2) "hello2"\n===============================================================================\n\n=============================== rpoplpush =====================================\n# rpoplpush: 移除列表的最后一个元素，将他移动到新的列表中！\n\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> rpush mylist "hello"\n(integer) 1\n127.0.0.1:6379> rpush mylist "hell01"\n(integer) 2\n127.0.0.1:6379> rpush mylist "hell02"\n(integer) 3\n127.0.0.1:6379> rpush mylist "hell03"\n(integer) 4\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "hell01"\n3) "hell02"\n4) "hell03"\n127.0.0.1:6379> rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的 列表中！\n"hell03"\n127.0.0.1:6379> lrange mylist 0 -1 # 查看原来的列表\n1) "hello"\n2) "hell01"\n3) "hell02"\n127.0.0.1:6379> lrange myotherlist 0 -1 # 查看目标列表中，确实存在改值！\n1) "hell03"\n===============================================================================\n\n============================= exists/lset =====================================\n# exists: 判断list列表是否存在\n# lset: 将列表中指定下标的值替换为另外一个值，"更新操作"(key不存在时( err no such key),不能直接使用lset创建可以,需使用lpush/rpush. index下标不存在时(err index out of range),不能直接使用)\n\n127.0.0.1:6379> keys * \n(empty list or set)\n127.0.0.1:6379> exists list # 判断这个列表是否存在\n(integer) 0\n127.0.0.1:6379> lset list 0 item # 如果不存在列表,我们使用lset去更新就会报错\n(error) err no such key\n127.0.0.1:6379> lpush list value1 # 设置值 (左)\n(integer) 1\n127.0.0.1:6379> lrange list 0 0 # 获取下标"0"值\n1) "value1"\n127.0.0.1:6379> lset list 0 item # 下标"0", 如果存在，更新当前下标的值\nok\n127.0.0.1:6379> lrange list 0 0 \n1) "item"\n127.0.0.1:6379> lset list 1 other\n(error) err index out of range\n===============================================================================\n\n=============================== linsert (插入) ================================\n# linsert: 将某个具体的value插入到列表中某个元素的前面或者后面！\n\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> rpush mylist "hello"\n(integer) 1\n127.0.0.1:6379> rpush mylist "world"\n(integer) 2\n127.0.0.1:6379> lrange mylist 0 -1 # 获取所有mylist值\n1) "hello"\n2) "world"\n127.0.0.1:6379> linsert mylist before "world" "other" # 将某个具体的value插入到列表中某个元素的前面！\n(integer) 3\n127.0.0.1:6379> lrange mylist 0 -1 # 获取所有mylist值\n1) "hello"\n2) "other"\n3) "world"\n127.0.0.1:6379> linsert mylist after world after # 将某个具体的value插入到列表中某个元素的后面！\n(integer) 4\n127.0.0.1:6379> lrange mylist 0 -1 # 获取所有mylist值\n1) "hello"\n2) "other"\n3) "world"\n4) "after"\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n\n\n> 小结:\n> \n> 他实际上是一个链表，before node after ， left，right 都可以插入值\n> \n> 如果key 不存在，创建新的链表\n> \n> 如果key存在，新增内容\n> \n> 如果移除了所有值，空链表，也代表不存在！\n> \n> 在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~\n\nlist列表应用场景: 消息排队！消息队列 （lpush rpop），栈（ lpush lpop）！\n\n\n# 1.3 set（集合）\n\nset中的值是不能重读的！ set是不重复的.\n\n============================= 基础 =======================================\n# sadd: set集合中添加元素\n# smembers: 查看指定set的所有值\n# sismember: 判断某一个值是不是在set集合中\n\n127.0.0.1:6379> sadd myset "hello" # set集合中添加元素\n(integer) 1\n127.0.0.1:6379> sadd myset "world" \n(integer) 1\n127.0.0.1:6379> sadd myset "chggx"\n(integer) 1\n127.0.0.1:6379> smembers myset # 查看指定set的所有值\n1) "chggx"\n2) "hello"\n3) "world"\n127.0.0.1:6379> sismember myset hello # 判断某一个值是不是在set集合中！\n(integer) 1\n127.0.0.1:6379> sismember myset redis\n(integer) 0\n===============================================================================\n\n============================= scard (元素个数) =================================\n# scard: 获取set集合中的内容元素个数！\n\n127.0.0.1:6379> scard myset # 获取set集合中的内容元素个数！\n(integer) 3\n127.0.0.1:6379> sadd myset "hello" # set集合中添加元素\n(integer) 0\n127.0.0.1:6379> sadd myset "redis" # 说明 set 集合 的元素是不重复的\n(integer) 1\n127.0.0.1:6379> scard myset # 获取set集合中的内容元素个数！\n(integer) 4\n============================= srem (移除元素) ================================\n# srem: 移除set集合中的指定元素\n\n127.0.0.1:6379> smembers myset\n1) "chggx"\n2) "hello"\n3) "redis"\n4) "world"\n127.0.0.1:6379> scard myset\n(integer) 4\n127.0.0.1:6379> srem myset chggx # 移除set集合中的指定元素\n(integer) 1\n127.0.0.1:6379> scard myset // 获取set集合中内容的元素个数\n(integer) 3\n127.0.0.1:6379> smembers myset // 查看set集合的值\n1) "hello"\n2) "redis"\n3) "world"\n===============================================================================\n\n============================== srandmember ====================================\n# set 无序不重复集合,抽随机\n# srandmember: 随机抽取出指定个数元素\n\n127.0.0.1:6379> smembers myset\n1) "hello"\n2) "redis"\n3) "world"\n127.0.0.1:6379> srandmember myset # 随机抽取出一个元素\n"hello"\n127.0.0.1:6379> srandmember myset \n"redis"\n127.0.0.1:6379> srandmember myset \n"world"\n127.0.0.1:6379> srandmember myset 2 # 随机抽取出指定个数元素\n1) "redis"\n2) "world"\n127.0.0.1:6379> srandmember myset 2\n1) "redis"\n2) "world"\n===============================================================================\n\n============================== spop (随机删key) ================================\n删除定的key，随机删除key！\n\n127.0.0.1:6379> smembers myset\n1) "hello"\n2) "redis"\n3) "world"\n127.0.0.1:6379> spop myset # 随机删除一些set集合中的元素(弹出set集合中的元素)\n"world"\n127.0.0.1:6379> spop myset\n"hello"\n127.0.0.1:6379> smembers myset\n1) "redis"\n================================ smove =======================================\n# smove: 将一个指定的值，移动到另外一个set集合！\n\n127.0.0.1:6379> sadd myset "hell0"\n(integer) 1\n127.0.0.1:6379> sadd myset "world"\n(integer) 1\n127.0.0.1:6379> sadd myset "chggx"\n(integer) 1\n127.0.0.1:6379> smembers myset\n1) "chggx"\n2) "hell0"\n3) "world"\n127.0.0.1:6379> sadd myset2 "set2"\n(integer) 1\n127.0.0.1:6379> smembers myset2\n1) "set2"\n127.0.0.1:6379> smove myset myset2 "chggx" #  将一个指定的值，移动到另外一个set集合！\n(integer) 1\n127.0.0.1:6379> smembers myset\n1) "hell0"\n2) "world"\n127.0.0.1:6379> smembers myset2\n1) "chggx"\n2) "set2"\n===============================================================================\n\n================================ 并集 =========================================\n # 数字集合类： \n# \t- 差集 sdiff \n# \t- 交集 sinter\n# \t- 并集 sunion\n\n127.0.0.1:6379> sadd key1 "a"\n(integer) 1\n127.0.0.1:6379> sadd key1 "b"\n(integer) 1\n127.0.0.1:6379> sadd key1 "c"\n(integer) 1\n127.0.0.1:6379> sadd key2 "c"\n(integer) 1\n127.0.0.1:6379> sadd key2 "d"\n(integer) 1\n127.0.0.1:6379> sadd key2 "e"\n(integer) 1\n127.0.0.1:6379> smembers key1\n1) "b"\n2) "c"\n3) "a"\n127.0.0.1:6379> smembers key2\n1) "d"\n2) "c"\n3) "e"\n127.0.0.1:6379> sdiff key1 key2 # 差集\n1) "b"\n2) "a"\n127.0.0.1:6379> sinter key1 key2 # 交集 共同好友就可以这样实现\n1) "c"\n127.0.0.1:6379> sunion key1 key2 # 并集\n1) "c"\n2) "a"\n3) "d"\n4) "b"\n5) "e"\n\n# 场景:\n# 微博，b站，共同关注！(并集)\n# 微博，a用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！\n# 共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n\n\n\n# 1.4 hash\n\nmap集合，key-map! 时候这个值是一个map集合！ 本质和string类型没有太大区别，还是一个简单的 key-vlaue！\n\n============================== 基础 ========================================\n# hset: set一个具体 key-vlaue\n# hget: 获取一个字段值\n# hmset: set多个 key-vlaue\n# hmget: 获取多个字段值\n# hgetall: 获取全部的数据(以ley-value形式展示)\n# hdel: 删除hash中指定key字段！对应的value值也就消失了！\n\n127.0.0.1:6379> hset myhash field1 chggx # set一个具体 key-vlaue\n(integer) 1\n127.0.0.1:6379> hget myhash field1 # 获取一个字段值\n"chggx"\n127.0.0.1:6379> hmset myhash field1 hello field2 world  # set多个 key-vlaue\nok\n127.0.0.1:6379> hmget myhash field1 field2 # 获取多个字段值\n1) "hello"\n2) "world"\n127.0.0.1:6379> hgetall myhash # 获取全部的数据\n1) "field1"\n2) "hello"\n3) "field2"\n4) "world"\n127.0.0.1:6379> hdel myhash field1 # 删除hash中指定key字段！对应的value值也就消失了！\n(integer) 1\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "world"\n===============================================================================\n\n=============================== 长度(hlen) ====================================\n# hlen: 获取hash表的字段数量！\n\n127.0.0.1:6379> hmset myhash field1 hello field2 world\nok\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "world"\n3) "field1"\n4) "hello"\n127.0.0.1:6379> hlen myhash # 获取hash表的字段数量！\n(integer) 2\n===============================================================================\n\n=============================== 指定字段是否存在 ================================\n# hexists: \n\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "world"\n3) "field1"\n4) "hello"\n127.0.0.1:6379> hexists myhash field1 # 判断hash中指定字段是否存在！\n(integer) 1\n127.0.0.1:6379> hexists myhash field3\n(integer) 0\n===============================================================================\n\n============================= 单独获取field/value ==============================\n# hkeys: 只获得所有field \n# hvals: 只获得所有value\n\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "world"\n3) "field1"\n4) "hello"\n127.0.0.1:6379> hkeys myhash # 只获得所有field\n1) "field2"\n2) "field1"\n127.0.0.1:6379> hvals myhash # 只获得所有value\n1) "world"\n2) "hello"\n===============================================================================\n\n================================ 自增/自减======================================\nincr/decr\n\n127.0.0.1:6379> hset myhash field3 5\n(integer) 1\n127.0.0.1:6379> hincrby myhash field3 1 # 指定增量\n(integer) 6\n127.0.0.1:6379> hincrby myhash field3 1\n(integer) 7\n127.0.0.1:6379> hincrby myhash field3 -1\n(integer) 6\n127.0.0.1:6379> hsetnx myhash field4 hello # 如果不存在则可以设置\n(integer) 1\n127.0.0.1:6379> hsetnx myhash field4 hello # 如果存在则不可以设置\n(integer) 0\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n> hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！\n> \n> hash 更适合于对象的存储，string更加适合字符串存储！\n\n\n# 1.5 zset(有序集合)\n\n在set的基础上，增加了一个值，set k1 v1 zset k1 score1 v1\n\n================================ 基础 =========================================\n# zadd: 添加一个/多个值\n# zrange: 获取所有值\n\n127.0.0.1:6379> zadd myset 1 one # 添加一个值\n(integer) 1\n127.0.0.1:6379> zadd myset 2 two 3 three # 添加多个值\n(integer) 2\n127.0.0.1:6379> zrange myset 0 -1 # 获取所有值\n1) "one"\n2) "two"\n3) "three"\n===============================================================================\n\n=============================== 排序如何实现 ===================================\n# zrangebyscore: 由低到高排序\n# zrevrange: [反转] 倒序排列\n\n127.0.0.1:6379> zadd salary 2500 zhangsan # 添加三个用户\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 lisi\n(integer) 1\n127.0.0.1:6379> zadd salary 500 wangwu\n(integer) 1\n# 语法: zrangebyscore key min max\n127.0.0.1:6379> zrangebyscore salary -inf +inf # 显示全部的用户 从小到大！(-∞,+∞) "wangwu"\n2) "zhangsan"\n3) "lisi"\n127.0.0.1:6379> zrevrange salary 0 -1  # 从大到进行排序！\n1) "lisi"\n2) "zhangsan"\n127.0.0.1:6379> zrangebyscore salary -inf +inf withscores # 显示全部的用户并且附带成绩\n1) "wangwu"\n2) "500"\n3) "zhangsan"\n4) "2500"\n5) "lisi"\n6) "5000"\n127.0.0.1:6379> zrangebyscore salary -inf 2500 withscores # 显示工资小于2500员工的升序排序！\n1) "wangwu"\n2) "500"\n3) "zhangsan"\n4) "2500"\n===============================================================================\n\n================================ 移除(zrem) ===================================\n# zrem: 移除有序集合中的指定元素\n# zcard: 获取有序集合中的个数\n\n127.0.0.1:6379> zrange salary 0 -1\n1) "wangwu"\n2) "zhangsan"\n3) "lisi"\n127.0.0.1:6379> zrem salary wangwu # 移除有序集合中的指定元素\n(integer) 1\n127.0.0.1:6379> zrange salary 0 -1\n1) "zhangsan"\n2) "lisi"\n127.0.0.1:6379> zcard salary # 获取有序集合中的个数\n(integer) 2\n===============================================================================\n\n=============================== zcount(统计) ==================================\n# zcount: 获取指定区间的成员数量！\n\n127.0.0.1:6379> zadd myset 1 hello\n(integer) 1\n127.0.0.1:6379> zadd myset 2 world 3 chggx\n(integer) 2\n127.0.0.1:6379> zrange myset 0 -1\n1) "hello"\n2) "world"\n3) "chggx"\n127.0.0.1:6379> zcount myset 1 3 # 获取指定区间的成员数量！\n(integer) 3\n127.0.0.1:6379> zcount myset 1 2\n(integer) 2\n127.0.0.1:6379> zcount myset 1 1\n(integer) 1\n===============================================================================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n案例思路：set 排序 存储班级成绩表，工资表排序！\n\n普通消息，1， 重要消息 2，带权重进行判断！\n\n排行榜应用实现，取top n 测试！\n\n\n# 2. 特殊数据类型\n\n\n# 2.1 geospatial 地理位置\n\n# 2.1.1 介绍\n\n场景: 朋友的定位，附近的人，打车距离计算？\n\nredis 的 geo 在redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！\n\n可以查询一些测试数据：http://www.jsons.cn/lngcodeinfo/0706d99c19a781a3/\n\n# 2.2.2 命令\n\nredis geospatial 的6个命令\n\n官方文档：https://www.redis.net.cn/order/3685.html\n\n\n\n 1. geoadd\n\n * geoadd 添加地理位置\n\n# 参数 key 值（经度、纬度、名称）\n127.0.0.1:6379> geoadd china:city 116.40 39.90 beijing\n(integer) 1\n127.0.0.1:6379> geoadd china:city 121.47 31.23 shanghai \n(integer) 1\n127.0.0.1:6379> geoadd china:city 120.15 30.28 hangzhou\n(integer) 1\n127.0.0.1:6379> geoadd china:city 106.50 29.53 chongqing\n(integer) 1\n127.0.0.1:6379> geoadd china:city 114.08 22.54 shenzhen\n(integer) 1\n127.0.0.1:6379> geoadd china:city 113.66 34.75 zhengzhou\n(integer) 1\n127.0.0.1:6379> geoadd china:city 118.76 32.04 nanjing 118.11 24.49 xiamen\n(integer) 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> # 规则：两极无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！\n> \n> # 有效的经度从-180度到180度。\n> \n> # 有效的纬度从-85.05112878度到85.05112878度。\n> \n> # 当坐标位置超出上述指定范围时，该命令将会返回一个错误。\n\n 2. geopos\n\n获得当前定位：一定是一个坐标值！\n\n127.0.0.1:6379> geopos china:city beijing # 获取指定的城市的经度和纬度！\n1) 1) "116.39999896287918091"\n   2) "39.90000009167092543"\n127.0.0.1:6379> geopos china:city hangzhou\n1) 1) "120.15000075101852417"\n   2) "30.2800007575645509"\n127.0.0.1:6379> geopos china:city nanjing shenzhen\n1) 1) "118.75999957323074341"\n   2) "32.03999960287850968"\n2) 1) "114.08000081777572632"\n   2) "22.53999903789756587"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 3. geodist\n\n * 返回两个给定位置之间的距离。\n\n * 单位：\n   \n   m 表示单位为米。\n   \n   km 表示单位为千米。\n   \n   mi 表示单位为英里。\n   \n   ft 表示单位为英尺。\n\n127.0.0.1:6379> geodist china:city beijing shanghai km # 查看北京到上海的直线距离\n"1067.3788"\n127.0.0.1:6379> geodist china:city beijing hangzhou km # 查看北京到杭州的直线距离\n"1122.7998"\n127.0.0.1:6379> geodist china:city beijing chongqing km # 查看北京到重庆的直线距离\n"1464.0708"\n127.0.0.1:6379> geodist china:city beijing shenzhen km # 查看北京到深圳的直线距离\n"1943.2550"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. georadius\n\n * 以给定的经纬度为中心， 找出某一半径内的元素\n\n * 应用:\n   \n   我附近的人(找朋友)？ （获得所有附近的人的地址，定位！）通过半径来查询！\n\n127.0.0.1:6379> georadius china:city 110 30 500 km # 以110，30 这个经纬度为中心，寻 找方圆500km内的城市\n1) "chongqing"\n127.0.0.1:6379> georadius china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻 找方圆1000km内的城市\n1) "chongqing"\n2) "shenzhen"\n3) "hangzhou"\n4) "zhengzhou"\n5) "nanjing"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist # 显示到中间距离的位置\n1) 1) "chongqing"\n   2) "341.9374"\n2) 1) "shenzhen"\n   2) "923.9364"\n3) 1) "hangzhou"\n   2) "976.4868"\n4) 1) "zhengzhou"\n   2) "630.2160"\n5) 1) "nanjing"\n   2) "864.9816"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withcoord # 显示他人的定位信息\n1) 1) "chongqing"\n   2) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n2) 1) "shenzhen"\n   2) 1) "114.08000081777572632"\n      2) "22.53999903789756587"\n3) 1) "hangzhou"\n   2) 1) "120.15000075101852417"\n      2) "30.2800007575645509"\n4) 1) "zhengzhou"\n   2) 1) "113.65999907255172729"\n      2) "34.74999926510690784"\n5) 1) "nanjing"\n   2) 1) "118.75999957323074341"\n      2) "32.03999960287850968"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist withcoord count 1\n# 筛选出指定的结果！\n1) 1) "chongqing"\n   2) "341.9374"\n   3) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist withcoord count 2\n# 筛选出指定的结果！\n1) 1) "chongqing"\n   2) "341.9374"\n   3) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n2) 1) "zhengzhou"\n   2) "630.2160"\n   3) 1) "113.65999907255172729"\n      2) "34.74999926510690784"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist withcoord count 3\n# 筛选出指定的结果！\n1) 1) "chongqing"\n   2) "341.9374"\n   3) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n2) 1) "zhengzhou"\n   2) "630.2160"\n   3) 1) "113.65999907255172729"\n      2) "34.74999926510690784"\n3) 1) "nanjing"\n   2) "864.9816"\n   3) 1) "118.75999957323074341"\n      2) "32.03999960287850968"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withdist withcoord count 4\n# 筛选出指定的结果！\n1) 1) "chongqing"\n   2) "341.9374"\n   3) 1) "106.49999767541885376"\n      2) "29.52999957900659211"\n2) 1) "zhengzhou"\n   2) "630.2160"\n   3) 1) "113.65999907255172729"\n      2) "34.74999926510690784"\n3) 1) "nanjing"\n   2) "864.9816"\n   3) 1) "118.75999957323074341"\n      2) "32.03999960287850968"\n4) 1) "shenzhen"\n   2) "923.9364"\n   3) 1) "114.08000081777572632"\n      2) "22.53999903789756587"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n 5. georadiusbymember [定位]\n\n * 找出位于指定元素周围的其他元素！\n\n127.0.0.1:6379> georadiusbymember china:city beijjing 1000 km\n1) "zhengzhou"\n2) "nanjing"\n3) "beijjing"\n127.0.0.1:6379> georadiusbymember china:city shanghai 400 km\n1) "hangzhou"\n2) "shanghai"\n3) "nanjing"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 6. geohash\n\n * 命令 - 返回一个或多个位置元素的 geohash 表示\n * 该命令将返回11个字符的geohash字符串!\n\n# 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！\n127.0.0.1:6379> geohash china:city beijjing zhengzhou\n1) "wx4fbxxfke0"\n2) "ww0vdqh9mv0"\n\n\n1\n2\n3\n4\n\n\n# 2.1.3 geo 底层的实现原理\n\ngeo 底层的实现原理其实就是 zset！我们可以使用zset命令来操作geo！\n\n127.0.0.1:6379> zrange china:city 0 -1 # 查看地图中全部的元素\n1) "chongqing"\n2) "shenzhen"\n3) "xiamen"\n4) "hangzhou"\n5) "shanghai"\n6) "zhengzhou"\n7) "nanjing"\n8) "beijjing"\n127.0.0.1:6379> zrem china:city xiamen # 移除指定元素！\n(integer) 1\n127.0.0.1:6379> zrange china:city 0 -1\n1) "chongqing"\n2) "shenzhen"\n3) "hangzhou"\n4) "shanghai"\n5) "zhengzhou"\n6) "nanjing"\n7) "beijjing"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.2 hyperloglog\n\n# 2.2.1 什么是基数？\n\n * a {1,3,5,7,8,7}\n * b {1,3,5,7,8}\n\n> 基数（不重复的元素） = 5，可以接受误差！\n\n# 2.2.2 简介\n\nredis 2.8.9 版本就更新了 hyperloglog 数据结构！\n\nredis hyperloglog 基数统计的算法！\n\n# 2.2.3 优点\n\n优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12kb内存！如果要从内存角度来比较的话 hyperloglog 首选！\n\n网页的 uv （一个人访问一个网站多次，但是还是算作一个人！）\n\n传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !\n\n这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；\n\n0.81% 错误率！ 统计uv任务，可以忽略不计的！\n\n# 2.2.4 命令测试\n\n# pfadd: 创建\n# pfcount: 统计\n# pfmerge: 合并(获取一个并集)\n\n127.0.0.1:6379> pfadd mykey a b c d e f g h i j # 创建第一组元素 mykey\n(integer) 1\n127.0.0.1:6379> pfcount mykey  # 统计 mykey 元素的基数数量\n(integer) 10\n127.0.0.1:6379> pfadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2\t\n(integer) 1\n127.0.0.1:6379> pfcount mykey2\n(integer) 9\n127.0.0.1:6379> pfmerge mykey3 mykey mykey2 # 合并两组 mykey mykey2 => mykey3 并集\nok\n127.0.0.1:6379> pfcount mykey3 # 看并集的数量！\n(integer) 15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 如果允许容错，那么一定可以使用 hyperloglog ！\n> \n> 如果不允许容错，就使用 set 或者自己的数据类型即可！\n\n\n# 2.3 bitmap 位图\n\n# 2.3.1 位存储\n\n场景: 统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用bitmaps！\n\nbitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！\n\n> 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！\n\n# 2.3.2 测试\n\n 1. 使用bitmap 来记录 周一到周日的打卡！\n\n * 周一：1 周二：0 周三：0 周四：1 ......\n\n127.0.0.1:6379> setbit sign 0 1\n(integer) 0\n127.0.0.1:6379> setbit sign 1 0\n(integer) 0\n127.0.0.1:6379> setbit sign 2 0\n(integer) 0\n127.0.0.1:6379> setbit sign 3 1\n(integer) 0\n127.0.0.1:6379> setbit sign 4 1\n(integer) 0\n127.0.0.1:6379> setbit sign 5 0\n(integer) 0\n127.0.0.1:6379> setbit sign 6 0\n(integer) 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 2. 查看某一天是否有打卡！\n\n127.0.0.1:6379> getbit sign 3 # 查看周四是否打卡\n(integer) 1\n127.0.0.1:6379> getbit sign 6 # 查看周日是否打卡\n(integer) 0\n127.0.0.1:6379> getbit sign 0 # 查看周一是否打卡\n(integer) 1\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 统计操作，统计 打卡的天数！\n\n127.0.0.1:6379> bitcount sign # 统计这周的打卡记录,就可以查看是否全勤\n(integer) 3\n127.0.0.1:6379> bitcount sign 0 5 # 统计周一到周六打卡记录\n(integer) 3\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Redis实现乐观锁",frontmatter:{title:"Redis实现乐观锁",date:"2023-02-27T11:23:36.000Z",permalink:"/pages/1d5ebe/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E7%BC%93%E5%AD%98/4.Redis%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81.html",relativePath:"04.后端应用框架/03.中间件/01.缓存/4.Redis实现乐观锁.md",key:"v-085168b4",path:"/pages/1d5ebe/",headers:[{level:2,title:"1. 悲观锁",slug:"_1-悲观锁",normalizedTitle:"1. 悲观锁",charIndex:30},{level:2,title:"2. 乐观锁",slug:"_2-乐观锁",normalizedTitle:"2. 乐观锁",charIndex:72},{level:2,title:"3.  redis监视测试",slug:"_3-redis监视测试",normalizedTitle:"3.  redis监视测试",charIndex:null},{level:3,title:"3.1 正常执行",slug:"_3-1-正常执行",normalizedTitle:"3.1 正常执行",charIndex:193},{level:3,title:"3.2 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！",slug:"_3-2-测试多线程修改值-使用watch-可以当做redis的乐观锁操作",normalizedTitle:"3.2 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！",charIndex:554},{level:4,title:"3.2.1 问题",slug:"_3-2-1-问题",normalizedTitle:"3.2.1 问题",charIndex:597},{level:4,title:"3.2.2 解决",slug:"_3-2-2-解决",normalizedTitle:"3.2.2 解决",charIndex:990},{level:2,title:"4. 场景",slug:"_4-场景",normalizedTitle:"4. 场景",charIndex:1365}],headersStr:"1. 悲观锁 2. 乐观锁 3.  redis监视测试 3.1 正常执行 3.2 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！ 3.2.1 问题 3.2.2 解决 4. 场景",content:'# Redis实现乐观锁\n\n> 监控: Watch\n\n\n# 1. 悲观锁\n\n * 很悲观，认为什么时候都会出问题，无论做什么都会加锁！\n\n\n# 2. 乐观锁\n\n * 很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否有人修改过这个数据，\n\n * 获取version\n\n * 更新的时候比较 version\n\n\n# 3. redis监视测试\n\n\n# 3.1 正常执行\n\n * watch: 监视\n\n127.0.0.1:6379> set money 100\nOK\n127.0.0.1:6379> set out 0\nOK\n127.0.0.1:6379> watch money # 监视 money 对象\nOK\n127.0.0.1:6379> multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！\nOK\n127.0.0.1:6379> decrby money 20\nQUEUED\n127.0.0.1:6379> incrby out 20\nQUEUED\n127.0.0.1:6379> exec\n1) (integer) 80\n2) (integer) 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3.2 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！\n\n# 3.2.1 问题\n\n * 线程1\n\n127.0.0.1:6379> watch money # 监视 money 对象\nOK\n127.0.0.1:6379> multi # 开启线程\nOK\n127.0.0.1:6379> decrby money 10\nQUEUED\n127.0.0.1:6379> incrby out 10\nQUEUED\n127.0.0.1:6379> exec\n(nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 线程2\n\n127.0.0.1:6379> get money\n"80"\n127.0.0.1:6379> set money 1000 # 修改 money\nOK\n\n\n1\n2\n3\n4\n\n\n> 在线程1执行 exec 操作之前,我们先执行线程2,修改money的值后, 导致事务执行失败,结果: 执行 exec 后 出现 (nil)\n\n# 3.2.2 解决\n\n * unwatch: 如果发现事务执行失败,就可先解锁\n\n127.0.0.1:6379> unwatch # 如果发现事务执行失败,就可先解锁\nOK\n127.0.0.1:6379> watch money # 获取最新的值,再次监视,select version(通过版本)\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> decrby money 1\nQUEUED\n127.0.0.1:6379> incrby out 1\nQUEUED\n127.0.0.1:6379> exec # 比对监视的是否发生变化\n1) (integer) 999\n2) (integer) 21\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 如果修改失败，获取最新的值就好\n\n\n# 4. 场景\n\n秒杀\n\n> 参考: https://www.cnblogs.com/jasonZh/p/9522772.html',normalizedContent:'# redis实现乐观锁\n\n> 监控: watch\n\n\n# 1. 悲观锁\n\n * 很悲观，认为什么时候都会出问题，无论做什么都会加锁！\n\n\n# 2. 乐观锁\n\n * 很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否有人修改过这个数据，\n\n * 获取version\n\n * 更新的时候比较 version\n\n\n# 3. redis监视测试\n\n\n# 3.1 正常执行\n\n * watch: 监视\n\n127.0.0.1:6379> set money 100\nok\n127.0.0.1:6379> set out 0\nok\n127.0.0.1:6379> watch money # 监视 money 对象\nok\n127.0.0.1:6379> multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！\nok\n127.0.0.1:6379> decrby money 20\nqueued\n127.0.0.1:6379> incrby out 20\nqueued\n127.0.0.1:6379> exec\n1) (integer) 80\n2) (integer) 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3.2 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！\n\n# 3.2.1 问题\n\n * 线程1\n\n127.0.0.1:6379> watch money # 监视 money 对象\nok\n127.0.0.1:6379> multi # 开启线程\nok\n127.0.0.1:6379> decrby money 10\nqueued\n127.0.0.1:6379> incrby out 10\nqueued\n127.0.0.1:6379> exec\n(nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 线程2\n\n127.0.0.1:6379> get money\n"80"\n127.0.0.1:6379> set money 1000 # 修改 money\nok\n\n\n1\n2\n3\n4\n\n\n> 在线程1执行 exec 操作之前,我们先执行线程2,修改money的值后, 导致事务执行失败,结果: 执行 exec 后 出现 (nil)\n\n# 3.2.2 解决\n\n * unwatch: 如果发现事务执行失败,就可先解锁\n\n127.0.0.1:6379> unwatch # 如果发现事务执行失败,就可先解锁\nok\n127.0.0.1:6379> watch money # 获取最新的值,再次监视,select version(通过版本)\nok\n127.0.0.1:6379> multi\nok\n127.0.0.1:6379> decrby money 1\nqueued\n127.0.0.1:6379> incrby out 1\nqueued\n127.0.0.1:6379> exec # 比对监视的是否发生变化\n1) (integer) 999\n2) (integer) 21\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 如果修改失败，获取最新的值就好\n\n\n# 4. 场景\n\n秒杀\n\n> 参考: https://www.cnblogs.com/jasonzh/p/9522772.html',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Redis-Jedis",frontmatter:{title:"Redis-Jedis",date:"2023-02-27T11:23:36.000Z",permalink:"/pages/4fbc1c/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E7%BC%93%E5%AD%98/5.Redis-Jedis.html",relativePath:"04.后端应用框架/03.中间件/01.缓存/5.Redis-Jedis.md",key:"v-eaf3101a",path:"/pages/4fbc1c/",headers:[{level:2,title:"1. 什么是Jedis?",slug:"_1-什么是jedis",normalizedTitle:"1. 什么是jedis?",charIndex:18},{level:2,title:"2. 测试",slug:"_2-测试",normalizedTitle:"2. 测试",charIndex:124},{level:3,title:"2.1 依赖",slug:"_2-1-依赖",normalizedTitle:"2.1 依赖",charIndex:134},{level:3,title:"2.2 测试连接",slug:"_2-2-测试连接",normalizedTitle:"2.2 测试连接",charIndex:675},{level:2,title:"3. 常用API",slug:"_3-常用api",normalizedTitle:"3. 常用api",charIndex:1146},{level:3,title:"3.1 Redis-Key",slug:"_3-1-redis-key",normalizedTitle:"3.1 redis-key",charIndex:1196},{level:3,title:"3.2 String (字符串)",slug:"_3-2-string-字符串",normalizedTitle:"3.2 string (字符串)",charIndex:2534},{level:3,title:"3.3 List (列表)",slug:"_3-3-list-列表",normalizedTitle:"3.3 list (列表)",charIndex:4892},{level:3,title:"3.4 Set (集合)",slug:"_3-4-set-集合",normalizedTitle:"3.4 set (集合)",charIndex:7419},{level:3,title:"3.5 Hash",slug:"_3-5-hash",normalizedTitle:"3.5 hash",charIndex:10109},{level:2,title:"4. 事务",slug:"_4-事务",normalizedTitle:"4. 事务",charIndex:11890}],headersStr:"1. 什么是Jedis? 2. 测试 2.1 依赖 2.2 测试连接 3. 常用API 3.1 Redis-Key 3.2 String (字符串) 3.3 List (列表) 3.4 Set (集合) 3.5 Hash 4. 事务",content:'# Redis-Jedis\n\n\n# 1. 什么是Jedis?\n\nJedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用java操作redis，那么一定要对Jedis 十分的熟悉！\n\n\n# 2. 测试\n\n\n# 2.1 依赖\n\n\x3c!--导入jedis的包--\x3e\n    <dependencies>\n        \x3c!-- https://mvnrepository.com/artifact/redis.clients/jedis --\x3e\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>3.2.0</version>\n        </dependency>\n        \x3c!--fastjson--\x3e\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.62</version>\n        </dependency>\n    </dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.2 测试连接\n\n/**\n * @Author: CHGGX\n * @Description: <h1> 测试Jedis连接redis </h1>\n */\npublic class TestPing {\n\n    public static void main(String[] args) {\n        // 1、 new Jedis 对象即可\n        Jedis jedis = new Jedis("127.0.0.1",6379);\n        // Jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！\n        System.out.println(jedis.ping());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nE:\\develop\\Java\\jdk1.8.0_91\\bin\\java.exe "......\nPONG\n\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n\n\n\n# 3. 常用API\n\n> 所有的api命令，就是我们对应的redos的指令，一个都没有变化！\n\n\n# 3.1 Redis-Key\n\n/**\n * @author CHGGX\n */\npublic class TestKey {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n\n        System.out.println("清空数据："+jedis.flushDB());\n        System.out.println("判断某个键是否存在："+jedis.exists("username"));\n        System.out.println("新增<\'username\',\'kuangshen\'>的键值对："+jedis.set("username", "chggx"));\n        System.out.println("新增<\'password\',\'password\'>的键值对："+jedis.set("password", "password"));\n        System.out.print("系统中所有的键如下：");\n        Set<String> keys = jedis.keys("*");\n        System.out.println(keys);\n\n        System.out.println("删除键password:"+jedis.del("password"));\n        System.out.println("判断键password是否存在："+jedis.exists("password"));\n        System.out.println("查看键username所存储的值的类型："+jedis.type("username"));\n        System.out.println("随机返回key空间的一个："+jedis.randomKey());\n        System.out.println("重命名key："+jedis.rename("username","name"));\n        System.out.println("取出改后的name："+jedis.get("name"));\n        System.out.println("按索引查询："+jedis.select(0));\n                System.out.println("删除当前选择数据库中的所有key："+jedis.flushDB());\n        System.out.println("返回当前数据库中key的数目："+jedis.dbSize());\n        System.out.println("删除所有数据库中的所有key："+jedis.flushAll());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3.2 String (字符串)\n\n/**\n * @author CHGGX\n * 测试String类型\n */\npublic class TestString {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n\n        jedis.flushDB();\n        System.out.println("===========增加数据===========");\n        System.out.println(jedis.set("key1","value1"));\n        System.out.println(jedis.set("key2","value2"));\n        System.out.println(jedis.set("key3", "value3"));\n        System.out.println("删除键key2:"+jedis.del("key2"));\n        System.out.println("获取键key2:"+jedis.get("key2"));\n        System.out.println("修改key1:"+jedis.set("key1", "value1Changed"));\n        System.out.println("获取key1的值："+jedis.get("key1"));\n        System.out.println("在key3后面加入值："+jedis.append("key3", "End"));\n        System.out.println("key3的值："+jedis.get("key3"));\n        System.out.println("增加多个键值对："+jedis.mset("key01","value01","key02","value02","key03","value03"));\n        System.out.println("获取多个键值对："+jedis.mget("key01","key02","key03"));\n        System.out.println("获取多个键值对："+jedis.mget("key01","key02","key03","key04"));\n        System.out.println("删除多个键值对："+jedis.del("key01","key02"));\n        System.out.println("获取多个键值对："+jedis.mget("key01","key02","key03"));\n\n        jedis.flushDB();\n        System.out.println("===========新增键值对防止覆盖原先值==============");\n        System.out.println(jedis.setnx("key1", "value1"));\n        System.out.println(jedis.setnx("key2", "value2"));\n        System.out.println(jedis.setnx("key2", "value2-new"));\n        System.out.println(jedis.get("key1"));\n        System.out.println(jedis.get("key2"));\n\n        System.out.println("===========新增键值对并设置有效时间=============");\n        System.out.println(jedis.setex("key3", 2, "value3"));\n        System.out.println(jedis.get("key3"));\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(jedis.get("key3"));\n\n        System.out.println("===========获取原值，更新为新值==========");\n        System.out.println(jedis.getSet("key2", "key2GetSet"));\n        System.out.println(jedis.get("key2"));\n\n        System.out.println("获得key2的值的字串："+jedis.getrange("key2", 2, 4));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 3.3 List (列表)\n\n/**\n * @author CHGGX\n */\npublic class TestList {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n        jedis.flushDB();\n        System.out.println("===========添加一个list===========");\n        jedis.lpush("collections", "ArrayList", "Vector", "Stack", "HashMap", "WeakHashMap", "LinkedHashMap");\n        jedis.lpush("collections", "HashSet");\n        jedis.lpush("collections", "TreeSet");\n        jedis.lpush("collections", "TreeMap");\n        // -1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部\n        System.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        System.out.println("collections区间0-3的元素："+jedis.lrange("collections",0,3));\n        System.out.println("===============================");\n        // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈\n        System.out.println("删除指定元素个数："+jedis.lrem("collections", 2, "HashMap"));\n        System.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        System.out.println("删除下表0-3区间之外的元素："+jedis.ltrim("collections", 0, 3));\n        System.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        System.out.println("collections列表出栈（左端）："+jedis.lpop("collections"));\n        System.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        System.out.println("collections添加元素，从列表右端，与lpush相对应："+jedis.rpush("collections", "EnumMap"));\n        System.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        System.out.println("collections列表出栈（右端）："+jedis.rpop("collections"));\n        System.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        System.out.println("修改collections指定下标1的内容："+jedis.lset("collections", 1, "LinkedArrayList"));\n        System.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        System.out.println("===============================");\n        System.out.println("collections的长度："+jedis.llen("collections"));\n        System.out.println("获取collections下标为2的元素："+jedis.lindex("collections", 2));\n        System.out.println("===============================");\n        jedis.lpush("sortedList", "3","6","2","0","7","4");\n        System.out.println("sortedList排序前："+jedis.lrange("sortedList", 0, -1));\n        System.out.println(jedis.sort("sortedList"));\n        System.out.println("sortedList排序后："+jedis.lrange("sortedList", 0, -1));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 3.4 Set (集合)\n\n/**\n * @author CHGGX\n */\npublic class TestSet {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n        jedis.flushDB();\n        System.out.println("============向集合中添加元素（不重复）============");\n        System.out.println(jedis.sadd("eleSet", "e1","e2","e4","e3","e0","e8","e7","e5"));\n        System.out.println(jedis.sadd("eleSet", "e6"));\n        System.out.println(jedis.sadd("eleSet", "e6"));\n        System.out.println("eleSet的所有元素为："+jedis.smembers("eleSet"));\n        System.out.println("删除一个元素e0："+jedis.srem("eleSet", "e0"));\n        System.out.println("eleSet的所有元素为："+jedis.smembers("eleSet"));\n        System.out.println("删除两个元素e7和e6："+jedis.srem("eleSet", "e7","e6"));\n        System.out.println("eleSet的所有元素为："+jedis.smembers("eleSet"));\n        System.out.println("随机的移除集合中的一个元素："+jedis.spop("eleSet"));\n        System.out.println("随机的移除集合中的一个元素："+jedis.spop("eleSet"));\n        System.out.println("eleSet的所有元素为："+jedis.smembers("eleSet"));\n        System.out.println("eleSet中包含元素的个数："+jedis.scard("eleSet"));\n        System.out.println("e3是否在eleSet中："+jedis.sismember("eleSet", "e3"));\n        System.out.println("e1是否在eleSet中："+jedis.sismember("eleSet", "e1"));\n        System.out.println("e1是否在eleSet中："+jedis.sismember("eleSet", "e5"));\n        System.out.println("=================================");\n        System.out.println(jedis.sadd("eleSet1", "e1","e2","e4","e3","e0","e8","e7","e5"));\n        System.out.println(jedis.sadd("eleSet2", "e1","e2","e4","e3","e0","e8"));\n        // 移到集合元素\n        System.out.println("将eleSet1中删除e1并存入eleSet3中："+jedis.smove("eleSet1", "eleSet3", "e1"));\n        System.out.println("将eleSet1中删除e2并存入eleSet3中："+jedis.smove("eleSet1", "eleSet3", "e2"));\n        System.out.println("eleSet1中的元素："+jedis.smembers("eleSet1"));\n        System.out.println("eleSet3中的元素："+jedis.smembers("eleSet3"));\n        System.out.println("============集合运算=================");\n        System.out.println("eleSet1中的元素："+jedis.smembers("eleSet1"));\n        System.out.println("eleSet2中的元素："+jedis.smembers("eleSet2"));\n        System.out.println("eleSet1和eleSet2的交集:"+jedis.sinter("eleSet1","eleSet2"));\n        System.out.println("eleSet1和eleSet2的并集:"+jedis.sunion("eleSet1","eleSet2"));\n        // eleSet1中有，eleSet2中没有\n        System.out.println("eleSet1和eleSet2的差集:"+jedis.sdiff("eleSet1","eleSet2"));\n        // 求交集并将交集保存到dstkey的集合\n        jedis.sinterstore("eleSet4","eleSet1","eleSet2");\n        System.out.println("eleSet4中的元素："+jedis.smembers("eleSet4"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 3.5 Hash\n\n/**\n * @author CHGGX\n */\npublic class TestHash {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n        jedis.flushDB();\n        Map<String,String> map = new HashMap<String,String>();\n        map.put("key1","value1");\n        map.put("key2","value2");\n        map.put("key3","value3");\n        map.put("key4","value4");\n        //添加名称为hash（key）的hash元素\n        jedis.hmset("hash",map);\n        //向名称为hash的hash中添加key为key5，value为value5元素\n        jedis.hset("hash", "key5", "value5");\n        // return Map<String,String>\n        System.out.println("散列hash的所有键值对为："+jedis.hgetAll("hash"));\n        // return Set<String>\n        System.out.println("散列hash的所有键为："+jedis.hkeys("hash"));\n        // return List<String>\n        System.out.println("散列hash的所有值为："+jedis.hvals("hash"));\n        System.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6："+jedis.hincrBy("hash", "key6", 6));\n        System.out.println("散列hash的所有键值对为："+jedis.hgetAll("hash"));\n        System.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6："+jedis.hincrBy("hash", "key6", 3));\n        System.out.println("散列hash的所有键值对为："+jedis.hgetAll("hash"));\n        System.out.println("删除一个或者多个键值对："+jedis.hdel("hash", "key2"));\n        System.out.println("散列hash的所有键值对为："+jedis.hgetAll("hash"));\n        System.out.println("散列hash中键值对的个数："+jedis.hlen("hash"));\n        System.out.println("判断hash中是否存在key2："+jedis.hexists("hash","key2"));\n        System.out.println("判断hash中是否存在key3："+jedis.hexists("hash","key3"));\n        System.out.println("获取hash中的值："+jedis.hmget("hash","key3"));\n        System.out.println("获取hash中的值："+jedis.hmget("hash","key3","key4"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 4. 事务\n\n/**\n * @author CHGGX\n */\npublic class TestTX {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n\n        jedis.flushDB();\n\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put("hello","world");\n        jsonObject.put("name","chggx");\n        // 开启事务\n        Transaction multi = jedis.multi();\n        String result = jsonObject.toJSONString();\n//         jedis.watch(result);\n        try {\n            multi.set("user1",result);\n            multi.set("user2",result);\n            // 代码抛出异常事务，执行失败！\n            int i = 1/0 ;\n            // 执行事务！\n            multi.exec();\n        } catch (Exception e) {\n            // 放弃事务\n            multi.discard();\n            e.printStackTrace();\n        } finally {\n            System.out.println(jedis.get("user1"));\n            System.out.println(jedis.get("user2"));\n            // 关闭连接\n            jedis.close();\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n> 同redis命令',normalizedContent:'# redis-jedis\n\n\n# 1. 什么是jedis?\n\njedis 是 redis 官方推荐的 java连接开发工具！ 使用java 操作redis 中间件！如果你要使用java操作redis，那么一定要对jedis 十分的熟悉！\n\n\n# 2. 测试\n\n\n# 2.1 依赖\n\n\x3c!--导入jedis的包--\x3e\n    <dependencies>\n        \x3c!-- https://mvnrepository.com/artifact/redis.clients/jedis --\x3e\n        <dependency>\n            <groupid>redis.clients</groupid>\n            <artifactid>jedis</artifactid>\n            <version>3.2.0</version>\n        </dependency>\n        \x3c!--fastjson--\x3e\n        <dependency>\n            <groupid>com.alibaba</groupid>\n            <artifactid>fastjson</artifactid>\n            <version>1.2.62</version>\n        </dependency>\n    </dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.2 测试连接\n\n/**\n * @author: chggx\n * @description: <h1> 测试jedis连接redis </h1>\n */\npublic class testping {\n\n    public static void main(string[] args) {\n        // 1、 new jedis 对象即可\n        jedis jedis = new jedis("127.0.0.1",6379);\n        // jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！\n        system.out.println(jedis.ping());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ne:\\develop\\java\\jdk1.8.0_91\\bin\\java.exe "......\npong\n\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n\n\n\n# 3. 常用api\n\n> 所有的api命令，就是我们对应的redos的指令，一个都没有变化！\n\n\n# 3.1 redis-key\n\n/**\n * @author chggx\n */\npublic class testkey {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n\n        system.out.println("清空数据："+jedis.flushdb());\n        system.out.println("判断某个键是否存在："+jedis.exists("username"));\n        system.out.println("新增<\'username\',\'kuangshen\'>的键值对："+jedis.set("username", "chggx"));\n        system.out.println("新增<\'password\',\'password\'>的键值对："+jedis.set("password", "password"));\n        system.out.print("系统中所有的键如下：");\n        set<string> keys = jedis.keys("*");\n        system.out.println(keys);\n\n        system.out.println("删除键password:"+jedis.del("password"));\n        system.out.println("判断键password是否存在："+jedis.exists("password"));\n        system.out.println("查看键username所存储的值的类型："+jedis.type("username"));\n        system.out.println("随机返回key空间的一个："+jedis.randomkey());\n        system.out.println("重命名key："+jedis.rename("username","name"));\n        system.out.println("取出改后的name："+jedis.get("name"));\n        system.out.println("按索引查询："+jedis.select(0));\n                system.out.println("删除当前选择数据库中的所有key："+jedis.flushdb());\n        system.out.println("返回当前数据库中key的数目："+jedis.dbsize());\n        system.out.println("删除所有数据库中的所有key："+jedis.flushall());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3.2 string (字符串)\n\n/**\n * @author chggx\n * 测试string类型\n */\npublic class teststring {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n\n        jedis.flushdb();\n        system.out.println("===========增加数据===========");\n        system.out.println(jedis.set("key1","value1"));\n        system.out.println(jedis.set("key2","value2"));\n        system.out.println(jedis.set("key3", "value3"));\n        system.out.println("删除键key2:"+jedis.del("key2"));\n        system.out.println("获取键key2:"+jedis.get("key2"));\n        system.out.println("修改key1:"+jedis.set("key1", "value1changed"));\n        system.out.println("获取key1的值："+jedis.get("key1"));\n        system.out.println("在key3后面加入值："+jedis.append("key3", "end"));\n        system.out.println("key3的值："+jedis.get("key3"));\n        system.out.println("增加多个键值对："+jedis.mset("key01","value01","key02","value02","key03","value03"));\n        system.out.println("获取多个键值对："+jedis.mget("key01","key02","key03"));\n        system.out.println("获取多个键值对："+jedis.mget("key01","key02","key03","key04"));\n        system.out.println("删除多个键值对："+jedis.del("key01","key02"));\n        system.out.println("获取多个键值对："+jedis.mget("key01","key02","key03"));\n\n        jedis.flushdb();\n        system.out.println("===========新增键值对防止覆盖原先值==============");\n        system.out.println(jedis.setnx("key1", "value1"));\n        system.out.println(jedis.setnx("key2", "value2"));\n        system.out.println(jedis.setnx("key2", "value2-new"));\n        system.out.println(jedis.get("key1"));\n        system.out.println(jedis.get("key2"));\n\n        system.out.println("===========新增键值对并设置有效时间=============");\n        system.out.println(jedis.setex("key3", 2, "value3"));\n        system.out.println(jedis.get("key3"));\n        try {\n            timeunit.seconds.sleep(3);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println(jedis.get("key3"));\n\n        system.out.println("===========获取原值，更新为新值==========");\n        system.out.println(jedis.getset("key2", "key2getset"));\n        system.out.println(jedis.get("key2"));\n\n        system.out.println("获得key2的值的字串："+jedis.getrange("key2", 2, 4));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 3.3 list (列表)\n\n/**\n * @author chggx\n */\npublic class testlist {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n        jedis.flushdb();\n        system.out.println("===========添加一个list===========");\n        jedis.lpush("collections", "arraylist", "vector", "stack", "hashmap", "weakhashmap", "linkedhashmap");\n        jedis.lpush("collections", "hashset");\n        jedis.lpush("collections", "treeset");\n        jedis.lpush("collections", "treemap");\n        // -1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部\n        system.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        system.out.println("collections区间0-3的元素："+jedis.lrange("collections",0,3));\n        system.out.println("===============================");\n        // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈\n        system.out.println("删除指定元素个数："+jedis.lrem("collections", 2, "hashmap"));\n        system.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        system.out.println("删除下表0-3区间之外的元素："+jedis.ltrim("collections", 0, 3));\n        system.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        system.out.println("collections列表出栈（左端）："+jedis.lpop("collections"));\n        system.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        system.out.println("collections添加元素，从列表右端，与lpush相对应："+jedis.rpush("collections", "enummap"));\n        system.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        system.out.println("collections列表出栈（右端）："+jedis.rpop("collections"));\n        system.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        system.out.println("修改collections指定下标1的内容："+jedis.lset("collections", 1, "linkedarraylist"));\n        system.out.println("collections的内容："+jedis.lrange("collections", 0, -1));\n        system.out.println("===============================");\n        system.out.println("collections的长度："+jedis.llen("collections"));\n        system.out.println("获取collections下标为2的元素："+jedis.lindex("collections", 2));\n        system.out.println("===============================");\n        jedis.lpush("sortedlist", "3","6","2","0","7","4");\n        system.out.println("sortedlist排序前："+jedis.lrange("sortedlist", 0, -1));\n        system.out.println(jedis.sort("sortedlist"));\n        system.out.println("sortedlist排序后："+jedis.lrange("sortedlist", 0, -1));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 3.4 set (集合)\n\n/**\n * @author chggx\n */\npublic class testset {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n        jedis.flushdb();\n        system.out.println("============向集合中添加元素（不重复）============");\n        system.out.println(jedis.sadd("eleset", "e1","e2","e4","e3","e0","e8","e7","e5"));\n        system.out.println(jedis.sadd("eleset", "e6"));\n        system.out.println(jedis.sadd("eleset", "e6"));\n        system.out.println("eleset的所有元素为："+jedis.smembers("eleset"));\n        system.out.println("删除一个元素e0："+jedis.srem("eleset", "e0"));\n        system.out.println("eleset的所有元素为："+jedis.smembers("eleset"));\n        system.out.println("删除两个元素e7和e6："+jedis.srem("eleset", "e7","e6"));\n        system.out.println("eleset的所有元素为："+jedis.smembers("eleset"));\n        system.out.println("随机的移除集合中的一个元素："+jedis.spop("eleset"));\n        system.out.println("随机的移除集合中的一个元素："+jedis.spop("eleset"));\n        system.out.println("eleset的所有元素为："+jedis.smembers("eleset"));\n        system.out.println("eleset中包含元素的个数："+jedis.scard("eleset"));\n        system.out.println("e3是否在eleset中："+jedis.sismember("eleset", "e3"));\n        system.out.println("e1是否在eleset中："+jedis.sismember("eleset", "e1"));\n        system.out.println("e1是否在eleset中："+jedis.sismember("eleset", "e5"));\n        system.out.println("=================================");\n        system.out.println(jedis.sadd("eleset1", "e1","e2","e4","e3","e0","e8","e7","e5"));\n        system.out.println(jedis.sadd("eleset2", "e1","e2","e4","e3","e0","e8"));\n        // 移到集合元素\n        system.out.println("将eleset1中删除e1并存入eleset3中："+jedis.smove("eleset1", "eleset3", "e1"));\n        system.out.println("将eleset1中删除e2并存入eleset3中："+jedis.smove("eleset1", "eleset3", "e2"));\n        system.out.println("eleset1中的元素："+jedis.smembers("eleset1"));\n        system.out.println("eleset3中的元素："+jedis.smembers("eleset3"));\n        system.out.println("============集合运算=================");\n        system.out.println("eleset1中的元素："+jedis.smembers("eleset1"));\n        system.out.println("eleset2中的元素："+jedis.smembers("eleset2"));\n        system.out.println("eleset1和eleset2的交集:"+jedis.sinter("eleset1","eleset2"));\n        system.out.println("eleset1和eleset2的并集:"+jedis.sunion("eleset1","eleset2"));\n        // eleset1中有，eleset2中没有\n        system.out.println("eleset1和eleset2的差集:"+jedis.sdiff("eleset1","eleset2"));\n        // 求交集并将交集保存到dstkey的集合\n        jedis.sinterstore("eleset4","eleset1","eleset2");\n        system.out.println("eleset4中的元素："+jedis.smembers("eleset4"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 3.5 hash\n\n/**\n * @author chggx\n */\npublic class testhash {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n        jedis.flushdb();\n        map<string,string> map = new hashmap<string,string>();\n        map.put("key1","value1");\n        map.put("key2","value2");\n        map.put("key3","value3");\n        map.put("key4","value4");\n        //添加名称为hash（key）的hash元素\n        jedis.hmset("hash",map);\n        //向名称为hash的hash中添加key为key5，value为value5元素\n        jedis.hset("hash", "key5", "value5");\n        // return map<string,string>\n        system.out.println("散列hash的所有键值对为："+jedis.hgetall("hash"));\n        // return set<string>\n        system.out.println("散列hash的所有键为："+jedis.hkeys("hash"));\n        // return list<string>\n        system.out.println("散列hash的所有值为："+jedis.hvals("hash"));\n        system.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6："+jedis.hincrby("hash", "key6", 6));\n        system.out.println("散列hash的所有键值对为："+jedis.hgetall("hash"));\n        system.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6："+jedis.hincrby("hash", "key6", 3));\n        system.out.println("散列hash的所有键值对为："+jedis.hgetall("hash"));\n        system.out.println("删除一个或者多个键值对："+jedis.hdel("hash", "key2"));\n        system.out.println("散列hash的所有键值对为："+jedis.hgetall("hash"));\n        system.out.println("散列hash中键值对的个数："+jedis.hlen("hash"));\n        system.out.println("判断hash中是否存在key2："+jedis.hexists("hash","key2"));\n        system.out.println("判断hash中是否存在key3："+jedis.hexists("hash","key3"));\n        system.out.println("获取hash中的值："+jedis.hmget("hash","key3"));\n        system.out.println("获取hash中的值："+jedis.hmget("hash","key3","key4"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 4. 事务\n\n/**\n * @author chggx\n */\npublic class testtx {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n\n        jedis.flushdb();\n\n        jsonobject jsonobject = new jsonobject();\n        jsonobject.put("hello","world");\n        jsonobject.put("name","chggx");\n        // 开启事务\n        transaction multi = jedis.multi();\n        string result = jsonobject.tojsonstring();\n//         jedis.watch(result);\n        try {\n            multi.set("user1",result);\n            multi.set("user2",result);\n            // 代码抛出异常事务，执行失败！\n            int i = 1/0 ;\n            // 执行事务！\n            multi.exec();\n        } catch (exception e) {\n            // 放弃事务\n            multi.discard();\n            e.printstacktrace();\n        } finally {\n            system.out.println(jedis.get("user1"));\n            system.out.println(jedis.get("user2"));\n            // 关闭连接\n            jedis.close();\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n> 同redis命令',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"SpringBoot整合",frontmatter:{title:"SpringBoot整合",date:"2023-02-27T11:23:36.000Z",permalink:"/pages/315078/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E7%BC%93%E5%AD%98/6.SpringBoot%E6%95%B4%E5%90%88.html",relativePath:"04.后端应用框架/03.中间件/01.缓存/6.SpringBoot整合.md",key:"v-789a3d66",path:"/pages/315078/",headers:[{level:2,title:"1. 依赖",slug:"_1-依赖",normalizedTitle:"1. 依赖",charIndex:310},{level:2,title:"2. 配置",slug:"_2-配置",normalizedTitle:"2. 配置",charIndex:1931},{level:3,title:"2.1  redis配置类[源码]",slug:"_2-1-redis配置类-源码",normalizedTitle:"2.1  redis配置类[源码]",charIndex:null},{level:3,title:"2.2 配置文件",slug:"_2-2-配置文件",normalizedTitle:"2.2 配置文件",charIndex:3813},{level:2,title:"3 测试",slug:"_3-测试",normalizedTitle:"3 测试",charIndex:4334},{level:3,title:"3.1 乱码",slug:"_3-1-乱码",normalizedTitle:"3.1 乱码",charIndex:4343},{level:3,title:"3.2  对象保存需要序列化",slug:"_3-2-对象保存需要序列化",normalizedTitle:"3.2  对象保存需要序列化",charIndex:null},{level:2,title:"4. redis序列化配置",slug:"_4-redis序列化配置",normalizedTitle:"4. redis序列化配置",charIndex:5171},{level:3,title:"4.1 自定义redis配置类",slug:"_4-1-自定义redis配置类",normalizedTitle:"4.1 自定义redis配置类",charIndex:5211},{level:3,title:"4.2 自定义redis工具类",slug:"_4-2-自定义redis工具类",normalizedTitle:"4.2 自定义redis工具类",charIndex:7845}],headersStr:"1. 依赖 2. 配置 2.1  redis配置类[源码] 2.2 配置文件 3 测试 3.1 乱码 3.2  对象保存需要序列化 4. redis序列化配置 4.1 自定义redis配置类 4.2 自定义redis工具类",content:'# SpringBoot整合\n\nSpringBoot 操作数据：spring-data jpa. jdbc. mongodb. redis！\n\nSpringData 也是和 SpringBoot 齐名的项目！\n\n> 说明： 在 SpringBoot2.x 之后，客户端原来使用的jedis 被替换为了 lettuce?\n> \n> jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式.\n> \n> lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式.\n\n\n# 1. 依赖\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n> springboot版本 2.x使用的是 lettce\n\n * 上边集成boot的依赖所包含的核心包\n\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter</artifactId>\n    <version>2.2.5.RELEASE</version>\n    <scope>compile</scope>\n  </dependency>\n  <dependency>\n    <groupId>org.springframework.data</groupId>\n    <artifactId>spring-data-redis</artifactId>\n    <version>2.2.5.RELEASE</version>\n    <scope>compile</scope>\n    <exclusions>\n      <exclusion>\n        <artifactId>jcl-over-slf4j</artifactId>\n        <groupId>org.slf4j</groupId>\n      </exclusion>\n    </exclusions>\n  </dependency>\n  <dependency>\n    <groupId>io.lettuce</groupId>\n    <artifactId>lettuce-core</artifactId>\n    <version>5.2.2.RELEASE</version>\n    <scope>compile</scope>\n  </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n当在配置文件application.properties配置 lettuce 时,启动项目出现\n\nCaused by: java.lang.ClassNotFoundException: org.apache.commons.pool2.impl.GenericObjectPoolConfig\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 93 more\n\n\n1\n2\n3\n4\n5\n6\n\n\n解决: pxm.xml配置\n\n\x3c!--redis客户端Lettuce 数据库连接池依赖 --\x3e\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2. 配置\n\n\n# 2.1 redis配置类[源码]\n\n * RedisAutoConfiguration\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\n@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\npublic class RedisAutoConfiguration {\n\n   // RedisTemplate\n   @Bean\n   // 我们可以自己定义一个 redisTemplate来替换这个默认的！\n   @ConditionalOnMissingBean(name = "redisTemplate")\n   public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\n         throws UnknownHostException {\n       // 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！\n       // 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 <String, Object>\n      RedisTemplate<Object, Object> template = new RedisTemplate<>();\n      template.setConnectionFactory(redisConnectionFactory);\n      return template;\n   }\n\n    // StringRedisTemplate\n   @Bean\n   // 由于 String 是redis中最常使用的类型，所以说单独提出来了一 个bean！\n   @ConditionalOnMissingBean\n   public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)\n         throws UnknownHostException {\n      StringRedisTemplate template = new StringRedisTemplate();\n      template.setConnectionFactory(redisConnectionFactory);\n      return template;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n> @ConditionalOnMissingBean: 当这个Bean不存在式,这个类生效\n\n * RedisProperties: redis默认配置\n\n@ConfigurationProperties(prefix = "spring.redis")\npublic class RedisProperties {\n\n   private int database = 0;\n\n   private String url;\n\n   private String host = "localhost";\n\n   private String password;\n\n   private int port = 6379;\n\n   private boolean ssl;\n\n   private Duration timeout;\n\n   private String clientName;\n\n   private Sentinel sentinel;\n\n   private Cluster cluster;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.2 配置文件\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n# Redis数据库索引（默认为0）\nspring.redis.database=0\n#  Redis服务器连接密码（默认为空）\nspring.redis.password=\n# 连接超时时间\nspring.redis.timeout=10000ms\n\n# 这里使用 lettuce\n# 连接池最大连接数\nspring.redis.lettuce.pool.max-active=1000 \n# 连接池最大阻塞等待时间\nspring.redis.lettuce.pool.max-wait=-1ms\n# 连接池最大空闲连接\nspring.redis.lettuce.pool.max-idle=10 \n#连接池最小空闲连接\nspring.redis.lettuce.pool.min-idle=5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 此处使用 .properties 形式配置\n\n\n# 3 测试\n\n\n# 3.1 乱码\n\n\t@Resource\n    private RedisTemplate redisTemplate;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Test\n    void contextLoads() {\n        redisTemplate.opsForValue().set("key01", "Hello Redis !");\n        stringRedisTemplate.opsForValue().set("key02", "Hello Redis !");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n127.0.0.1:6379> keys *\n1) "key02" \n2) "\\xac\\xed\\x00\\x05t\\x00\\x05key01"\n\n\n1\n2\n3\n\n\n> redisTemplate: 出现中文乱码\n\n\n# 3.2 对象保存需要序列化\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n\n    private String name;\n    private Integer age;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n// User实体类,未序列化\nUser user = new User("chggx", 3);\nredisTemplate.opsForValue().set("user",user);\n\n\n1\n2\n3\n\n\n结果:\n\n\n\n解决: 在 User中添加序列化 implements Serializable\n\n127.0.0.1:6379> keys *\n1) "\\xac\\xed\\x00\\x05t\\x00\\x04user"\n\n\n1\n2\n\n\n\n# 4. redis序列化配置\n\n * RedisTemplate\n\n\n\n\n\n\n# 4.1 自定义redis配置类\n\n@Configuration\npublic class RedisConfig {\n\n    /**\n     * Redis连接工厂\n     */\n    @Autowired\n    private RedisConnectionFactory redisConnectionFactory;\n\n    /**\n     * String 的序列化\n     *\n     * @return\n     */\n    @Bean\n    public RedisSerializer<String> stringRedisSerializer() {\n        return new StringRedisSerializer();\n    }\n\n    /**\n     * Jackson2JsonRedisSerializer序列化\n     *\n     * @return\n     */\n    @Bean\n    public Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer() {\n        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n        return jackson2JsonRedisSerializer;\n    }\n\n    /**\n     * RedisTemplate\n     *\n     * @return\n     */\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate() {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n\n        // Redis连接工厂\n        template.setConnectionFactory(redisConnectionFactory);\n\n        // key采用String的序列化方式\n        template.setKeySerializer(stringRedisSerializer());\n        // hash的key也采用String的序列化方式\n        template.setHashKeySerializer(stringRedisSerializer());\n        // value序列化方式采用\n        template.setValueSerializer(jackson2JsonRedisSerializer());\n        // hash的value序列化方式采用\n        template.setHashValueSerializer(jackson2JsonRedisSerializer());\n        template.afterPropertiesSet();\n        // 开启事务支持\n        template.setEnableTransactionSupport(true);\n        return template;\n    }\n\n    /**\n     * StringRedisTemplate\n     *\n     * @param redisConnectionFactory\n     * @return\n     */\n    @Bean\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {\n        StringRedisTemplate template = new StringRedisTemplate();\n        // Redis连接工厂\n        template.setConnectionFactory(redisConnectionFactory);\n\n        // 开启事务支持\n        template.setEnableTransactionSupport(true);\n        return template;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n * 3.2 中结果,经过redis json序列化 后\n\n127.0.0.1:6379> keys *\n1) "user"\n127.0.0.1:6379> get user\n"[\\"com.chggx.pojo.User\\",{\\"name\\":\\"chggx\\",\\"age\\":3}]"\n\n\n1\n2\n3\n4\n\n\n\n# 4.2 自定义redis工具类\n\n自定义Redis配置类\n\n> 链接：https://pan.baidu.com/s/1mVAi1-yG7fA2Y-hTwEzp5g 提取码：fp92\n\n * 测试\n\n/**\n * 自定义缓存类\n */\n@Autowired\nprivate RedisUtil redisUtil;\n\n @Test\nvoid test03(){\n    // 设置\n    redisUtil.set("name","chggx");\n    // 获取\n    System.out.println(redisUtil.get("name"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# springboot整合\n\nspringboot 操作数据：spring-data jpa. jdbc. mongodb. redis！\n\nspringdata 也是和 springboot 齐名的项目！\n\n> 说明： 在 springboot2.x 之后，客户端原来使用的jedis 被替换为了 lettuce?\n> \n> jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 bio 模式.\n> \n> lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 nio 模式.\n\n\n# 1. 依赖\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n> springboot版本 2.x使用的是 lettce\n\n * 上边集成boot的依赖所包含的核心包\n\n<dependencies>\n  <dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter</artifactid>\n    <version>2.2.5.release</version>\n    <scope>compile</scope>\n  </dependency>\n  <dependency>\n    <groupid>org.springframework.data</groupid>\n    <artifactid>spring-data-redis</artifactid>\n    <version>2.2.5.release</version>\n    <scope>compile</scope>\n    <exclusions>\n      <exclusion>\n        <artifactid>jcl-over-slf4j</artifactid>\n        <groupid>org.slf4j</groupid>\n      </exclusion>\n    </exclusions>\n  </dependency>\n  <dependency>\n    <groupid>io.lettuce</groupid>\n    <artifactid>lettuce-core</artifactid>\n    <version>5.2.2.release</version>\n    <scope>compile</scope>\n  </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n当在配置文件application.properties配置 lettuce 时,启动项目出现\n\ncaused by: java.lang.classnotfoundexception: org.apache.commons.pool2.impl.genericobjectpoolconfig\n\tat java.net.urlclassloader.findclass(urlclassloader.java:381)\n\tat java.lang.classloader.loadclass(classloader.java:424)\n\tat sun.misc.launcher$appclassloader.loadclass(launcher.java:331)\n\tat java.lang.classloader.loadclass(classloader.java:357)\n\t... 93 more\n\n\n1\n2\n3\n4\n5\n6\n\n\n解决: pxm.xml配置\n\n\x3c!--redis客户端lettuce 数据库连接池依赖 --\x3e\n<dependency>\n    <groupid>org.apache.commons</groupid>\n    <artifactid>commons-pool2</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2. 配置\n\n\n# 2.1 redis配置类[源码]\n\n * redisautoconfiguration\n\n@configuration(proxybeanmethods = false)\n@conditionalonclass(redisoperations.class)\n@enableconfigurationproperties(redisproperties.class)\n@import({ lettuceconnectionconfiguration.class, jedisconnectionconfiguration.class })\npublic class redisautoconfiguration {\n\n   // redistemplate\n   @bean\n   // 我们可以自己定义一个 redistemplate来替换这个默认的！\n   @conditionalonmissingbean(name = "redistemplate")\n   public redistemplate<object, object> redistemplate(redisconnectionfactory redisconnectionfactory)\n         throws unknownhostexception {\n       // 默认的 redistemplate 没有过多的设置，redis 对象都是需要序列化！\n       // 两个泛型都是 object, object 的类型，我们后使用需要强制转换 <string, object>\n      redistemplate<object, object> template = new redistemplate<>();\n      template.setconnectionfactory(redisconnectionfactory);\n      return template;\n   }\n\n    // stringredistemplate\n   @bean\n   // 由于 string 是redis中最常使用的类型，所以说单独提出来了一 个bean！\n   @conditionalonmissingbean\n   public stringredistemplate stringredistemplate(redisconnectionfactory redisconnectionfactory)\n         throws unknownhostexception {\n      stringredistemplate template = new stringredistemplate();\n      template.setconnectionfactory(redisconnectionfactory);\n      return template;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n> @conditionalonmissingbean: 当这个bean不存在式,这个类生效\n\n * redisproperties: redis默认配置\n\n@configurationproperties(prefix = "spring.redis")\npublic class redisproperties {\n\n   private int database = 0;\n\n   private string url;\n\n   private string host = "localhost";\n\n   private string password;\n\n   private int port = 6379;\n\n   private boolean ssl;\n\n   private duration timeout;\n\n   private string clientname;\n\n   private sentinel sentinel;\n\n   private cluster cluster;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.2 配置文件\n\n# redis服务器地址\nspring.redis.host=127.0.0.1\n# redis服务器连接端口\nspring.redis.port=6379\n# redis数据库索引（默认为0）\nspring.redis.database=0\n#  redis服务器连接密码（默认为空）\nspring.redis.password=\n# 连接超时时间\nspring.redis.timeout=10000ms\n\n# 这里使用 lettuce\n# 连接池最大连接数\nspring.redis.lettuce.pool.max-active=1000 \n# 连接池最大阻塞等待时间\nspring.redis.lettuce.pool.max-wait=-1ms\n# 连接池最大空闲连接\nspring.redis.lettuce.pool.max-idle=10 \n#连接池最小空闲连接\nspring.redis.lettuce.pool.min-idle=5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 此处使用 .properties 形式配置\n\n\n# 3 测试\n\n\n# 3.1 乱码\n\n\t@resource\n    private redistemplate redistemplate;\n\n    @resource\n    private stringredistemplate stringredistemplate;\n\n    @test\n    void contextloads() {\n        redistemplate.opsforvalue().set("key01", "hello redis !");\n        stringredistemplate.opsforvalue().set("key02", "hello redis !");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n127.0.0.1:6379> keys *\n1) "key02" \n2) "\\xac\\xed\\x00\\x05t\\x00\\x05key01"\n\n\n1\n2\n3\n\n\n> redistemplate: 出现中文乱码\n\n\n# 3.2 对象保存需要序列化\n\n@data\n@allargsconstructor\n@noargsconstructor\npublic class user {\n\n    private string name;\n    private integer age;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n// user实体类,未序列化\nuser user = new user("chggx", 3);\nredistemplate.opsforvalue().set("user",user);\n\n\n1\n2\n3\n\n\n结果:\n\n\n\n解决: 在 user中添加序列化 implements serializable\n\n127.0.0.1:6379> keys *\n1) "\\xac\\xed\\x00\\x05t\\x00\\x04user"\n\n\n1\n2\n\n\n\n# 4. redis序列化配置\n\n * redistemplate\n\n\n\n\n\n\n# 4.1 自定义redis配置类\n\n@configuration\npublic class redisconfig {\n\n    /**\n     * redis连接工厂\n     */\n    @autowired\n    private redisconnectionfactory redisconnectionfactory;\n\n    /**\n     * string 的序列化\n     *\n     * @return\n     */\n    @bean\n    public redisserializer<string> stringredisserializer() {\n        return new stringredisserializer();\n    }\n\n    /**\n     * jackson2jsonredisserializer序列化\n     *\n     * @return\n     */\n    @bean\n    public jackson2jsonredisserializer<object> jackson2jsonredisserializer() {\n        jackson2jsonredisserializer<object> jackson2jsonredisserializer = new jackson2jsonredisserializer<>(object.class);\n        objectmapper objectmapper = new objectmapper();\n        objectmapper.setvisibility(propertyaccessor.all, jsonautodetect.visibility.any);\n        objectmapper.enabledefaulttyping(objectmapper.defaulttyping.non_final);\n        jackson2jsonredisserializer.setobjectmapper(objectmapper);\n        return jackson2jsonredisserializer;\n    }\n\n    /**\n     * redistemplate\n     *\n     * @return\n     */\n    @bean\n    public redistemplate<object, object> redistemplate() {\n        redistemplate<object, object> template = new redistemplate<>();\n\n        // redis连接工厂\n        template.setconnectionfactory(redisconnectionfactory);\n\n        // key采用string的序列化方式\n        template.setkeyserializer(stringredisserializer());\n        // hash的key也采用string的序列化方式\n        template.sethashkeyserializer(stringredisserializer());\n        // value序列化方式采用\n        template.setvalueserializer(jackson2jsonredisserializer());\n        // hash的value序列化方式采用\n        template.sethashvalueserializer(jackson2jsonredisserializer());\n        template.afterpropertiesset();\n        // 开启事务支持\n        template.setenabletransactionsupport(true);\n        return template;\n    }\n\n    /**\n     * stringredistemplate\n     *\n     * @param redisconnectionfactory\n     * @return\n     */\n    @bean\n    public stringredistemplate stringredistemplate(redisconnectionfactory redisconnectionfactory) {\n        stringredistemplate template = new stringredistemplate();\n        // redis连接工厂\n        template.setconnectionfactory(redisconnectionfactory);\n\n        // 开启事务支持\n        template.setenabletransactionsupport(true);\n        return template;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n * 3.2 中结果,经过redis json序列化 后\n\n127.0.0.1:6379> keys *\n1) "user"\n127.0.0.1:6379> get user\n"[\\"com.chggx.pojo.user\\",{\\"name\\":\\"chggx\\",\\"age\\":3}]"\n\n\n1\n2\n3\n4\n\n\n\n# 4.2 自定义redis工具类\n\n自定义redis配置类\n\n> 链接：https://pan.baidu.com/s/1mvai1-yg7fa2y-htwezp5g 提取码：fp92\n\n * 测试\n\n/**\n * 自定义缓存类\n */\n@autowired\nprivate redisutil redisutil;\n\n @test\nvoid test03(){\n    // 设置\n    redisutil.set("name","chggx");\n    // 获取\n    system.out.println(redisutil.get("name"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Redis的配置文件详解",frontmatter:{title:"Redis的配置文件详解",date:"2023-02-27T11:23:36.000Z",permalink:"/pages/255a13/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/03.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E7%BC%93%E5%AD%98/7.Redis%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3.html",relativePath:"04.后端应用框架/03.中间件/01.缓存/7.Redis的配置文件详解.md",key:"v-123e5264",path:"/pages/255a13/",headers:[{level:2,title:"1. 单位",slug:"_1-单位",normalizedTitle:"1. 单位",charIndex:71},{level:2,title:"2.  包含 INCLUDES",slug:"_2-包含-includes",normalizedTitle:"2.  包含 includes",charIndex:null},{level:2,title:"3. 网络 NETWORK",slug:"_3-网络-network",normalizedTitle:"3. 网络 network",charIndex:1320},{level:2,title:"4. 通用配置  GENERAL",slug:"_4-通用配置-general",normalizedTitle:"4. 通用配置  general",charIndex:null},{level:2,title:"5. 快照 SNAPSHOTTING",slug:"_5-快照-snapshotting",normalizedTitle:"5. 快照 snapshotting",charIndex:3137},{level:2,title:"6. 主从复制 REPLICATION",slug:"_6-主从复制-replication",normalizedTitle:"6. 主从复制 replication",charIndex:4270},{level:2,title:"7. 安全 SECURITY",slug:"_7-安全-security",normalizedTitle:"7. 安全 security",charIndex:4304},{level:3,title:"设置密码",slug:"设置密码",normalizedTitle:"设置密码",charIndex:1390},{level:2,title:"8. 限制 CLIENTS",slug:"_8-限制-clients",normalizedTitle:"8. 限制 clients",charIndex:5195},{level:2,title:"9. aof模式 APPEND ONLY MODE",slug:"_9-aof模式-append-only-mode",normalizedTitle:"9. aof模式 append only mode",charIndex:6010}],headersStr:"1. 单位 2.  包含 INCLUDES 3. 网络 NETWORK 4. 通用配置  GENERAL 5. 快照 SNAPSHOTTING 6. 主从复制 REPLICATION 7. 安全 SECURITY 设置密码 8. 限制 CLIENTS 9. aof模式 APPEND ONLY MODE",content:'# Redis的配置文件详解\n\n> 进入 /usr/local/bin/redis-config 打开配置文件 redis.conf\n\n\n# 1. 单位\n\n# 1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024*1024 bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024*1024*1024 bytes\n#\n# units are case insensitive so 1GB 1Gb 1gB are all the same.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n配置文件 unit单位 redis.conf对内存大小的大小写不敏感\n\n\n# 2. 包含 INCLUDES\n\n################################## INCLUDES ###################################\n\n# Include one or more other config files here.  This is useful if you\n# have a standard template that goes to all Redis servers but also need\n# to customize a few per-server settings.  Include files can include\n# other files, so use this wisely.\n#\n# Notice option "include" won\'t be rewritten by command "CONFIG REWRITE"\n# from admin or Redis Sentinel. Since Redis always uses the last processed\n# line as value of a configuration directive, you\'d better put includes\n# at the beginning of this file to avoid overwriting config change at runtime.\n#\n# If instead you are interested in using includes to override configuration\n# options, it is better to use include as the last line.\n#\n# include /path/to/local.conf\n# include /path/to/other.conf\n\n################################## MODULES #####################################\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3. 网络 NETWORK\n\n# 绑定的ip地址\nbind 127.0.0.1\n\n# 保护模式，默认是开启状态，只允许本地客户端连接， 可以设置密码或添加bind来连接\nprotected-mode yes\n\n# 端口号，默认为6379，如果设为0，redis将不在socket 上监听任何客户端连接\nport 6379\n\n# TCP监听的最大容纳数量，在高并发的环境下，你需要把这个值调高以避免客户端连接缓慢的问题。Linux 内核会把这个值缩小成 /proc/sys/net/core/somaxconn对应的值，要提升并发量需要修改这两个值才能达到目的\ntcp-backlog 511\n\n# 指定redis监听的unix socket路径，默认不启用，unixsocketper指定文件的权限\nunixsocket /tmp/redis.sock\nunixsocketperm 700\n\n# 指定在一个 client 空闲多少秒之后关闭连接（0表示永不关闭）\ntimeout 0\n\n# 单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0，则不会周期性的检测\ntcp-keepalive 300\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4. 通用配置 GENERAL\n\n# 默认情况下 redis 不是作为守护进程运行(后台的方式运行)的 (默认是 no) ，如果你想让它在后台运行，你就把它改成 yes。当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面\ndaemonize yes \n\n# 可以通过upstart和systemd管理Redis守护进程\n# 选项：\n#   supervised no - 没有监督互动\n#   supervised upstart - 通过将Redis置于SIGSTOP模式来启动信号\n#   supervised systemd - signal systemd将READY = 1写入$ NOTIFY_SOCKET\n#   supervised auto - 检测upstart或systemd方法基于 UPSTART_JOB或NOTIFY_SOCKET环境变量\nsupervised no \n\n# 配置PID文件路径，当redis作为守护进程运行的时候(后台的方式运行)，它会把 pid 默认写到 /var/redis/run/redis_6379.pid 文件里面\npidfile /var/run/redis_6379.pid\n\n# 定义日志级别。\n#  可以是下面的这些值：\n#  debug（记录大量日志信息，适用于开发、测试阶段）\n#  verbose（较多日志信息）\n#  notice（适量日志信息，使用于生产环境）\n#  warning（仅有部分重要、关键信息才会被记录）\nloglevel notice\n\n# 日志文件的位置，当指定为空字符串时，为标准输出，如果redis已守护进程模式运行，那么日志将会输出到/dev/null\nlogfile ""\n\n# 要想把日志记录到系统日志，就把它改成 yes，也可以可选择性的更新其他的syslog 参数以达到你的要求\nsyslog-enabled no\n\n# 设置系统日志的ID\nsyslog-ident redis\n\n# 指定系统日志设置，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值\nsyslog-facility local0\n\n# 设置数据库的数目 (默认有16个数据库)。默认的数据库是DB 0 ，可以在每个连接上使用select  <dbid> 命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。\ndatabases 16\n\n# 是否总是显示LOGO\nalways-show-logo yes \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 5. 快照 SNAPSHOTTING\n\n持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof\n\nredis 是内存数据库，如果没有持久化，那么数据断电及失！\n\n# 存 DB 到磁盘：\n#    格式：save <间隔时间（秒）> <写入次数>\n#    根据给定的时间间隔和写入次数将数据保存到磁盘\n\n#    注意：你可以注释掉所有的 save 行来停用保存功能。\n#    也可以直接一个空字符串来实现停用：save ""\n# 如果900s内，如果至少有一个1 key进行了修改，我们及时进行持久化操作 \nsave 900 1 \n# 如果300s内，如果至少10 key进行了修改，我们及时进行持久化操作 \nsave 300 10 \n# 如果60s内，如果至少10000 key进行了修改，我们及时进行持久化操作 \nsave 60 10000\n\n# 持久化如果出错，是否还需要继续工作！\n#  如果用户开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。\n#  这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。\n#  如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。\n#  如果下一次RDB持久化成功，redis会自动恢复接受写请求。\n#  如果不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，可以关闭这个功能，以便在快照写入失败时，也能确保redis继续接受新的写请求。\nstop-writes-on-bgsave-error yes \n\n#  对于存储到磁盘中的快照，可以设置是否进行压缩存储。\n#  如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，\n#  可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。\nrdbcompression yes\n\n# 在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。[保存rdb文件的时候，进行错误的检查校验！]\nrdbchecksum yes \n\n# 设置快照的文件名\ndbfilename dump.rdb\n\n# 设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名\ndir ./ \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 6. 主从复制 REPLICATION\n\n> 详见主从复制\n\n\n# 7. 安全 SECURITY\n\n\n# 设置密码\n\n * 方式一: 配置文件中设置\n\n# requirepass foobared\n# 设置redis密码\nrequirepass 123456\n\n\n1\n2\n3\n\n * 方式二: 命令行\n\n127.0.0.1:6379> config get requirepass # 获取redis密码\n1) "requirepass"\n2) ""\n127.0.0.1:6379> config set requirepass "123456" # 设置redis密码\nOK\n127.0.0.1:6379> config get requirepass # 没有密码,所有命令没有权限\n(error) NOAUTH Authentication required.\n127.0.0.1:6379> ping \n(error) NOAUTH Authentication required.\n127.0.0.1:6379> auth 123456 # 使用密码认证登录\nOK\n127.0.0.1:6379> config get requirepass\n1) "requirepass"\n2) "123456"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 密码认证登录\n\n# 1. 方式不安全\n[root@VM-0-14-centos bin]# redis-cli -p 6379 -a 123456\nWarning: Using a password with \'-a\' or \'-u\' option on the command line interface may not be safe.\n127.0.0.1:6379> \n\n# 2. 安全\n[root@VM-0-14-centos bin]# redis-cli -p 6379\n127.0.0.1:6379> auth 123456 # 使用密码认证登录\nOK\n127.0.0.1:6379> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 8. 限制 CLIENTS\n\n#   设置"客户端最大并发连接数"，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件. 描述符数-32（redis server自身会使用一些），如果设置 maxclients为0. 表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\nmaxclients 10000\n\n# redis 配置最大的内存容量\n# 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key. 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区，格式：maxmemory <bytes>\nmaxmemory <bytes> \n\n# 内存到达上限之后的处理策略\n# 1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key 3、volatile-random：随机删除即将过期key 4、allkeys-random：随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误\nmaxmemory-policy noeviction\n\n#  LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)\n#  随意你可以选择样本大小进行检，redis默认选择3个样本进行检测，你可以通过maxmemory-samples进行设置样本数\nmaxmemory-samples 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 9. aof模式 APPEND ONLY MODE\n\nappendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下， rdb完全够用！ \n\nappendfilename "appendonly.aof" # 持久化的文件的名字 \n\n# appendfsync always # 每次修改都会 sync。消耗性能 \nappendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！\n# appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'# redis的配置文件详解\n\n> 进入 /usr/local/bin/redis-config 打开配置文件 redis.conf\n\n\n# 1. 单位\n\n# 1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024*1024 bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024*1024*1024 bytes\n#\n# units are case insensitive so 1gb 1gb 1gb are all the same.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n配置文件 unit单位 redis.conf对内存大小的大小写不敏感\n\n\n# 2. 包含 includes\n\n################################## includes ###################################\n\n# include one or more other config files here.  this is useful if you\n# have a standard template that goes to all redis servers but also need\n# to customize a few per-server settings.  include files can include\n# other files, so use this wisely.\n#\n# notice option "include" won\'t be rewritten by command "config rewrite"\n# from admin or redis sentinel. since redis always uses the last processed\n# line as value of a configuration directive, you\'d better put includes\n# at the beginning of this file to avoid overwriting config change at runtime.\n#\n# if instead you are interested in using includes to override configuration\n# options, it is better to use include as the last line.\n#\n# include /path/to/local.conf\n# include /path/to/other.conf\n\n################################## modules #####################################\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3. 网络 network\n\n# 绑定的ip地址\nbind 127.0.0.1\n\n# 保护模式，默认是开启状态，只允许本地客户端连接， 可以设置密码或添加bind来连接\nprotected-mode yes\n\n# 端口号，默认为6379，如果设为0，redis将不在socket 上监听任何客户端连接\nport 6379\n\n# tcp监听的最大容纳数量，在高并发的环境下，你需要把这个值调高以避免客户端连接缓慢的问题。linux 内核会把这个值缩小成 /proc/sys/net/core/somaxconn对应的值，要提升并发量需要修改这两个值才能达到目的\ntcp-backlog 511\n\n# 指定redis监听的unix socket路径，默认不启用，unixsocketper指定文件的权限\nunixsocket /tmp/redis.sock\nunixsocketperm 700\n\n# 指定在一个 client 空闲多少秒之后关闭连接（0表示永不关闭）\ntimeout 0\n\n# 单位是秒，表示将周期性的使用so_keepalive检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0，则不会周期性的检测\ntcp-keepalive 300\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4. 通用配置 general\n\n# 默认情况下 redis 不是作为守护进程运行(后台的方式运行)的 (默认是 no) ，如果你想让它在后台运行，你就把它改成 yes。当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面\ndaemonize yes \n\n# 可以通过upstart和systemd管理redis守护进程\n# 选项：\n#   supervised no - 没有监督互动\n#   supervised upstart - 通过将redis置于sigstop模式来启动信号\n#   supervised systemd - signal systemd将ready = 1写入$ notify_socket\n#   supervised auto - 检测upstart或systemd方法基于 upstart_job或notify_socket环境变量\nsupervised no \n\n# 配置pid文件路径，当redis作为守护进程运行的时候(后台的方式运行)，它会把 pid 默认写到 /var/redis/run/redis_6379.pid 文件里面\npidfile /var/run/redis_6379.pid\n\n# 定义日志级别。\n#  可以是下面的这些值：\n#  debug（记录大量日志信息，适用于开发、测试阶段）\n#  verbose（较多日志信息）\n#  notice（适量日志信息，使用于生产环境）\n#  warning（仅有部分重要、关键信息才会被记录）\nloglevel notice\n\n# 日志文件的位置，当指定为空字符串时，为标准输出，如果redis已守护进程模式运行，那么日志将会输出到/dev/null\nlogfile ""\n\n# 要想把日志记录到系统日志，就把它改成 yes，也可以可选择性的更新其他的syslog 参数以达到你的要求\nsyslog-enabled no\n\n# 设置系统日志的id\nsyslog-ident redis\n\n# 指定系统日志设置，必须是 user 或者是 local0-local7 之间的值\nsyslog-facility local0\n\n# 设置数据库的数目 (默认有16个数据库)。默认的数据库是db 0 ，可以在每个连接上使用select  <dbid> 命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。\ndatabases 16\n\n# 是否总是显示logo\nalways-show-logo yes \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 5. 快照 snapshotting\n\n持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof\n\nredis 是内存数据库，如果没有持久化，那么数据断电及失！\n\n# 存 db 到磁盘：\n#    格式：save <间隔时间（秒）> <写入次数>\n#    根据给定的时间间隔和写入次数将数据保存到磁盘\n\n#    注意：你可以注释掉所有的 save 行来停用保存功能。\n#    也可以直接一个空字符串来实现停用：save ""\n# 如果900s内，如果至少有一个1 key进行了修改，我们及时进行持久化操作 \nsave 900 1 \n# 如果300s内，如果至少10 key进行了修改，我们及时进行持久化操作 \nsave 300 10 \n# 如果60s内，如果至少10000 key进行了修改，我们及时进行持久化操作 \nsave 60 10000\n\n# 持久化如果出错，是否还需要继续工作！\n#  如果用户开启了rdb快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。\n#  这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。\n#  如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。\n#  如果下一次rdb持久化成功，redis会自动恢复接受写请求。\n#  如果不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，可以关闭这个功能，以便在快照写入失败时，也能确保redis继续接受新的写请求。\nstop-writes-on-bgsave-error yes \n\n#  对于存储到磁盘中的快照，可以设置是否进行压缩存储。\n#  如果是的话，redis会采用lzf算法进行压缩。如果你不想消耗cpu来进行压缩的话，\n#  可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。\nrdbcompression yes\n\n# 在存储快照后，我们还可以让redis使用crc64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。[保存rdb文件的时候，进行错误的检查校验！]\nrdbchecksum yes \n\n# 设置快照的文件名\ndbfilename dump.rdb\n\n# 设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名\ndir ./ \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 6. 主从复制 replication\n\n> 详见主从复制\n\n\n# 7. 安全 security\n\n\n# 设置密码\n\n * 方式一: 配置文件中设置\n\n# requirepass foobared\n# 设置redis密码\nrequirepass 123456\n\n\n1\n2\n3\n\n * 方式二: 命令行\n\n127.0.0.1:6379> config get requirepass # 获取redis密码\n1) "requirepass"\n2) ""\n127.0.0.1:6379> config set requirepass "123456" # 设置redis密码\nok\n127.0.0.1:6379> config get requirepass # 没有密码,所有命令没有权限\n(error) noauth authentication required.\n127.0.0.1:6379> ping \n(error) noauth authentication required.\n127.0.0.1:6379> auth 123456 # 使用密码认证登录\nok\n127.0.0.1:6379> config get requirepass\n1) "requirepass"\n2) "123456"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 密码认证登录\n\n# 1. 方式不安全\n[root@vm-0-14-centos bin]# redis-cli -p 6379 -a 123456\nwarning: using a password with \'-a\' or \'-u\' option on the command line interface may not be safe.\n127.0.0.1:6379> \n\n# 2. 安全\n[root@vm-0-14-centos bin]# redis-cli -p 6379\n127.0.0.1:6379> auth 123456 # 使用密码认证登录\nok\n127.0.0.1:6379> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 8. 限制 clients\n\n#   设置"客户端最大并发连接数"，默认无限制，redis可以同时打开的客户端连接数为redis进程可以打开的最大文件. 描述符数-32（redis server自身会使用一些），如果设置 maxclients为0. 表示不作限制。当客户端连接数到达限制时，redis会关闭新的连接并向客户端返回max number of clients reached错误信息\nmaxclients 10000\n\n# redis 配置最大的内存容量\n# 指定redis最大内存限制，redis在启动时会把数据加载到内存中，达到最大内存后，redis会先尝试清除已到期或即将到期的key. 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。redis新的vm机制，会把key存放内存，value会存放在swap区，格式：maxmemory <bytes>\nmaxmemory <bytes> \n\n# 内存到达上限之后的处理策略\n# 1、volatile-lru：只对设置了过期时间的key进行lru（默认值） 2、allkeys-lru ： 删除lru算法的key 3、volatile-random：随机删除即将过期key 4、allkeys-random：随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误\nmaxmemory-policy noeviction\n\n#  lru 和 minimal ttl 算法都不是精准的算法，但是相对精确的算法(为了节省内存)\n#  随意你可以选择样本大小进行检，redis默认选择3个样本进行检测，你可以通过maxmemory-samples进行设置样本数\nmaxmemory-samples 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 9. aof模式 append only mode\n\nappendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下， rdb完全够用！ \n\nappendfilename "appendonly.aof" # 持久化的文件的名字 \n\n# appendfsync always # 每次修改都会 sync。消耗性能 \nappendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！\n# appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"HTML",frontmatter:{title:"HTML",date:"2023-02-27T11:08:07.000Z",permalink:"/pages/3ae290/"},regularPath:"/05.%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/01.%E5%9F%BA%E7%A1%80%E5%A5%97%E9%A4%90/01.%E4%B8%89%E5%A4%A7%E4%BB%B6/01.HTML.html",relativePath:"05.前端应用框架/01.基础套餐/01.三大件/01.HTML.md",key:"v-1b4ef6fe",path:"/pages/3ae290/",headersStr:null,content:"HTML",normalizedContent:"html",charsets:{},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"ElasticSearch7.6.1快速入门",frontmatter:{title:"ElasticSearch7.6.1快速入门",date:"2023-02-27T11:51:02.000Z",permalink:"/pages/6641bc/"},regularPath:"/04.%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/05.%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/01.ElasticSearch/01.ElasticSearch7.6.1%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"04.后端应用框架/05.搜索引擎/01.ElasticSearch/01.ElasticSearch7.6.1快速入门.md",key:"v-c4256d48",path:"/pages/6641bc/",headers:[{level:2,title:"1. ElasticSearch概述",slug:"_1-elasticsearch概述",normalizedTitle:"1. elasticsearch概述",charIndex:159},{level:2,title:"2. ES安装",slug:"_2-es安装",normalizedTitle:"2. es安装",charIndex:367},{level:3,title:"2.1 下载",slug:"_2-1-下载",normalizedTitle:"2.1 下载",charIndex:491},{level:3,title:"2.2 安装",slug:"_2-2-安装",normalizedTitle:"2.2 安装",charIndex:516},{level:4,title:"2.2.1 解压即可",slug:"_2-2-1-解压即可",normalizedTitle:"2.2.1 解压即可",charIndex:526},{level:4,title:"2.2.2 目录结构",slug:"_2-2-2-目录结构",normalizedTitle:"2.2.2 目录结构",charIndex:540},{level:4,title:"2.2.3 启动",slug:"_2-2-3-启动",normalizedTitle:"2.2.3 启动",charIndex:766},{level:4,title:"2.2.4 访问",slug:"_2-2-4-访问",normalizedTitle:"2.2.4 访问",charIndex:882},{level:3,title:"2.3 安装可视化界面 es head的插件",slug:"_2-3-安装可视化界面-es-head的插件",normalizedTitle:"2.3 安装可视化界面 es head的插件",charIndex:924},{level:4,title:"2.3.1 下载地址",slug:"_2-3-1-下载地址",normalizedTitle:"2.3.1 下载地址",charIndex:950},{level:4,title:"2.3.2 启动",slug:"_2-3-2-启动",normalizedTitle:"2.3.2 启动",charIndex:986},{level:4,title:"2.3.3 连接测试",slug:"_2-3-3-连接测试",normalizedTitle:"2.3.3 连接测试",charIndex:1033},{level:4,title:"2.3.4 重启es服务器，然后再次连接",slug:"_2-3-4-重启es服务器-然后再次连接",normalizedTitle:"2.3.4 重启es服务器，然后再次连接",charIndex:1184},{level:3,title:"2.4 了解 ELK",slug:"_2-4-了解-elk",normalizedTitle:"2.4 了解 elk",charIndex:1255},{level:3,title:"2.5 Kibana",slug:"_2-5-kibana",normalizedTitle:"2.5 kibana",charIndex:1656},{level:4,title:"2.5.1 概述",slug:"_2-5-1-概述",normalizedTitle:"2.5.1 概述",charIndex:1670},{level:4,title:"2.5.2 下载",slug:"_2-5-2-下载",normalizedTitle:"2.5.2 下载",charIndex:1920},{level:4,title:"2.5.3 解压目录",slug:"_2-5-3-解压目录",normalizedTitle:"2.5.3 解压目录",charIndex:1956},{level:4,title:"2.5.4 启动",slug:"_2-5-4-启动",normalizedTitle:"2.5.4 启动",charIndex:1972},{level:4,title:"2.5.5 访问",slug:"_2-5-5-访问",normalizedTitle:"2.5.5 访问",charIndex:2009},{level:4,title:"2.5.6 测试工具",slug:"_2-5-6-测试工具",normalizedTitle:"2.5.6 测试工具",charIndex:2046},{level:4,title:"2.5.7 汉化",slug:"_2-5-7-汉化",normalizedTitle:"2.5.7 汉化",charIndex:2099},{level:2,title:"3. ES核心概念",slug:"_3-es核心概念",normalizedTitle:"3. es核心概念",charIndex:2791},{level:3,title:"3.1 关系行数据库 和 elasticsearch",slug:"_3-1-关系行数据库-和-elasticsearch",normalizedTitle:"3.1 关系行数据库 和 elasticsearch",charIndex:2912},{level:3,title:"3.2 逻辑设计",slug:"_3-2-逻辑设计",normalizedTitle:"3.2 逻辑设计",charIndex:3217},{level:3,title:"3.3 逻辑设计",slug:"_3-3-逻辑设计",normalizedTitle:"3.3 逻辑设计",charIndex:3332},{level:4,title:"3.3.1 文档",slug:"_3-3-1-文档",normalizedTitle:"3.3.1 文档",charIndex:3460},{level:4,title:"3.3.2 类型",slug:"_3-3-2-类型",normalizedTitle:"3.3.2 类型",charIndex:3984},{level:4,title:"3.3.3 索引",slug:"_3-3-3-索引",normalizedTitle:"3.3.3 索引",charIndex:4301},{level:2,title:"4. IK分词器",slug:"_4-ik分词器",normalizedTitle:"4. ik分词器",charIndex:4401},{level:3,title:"4.1 下载",slug:"_4-1-下载",normalizedTitle:"4.1 下载",charIndex:4604},{level:3,title:"4.2 安装",slug:"_4-2-安装",normalizedTitle:"4.2 安装",charIndex:4619},{level:3,title:"4.2 重启,访问",slug:"_4-2-重启-访问",normalizedTitle:"4.2 重启,访问",charIndex:4662},{level:3,title:"4.3 Kibana测试",slug:"_4-3-kibana测试",normalizedTitle:"4.3 kibana测试",charIndex:4727},{level:4,title:"4.3.1 ik_smart分词",slug:"_4-3-1-ik-smart分词",normalizedTitle:"4.3.1 ik_smart分词",charIndex:4743},{level:4,title:"4.3.2 ikmaxword分词",slug:"_4-3-2-ik-max-word分词",normalizedTitle:"4.3.2 ikmaxword分词",charIndex:null},{level:3,title:"4.4 自定义分词器的字典",slug:"_4-4-自定义分词器的字典",normalizedTitle:"4.4 自定义分词器的字典",charIndex:6332},{level:4,title:"问题:",slug:"问题",normalizedTitle:"问题:",charIndex:6351},{level:4,title:"解决",slug:"解决",normalizedTitle:"解决",charIndex:6383},{level:4,title:"重启",slug:"重启",normalizedTitle:"重启",charIndex:1190},{level:4,title:"Kibana结果",slug:"kibana结果",normalizedTitle:"kibana结果",charIndex:6479},{level:2,title:"5. Rest风格说明",slug:"_5-rest风格说明",normalizedTitle:"5. rest风格说明",charIndex:6534},{level:2,title:"6. 索引的基本操作",slug:"_6-索引的基本操作",normalizedTitle:"6. 索引的基本操作",charIndex:7037},{level:3,title:"6.1 类型",slug:"_6-1-类型",normalizedTitle:"6.1 类型",charIndex:7052},{level:3,title:"6.2 创建一个索引",slug:"_6-2-创建一个索引",normalizedTitle:"6.2 创建一个索引",charIndex:7261},{level:4,title:"6.2.1 无字段类型",slug:"_6-2-1-无字段类型",normalizedTitle:"6.2.1 无字段类型",charIndex:7275},{level:4,title:"6.3.2 设置字段类型",slug:"_6-3-2-设置字段类型",normalizedTitle:"6.3.2 设置字段类型",charIndex:7359},{level:3,title:"6.3 获取索引信息",slug:"_6-3-获取索引信息",normalizedTitle:"6.3 获取索引信息",charIndex:7378},{level:3,title:"6.4  查看默认的信息(另一种创建索引的方式)",slug:"_6-4-查看默认的信息-另一种创建索引的方式",normalizedTitle:"6.4  查看默认的信息(另一种创建索引的方式)",charIndex:null},{level:4,title:"获取信息",slug:"获取信息",normalizedTitle:"获取信息",charIndex:7460},{level:3,title:"6.5 修改索引",slug:"_6-5-修改索引",normalizedTitle:"6.5 修改索引",charIndex:7516},{level:4,title:"6.5.1 旧的方式 \tPUT",slug:"_6-5-1-旧的方式-put",normalizedTitle:"6.5.1 旧的方式 \tput",charIndex:null},{level:4,title:"6.5.2 新的方式 POST",slug:"_6-5-2-新的方式-post",normalizedTitle:"6.5.2 新的方式 post",charIndex:7565},{level:3,title:"6.6 删除索引 DELETE",slug:"_6-6-删除索引-delete",normalizedTitle:"6.6 删除索引 delete",charIndex:7587},{level:3,title:"6.7 扩展",slug:"_6-7-扩展",normalizedTitle:"6.7 扩展",charIndex:7609},{level:2,title:"7. 文档的基本操作",slug:"_7-文档的基本操作",normalizedTitle:"7. 文档的基本操作",charIndex:8797},{level:2,title:"8. 集成SringBoot",slug:"_8-集成sringboot",normalizedTitle:"8. 集成sringboot",charIndex:8812},{level:3,title:"1. 官方文档",slug:"_1-官方文档",normalizedTitle:"1. 官方文档",charIndex:8852},{level:3,title:"2. 创建SpringBoot项目",slug:"_2-创建springboot项目",normalizedTitle:"2. 创建springboot项目",charIndex:9103},{level:4,title:"2.1 依赖",slug:"_2-1-依赖",normalizedTitle:"2.1 依赖",charIndex:9124},{level:4,title:"2.2. 问题",slug:"_2-2-问题",normalizedTitle:"2.2. 问题",charIndex:9312},{level:5,title:"解决",slug:"解决-2",normalizedTitle:"解决",charIndex:6383},{level:4,title:"2.3 提供的对象",slug:"_2-3-提供的对象",normalizedTitle:"2.3 提供的对象",charIndex:9521},{level:5,title:"spring data下的默认对象",slug:"spring-data下的默认对象",normalizedTitle:"spring data下的默认对象",charIndex:9534},{level:5,title:"rest 对象",slug:"rest-对象",normalizedTitle:"rest 对象",charIndex:9557},{level:3,title:"3 API使用",slug:"_3-api使用",normalizedTitle:"3 api使用",charIndex:12683},{level:4,title:"3.1 创建索引",slug:"_3-1-创建索引",normalizedTitle:"3.1 创建索引",charIndex:12723},{level:4,title:"3.2 获取索引",slug:"_3-2-获取索引",normalizedTitle:"3.2 获取索引",charIndex:13368},{level:4,title:"3.3 删除索引",slug:"_3-3-删除索引",normalizedTitle:"3.3 删除索引",charIndex:13736},{level:4,title:"3.4 创建文档",slug:"_3-4-创建文档",normalizedTitle:"3.4 创建文档",charIndex:14109},{level:4,title:"3.5 获取文档",slug:"_3-5-获取文档",normalizedTitle:"3.5 获取文档",charIndex:15019},{level:4,title:"3.6 修改文档",slug:"_3-6-修改文档",normalizedTitle:"3.6 修改文档",charIndex:15901},{level:4,title:"3.7 删除文档",slug:"_3-7-删除文档",normalizedTitle:"3.7 删除文档",charIndex:16494},{level:4,title:"3.8  批量添加",slug:"_3-8-批量添加",normalizedTitle:"3.8  批量添加",charIndex:null},{level:4,title:"3.9 查询",slug:"_3-9-查询",normalizedTitle:"3.9 查询",charIndex:18058},{level:2,title:"9. 爬虫",slug:"_9-爬虫",normalizedTitle:"9. 爬虫",charIndex:19298}],headersStr:"1. ElasticSearch概述 2. ES安装 2.1 下载 2.2 安装 2.2.1 解压即可 2.2.2 目录结构 2.2.3 启动 2.2.4 访问 2.3 安装可视化界面 es head的插件 2.3.1 下载地址 2.3.2 启动 2.3.3 连接测试 2.3.4 重启es服务器，然后再次连接 2.4 了解 ELK 2.5 Kibana 2.5.1 概述 2.5.2 下载 2.5.3 解压目录 2.5.4 启动 2.5.5 访问 2.5.6 测试工具 2.5.7 汉化 3. ES核心概念 3.1 关系行数据库 和 elasticsearch 3.2 逻辑设计 3.3 逻辑设计 3.3.1 文档 3.3.2 类型 3.3.3 索引 4. IK分词器 4.1 下载 4.2 安装 4.2 重启,访问 4.3 Kibana测试 4.3.1 ik_smart分词 4.3.2 ikmaxword分词 4.4 自定义分词器的字典 问题: 解决 重启 Kibana结果 5. Rest风格说明 6. 索引的基本操作 6.1 类型 6.2 创建一个索引 6.2.1 无字段类型 6.3.2 设置字段类型 6.3 获取索引信息 6.4  查看默认的信息(另一种创建索引的方式) 获取信息 6.5 修改索引 6.5.1 旧的方式 \tPUT 6.5.2 新的方式 POST 6.6 删除索引 DELETE 6.7 扩展 7. 文档的基本操作 8. 集成SringBoot 1. 官方文档 2. 创建SpringBoot项目 2.1 依赖 2.2. 问题 解决 2.3 提供的对象 spring data下的默认对象 rest 对象 3 API使用 3.1 创建索引 3.2 获取索引 3.3 删除索引 3.4 创建文档 3.5 获取文档 3.6 修改文档 3.7 删除文档 3.8  批量添加 3.9 查询 9. 爬虫",content:'# ElasticSearch7.6.1快速入门\n\n> 本次ElasticSearch版本 ElasticSearch7.6.1,Java版本 Java8\n> \n> 环境资源 :\n> \n> 链接：https://pan.baidu.com/s/1zJHCPe2vB0KguE_DhknhMA 提取码：h7n4\n\n\n# 1. ElasticSearch概述\n\nElaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别（大数据时代）的数据。es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。\n\n\n# 2. ES安装\n\n> 声明：JDK1.8 ，最低要求！ ElasticSearch 客户端，界面工具！\n> \n> Java开发，ElasticSearch 的版本和我们之后对应的 Java 的核心jar包！ 版本对应！JDK 环境是正常！\n\n\n# 2.1 下载\n\n官网\n\n\n\n下载地址\n\n\n\n\n# 2.2 安装\n\n# 2.2.1 解压即可\n\n# 2.2.2 目录结构\n\n\n\n> 功能\n\nbin 启动文件 \nconfig 配置文件 \n\tlog4j2 日志配置文件 \n\tjvm.options java 虚拟机相关的配置  配置ES内存参数 \n\telasticsearch.yml elasticsearch 的配置文件！ 默认 9200 端口！ 跨域！ \nlib 相关jar包 \nlogs 日志！ \nmodules 功能模块 \nplugins 插件！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 2.2.3 启动\n\n双击 bin 目录下的 elasticsearch.bat 启动ES\n\n\n\n> 使用Java版本,需要Java11,这里使用Java8.\n\n\n\n> 默认端口号: 9200\n> \n> 通信端口号: 9300\n\n# 2.2.4 访问\n\n地址 http://localhost:9200/\n\n\n\n\n# 2.3 安装可视化界面 es head的插件\n\n# 2.3.1 下载地址\n\n此项目需要环境 node.js ,npm\n\n# 2.3.2 启动\n\nnpm install \nnpm run start\n\n\n1\n2\n\n\n# 2.3.3 连接测试\n\n访问 http://localhost:9100/\n\n\n\n存在跨域问题：\n\n * 配置es, 修改 elasticsearch.yaml 添加如下:\n\nhttp.cors.enabled: true \nhttp.cors.allow-origin: "*"\n\n\n1\n2\n\n\n# 2.3.4 重启es服务器，然后再次连接\n\n\n\n> 这个head我们就把它当做数据展示工具！我们后面所有的查询，使用Kibana ！\n\n\n# 2.4 了解 ELK\n\nELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。市面上也被成为Elastic Stack。\n\n * Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es。\n\n * Logstash是ELK的中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/MQ/redis/elasticsearch/kafka等）。Kibana可以将elasticsearch的数据通过友好的页面展示出来，提供实时分析的功能。\n\n\n# 2.5 Kibana\n\n# 2.5.1 概述\n\nKibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。\n\n# 2.5.2 下载\n\n\n\n> Kibana 版本要和 Es 一致！\n\n# 2.5.3 解压目录\n\n\n\n# 2.5.4 启动\n\n双击 bin 目录下 kibana.bat\n\n\n\n# 2.5.5 访问\n\nhttp://localhost:5601\n\n\n\n# 2.5.6 测试工具\n\n\n\n> 开发工具！ （Post、curl、head、谷歌浏览器插件测试！）\n\n# 2.5.7 汉化\n\n * 在 x-pack\\plugins\\translations\\translations\\zh-CN.json 已有中文设置\n\n{\n    "messages": {\n    "common.ui.aggResponse.allDocsTitle": "所有文档",\n    "common.ui.aggResponse.fieldLabel": "字段",\n    "common.ui.aggResponse.valueLabel": "值",\n "xpack.watcher.watchEdit.thresholdWatchExpression.aggType.fieldIsRequiredValidationMessage": "此字段必填。",\n    "xpack.watcher.watcherDescription": "通过创建、管理和监测警报来检测数据中的更改。"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 修改 config\\kibana.yml\n\n# Specifies locale to be used for all localizable strings, dates and number formats.\n# Supported languages are the following: English - en , by default , Chinese - zh-CN .\n#i18n.locale: "en"\ni18n.locale: "zh-CN"\n\n\n1\n2\n3\n4\n\n * 访问\n\n\n\n\n# 3. ES核心概念\n\n 1. 索引\n\n 2. 字段类型（mapping）\n\n 3. 文档（documents）\n\n> elasticsearch是面向文档，关系行数据库 和 elasticsearch 客观的对比！一切都是JSON！\n\n\n# 3.1 关系行数据库 和 elasticsearch\n\nRELATIONAL DB [MYSQL]   ELASTICSEARCH\n数据库(database)           索引(indices)\n表(tables)               类型(types) [会被弃用]\n行(rows)                 文档（documents）\n字段(columns)             域(fields)\n\n> elasticsearch(集群)中可以包含多个索引(数据库)，每个索引中可以包含多个类型(表)，每个类型下又包含多 个文档(行)，每个文档中又包含多个字段(列)。\n\n\n# 3.2 逻辑设计\n\nelasticsearch 在后台把每个索引划分成多个分片，每分分片可以在集群中的不同服务器间迁移\n\n * 一个elasticsearch 就是一个集群！默认的集群名称就是 elaticsearh\n\n\n\n\n# 3.3 逻辑设计\n\n一个索引类型中，包含多个文档，比如说文档1，文档2。 当我们索引一篇文档时，可以通过这样的一各顺序找到 它: 索引 ▷ 类型 ▷ 文档ID ，通过这个组合我们就能索引到某个具体的文档。 注意:ID不必是整数，实际上它是个字符串。\n\n# 3.3.1 文档\n\n> 就是一条数据\n\n就是我们的一条条数据\n\nuser \n\n1 zhangsan 18 \n\n2 kuangshen 3\n\n\n1\n2\n3\n4\n5\n\n\n之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是 "文档"，elasticsearch中，文档有几个 重要属性 :\n\n * 自我包含，一篇文档同时包含字段和对应的值，也就是同时包含 key:value！\n\n * 可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的！ {就是一个json对象！fastjson进行自动转换！}\n\n * 灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。\n\n尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符 串也可以是整形。因elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。\n\n# 3.3.2 类型\n\n\n\n类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射，比如 name 映 射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整形。 但是elasticsearch也可能猜不对， 所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。\n\n# 3.3.3 索引\n\n> 就是数据库！\n\n索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。\n\n\n# 4. IK分词器\n\n分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词\n\n> 使用中文，建议使用ik分词器！\n> \n> IK提供了两个分词算法：ik_smart 和 ik_max_word，其中 ik_smart 为最少切分，ik_max_word为最细粒度划分！\n\n\n# 4.1 下载\n\n网址\n\n\n# 4.2 安装\n\n解压,放在 ES 中的 plugins 的 ik 目录下\n\n\n\n\n# 4.2 重启,访问\n\n * 加载插件\n\n\n\n * 查看es的插件 elasticsearch-plugin list\n\n\n\n\n# 4.3 Kibana测试\n\n# 4.3.1 ik_smart分词\n\nik_smart 为最少切分\n\n\n\n# 4.3.2 ik_max_word分词\n\nik_max_word为最细粒度划分！\n\nGET _analyze\n{\n  "analyzer": "ik_max_word",\n  "text": "中华人民共和国"\n}\n\n\n1\n2\n3\n4\n5\n\n * 结果\n\n{\n  "tokens" : [\n    {\n      "token" : "中华人民共和国",\n      "start_offset" : 0,\n      "end_offset" : 7,\n      "type" : "CN_WORD",\n      "position" : 0\n    },\n    {\n      "token" : "中华人民",\n      "start_offset" : 0,\n      "end_offset" : 4,\n      "type" : "CN_WORD",\n      "position" : 1\n    },\n    {\n      "token" : "中华",\n      "start_offset" : 0,\n      "end_offset" : 2,\n      "type" : "CN_WORD",\n      "position" : 2\n    },\n    {\n      "token" : "华人",\n      "start_offset" : 1,\n      "end_offset" : 3,\n      "type" : "CN_WORD",\n      "position" : 3\n    },\n    {\n      "token" : "人民共和国",\n      "start_offset" : 2,\n      "end_offset" : 7,\n      "type" : "CN_WORD",\n      "position" : 4\n    },\n    {\n      "token" : "人民",\n      "start_offset" : 2,\n      "end_offset" : 4,\n      "type" : "CN_WORD",\n      "position" : 5\n    },\n    {\n      "token" : "共和国",\n      "start_offset" : 4,\n      "end_offset" : 7,\n      "type" : "CN_WORD",\n      "position" : 6\n    },\n    {\n      "token" : "共和",\n      "start_offset" : 4,\n      "end_offset" : 6,\n      "type" : "CN_WORD",\n      "position" : 7\n    },\n    {\n      "token" : "国",\n      "start_offset" : 6,\n      "end_offset" : 7,\n      "type" : "CN_CHAR",\n      "position" : 8\n    }\n  ]\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 4.4 自定义分词器的字典\n\n\n\n# 问题:\n\n当输入我是晨光向时没有我们想要的晨光向这个分词\n\n# 解决\n\n> ik 分词器增加自己的 !\n\n在 elasticsearch-7.6.1\\plugins\\ik\\config 下配置\n\n\n\nmy.dic\n\n晨光向\n\n\n1\n\n\n# 重启\n\n\n\n# Kibana结果\n\n\n\n> 以后的话，我们需要自己配置 分词就在自己定义的dic文件中进行配置即可！\n\n\n# 5. Rest风格说明\n\n一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n\nMETHOD   URL地址                                   描述\nPUT      localhost:9200/索引名称/类型名称/文档id           创建文档（指定文档id）\nPOST     localhost:9200/索引名称/类型名称                创建文档（随机文档id）\nPOST     localhost:9200/索引名称/类型名称/文档id/_update   修改文档\nDELETE   localhost:9200/索引名称/类型名称/文档id           删除文档\nGET      localhost:9200/索引名称/类型名称/文档id           查询文档通过文档id\nPOST     localhost:9200/索引名称/类型名称/_search        查询所有数据\n\n\n# 6. 索引的基本操作\n\n\n# 6.1 类型\n\n * 字符串类型\n   \n   text , keyword\n\n * 数值类型\n   \n   long, integer, short, byte, double, flfloat, half_flfloat, scaled_flfloat\n\n * 日期类型\n   \n   date\n\n * 布尔值类型\n   \n   boolean\n\n * 二进制\n   \n   binary\n\n * ...\n\n\n# 6.2 创建一个索引\n\n# 6.2.1 无字段类型\n\nPUT /索引名/类型名/文档id \n{\n    请求体\n}\n\n\n1\n2\n3\n4\n\n\n\n\nhead\n\n\n\n> es可以作为数据库操作.\n\n# 6.3.2 设置字段类型\n\n\n\n\n# 6.3 获取索引信息\n\n可以通过 GET 请求获取具体的信息！\n\n\n\n\n# 6.4 查看默认的信息(另一种创建索引的方式)\n\n * 创建索引 test3\n\n\n\n# 获取信息\n\n\n\n> 如果自己的文档字段没有指定，那么es 就会给我们默认配置字段类型！推荐这种方式,.\n\n\n# 6.5 修改索引\n\n修改,提交试用PUT方式覆盖,\n\n# 6.5.1 旧的方式 PUT\n\n\n\n# 6.5.2 新的方式 POST\n\n\n\n\n# 6.6 删除索引 DELETE\n\n\n\n\n# 6.7 扩展\n\n通过 GET _cat/可以获取es的当前的很多信息\n\n# 状态\nGET _cat/health\n# 版本信息\nGET _cat/indices\n\n\n1\n2\n3\n4\n\n\n上边文档\n\n# ik_smart\nGET _analyze\n{\n  "analyzer": "ik_smart",\n  "text": "中华人民共和国"\n}\n\n# ik_max_word\nGET _analyze\n{\n  "analyzer": "ik_max_word",\n  "text": "我是晨光向"\n}\n\n# 创建索引\nPUT /test1/type1/1\n{\n  "name": "晨光向",\n  "age": "14"\n}\n\n# 指定字段的类型\nPUT /test2\n{\n  "mappings": {\n    "properties": {\n      "name": {\n        "type": "text"\n      },\n      "age": {\n        "type": "long"\n      },\n      "birthday": {\n        "type": "date"\n      }\n    }\n  }\n}\n\n# 获取test2的信息\nGET test2\n\n# 创建索引 \n# es7 启用 type类型 \n# 这里使用 _doc \nPUT /test3/_doc/1\n{\n  "name": "晨光向",\n  "age": "14",\n  "birthday": "1996-01-09"\n}\n\n# 获取teset3信息\nGET test3\n\n# 扩展\n# 状态\nGET _cat/health\n# 版本信息\nGET _cat/indices\n\n\n# 之前: 修改test3\nPUT /test3/_doc/1\n{\n  "name": "晨光向123",\n  "age": "14",\n  "birthday": "1996-01-09"\n}\n\n# 现在: 修改test3\nPOST /test3/_doc/1/_update\n{\n  "doc":{\n    "name": "我是谁"\n  }\n}\n\n# 删除索引\nDELETE test1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n\n# 7. 文档的基本操作\n\n\n# 8. 集成SringBoot\n\n> SpringBoot版本2.2.5\n\n\n# 1. 官方文档\n\n * 第一步\n\n\n\n * 第二步\n\n\n\n * 第三步\n\n\n\n * 第四部: 原生依赖\n\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-client</artifactId>\n    <version>7.6.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n> 配合版本\n\n * 第五步: 对象\n\n\n\n\n# 2. 创建SpringBoot项目\n\n# 2.1 依赖\n\n\x3c!--elasticsearch依赖--\x3e\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-data-elasticsearch</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 2.2. 问题\n\nelasticsearch版本问题: 版本与es不一致\n\n\n\n# 解决\n\n<properties>\n   \x3c!--自定义elasticsearch版本 7.6.1 --\x3e\n   <elasticsearch.version>7.6.1</elasticsearch.version>\n</properties>\n\n\n1\n2\n3\n4\n\n\n\n\n> 注意: 导入依赖版本一定要与安装的es版本一致.\n\n# 2.3 提供的对象\n\n# spring data下的默认对象\n\n\n\n# rest 对象\n\n\n\n核心配置\n\n/**\n * Elasticsearch rest client infrastructure configurations.\n *\n * @author Brian Clozel\n * @author Stephane Nicoll\n */\nclass RestClientConfigurations {\n\n   @Configuration(proxyBeanMethods = false)\n   static class RestClientBuilderConfiguration {\n\n      @Bean\n      @ConditionalOnMissingBean\n      RestClientBuilder elasticsearchRestClientBuilder(RestClientProperties properties,\n            ObjectProvider<RestClientBuilderCustomizer> builderCustomizers) {\n         HttpHost[] hosts = properties.getUris().stream().map(HttpHost::create).toArray(HttpHost[]::new);\n         RestClientBuilder builder = RestClient.builder(hosts);\n         PropertyMapper map = PropertyMapper.get();\n         map.from(properties::getUsername).whenHasText().to((username) -> {\n            CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n            Credentials credentials = new UsernamePasswordCredentials(properties.getUsername(),\n                  properties.getPassword());\n            credentialsProvider.setCredentials(AuthScope.ANY, credentials);\n            builder.setHttpClientConfigCallback(\n                  (httpClientBuilder) -> httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider));\n         });\n         builder.setRequestConfigCallback((requestConfigBuilder) -> {\n            map.from(properties::getConnectionTimeout).whenNonNull().asInt(Duration::toMillis)\n                  .to(requestConfigBuilder::setConnectTimeout);\n            map.from(properties::getReadTimeout).whenNonNull().asInt(Duration::toMillis)\n                  .to(requestConfigBuilder::setSocketTimeout);\n            return requestConfigBuilder;\n         });\n         builderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));\n         return builder;\n      }\n\n   }\n\n   @Configuration(proxyBeanMethods = false)\n   @ConditionalOnClass(RestHighLevelClient.class)\n   static class RestHighLevelClientConfiguration {\n\t// RestHighLevelClient 高级客户端，也是项目会用到的客户端\n      @Bean\n      @ConditionalOnMissingBean\n      RestHighLevelClient elasticsearchRestHighLevelClient(RestClientBuilder restClientBuilder) {\n         return new RestHighLevelClient(restClientBuilder);\n      }\n\n      @Bean\n      @ConditionalOnMissingBean\n      RestClient elasticsearchRestClient(RestClientBuilder builder,\n            ObjectProvider<RestHighLevelClient> restHighLevelClient) {\n         RestHighLevelClient client = restHighLevelClient.getIfUnique();\n         if (client != null) {\n            return client.getLowLevelClient();\n         }\n         return builder.build();\n      }\n\n   }\n\n   @Configuration(proxyBeanMethods = false)\n   static class RestClientFallbackConfiguration {\n\t// RestHighLevelClient 普通客户端\n      @Bean\n      @ConditionalOnMissingBean\n      RestClient elasticsearchRestClient(RestClientBuilder builder) {\n         return builder.build();\n      }\n\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 3 API使用\n\n * 这里使用 rest对象 内容以 JSON格式展示\n\n# 3.1 创建索引\n\nclass ElasticsearchApiApplicationTests {\n\n   /**\n    * @Autowired: 根据类型匹配\n    */\n   @Autowired\n   @Qualifier("restHighLevelClient")\n   private RestHighLevelClient client;\n\n   /** \n    * 创建索引 Request CreateIndexRequest\n    */\n   @Test\n   void contextLoads() throws IOException {\n      // 1. 创建索引请求\n      CreateIndexRequest request = new CreateIndexRequest("chggx_index");\n      // 2. 客户端执行请求\n      CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT);\n      // 3. 打印响应\n      System.out.println(createIndexResponse);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 3.2 获取索引\n\n/**\n * 获取索引 判断是否存在 GET GetIndexRequest\n */\n@Test\nvoid testExistIndex() throws IOException {\n    // 1. 获取索引请求\n    GetIndexRequest request = new GetIndexRequest("chggx_index");\n    // 2. 判断是否存在\n    boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);\n    // 3. 打印结果 true\n    System.out.println(exists);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 3.3 删除索引\n\n/**\n * 删除索引 DELETE DeleteIndexRequest\n */\n@Test\nvoid testDeleteIndex() throws IOException {\n    // 1. 获取删除请求\n    DeleteIndexRequest request = new DeleteIndexRequest("test2");\n    // 2. 删除索引\n    AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT);\n    System.out.println(delete.isAcknowledged());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 3.4 创建文档\n\n/**\n * 添加文档 IndexRequest\n */\n@Test\nvoid testAddDocument() throws IOException {\n    // 1. 创建对象\n    User user = new User("chggx", 12);\n    // 2. 创建请求\n    IndexRequest request = new IndexRequest("chggx_index");\n    // 3. 规则 /put/chggx_index/_doc/1\n    request.id("1");\n    // 超时 request.timeout("1s");\n    request.timeout(TimeValue.timeValueSeconds(1));\n    // 4. 将数据放入请求 JSON\n    request.source(JSON.toJSONString(user), XContentType.JSON);\n    // 5. 客户端发送请求,获取响应结果\n    IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT);\n\n    // IndexResponse[index=chggx_index,type=_doc,id=1,version=1,result=created,seqNo=0,primaryTerm=1,shards={"total":2,"successful":1,"failed":0}]\n    System.out.println(indexResponse.toString());\n    // CREATED 第一次创建: CREATED 以后更新 UPDATE\n    System.out.println(indexResponse.status());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 3.5 获取文档\n\n 1. 判断是否存在\n\n/**\n * 获取文档, 判断是否存在 GetRequest\n */\n@Test\nvoid testIsExists() throws IOException {\n    // 1. 创建获取请求\n    GetRequest getRequest = new GetRequest("chggx_index", "1");\n    // 2. 不获取返回的 _source 的上下文了\n    getRequest.fetchSourceContext(new FetchSourceContext(false));\n    // 3. 排序\n    getRequest.storedFields("_none_");\n\n    boolean exists = client.exists(getRequest, RequestOptions.DEFAULT);\n    System.out.println(exists);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 2. 获取文档信息\n\n/**\n * 获取文档信息 GetRequest\n */\n@Test\nvoid testGetDocument() throws IOException {\n    // 1. 创建获取请求\n    GetRequest getRequest = new GetRequest("chggx_index", "1");\n    // 2. 获取文档信息\n    GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);\n    // 3. 打印文档内容 {"age":12,"name":"chggx"}\n    System.out.println(getResponse.getSourceAsString());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 3.6 修改文档\n\n/**\n * 更新文档信息 UpdateRequest\n */\n@Test\nvoid testUpdateDocument() throws IOException {\n    // 1. 创建获取请求\n    UpdateRequest updateRequest = new UpdateRequest("chggx_index", "1");\n    // 2. 更新内容表\n    updateRequest.timeout("1s");\n    User user = new User("My CHGGX", 18);\n    // 转换为 Json 数据\n    updateRequest.doc(JSON.toJSONString(user), XContentType.JSON);\n    // 3. 获取文档信息 OK\n    UpdateResponse updateResponse = client.update(updateRequest, RequestOptions.DEFAULT);\n    // 4. 打印更新文档内容 OK\n    System.out.println(updateResponse.status());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 3.7 删除文档\n\n/**\n * 删除文档信息\n */\n@Test\nvoid testDeleteDocument() throws IOException {\n    // 1. 创建获取请求\n    DeleteRequest deleteRequest = new DeleteRequest("test3", "1");\n    // 2 删除文档信息\n    DeleteResponse deleteResponse = client.delete(deleteRequest, RequestOptions.DEFAULT);\n    // 3. 打印文档内容 OK\n    System.out.println(deleteResponse.status());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 3.8 批量添加\n\n/**\n     * 特殊的,批量插入数据 BulkRequest\n     */\n    @Test\n    void testBulkRequest() throws IOException {\n        // 1. 创建获取请求\n        BulkRequest bulkRequest = new BulkRequest();\n        // 2. 设置数据\n        bulkRequest.timeout("10s");\n        ArrayList<User> userList = new ArrayList<>();\n        userList.add(new User("Java 1", 5));\n        userList.add(new User("Java 2", 5));\n        userList.add(new User("Java 3", 5));\n        userList.add(new User("Java 4", 5));\n        userList.add(new User("Java 5", 5));\n        for (int i = 0; i < userList.size(); i++) {\n            // 批量添加\n            bulkRequest.add(\n                    new IndexRequest("chggx_bulk")\n                            .id("" + (i + 1))\n                            .source(JSON.toJSONString(userList.get(i)), XContentType.JSON)\n            );\n        }\n        // 3. 批量添加\n        BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT);\n        // 4. 打印文档内容 OK\n        System.out.println(bulkResponse.status());\n        // 是否失败 false: 代表成功\n        System.out.println(bulkResponse.hasFailures());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 3.9 查询\n\n    /**\n     * 查询 SearchRequest\n     */\n    @Test\n    void testSearch() throws IOException {\n        // 1. 创建获取请求\n        SearchRequest searchRequest = new SearchRequest("chggx_bulk");\n        // 2. 构建搜索条件\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\n        // QueryBuilders: 查询条件\n        // termQuery: 精确查询\n        // matchAllQuery: 匹配所有\n        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery("age", 5);\n//        MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery();\n        sourceBuilder.query(termQueryBuilder);\n        // 查询超时时间\n        sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS));\n        searchRequest.source(sourceBuilder);\n        // 3. 搜索信息\n        SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);\n        // 4. 打印文档内容 OK\n        System.out.println(JSON.toJSONString(searchResponse.getHits()));\n        System.out.println("============================================");\n        for (SearchHit documentFields : searchResponse.getHits().getHits()) {\n            System.out.println(documentFields.getSourceAsMap());\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 9. 爬虫',normalizedContent:'# elasticsearch7.6.1快速入门\n\n> 本次elasticsearch版本 elasticsearch7.6.1,java版本 java8\n> \n> 环境资源 :\n> \n> 链接：https://pan.baidu.com/s/1zjhcpe2vb0kgue_dhknhma 提取码：h7n4\n\n\n# 1. elasticsearch概述\n\nelaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理pb级别（大数据时代）的数据。es也使用java开发并使用lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的restful api来隐藏lucene的复杂性，从而让全文搜索变得简单。\n\n\n# 2. es安装\n\n> 声明：jdk1.8 ，最低要求！ elasticsearch 客户端，界面工具！\n> \n> java开发，elasticsearch 的版本和我们之后对应的 java 的核心jar包！ 版本对应！jdk 环境是正常！\n\n\n# 2.1 下载\n\n官网\n\n\n\n下载地址\n\n\n\n\n# 2.2 安装\n\n# 2.2.1 解压即可\n\n# 2.2.2 目录结构\n\n\n\n> 功能\n\nbin 启动文件 \nconfig 配置文件 \n\tlog4j2 日志配置文件 \n\tjvm.options java 虚拟机相关的配置  配置es内存参数 \n\telasticsearch.yml elasticsearch 的配置文件！ 默认 9200 端口！ 跨域！ \nlib 相关jar包 \nlogs 日志！ \nmodules 功能模块 \nplugins 插件！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 2.2.3 启动\n\n双击 bin 目录下的 elasticsearch.bat 启动es\n\n\n\n> 使用java版本,需要java11,这里使用java8.\n\n\n\n> 默认端口号: 9200\n> \n> 通信端口号: 9300\n\n# 2.2.4 访问\n\n地址 http://localhost:9200/\n\n\n\n\n# 2.3 安装可视化界面 es head的插件\n\n# 2.3.1 下载地址\n\n此项目需要环境 node.js ,npm\n\n# 2.3.2 启动\n\nnpm install \nnpm run start\n\n\n1\n2\n\n\n# 2.3.3 连接测试\n\n访问 http://localhost:9100/\n\n\n\n存在跨域问题：\n\n * 配置es, 修改 elasticsearch.yaml 添加如下:\n\nhttp.cors.enabled: true \nhttp.cors.allow-origin: "*"\n\n\n1\n2\n\n\n# 2.3.4 重启es服务器，然后再次连接\n\n\n\n> 这个head我们就把它当做数据展示工具！我们后面所有的查询，使用kibana ！\n\n\n# 2.4 了解 elk\n\nelk是elasticsearch、logstash、kibana三大开源框架首字母大写简称。市面上也被成为elastic stack。\n\n * elasticsearch是一个基于lucene、分布式、通过restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用elasticsearch作为底层支持框架，可见elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称elasticsearch为es。\n\n * logstash是elk的中央数据流引擎，用于从不同目标（文件/数据存储/mq）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/mq/redis/elasticsearch/kafka等）。kibana可以将elasticsearch的数据通过友好的页面展示出来，提供实时分析的功能。\n\n\n# 2.5 kibana\n\n# 2.5.1 概述\n\nkibana是一个针对elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在elasticsearch索引中的数据。使用kibana，可以通过各种图表进行高级数据分析及展示。kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显elasticsearch查询动态。设置kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成kibana安装并启动elasticsearch索引监测。\n\n# 2.5.2 下载\n\n\n\n> kibana 版本要和 es 一致！\n\n# 2.5.3 解压目录\n\n\n\n# 2.5.4 启动\n\n双击 bin 目录下 kibana.bat\n\n\n\n# 2.5.5 访问\n\nhttp://localhost:5601\n\n\n\n# 2.5.6 测试工具\n\n\n\n> 开发工具！ （post、curl、head、谷歌浏览器插件测试！）\n\n# 2.5.7 汉化\n\n * 在 x-pack\\plugins\\translations\\translations\\zh-cn.json 已有中文设置\n\n{\n    "messages": {\n    "common.ui.aggresponse.alldocstitle": "所有文档",\n    "common.ui.aggresponse.fieldlabel": "字段",\n    "common.ui.aggresponse.valuelabel": "值",\n "xpack.watcher.watchedit.thresholdwatchexpression.aggtype.fieldisrequiredvalidationmessage": "此字段必填。",\n    "xpack.watcher.watcherdescription": "通过创建、管理和监测警报来检测数据中的更改。"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 修改 config\\kibana.yml\n\n# specifies locale to be used for all localizable strings, dates and number formats.\n# supported languages are the following: english - en , by default , chinese - zh-cn .\n#i18n.locale: "en"\ni18n.locale: "zh-cn"\n\n\n1\n2\n3\n4\n\n * 访问\n\n\n\n\n# 3. es核心概念\n\n 1. 索引\n\n 2. 字段类型（mapping）\n\n 3. 文档（documents）\n\n> elasticsearch是面向文档，关系行数据库 和 elasticsearch 客观的对比！一切都是json！\n\n\n# 3.1 关系行数据库 和 elasticsearch\n\nrelational db [mysql]   elasticsearch\n数据库(database)           索引(indices)\n表(tables)               类型(types) [会被弃用]\n行(rows)                 文档（documents）\n字段(columns)             域(fields)\n\n> elasticsearch(集群)中可以包含多个索引(数据库)，每个索引中可以包含多个类型(表)，每个类型下又包含多 个文档(行)，每个文档中又包含多个字段(列)。\n\n\n# 3.2 逻辑设计\n\nelasticsearch 在后台把每个索引划分成多个分片，每分分片可以在集群中的不同服务器间迁移\n\n * 一个elasticsearch 就是一个集群！默认的集群名称就是 elaticsearh\n\n\n\n\n# 3.3 逻辑设计\n\n一个索引类型中，包含多个文档，比如说文档1，文档2。 当我们索引一篇文档时，可以通过这样的一各顺序找到 它: 索引 ▷ 类型 ▷ 文档id ，通过这个组合我们就能索引到某个具体的文档。 注意:id不必是整数，实际上它是个字符串。\n\n# 3.3.1 文档\n\n> 就是一条数据\n\n就是我们的一条条数据\n\nuser \n\n1 zhangsan 18 \n\n2 kuangshen 3\n\n\n1\n2\n3\n4\n5\n\n\n之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是 "文档"，elasticsearch中，文档有几个 重要属性 :\n\n * 自我包含，一篇文档同时包含字段和对应的值，也就是同时包含 key:value！\n\n * 可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的！ {就是一个json对象！fastjson进行自动转换！}\n\n * 灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。\n\n尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符 串也可以是整形。因elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。\n\n# 3.3.2 类型\n\n\n\n类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射，比如 name 映 射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整形。 但是elasticsearch也可能猜不对， 所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。\n\n# 3.3.3 索引\n\n> 就是数据库！\n\n索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。\n\n\n# 4. ik分词器\n\n分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词\n\n> 使用中文，建议使用ik分词器！\n> \n> ik提供了两个分词算法：ik_smart 和 ik_max_word，其中 ik_smart 为最少切分，ik_max_word为最细粒度划分！\n\n\n# 4.1 下载\n\n网址\n\n\n# 4.2 安装\n\n解压,放在 es 中的 plugins 的 ik 目录下\n\n\n\n\n# 4.2 重启,访问\n\n * 加载插件\n\n\n\n * 查看es的插件 elasticsearch-plugin list\n\n\n\n\n# 4.3 kibana测试\n\n# 4.3.1 ik_smart分词\n\nik_smart 为最少切分\n\n\n\n# 4.3.2 ik_max_word分词\n\nik_max_word为最细粒度划分！\n\nget _analyze\n{\n  "analyzer": "ik_max_word",\n  "text": "中华人民共和国"\n}\n\n\n1\n2\n3\n4\n5\n\n * 结果\n\n{\n  "tokens" : [\n    {\n      "token" : "中华人民共和国",\n      "start_offset" : 0,\n      "end_offset" : 7,\n      "type" : "cn_word",\n      "position" : 0\n    },\n    {\n      "token" : "中华人民",\n      "start_offset" : 0,\n      "end_offset" : 4,\n      "type" : "cn_word",\n      "position" : 1\n    },\n    {\n      "token" : "中华",\n      "start_offset" : 0,\n      "end_offset" : 2,\n      "type" : "cn_word",\n      "position" : 2\n    },\n    {\n      "token" : "华人",\n      "start_offset" : 1,\n      "end_offset" : 3,\n      "type" : "cn_word",\n      "position" : 3\n    },\n    {\n      "token" : "人民共和国",\n      "start_offset" : 2,\n      "end_offset" : 7,\n      "type" : "cn_word",\n      "position" : 4\n    },\n    {\n      "token" : "人民",\n      "start_offset" : 2,\n      "end_offset" : 4,\n      "type" : "cn_word",\n      "position" : 5\n    },\n    {\n      "token" : "共和国",\n      "start_offset" : 4,\n      "end_offset" : 7,\n      "type" : "cn_word",\n      "position" : 6\n    },\n    {\n      "token" : "共和",\n      "start_offset" : 4,\n      "end_offset" : 6,\n      "type" : "cn_word",\n      "position" : 7\n    },\n    {\n      "token" : "国",\n      "start_offset" : 6,\n      "end_offset" : 7,\n      "type" : "cn_char",\n      "position" : 8\n    }\n  ]\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 4.4 自定义分词器的字典\n\n\n\n# 问题:\n\n当输入我是晨光向时没有我们想要的晨光向这个分词\n\n# 解决\n\n> ik 分词器增加自己的 !\n\n在 elasticsearch-7.6.1\\plugins\\ik\\config 下配置\n\n\n\nmy.dic\n\n晨光向\n\n\n1\n\n\n# 重启\n\n\n\n# kibana结果\n\n\n\n> 以后的话，我们需要自己配置 分词就在自己定义的dic文件中进行配置即可！\n\n\n# 5. rest风格说明\n\n一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n\nmethod   url地址                                   描述\nput      localhost:9200/索引名称/类型名称/文档id           创建文档（指定文档id）\npost     localhost:9200/索引名称/类型名称                创建文档（随机文档id）\npost     localhost:9200/索引名称/类型名称/文档id/_update   修改文档\ndelete   localhost:9200/索引名称/类型名称/文档id           删除文档\nget      localhost:9200/索引名称/类型名称/文档id           查询文档通过文档id\npost     localhost:9200/索引名称/类型名称/_search        查询所有数据\n\n\n# 6. 索引的基本操作\n\n\n# 6.1 类型\n\n * 字符串类型\n   \n   text , keyword\n\n * 数值类型\n   \n   long, integer, short, byte, double, flfloat, half_flfloat, scaled_flfloat\n\n * 日期类型\n   \n   date\n\n * 布尔值类型\n   \n   boolean\n\n * 二进制\n   \n   binary\n\n * ...\n\n\n# 6.2 创建一个索引\n\n# 6.2.1 无字段类型\n\nput /索引名/类型名/文档id \n{\n    请求体\n}\n\n\n1\n2\n3\n4\n\n\n\n\nhead\n\n\n\n> es可以作为数据库操作.\n\n# 6.3.2 设置字段类型\n\n\n\n\n# 6.3 获取索引信息\n\n可以通过 get 请求获取具体的信息！\n\n\n\n\n# 6.4 查看默认的信息(另一种创建索引的方式)\n\n * 创建索引 test3\n\n\n\n# 获取信息\n\n\n\n> 如果自己的文档字段没有指定，那么es 就会给我们默认配置字段类型！推荐这种方式,.\n\n\n# 6.5 修改索引\n\n修改,提交试用put方式覆盖,\n\n# 6.5.1 旧的方式 put\n\n\n\n# 6.5.2 新的方式 post\n\n\n\n\n# 6.6 删除索引 delete\n\n\n\n\n# 6.7 扩展\n\n通过 get _cat/可以获取es的当前的很多信息\n\n# 状态\nget _cat/health\n# 版本信息\nget _cat/indices\n\n\n1\n2\n3\n4\n\n\n上边文档\n\n# ik_smart\nget _analyze\n{\n  "analyzer": "ik_smart",\n  "text": "中华人民共和国"\n}\n\n# ik_max_word\nget _analyze\n{\n  "analyzer": "ik_max_word",\n  "text": "我是晨光向"\n}\n\n# 创建索引\nput /test1/type1/1\n{\n  "name": "晨光向",\n  "age": "14"\n}\n\n# 指定字段的类型\nput /test2\n{\n  "mappings": {\n    "properties": {\n      "name": {\n        "type": "text"\n      },\n      "age": {\n        "type": "long"\n      },\n      "birthday": {\n        "type": "date"\n      }\n    }\n  }\n}\n\n# 获取test2的信息\nget test2\n\n# 创建索引 \n# es7 启用 type类型 \n# 这里使用 _doc \nput /test3/_doc/1\n{\n  "name": "晨光向",\n  "age": "14",\n  "birthday": "1996-01-09"\n}\n\n# 获取teset3信息\nget test3\n\n# 扩展\n# 状态\nget _cat/health\n# 版本信息\nget _cat/indices\n\n\n# 之前: 修改test3\nput /test3/_doc/1\n{\n  "name": "晨光向123",\n  "age": "14",\n  "birthday": "1996-01-09"\n}\n\n# 现在: 修改test3\npost /test3/_doc/1/_update\n{\n  "doc":{\n    "name": "我是谁"\n  }\n}\n\n# 删除索引\ndelete test1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n\n# 7. 文档的基本操作\n\n\n# 8. 集成sringboot\n\n> springboot版本2.2.5\n\n\n# 1. 官方文档\n\n * 第一步\n\n\n\n * 第二步\n\n\n\n * 第三步\n\n\n\n * 第四部: 原生依赖\n\n<dependency>\n    <groupid>org.elasticsearch.client</groupid>\n    <artifactid>elasticsearch-rest-client</artifactid>\n    <version>7.6.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n> 配合版本\n\n * 第五步: 对象\n\n\n\n\n# 2. 创建springboot项目\n\n# 2.1 依赖\n\n\x3c!--elasticsearch依赖--\x3e\n<dependency>\n   <groupid>org.springframework.boot</groupid>\n   <artifactid>spring-boot-starter-data-elasticsearch</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n# 2.2. 问题\n\nelasticsearch版本问题: 版本与es不一致\n\n\n\n# 解决\n\n<properties>\n   \x3c!--自定义elasticsearch版本 7.6.1 --\x3e\n   <elasticsearch.version>7.6.1</elasticsearch.version>\n</properties>\n\n\n1\n2\n3\n4\n\n\n\n\n> 注意: 导入依赖版本一定要与安装的es版本一致.\n\n# 2.3 提供的对象\n\n# spring data下的默认对象\n\n\n\n# rest 对象\n\n\n\n核心配置\n\n/**\n * elasticsearch rest client infrastructure configurations.\n *\n * @author brian clozel\n * @author stephane nicoll\n */\nclass restclientconfigurations {\n\n   @configuration(proxybeanmethods = false)\n   static class restclientbuilderconfiguration {\n\n      @bean\n      @conditionalonmissingbean\n      restclientbuilder elasticsearchrestclientbuilder(restclientproperties properties,\n            objectprovider<restclientbuildercustomizer> buildercustomizers) {\n         httphost[] hosts = properties.geturis().stream().map(httphost::create).toarray(httphost[]::new);\n         restclientbuilder builder = restclient.builder(hosts);\n         propertymapper map = propertymapper.get();\n         map.from(properties::getusername).whenhastext().to((username) -> {\n            credentialsprovider credentialsprovider = new basiccredentialsprovider();\n            credentials credentials = new usernamepasswordcredentials(properties.getusername(),\n                  properties.getpassword());\n            credentialsprovider.setcredentials(authscope.any, credentials);\n            builder.sethttpclientconfigcallback(\n                  (httpclientbuilder) -> httpclientbuilder.setdefaultcredentialsprovider(credentialsprovider));\n         });\n         builder.setrequestconfigcallback((requestconfigbuilder) -> {\n            map.from(properties::getconnectiontimeout).whennonnull().asint(duration::tomillis)\n                  .to(requestconfigbuilder::setconnecttimeout);\n            map.from(properties::getreadtimeout).whennonnull().asint(duration::tomillis)\n                  .to(requestconfigbuilder::setsockettimeout);\n            return requestconfigbuilder;\n         });\n         buildercustomizers.orderedstream().foreach((customizer) -> customizer.customize(builder));\n         return builder;\n      }\n\n   }\n\n   @configuration(proxybeanmethods = false)\n   @conditionalonclass(resthighlevelclient.class)\n   static class resthighlevelclientconfiguration {\n\t// resthighlevelclient 高级客户端，也是项目会用到的客户端\n      @bean\n      @conditionalonmissingbean\n      resthighlevelclient elasticsearchresthighlevelclient(restclientbuilder restclientbuilder) {\n         return new resthighlevelclient(restclientbuilder);\n      }\n\n      @bean\n      @conditionalonmissingbean\n      restclient elasticsearchrestclient(restclientbuilder builder,\n            objectprovider<resthighlevelclient> resthighlevelclient) {\n         resthighlevelclient client = resthighlevelclient.getifunique();\n         if (client != null) {\n            return client.getlowlevelclient();\n         }\n         return builder.build();\n      }\n\n   }\n\n   @configuration(proxybeanmethods = false)\n   static class restclientfallbackconfiguration {\n\t// resthighlevelclient 普通客户端\n      @bean\n      @conditionalonmissingbean\n      restclient elasticsearchrestclient(restclientbuilder builder) {\n         return builder.build();\n      }\n\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 3 api使用\n\n * 这里使用 rest对象 内容以 json格式展示\n\n# 3.1 创建索引\n\nclass elasticsearchapiapplicationtests {\n\n   /**\n    * @autowired: 根据类型匹配\n    */\n   @autowired\n   @qualifier("resthighlevelclient")\n   private resthighlevelclient client;\n\n   /** \n    * 创建索引 request createindexrequest\n    */\n   @test\n   void contextloads() throws ioexception {\n      // 1. 创建索引请求\n      createindexrequest request = new createindexrequest("chggx_index");\n      // 2. 客户端执行请求\n      createindexresponse createindexresponse = client.indices().create(request, requestoptions.default);\n      // 3. 打印响应\n      system.out.println(createindexresponse);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 3.2 获取索引\n\n/**\n * 获取索引 判断是否存在 get getindexrequest\n */\n@test\nvoid testexistindex() throws ioexception {\n    // 1. 获取索引请求\n    getindexrequest request = new getindexrequest("chggx_index");\n    // 2. 判断是否存在\n    boolean exists = client.indices().exists(request, requestoptions.default);\n    // 3. 打印结果 true\n    system.out.println(exists);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 3.3 删除索引\n\n/**\n * 删除索引 delete deleteindexrequest\n */\n@test\nvoid testdeleteindex() throws ioexception {\n    // 1. 获取删除请求\n    deleteindexrequest request = new deleteindexrequest("test2");\n    // 2. 删除索引\n    acknowledgedresponse delete = client.indices().delete(request, requestoptions.default);\n    system.out.println(delete.isacknowledged());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 3.4 创建文档\n\n/**\n * 添加文档 indexrequest\n */\n@test\nvoid testadddocument() throws ioexception {\n    // 1. 创建对象\n    user user = new user("chggx", 12);\n    // 2. 创建请求\n    indexrequest request = new indexrequest("chggx_index");\n    // 3. 规则 /put/chggx_index/_doc/1\n    request.id("1");\n    // 超时 request.timeout("1s");\n    request.timeout(timevalue.timevalueseconds(1));\n    // 4. 将数据放入请求 json\n    request.source(json.tojsonstring(user), xcontenttype.json);\n    // 5. 客户端发送请求,获取响应结果\n    indexresponse indexresponse = client.index(request, requestoptions.default);\n\n    // indexresponse[index=chggx_index,type=_doc,id=1,version=1,result=created,seqno=0,primaryterm=1,shards={"total":2,"successful":1,"failed":0}]\n    system.out.println(indexresponse.tostring());\n    // created 第一次创建: created 以后更新 update\n    system.out.println(indexresponse.status());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 3.5 获取文档\n\n 1. 判断是否存在\n\n/**\n * 获取文档, 判断是否存在 getrequest\n */\n@test\nvoid testisexists() throws ioexception {\n    // 1. 创建获取请求\n    getrequest getrequest = new getrequest("chggx_index", "1");\n    // 2. 不获取返回的 _source 的上下文了\n    getrequest.fetchsourcecontext(new fetchsourcecontext(false));\n    // 3. 排序\n    getrequest.storedfields("_none_");\n\n    boolean exists = client.exists(getrequest, requestoptions.default);\n    system.out.println(exists);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 2. 获取文档信息\n\n/**\n * 获取文档信息 getrequest\n */\n@test\nvoid testgetdocument() throws ioexception {\n    // 1. 创建获取请求\n    getrequest getrequest = new getrequest("chggx_index", "1");\n    // 2. 获取文档信息\n    getresponse getresponse = client.get(getrequest, requestoptions.default);\n    // 3. 打印文档内容 {"age":12,"name":"chggx"}\n    system.out.println(getresponse.getsourceasstring());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 3.6 修改文档\n\n/**\n * 更新文档信息 updaterequest\n */\n@test\nvoid testupdatedocument() throws ioexception {\n    // 1. 创建获取请求\n    updaterequest updaterequest = new updaterequest("chggx_index", "1");\n    // 2. 更新内容表\n    updaterequest.timeout("1s");\n    user user = new user("my chggx", 18);\n    // 转换为 json 数据\n    updaterequest.doc(json.tojsonstring(user), xcontenttype.json);\n    // 3. 获取文档信息 ok\n    updateresponse updateresponse = client.update(updaterequest, requestoptions.default);\n    // 4. 打印更新文档内容 ok\n    system.out.println(updateresponse.status());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 3.7 删除文档\n\n/**\n * 删除文档信息\n */\n@test\nvoid testdeletedocument() throws ioexception {\n    // 1. 创建获取请求\n    deleterequest deleterequest = new deleterequest("test3", "1");\n    // 2 删除文档信息\n    deleteresponse deleteresponse = client.delete(deleterequest, requestoptions.default);\n    // 3. 打印文档内容 ok\n    system.out.println(deleteresponse.status());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 3.8 批量添加\n\n/**\n     * 特殊的,批量插入数据 bulkrequest\n     */\n    @test\n    void testbulkrequest() throws ioexception {\n        // 1. 创建获取请求\n        bulkrequest bulkrequest = new bulkrequest();\n        // 2. 设置数据\n        bulkrequest.timeout("10s");\n        arraylist<user> userlist = new arraylist<>();\n        userlist.add(new user("java 1", 5));\n        userlist.add(new user("java 2", 5));\n        userlist.add(new user("java 3", 5));\n        userlist.add(new user("java 4", 5));\n        userlist.add(new user("java 5", 5));\n        for (int i = 0; i < userlist.size(); i++) {\n            // 批量添加\n            bulkrequest.add(\n                    new indexrequest("chggx_bulk")\n                            .id("" + (i + 1))\n                            .source(json.tojsonstring(userlist.get(i)), xcontenttype.json)\n            );\n        }\n        // 3. 批量添加\n        bulkresponse bulkresponse = client.bulk(bulkrequest, requestoptions.default);\n        // 4. 打印文档内容 ok\n        system.out.println(bulkresponse.status());\n        // 是否失败 false: 代表成功\n        system.out.println(bulkresponse.hasfailures());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 3.9 查询\n\n    /**\n     * 查询 searchrequest\n     */\n    @test\n    void testsearch() throws ioexception {\n        // 1. 创建获取请求\n        searchrequest searchrequest = new searchrequest("chggx_bulk");\n        // 2. 构建搜索条件\n        searchsourcebuilder sourcebuilder = new searchsourcebuilder();\n        // querybuilders: 查询条件\n        // termquery: 精确查询\n        // matchallquery: 匹配所有\n        termquerybuilder termquerybuilder = querybuilders.termquery("age", 5);\n//        matchallquerybuilder matchallquerybuilder = querybuilders.matchallquery();\n        sourcebuilder.query(termquerybuilder);\n        // 查询超时时间\n        sourcebuilder.timeout(new timevalue(60, timeunit.seconds));\n        searchrequest.source(sourcebuilder);\n        // 3. 搜索信息\n        searchresponse searchresponse = client.search(searchrequest, requestoptions.default);\n        // 4. 打印文档内容 ok\n        system.out.println(json.tojsonstring(searchresponse.gethits()));\n        system.out.println("============================================");\n        for (searchhit documentfields : searchresponse.gethits().gethits()) {\n            system.out.println(documentfields.getsourceasmap());\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 9. 爬虫',charsets:{cjk:!0},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"下载node",frontmatter:{title:"下载node",date:"2023-03-01T21:43:04.000Z",permalink:"/pages/abd7cf/"},regularPath:"/05.%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6/01.Node/01.%E4%B8%8B%E8%BD%BDnode.html",relativePath:"05.前端应用框架/03.组件化框架/01.Node/01.下载node.md",key:"v-639d5c4c",path:"/pages/abd7cf/",headers:[{level:2,title:"1. 下载node",slug:"_1-下载node",normalizedTitle:"1. 下载node",charIndex:2},{level:3,title:"1.1 官网下载",slug:"_1-1-官网下载",normalizedTitle:"1.1 官网下载",charIndex:16},{level:3,title:"1.2 中文下载",slug:"_1-2-中文下载",normalizedTitle:"1.2 中文下载",charIndex:157},{level:2,title:"2. 安装配置",slug:"_2-安装配置",normalizedTitle:"2. 安装配置",charIndex:200},{level:3,title:"2.1 安装node",slug:"_2-1-安装node",normalizedTitle:"2.1 安装node",charIndex:212},{level:3,title:"2.2 配置修改package的全局路径和npm缓存路径",slug:"_2-2-配置修改package的全局路径和npm缓存路径",normalizedTitle:"2.2 配置修改package的全局路径和npm缓存路径",charIndex:474},{level:3,title:"2.3 配置淘宝镜像",slug:"_2-3-配置淘宝镜像",normalizedTitle:"2.3 配置淘宝镜像",charIndex:820},{level:3,title:"2.4 查看npm配置信息",slug:"_2-4-查看npm配置信息",normalizedTitle:"2.4 查看npm配置信息",charIndex:1066},{level:3,title:"2.5 查看node版本信息",slug:"_2-5-查看node版本信息",normalizedTitle:"2.5 查看node版本信息",charIndex:1106},{level:2,title:"3. 配置yarn",slug:"_3-配置yarn",normalizedTitle:"3. 配置yarn",charIndex:1140},{level:3,title:"3.1 配置yarn",slug:"_3-1-配置yarn",normalizedTitle:"3.1 配置yarn",charIndex:1154},{level:4,title:"1.1 安装yarn",slug:"_1-1-安装yarn",normalizedTitle:"1.1 安装yarn",charIndex:1168},{level:4,title:"2. 卸载",slug:"_2-卸载",normalizedTitle:"2. 卸载",charIndex:1251},{level:4,title:"3. 查看yarn版本",slug:"_3-查看yarn版本",normalizedTitle:"3. 查看yarn版本",charIndex:1299},{level:3,title:"3.2 查看node配置信息",slug:"_3-2-查看node配置信息",normalizedTitle:"3.2 查看node配置信息",charIndex:1331},{level:3,title:"3.3 查询与更换源",slug:"_3-3-查询与更换源",normalizedTitle:"3.3 查询与更换源",charIndex:1402}],headersStr:"1. 下载node 1.1 官网下载 1.2 中文下载 2. 安装配置 2.1 安装node 2.2 配置修改package的全局路径和npm缓存路径 2.3 配置淘宝镜像 2.4 查看npm配置信息 2.5 查看node版本信息 3. 配置yarn 3.1 配置yarn 1.1 安装yarn 2. 卸载 3. 查看yarn版本 3.2 查看node配置信息 3.3 查询与更换源",content:'# 1. 下载node\n\n\n# 1.1 官网下载\n\n打开官网 Node.js官网 ，选择自己的版本，这里我使用的是Windows64位的，下载.msi安装包\n\n下载其他版本\n\n> 以14.x版本为例Index of /download/release/latest-v14.x/ (nodejs.org)\n\n\n# 1.2 中文下载\n\n下载 | Node.js 中文网 (nodejs.cn)\n\n\n# 2. 安装配置\n\n\n# 2.1 安装node\n\n双击运行安装包\n\n\n\n点击next下一步\n\n\n\n勾选同意，点击Next下一步\n\n\n\n选择安装位置，点击Next下一步\n\n\n\n选择安装方式，这里选择Add to PATH方式安装（自动添加到系统环境），点击Next下一步\n\n\n\n点击Next下一步\n\n\n\n点击Install安装\n\n\n\n等待安装完成\n\n\n\n安装完成，点击Finish\n\n\n\n右键“我的电脑”-选择属性-点击高级系统设置-点击环境变量-双击系统变量的PATH\n\n可以看到，安装完成自动配置环境变量，如果这里没有显示，可自行添加即可\n\n\n# 2.2 配置修改package的全局路径和npm缓存路径\n\n打开刚刚安装Node.js目录，创建 node_global和node_cache两个文件夹\n\n接着打开cmd命令工具，输入两句指令（根据自己实际修改路径）\n\nnpm config set prefix "D:\\Develop\\front\\nodejs\\node_global"\nnpm config set cache "D:\\Develop\\front\\nodejs\\node_cache"\n\n\n1\n2\n\n\n右键“我的电脑”-选择属性-点击高级系统设置-点击环境变量-新建系统变量\n\n接着双击用户变量的PATH\n\n输入 D:\\Develop\\front\\nodejs\\node_global\n\n\n\n点击确定，配置完成。\n\n\n# 2.3 配置淘宝镜像\n\n配置cnpm，配置淘宝镜像，默认路径下载比较缓慢，配置淘宝镜像可以加速下载速度，打开命令窗口执行以下命令即可，如果不想配置cnpm，可直接跳过此步骤；\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n\n\n直接设置为npm设置淘宝镜像仓库即可 😄\n\nnpm config set registry https://registry.npm.taobao.org\n\n\n1\n\n\n\n# 2.4 查看npm配置信息\n\nnpm config list\n\n\n1\n\n\n\n# 2.5 查看node版本信息\n\nnpm -v\n\n\n1\n\n\n\n\n\n# 3. 配置yarn\n\n\n# 3.1 配置yarn\n\n# 1.1 安装yarn\n\nnpm install yarn -g\n\n\n1\n\n\n右键“我的电脑”-选择属性-点击高级系统设置-点击环境变量-双击系统变量的PATH\n\n# 2. 卸载\n\nnpm uninstall yarn -g  // yarn卸载\n\n\n1\n\n\n# 3. 查看yarn版本\n\nyarn -v\n\n\n1\n\n\n\n\n\n# 3.2 查看node配置信息\n\n全局路径、缓存路径、以及淘宝镜像路径，查看是否安装正确\n\nyarn config list\n\n\n1\n\n\n\n# 3.3 查询与更换源\n\nyarn config get registry\nyarn config set registry https://registry.npm.taobao.org/\n\n\n1\n2\n',normalizedContent:'# 1. 下载node\n\n\n# 1.1 官网下载\n\n打开官网 node.js官网 ，选择自己的版本，这里我使用的是windows64位的，下载.msi安装包\n\n下载其他版本\n\n> 以14.x版本为例index of /download/release/latest-v14.x/ (nodejs.org)\n\n\n# 1.2 中文下载\n\n下载 | node.js 中文网 (nodejs.cn)\n\n\n# 2. 安装配置\n\n\n# 2.1 安装node\n\n双击运行安装包\n\n\n\n点击next下一步\n\n\n\n勾选同意，点击next下一步\n\n\n\n选择安装位置，点击next下一步\n\n\n\n选择安装方式，这里选择add to path方式安装（自动添加到系统环境），点击next下一步\n\n\n\n点击next下一步\n\n\n\n点击install安装\n\n\n\n等待安装完成\n\n\n\n安装完成，点击finish\n\n\n\n右键“我的电脑”-选择属性-点击高级系统设置-点击环境变量-双击系统变量的path\n\n可以看到，安装完成自动配置环境变量，如果这里没有显示，可自行添加即可\n\n\n# 2.2 配置修改package的全局路径和npm缓存路径\n\n打开刚刚安装node.js目录，创建 node_global和node_cache两个文件夹\n\n接着打开cmd命令工具，输入两句指令（根据自己实际修改路径）\n\nnpm config set prefix "d:\\develop\\front\\nodejs\\node_global"\nnpm config set cache "d:\\develop\\front\\nodejs\\node_cache"\n\n\n1\n2\n\n\n右键“我的电脑”-选择属性-点击高级系统设置-点击环境变量-新建系统变量\n\n接着双击用户变量的path\n\n输入 d:\\develop\\front\\nodejs\\node_global\n\n\n\n点击确定，配置完成。\n\n\n# 2.3 配置淘宝镜像\n\n配置cnpm，配置淘宝镜像，默认路径下载比较缓慢，配置淘宝镜像可以加速下载速度，打开命令窗口执行以下命令即可，如果不想配置cnpm，可直接跳过此步骤；\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n\n\n直接设置为npm设置淘宝镜像仓库即可 😄\n\nnpm config set registry https://registry.npm.taobao.org\n\n\n1\n\n\n\n# 2.4 查看npm配置信息\n\nnpm config list\n\n\n1\n\n\n\n# 2.5 查看node版本信息\n\nnpm -v\n\n\n1\n\n\n\n\n\n# 3. 配置yarn\n\n\n# 3.1 配置yarn\n\n# 1.1 安装yarn\n\nnpm install yarn -g\n\n\n1\n\n\n右键“我的电脑”-选择属性-点击高级系统设置-点击环境变量-双击系统变量的path\n\n# 2. 卸载\n\nnpm uninstall yarn -g  // yarn卸载\n\n\n1\n\n\n# 3. 查看yarn版本\n\nyarn -v\n\n\n1\n\n\n\n\n\n# 3.2 查看node配置信息\n\n全局路径、缓存路径、以及淘宝镜像路径，查看是否安装正确\n\nyarn config list\n\n\n1\n\n\n\n# 3.3 查询与更换源\n\nyarn config get registry\nyarn config set registry https://registry.npm.taobao.org/\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2023/03/01, 22:43:28",lastUpdatedTimestamp:1677681808e3},{title:"yarn常用命令",frontmatter:{title:"yarn常用命令",date:"2023-03-01T21:43:04.000Z",permalink:"/pages/5ca64b/"},regularPath:"/05.%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6/01.Node/02.yarn%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"05.前端应用框架/03.组件化框架/01.Node/02.yarn常用命令.md",key:"v-1f0508fd",path:"/pages/5ca64b/",headers:[{level:2,title:"1. 初始化新项目",slug:"_1-初始化新项目",normalizedTitle:"1. 初始化新项目",charIndex:11},{level:2,title:"2. 添加依赖包",slug:"_2-添加依赖包",normalizedTitle:"2. 添加依赖包",charIndex:178},{level:3,title:"开发环境",slug:"开发环境",normalizedTitle:"开发环境",charIndex:242},{level:3,title:"生产环境",slug:"生产环境",normalizedTitle:"生产环境",charIndex:436},{level:3,title:"全局",slug:"全局",normalizedTitle:"全局",charIndex:604},{level:2,title:"3. 更新一个依赖",slug:"_3-更新一个依赖",normalizedTitle:"3. 更新一个依赖",charIndex:718},{level:2,title:"4. 移除一个依赖",slug:"_4-移除一个依赖",normalizedTitle:"4. 移除一个依赖",charIndex:1006},{level:2,title:"5. 安装 package.json 中的所有文件",slug:"_5-安装-package-json-中的所有文件",normalizedTitle:"5. 安装 package.json 中的所有文件",charIndex:1143},{level:2,title:"6. 运行脚本",slug:"_6-运行脚本",normalizedTitle:"6. 运行脚本",charIndex:1420},{level:2,title:"7. 显示某个包信息",slug:"_7-显示某个包信息",normalizedTitle:"7. 显示某个包信息",charIndex:1680},{level:2,title:"8. 列出项目的所有依赖",slug:"_8-列出项目的所有依赖",normalizedTitle:"8. 列出项目的所有依赖",charIndex:1941},{level:2,title:"9. 管理 yarn 配置文件",slug:"_9-管理-yarn-配置文件",normalizedTitle:"9. 管理 yarn 配置文件",charIndex:2086},{level:2,title:"10. 缓存",slug:"_10-缓存",normalizedTitle:"10. 缓存",charIndex:2484}],headersStr:"1. 初始化新项目 2. 添加依赖包 开发环境 生产环境 全局 3. 更新一个依赖 4. 移除一个依赖 5. 安装 package.json 中的所有文件 6. 运行脚本 7. 显示某个包信息 8. 列出项目的所有依赖 9. 管理 yarn 配置文件 10. 缓存",content:"# 常用命令\n\n\n# 1. 初始化新项目\n\nyarn init 与 npm init 一样通过交互式会话创建一个 package.json 文件。\n\nyarn init\nnpm init\n\n\n1\n2\n\n\n跳过会话，直接通过默认值生成 package.json\n\nyarn init --yes # 简写 -y\nnpm init -y\n\n\n1\n2\n\n\n\n# 2. 添加依赖包\n\n通过 yarn add 添加依赖会更新 package.json 以及 yarn.lock 文件。\n\n\n# 开发环境\n\nyarn add <packageName> # 依赖会记录在 package.json 的 dependencies 下 开发环境\nyarn add webpack@2.3.3 # yarn --save 是 yarn 默认的，默认记录在 package.json 中\nnpm install webpack@2.3.3 --save # npm\n\n\n1\n2\n3\n\n\n\n# 生产环境\n\nyarn add <packageName> --dev # 依赖会记录在 package.json 的 devDependencies 下 生产环境\nyarn add webpack --dev # yarn 简写 -D\nnpm install webpack --save-dev # npm\n\n\n1\n2\n3\n\n\n\n# 全局\n\nyarn global add <packageName> 全局安装依赖\nyarn global add webpack # yarn\nnpm install webpack -g # npm\n\n\n1\n2\n3\n\n\n\n# 3. 更新一个依赖\n\nyarn upgrade # 用于更新包到基于规范范围的最新版本\n\nyarn upgrade # 升级所有依赖项，不记录在 package.json 中\nnpm update # npm 可以通过 ‘--save|--save-dev’ 指定升级哪类依赖\n\nyarn upgrade webpack # 升级指定包\nnpm update webpack --save-dev # npm\n\nyarn upgrade --latest # 忽略版本规则，升级到最新版本，并且更新 package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4. 移除一个依赖\n\nyarn remove <packageName>\nyarn remove webpack # yarn\nnpm uninstall webpack --save # npm 可以指定 --save | --save-dev\n\n\n1\n2\n3\n\n\n\n# 5. 安装 package.json 中的所有文件\n\nyarn 或者 yarn install\nyarn install # 或者 yarn 在 node_modules 目录安装 package.json 中列出的所有依赖\nnpm install # npm\n\nyarn install # 安装时，如果 node_modules 中有相应的包则不会重新下载 --force 可以强制重新下载安装\nyarn install --force # 强制下载安装\nnpm install --force # npm\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 6. 运行脚本\n\nyarn 或者 yarn install\nyarn install # 或者 yarn 在 node_modules 目录安装 package.json 中列出的所有依赖\n\nnpm install # npm\nyarn install 安装时，如果 node_modules 中有相应的包则不会重新下载 --force 可以强制重新下载安装\n\nyarn install --force # 强制下载安装\nnpm install --force # npm\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7. 显示某个包信息\n\nyarn info <packageName> 可以用来查看某个模块的最新版本信息\nyarn info webpack # yarn\nnpm info webpack # npm\n\nyarn info webpack --json # 输出 json 格式\nnpm info webpack --json # npm\n\nyarn info webpack readme # 输出 README 部分\nnpm info webpack readme\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 8. 列出项目的所有依赖\n\nyarn list\nyarn list # 列出当前项目的依赖\nnpm list # npm\n\nyarn list --depth=0 # 限制依赖的深度\nsudo yarn global list # 列出全局安装的模块\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 9. 管理 yarn 配置文件\n\nyarn coinfig\nyarn config set key value # 设置\nnpm config set key value\n\nyarn config get key # 读取值\nnpm config get key\n\nyarn config delete key # 删除\nnpm config delete key\n\nyarn config list # 显示当前配置\nnpm config list\n\nyarn config set registry https://registry.npm.taobao.org # 设置淘宝镜像\nnpm config set registry https://registry.npm.taobao.org # npm\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 10. 缓存\n\nyarn cache\n\nsudo yarn cache list # 列出已缓存的每个包\n\nsudo yarn cache dir # 返回 全局缓存位置\n\nsudo yarn cache clean # 清除缓存\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# 常用命令\n\n\n# 1. 初始化新项目\n\nyarn init 与 npm init 一样通过交互式会话创建一个 package.json 文件。\n\nyarn init\nnpm init\n\n\n1\n2\n\n\n跳过会话，直接通过默认值生成 package.json\n\nyarn init --yes # 简写 -y\nnpm init -y\n\n\n1\n2\n\n\n\n# 2. 添加依赖包\n\n通过 yarn add 添加依赖会更新 package.json 以及 yarn.lock 文件。\n\n\n# 开发环境\n\nyarn add <packagename> # 依赖会记录在 package.json 的 dependencies 下 开发环境\nyarn add webpack@2.3.3 # yarn --save 是 yarn 默认的，默认记录在 package.json 中\nnpm install webpack@2.3.3 --save # npm\n\n\n1\n2\n3\n\n\n\n# 生产环境\n\nyarn add <packagename> --dev # 依赖会记录在 package.json 的 devdependencies 下 生产环境\nyarn add webpack --dev # yarn 简写 -d\nnpm install webpack --save-dev # npm\n\n\n1\n2\n3\n\n\n\n# 全局\n\nyarn global add <packagename> 全局安装依赖\nyarn global add webpack # yarn\nnpm install webpack -g # npm\n\n\n1\n2\n3\n\n\n\n# 3. 更新一个依赖\n\nyarn upgrade # 用于更新包到基于规范范围的最新版本\n\nyarn upgrade # 升级所有依赖项，不记录在 package.json 中\nnpm update # npm 可以通过 ‘--save|--save-dev’ 指定升级哪类依赖\n\nyarn upgrade webpack # 升级指定包\nnpm update webpack --save-dev # npm\n\nyarn upgrade --latest # 忽略版本规则，升级到最新版本，并且更新 package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4. 移除一个依赖\n\nyarn remove <packagename>\nyarn remove webpack # yarn\nnpm uninstall webpack --save # npm 可以指定 --save | --save-dev\n\n\n1\n2\n3\n\n\n\n# 5. 安装 package.json 中的所有文件\n\nyarn 或者 yarn install\nyarn install # 或者 yarn 在 node_modules 目录安装 package.json 中列出的所有依赖\nnpm install # npm\n\nyarn install # 安装时，如果 node_modules 中有相应的包则不会重新下载 --force 可以强制重新下载安装\nyarn install --force # 强制下载安装\nnpm install --force # npm\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 6. 运行脚本\n\nyarn 或者 yarn install\nyarn install # 或者 yarn 在 node_modules 目录安装 package.json 中列出的所有依赖\n\nnpm install # npm\nyarn install 安装时，如果 node_modules 中有相应的包则不会重新下载 --force 可以强制重新下载安装\n\nyarn install --force # 强制下载安装\nnpm install --force # npm\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7. 显示某个包信息\n\nyarn info <packagename> 可以用来查看某个模块的最新版本信息\nyarn info webpack # yarn\nnpm info webpack # npm\n\nyarn info webpack --json # 输出 json 格式\nnpm info webpack --json # npm\n\nyarn info webpack readme # 输出 readme 部分\nnpm info webpack readme\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 8. 列出项目的所有依赖\n\nyarn list\nyarn list # 列出当前项目的依赖\nnpm list # npm\n\nyarn list --depth=0 # 限制依赖的深度\nsudo yarn global list # 列出全局安装的模块\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 9. 管理 yarn 配置文件\n\nyarn coinfig\nyarn config set key value # 设置\nnpm config set key value\n\nyarn config get key # 读取值\nnpm config get key\n\nyarn config delete key # 删除\nnpm config delete key\n\nyarn config list # 显示当前配置\nnpm config list\n\nyarn config set registry https://registry.npm.taobao.org # 设置淘宝镜像\nnpm config set registry https://registry.npm.taobao.org # npm\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 10. 缓存\n\nyarn cache\n\nsudo yarn cache list # 列出已缓存的每个包\n\nsudo yarn cache dir # 返回 全局缓存位置\n\nsudo yarn cache clean # 清除缓存\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2023/03/01, 22:43:28",lastUpdatedTimestamp:1677681808e3},{title:"Nginx",frontmatter:{title:"Nginx",date:"2023-02-27T11:10:09.000Z",permalink:"/pages/bcb9d3/"},regularPath:"/06.%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/01.Web%E6%9C%8D%E5%8A%A1%E5%99%A8/01.Nginx.html",relativePath:"06.运维知识/01.Web服务器/01.Nginx.md",key:"v-31c7e04c",path:"/pages/bcb9d3/",headersStr:null,content:"Nginx",normalizedContent:"nginx",charsets:{},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"SonarQube",frontmatter:{title:"SonarQube",date:"2023-02-26T14:42:19.000Z",permalink:"/pages/e8fc76/"},regularPath:"/06.%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/05.%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5/01..%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5%E5%B9%B3%E5%8F%B0-SonarQube.html",relativePath:"06.运维知识/05.代码质量检查/01..代码质量检查平台-SonarQube.md",key:"v-2836490b",path:"/pages/e8fc76/",headers:[{level:2,title:"前言：code review：",slug:"前言-code-review",normalizedTitle:"前言：code review：",charIndex:24},{level:2,title:"1. SonarQube 整体介绍",slug:"_1-sonarqube-整体介绍",normalizedTitle:"1. sonarqube 整体介绍",charIndex:1013},{level:3,title:"1.1 SonarQube 是什么?",slug:"_1-1-sonarqube-是什么",normalizedTitle:"1.1 sonarqube 是什么?",charIndex:1035},{level:3,title:"1.2 SonarQube 的工作原理",slug:"_1-2-sonarqube-的工作原理",normalizedTitle:"1.2 sonarqube 的工作原理",charIndex:1854},{level:2,title:"2. SonarQube 功能与使用说明",slug:"_2-sonarqube-功能与使用说明",normalizedTitle:"2. sonarqube 功能与使用说明",charIndex:2270},{level:3,title:"2.1 项目",slug:"_2-1-项目",normalizedTitle:"2.1 项目",charIndex:2295},{level:4,title:"1. 项目-总览",slug:"_1-项目-总览",normalizedTitle:"1. 项目-总览",charIndex:2307},{level:4,title:"2. 项目-问题",slug:"_2-项目-问题",normalizedTitle:"2. 项目-问题",charIndex:2321},{level:4,title:"3. 项目-安全热点",slug:"_3-项目-安全热点",normalizedTitle:"3. 项目-安全热点",charIndex:2842},{level:5,title:"3.1 项目-安全热点-复审：",slug:"_3-1-项目-安全热点-复审",normalizedTitle:"3.1 项目-安全热点-复审：",charIndex:2908},{level:5,title:"3.2 项目-安全热点-SonarQube提醒/建议",slug:"_3-2-项目-安全热点-sonarqube提醒-建议",normalizedTitle:"3.2 项目-安全热点-sonarqube提醒/建议",charIndex:3049},{level:4,title:"4. 项目-指标",slug:"_4-项目-指标",normalizedTitle:"4. 项目-指标",charIndex:3143},{level:4,title:"5. 项目-代码",slug:"_5-项目-代码",normalizedTitle:"5. 项目-代码",charIndex:3170},{level:4,title:"6. 项目-活动",slug:"_6-项目-活动",normalizedTitle:"6. 项目-活动",charIndex:3220},{level:4,title:"7. 项目-项目配置",slug:"_7-项目-项目配置",normalizedTitle:"7. 项目-项目配置",charIndex:3243},{level:3,title:"2.2 问题",slug:"_2-2-问题",normalizedTitle:"2.2 问题",charIndex:4049},{level:3,title:"2.3 代码规则",slug:"_2-3-代码规则",normalizedTitle:"2.3 代码规则",charIndex:4118},{level:3,title:"2.4 质量配置",slug:"_2-4-质量配置",normalizedTitle:"2.4 质量配置",charIndex:4153},{level:3,title:"2.5 质量阈",slug:"_2-5-质量阈",normalizedTitle:"2.5 质量阈",charIndex:4533},{level:4,title:"质量阈-自定义质量阈",slug:"质量阈-自定义质量阈",normalizedTitle:"质量阈-自定义质量阈",charIndex:4833},{level:3,title:"2.6 配置",slug:"_2-6-配置",normalizedTitle:"2.6 配置",charIndex:5123},{level:4,title:"1. 用户与权限",slug:"_1-用户与权限",normalizedTitle:"1. 用户与权限",charIndex:5133},{level:5,title:"1.1 用户管理",slug:"_1-1-用户管理",normalizedTitle:"1.1 用户管理",charIndex:5145},{level:5,title:"1.2 群组管理",slug:"_1-2-群组管理",normalizedTitle:"1.2 群组管理",charIndex:5159},{level:4,title:"2. 项目权限",slug:"_2-项目权限",normalizedTitle:"2. 项目权限",charIndex:5192},{level:4,title:"3. 用户与权限-最佳实践",slug:"_3-用户与权限-最佳实践",normalizedTitle:"3. 用户与权限-最佳实践",charIndex:5277},{level:4,title:"4. 提醒（邮件告警）",slug:"_4-提醒-邮件告警",normalizedTitle:"4. 提醒（邮件告警）",charIndex:5610},{level:5,title:"4.1 系统邮件设置",slug:"_4-1-系统邮件设置",normalizedTitle:"4.1 系统邮件设置",charIndex:5625},{level:5,title:"4.2 项目提醒设置",slug:"_4-2-项目提醒设置",normalizedTitle:"4.2 项目提醒设置",charIndex:5645}],headersStr:"前言：code review： 1. SonarQube 整体介绍 1.1 SonarQube 是什么? 1.2 SonarQube 的工作原理 2. SonarQube 功能与使用说明 2.1 项目 1. 项目-总览 2. 项目-问题 3. 项目-安全热点 3.1 项目-安全热点-复审： 3.2 项目-安全热点-SonarQube提醒/建议 4. 项目-指标 5. 项目-代码 6. 项目-活动 7. 项目-项目配置 2.2 问题 2.3 代码规则 2.4 质量配置 2.5 质量阈 质量阈-自定义质量阈 2.6 配置 1. 用户与权限 1.1 用户管理 1.2 群组管理 2. 项目权限 3. 用户与权限-最佳实践 4. 提醒（邮件告警） 4.1 系统邮件设置 4.2 项目提醒设置",content:"# SonarQube代码质量检查平台\n\n\n# 前言：code review：\n\n随着业务的发展，系统越来越庞大，原本简单稳定的功能，可能在不断迭代后复杂度上升，潜在的风险也随之暴露，导致最终服务不稳定，造成业务价值的损失。而为了减少这种情况，有一种比较好的方式就是提高代码质量，比如通过 code review，从而降低错误风险。首先，我们先来看看 code reivew 的用处：\n\n * （1）code review 可以通过大家的建议改善代码的质量，提高代码的可读性、可维护性，以及确保程序逻辑和对需求、设计的实现的正确性\n * （2）code review 是一个传递知识的方式，让不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码\n * （3）code review 也鼓励程序员们相互学习对方的长处和优点\n * （4）code review 也可以被用来确认自己的设计和实现是一个清楚和简单的\n\n但在 code reivew 的诸多用处中，我们并没有提到可以帮助找到程序的bug和保证代码风格和编码规范，这是因为我们认为：\n\n * code review 不应该承担发现代码错误的职责。code review 主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证。\n * code review 不应该成为保证代码风格和编码规范的手段。编码规范和代码风格都属于死的东西，当把自己的代码提交给团队 review 时，代码就应该是符合规范的，这是属于每个人自己的事情，不应该交由团队来完成，否则只会浪费大家本来就不够的时间。\n\n当然，上述言论只是说上面两件事情并不是 code review 的意图，并不是说，你不能在 code review 中报告一个程序的bug或是一个代码规范的问题。如果要把上述两件事归入 code review 的职责，那将会导致 code review 增加大量的人力成本，且工作量随代码量的增加而增加，审查效率低；并且简单的 code review 只能解决代码风格问题，很难发现代码缺陷、漏洞、重复度、复杂度等方面的问题，效果差。\n\n所以，对于上面这两件事情，除了需要作者自己保证外，当然还有工具可以帮助我们检查代码规范的，比如下文介绍的 Sonarqube 平台。\n\n\n# 1. SonarQube 整体介绍\n\n\n# 1.1 SonarQube 是什么?\n\nSonarQube 是一个代码质量管理的开源平台，通过 SonarQube 提供的代码扫描、质量阈值卡点等质量红线，我们可以提升系统的可靠性，提前捕获和提示代码中的错误，从而避免未定义的行为影响到用户，保证业务质量，也能确保管理的代码库干净并且可维护，以便提高开发人员的开发效率。\n\nSonarQube 可以从以下七个维度检测代码质量，而作为开发人员至少需要处理前5种代码质量问题。\n\n * （1）不遵循代码标准：sonar 可以通过 PMD、CheckStyle、Findbugs 等知名的静态代码规则分析工具规范代码编写。\n * （2）潜在的缺陷：sonar 可以通过 PMD、CheckStyle、Findbugs 等知名的静态代码规则分析工具检测出潜在的缺陷。\n * （3）糟糕的复杂度分布：文件、类、方法等，如果复杂度过高将难以改变，这会使得开发人员难以理解它们，且如果没有自动化的单元测试，对于程序中的任何组件的改变都将可能导致需要全面的回归测试。\n * （4）重复：显然程序中包含大量复制粘贴的代码是质量低下的，sonar 可以展示源码中重复严重的地方。\n * （5）注释不足或者过多：没有注释将使代码可读性变差，特别是当不可避免地出现人员变动时，程序的可读性将大幅下降，而过多的注释又会使得开发人员将精力过多地花费在阅读注释上，亦违背初衷。\n * （6）缺乏单元测试：sonar可以很方便地统计并展示单元测试覆盖率。\n * （7）糟糕的设计：通过sonar可以找出循环，展示包与包、类与类之间的相互依赖关系，可以检测自定义的架构规则，通过sonar可以管理第三方的jar包，可以利用LCOM4检测单个任务规则的应用情况，检测耦合。\n\n另外 SonarQube 也可以生成详细的代码分析质量报告，并通过强大的仪表盘展示出来，使我们能够根据角色的不同，查看不同维度的度量标准。\n\n\n# 1.2 SonarQube 的工作原理\n\n官方给出了典型的开发过程：\n\n * （1）开发人员在编写并提交代码（最好在 IDE 中集成 sonarlint 插件，并在本地进行代码分析检测，减少更多的缺陷代码被集成到 SCM 上）\n * （2）SCM 通过 webhook 调用，触发 CI 持续集成，CI 触发 Sonar Scanner，将本地代码进行扫描分析，输出分析报告，并发送给 SonarQube 服务端\n * （3）SonarQube 接受分析报告并处理，最终渲染到UI界面\n\n\n\nSonarQube工作流程包含3个组件：\n\n * （1）Scanner：扫描器，负责将源文件进行代码分析，并将分析后的报告发送给SonarQube服务器\n * （2）SonarQube Server：SonarQube服务器，负责处理分析报告，后台管理等\n * （3）Database server：数据库服务器，负责存储数据\n\n\n\n\n# 2. SonarQube 功能与使用说明\n\n\n# 2.1 项目\n\n\n\n# 1. 项目-总览\n\n\n\n# 2. 项目-问题\n\n\n\n问题共分为三种类型：\n\n * Bug：潜在的代码缺陷，可能引起系统执行异常（比如空指针、魔法值等）\n * 漏洞：潜在的安全漏洞，比如sql注入、cors、xss攻击等\n * 异味：代码的坏味道。比如不遵循代码标准、糟糕的复杂度分布、注释不足或注释过多、糟糕的设计等\n\n（1）问题类型（不推荐修改）\n\n\n\n（2）问题的重要程度（不推荐修改）\n\n\n\n（3）问题状态，分为五个状态：\n\n * 打开：问题被质量分析后的初始状态（SonarQube）\n * 确认：问题修复后，需要开发人员手动指定，表示该问题已修复（开发人员）\n * 误判：标记问题为误判，表示此问题不应该标记为问题，无需处理（管理员）\n * 标记为不会修复：表示此问题不做处理（管理员）\n * 重新打开：当SonarQube再次分析报告时，若问题再次暴露则显示为重新打开（SonarQube）\n\n\n\n（4）问题指派：\n\n可以将问题分配给指定用户。\n\n\n\n当问题分配给其他用户后，若该用户有启动提醒功能，则SonarQube会发送邮件进行告警\n\n\n\n当 Sonar 分析报告后，会根据SCM的相关记录找到对应的用户，进行自动指派。\n\n\n\n（5）其他：\n\n\n\n# 3. 项目-安全热点\n\n安全热点是SonarQube检测出来可能存在安全问题，需要项目管理员进行复审，确认是否存在问题。\n\n\n\n# 3.1 项目-安全热点-复审：\n\n首先确保当前用户具有管理安全热点的权限\n\n\n\n具有安全热点管理权限后，按钮将显示为蓝色\n\n\n\n复审状态总共有三个，分别为\n\n * （1）需要复审：默认状态\n * （2）已修复：表示该安全代码已经修复\n * （3）安全：代码风险，无需修改\n\n\n\n# 3.2 项目-安全热点-SonarQube提醒/建议\n\n在这个板块，SonarQube会解释为何是安全代码，且告诉你怎么修复。（英语不好的人建议翻译一下）\n\n\n\n翻译后\n\n\n\n\n\n\n\n# 4. 项目-指标\n\n观测当前项目的代码质量\n\n\n\n# 5. 项目-代码\n\n即SCM更新下来的代码，没啥区别，SonarQube自己也会存储一份\n\n\n\n# 6. 项目-活动\n\n分析记录的日志\n\n\n\n# 7. 项目-项目配置\n\n\n\n管理项目的基本配置\n\n1.7.1、设置：\n\n设置项目的基本配置信息（不推荐）\n\n\n\n*1.7.2、新代码周期：*\n\n设置新代码周期的定义，默认按通用配置（即按上个版本的分析开始计算）。\n\n\n\n也可以指定其他选项，如“天数”，可以指定距离上次分析多少天的数据作为为新代码\n\n\n\n1.7.3、质量配置：\n\n质量配置，表示项目适配的质量配置，质量配置都是基于语言的，一个质量配置下面会存在多个代码规则。下图表示的项目qx_whale的质量配置基于java、xml两种语言，别分启用了452和11条代码规则。\n\n\n\n1.7.4、质量阈：\n\n它是项目质量是否合格的标准，通过设置质量阈来判断项目的代码质量是否达标。\n\n\n\n默认使用SonarQube内置的质量阈配置（Sonar way）\n\n\n\n也可以自定义质量阈，如笔者定义的My Sonar Way，只要出现阻断违规问题，就达不到质量阈的要求\n\n\n\n1.7.5、自定义指标：\n\n即项目-指标板块，展示项目的代码质量。 官方表示未来会废弃，所以不推荐大家使用\n\n\n\n1.7.6、链接：\n\n配置一些跳转链接，比如项目的首页地址。建议在SonarScanner运行时指定sonar.links.homepage去配置首页地址\n\n\n\n1.7.7、权限：\n\n当前项目的权限配置，后面用户与权限模块会特别介绍，这里就不赘述了\n\n\n\n1.7.8、后台任务：\n\n可以查看项目最近分析的记录\n\n\n\n1.7.9、更新标识：\n\nSonarQube每个项目的标识都是唯一的，请确保使用者的项目标识唯一！！！\n\n\n\n1.7.10、网络调用：\n\n俗称web hook，懂得都懂（可以与jenkins集成，将分析报告的质量阈状态回传，以便jenkins判断是否继续执行pipeline任务）\n\n\n\n1.7.11、删除：\n\n谨慎操作，点击删除后有二次确认操作。\n\n\n\n\n# 2.2 问题\n\n问题菜单跟“项目-问题”展示的基本一致，不同的是，问题菜单展示的是个人参与项目的所有问题，所以数量上相对较多\n\n\n\n\n# 2.3 代码规则\n\n代码规则，用来分析代码是否有问题\n\n\n\n\n\n\n# 2.4 质量配置\n\n质量配置，用于定义编程语言的代码分析集合。一个质量配置可以配置多个代码规则\n\n\n\n举个例子，我们看下质量配置/Java下的代码规则详情，下图表示Java语言的质量配置模板Sonar way，共配置了452个激活的规则，187个未激活的规则，一共配置了639个规则。\n\n\n\n内置质量模板Sonar way不允许修改，若用户想要自定义质量模板，必须拥有“质量配置管理员”的权限才可以进行操作。\n\n\n\n\n\n举个例子，新建一个Java语言的质量模板\n\n\n\n\n\n在左边的卡片“规则”中，我们点击“更多激活规则”\n\n\n\n\n\n回到质量模板MyJavaRule，可以看到我们配置了一条代码规则。那么质量配置就介绍到这里了。\n\n\n\n什么情况下会使用到质量配置呢？一般使用官方内置的Sonar way即可，如果有特殊需求的话，可以自己去定义质量模板。\n\n\n# 2.5 质量阈\n\n质量阈是一系列基于指标的布尔表达式，用户标准化质量，它可以帮助我们实时了解项目是否已经满足生产要求了。在集成进流水线的情况下，质量阈提供了质量卡点的能力，当存在质量项尚未达标的情况下，阻止发布流程进入到下一环节，流水线运行时会根据对应的质量红线对测试任务进行判断，是否能够通过红线，如果未通过红线，对应的任务将失败。但考虑在一些特殊的情况下，未通过质量红线的流程也需要继续往下执行，可以由管理员将红线跳过\n\n\n\n上图表示，所有项目默认的质量阈均为Sonar way，指标解释：新代码分析时，若覆盖率小于80% 或者 重复行大于3% 或者…安全比率劣于A时，判定为质量阈失败。\n\n# 质量阈-自定义质量阈\n\n默认情况下，所有项目使用相同的质量阈，每个项目的质量阈状态都会展示在首页。质量阈值也可以进行自定义，设定不同等级的阈值，对于老项目，会使用最低等级的阈值：阻断性的错误数量要求为0，对于一些新的项目，则严格要求质量如严重性的错误要求为0等，只要无法通过质量阈值检查，那么项目是无法上线的。\n\n自定义质量阈，首先要有质量阈管理员的权限，可以参考下图设置（建议技术经理或者项目负责人设置此权限）\n\n\n\n\n\n新建一个自定义质量阈MySonarWay，只添加一个条件，当阻断违规的问题大于0时，判定为质量阈失败。\n\n同时，还可以指定哪些项目使用此质量阈\n\n\n\n\n# 2.6 配置\n\n# 1. 用户与权限\n\n# 1.1 用户管理\n\n\n\n# 1.2 群组管理\n\n可以通过群组，来进行用户的统一授权\n\n\n\n# 2. 项目权限\n\n项目权限，用于设置公开或者私有，****公开项目所有人都可以访问，私有项目只有访问权限的人可以访问（推荐）\n\n\n\n设置项目权限范围，管理员等\n\n\n\n# 3. 用户与权限-最佳实践\n\n角色大致上可以分为三种：系统管理员、技术经理、开发人员\n\n（1）最佳实践-角色分工-系统管理员：\n\n系统管理员：只负责sonar平台的管理，不负责项目相关操作\n\n\n\n（2）最佳实践-角色分工-技术经理：\n\n技术经理：负责项目成员定义，项目组定义，权限分配，质量配置、质量阈等配置\n\n\n\n（3）最佳实践-角色分工-开发人员：\n\n开发人员：默认项目创建与项目执行分析，当开发人员创建项目时，该人员成为项目的管理者，拥有项目的所有权\n\n\n\n（4）最佳实践-权限模板：\n\n配置默认权限模板（Default template），项目创建人拥有项目的所有权。\n\n\n\n若技术经理也需要同等权力的话，可以主动申请成为项目的管理员(详见下图)\n\n\n\n# 4. 提醒（邮件告警）\n\n# 4.1 系统邮件设置\n\n\n\n\n\n\n\n# 4.2 项目提醒设置\n\n只有订阅了项目提醒，用户才会收到项目推送的邮件。在管理员进行问题分配给用户时，特别有用。以下介绍如何进行项目提醒设置：\n\n（1）方式一：\n\n进入项目\n\n\n\n点击项目信息，设置提醒\n\n\n\n全部勾选\n\n\n\n（2）方式二（推荐）：\n\n一步到位，设置也简单。在个人账号设置自己的\n\n> 1、主要参考文章：\n> \n> https://blog.csdn.net/weixin_31257709/article/details/124566064\n> \n> 2、推荐阅读：\n> \n> 从Code Review 谈如何做技术\n> \n> Code Review中的几个提示",normalizedContent:"# sonarqube代码质量检查平台\n\n\n# 前言：code review：\n\n随着业务的发展，系统越来越庞大，原本简单稳定的功能，可能在不断迭代后复杂度上升，潜在的风险也随之暴露，导致最终服务不稳定，造成业务价值的损失。而为了减少这种情况，有一种比较好的方式就是提高代码质量，比如通过 code review，从而降低错误风险。首先，我们先来看看 code reivew 的用处：\n\n * （1）code review 可以通过大家的建议改善代码的质量，提高代码的可读性、可维护性，以及确保程序逻辑和对需求、设计的实现的正确性\n * （2）code review 是一个传递知识的方式，让不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码\n * （3）code review 也鼓励程序员们相互学习对方的长处和优点\n * （4）code review 也可以被用来确认自己的设计和实现是一个清楚和简单的\n\n但在 code reivew 的诸多用处中，我们并没有提到可以帮助找到程序的bug和保证代码风格和编码规范，这是因为我们认为：\n\n * code review 不应该承担发现代码错误的职责。code review 主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证。\n * code review 不应该成为保证代码风格和编码规范的手段。编码规范和代码风格都属于死的东西，当把自己的代码提交给团队 review 时，代码就应该是符合规范的，这是属于每个人自己的事情，不应该交由团队来完成，否则只会浪费大家本来就不够的时间。\n\n当然，上述言论只是说上面两件事情并不是 code review 的意图，并不是说，你不能在 code review 中报告一个程序的bug或是一个代码规范的问题。如果要把上述两件事归入 code review 的职责，那将会导致 code review 增加大量的人力成本，且工作量随代码量的增加而增加，审查效率低；并且简单的 code review 只能解决代码风格问题，很难发现代码缺陷、漏洞、重复度、复杂度等方面的问题，效果差。\n\n所以，对于上面这两件事情，除了需要作者自己保证外，当然还有工具可以帮助我们检查代码规范的，比如下文介绍的 sonarqube 平台。\n\n\n# 1. sonarqube 整体介绍\n\n\n# 1.1 sonarqube 是什么?\n\nsonarqube 是一个代码质量管理的开源平台，通过 sonarqube 提供的代码扫描、质量阈值卡点等质量红线，我们可以提升系统的可靠性，提前捕获和提示代码中的错误，从而避免未定义的行为影响到用户，保证业务质量，也能确保管理的代码库干净并且可维护，以便提高开发人员的开发效率。\n\nsonarqube 可以从以下七个维度检测代码质量，而作为开发人员至少需要处理前5种代码质量问题。\n\n * （1）不遵循代码标准：sonar 可以通过 pmd、checkstyle、findbugs 等知名的静态代码规则分析工具规范代码编写。\n * （2）潜在的缺陷：sonar 可以通过 pmd、checkstyle、findbugs 等知名的静态代码规则分析工具检测出潜在的缺陷。\n * （3）糟糕的复杂度分布：文件、类、方法等，如果复杂度过高将难以改变，这会使得开发人员难以理解它们，且如果没有自动化的单元测试，对于程序中的任何组件的改变都将可能导致需要全面的回归测试。\n * （4）重复：显然程序中包含大量复制粘贴的代码是质量低下的，sonar 可以展示源码中重复严重的地方。\n * （5）注释不足或者过多：没有注释将使代码可读性变差，特别是当不可避免地出现人员变动时，程序的可读性将大幅下降，而过多的注释又会使得开发人员将精力过多地花费在阅读注释上，亦违背初衷。\n * （6）缺乏单元测试：sonar可以很方便地统计并展示单元测试覆盖率。\n * （7）糟糕的设计：通过sonar可以找出循环，展示包与包、类与类之间的相互依赖关系，可以检测自定义的架构规则，通过sonar可以管理第三方的jar包，可以利用lcom4检测单个任务规则的应用情况，检测耦合。\n\n另外 sonarqube 也可以生成详细的代码分析质量报告，并通过强大的仪表盘展示出来，使我们能够根据角色的不同，查看不同维度的度量标准。\n\n\n# 1.2 sonarqube 的工作原理\n\n官方给出了典型的开发过程：\n\n * （1）开发人员在编写并提交代码（最好在 ide 中集成 sonarlint 插件，并在本地进行代码分析检测，减少更多的缺陷代码被集成到 scm 上）\n * （2）scm 通过 webhook 调用，触发 ci 持续集成，ci 触发 sonar scanner，将本地代码进行扫描分析，输出分析报告，并发送给 sonarqube 服务端\n * （3）sonarqube 接受分析报告并处理，最终渲染到ui界面\n\n\n\nsonarqube工作流程包含3个组件：\n\n * （1）scanner：扫描器，负责将源文件进行代码分析，并将分析后的报告发送给sonarqube服务器\n * （2）sonarqube server：sonarqube服务器，负责处理分析报告，后台管理等\n * （3）database server：数据库服务器，负责存储数据\n\n\n\n\n# 2. sonarqube 功能与使用说明\n\n\n# 2.1 项目\n\n\n\n# 1. 项目-总览\n\n\n\n# 2. 项目-问题\n\n\n\n问题共分为三种类型：\n\n * bug：潜在的代码缺陷，可能引起系统执行异常（比如空指针、魔法值等）\n * 漏洞：潜在的安全漏洞，比如sql注入、cors、xss攻击等\n * 异味：代码的坏味道。比如不遵循代码标准、糟糕的复杂度分布、注释不足或注释过多、糟糕的设计等\n\n（1）问题类型（不推荐修改）\n\n\n\n（2）问题的重要程度（不推荐修改）\n\n\n\n（3）问题状态，分为五个状态：\n\n * 打开：问题被质量分析后的初始状态（sonarqube）\n * 确认：问题修复后，需要开发人员手动指定，表示该问题已修复（开发人员）\n * 误判：标记问题为误判，表示此问题不应该标记为问题，无需处理（管理员）\n * 标记为不会修复：表示此问题不做处理（管理员）\n * 重新打开：当sonarqube再次分析报告时，若问题再次暴露则显示为重新打开（sonarqube）\n\n\n\n（4）问题指派：\n\n可以将问题分配给指定用户。\n\n\n\n当问题分配给其他用户后，若该用户有启动提醒功能，则sonarqube会发送邮件进行告警\n\n\n\n当 sonar 分析报告后，会根据scm的相关记录找到对应的用户，进行自动指派。\n\n\n\n（5）其他：\n\n\n\n# 3. 项目-安全热点\n\n安全热点是sonarqube检测出来可能存在安全问题，需要项目管理员进行复审，确认是否存在问题。\n\n\n\n# 3.1 项目-安全热点-复审：\n\n首先确保当前用户具有管理安全热点的权限\n\n\n\n具有安全热点管理权限后，按钮将显示为蓝色\n\n\n\n复审状态总共有三个，分别为\n\n * （1）需要复审：默认状态\n * （2）已修复：表示该安全代码已经修复\n * （3）安全：代码风险，无需修改\n\n\n\n# 3.2 项目-安全热点-sonarqube提醒/建议\n\n在这个板块，sonarqube会解释为何是安全代码，且告诉你怎么修复。（英语不好的人建议翻译一下）\n\n\n\n翻译后\n\n\n\n\n\n\n\n# 4. 项目-指标\n\n观测当前项目的代码质量\n\n\n\n# 5. 项目-代码\n\n即scm更新下来的代码，没啥区别，sonarqube自己也会存储一份\n\n\n\n# 6. 项目-活动\n\n分析记录的日志\n\n\n\n# 7. 项目-项目配置\n\n\n\n管理项目的基本配置\n\n1.7.1、设置：\n\n设置项目的基本配置信息（不推荐）\n\n\n\n*1.7.2、新代码周期：*\n\n设置新代码周期的定义，默认按通用配置（即按上个版本的分析开始计算）。\n\n\n\n也可以指定其他选项，如“天数”，可以指定距离上次分析多少天的数据作为为新代码\n\n\n\n1.7.3、质量配置：\n\n质量配置，表示项目适配的质量配置，质量配置都是基于语言的，一个质量配置下面会存在多个代码规则。下图表示的项目qx_whale的质量配置基于java、xml两种语言，别分启用了452和11条代码规则。\n\n\n\n1.7.4、质量阈：\n\n它是项目质量是否合格的标准，通过设置质量阈来判断项目的代码质量是否达标。\n\n\n\n默认使用sonarqube内置的质量阈配置（sonar way）\n\n\n\n也可以自定义质量阈，如笔者定义的my sonar way，只要出现阻断违规问题，就达不到质量阈的要求\n\n\n\n1.7.5、自定义指标：\n\n即项目-指标板块，展示项目的代码质量。 官方表示未来会废弃，所以不推荐大家使用\n\n\n\n1.7.6、链接：\n\n配置一些跳转链接，比如项目的首页地址。建议在sonarscanner运行时指定sonar.links.homepage去配置首页地址\n\n\n\n1.7.7、权限：\n\n当前项目的权限配置，后面用户与权限模块会特别介绍，这里就不赘述了\n\n\n\n1.7.8、后台任务：\n\n可以查看项目最近分析的记录\n\n\n\n1.7.9、更新标识：\n\nsonarqube每个项目的标识都是唯一的，请确保使用者的项目标识唯一！！！\n\n\n\n1.7.10、网络调用：\n\n俗称web hook，懂得都懂（可以与jenkins集成，将分析报告的质量阈状态回传，以便jenkins判断是否继续执行pipeline任务）\n\n\n\n1.7.11、删除：\n\n谨慎操作，点击删除后有二次确认操作。\n\n\n\n\n# 2.2 问题\n\n问题菜单跟“项目-问题”展示的基本一致，不同的是，问题菜单展示的是个人参与项目的所有问题，所以数量上相对较多\n\n\n\n\n# 2.3 代码规则\n\n代码规则，用来分析代码是否有问题\n\n\n\n\n\n\n# 2.4 质量配置\n\n质量配置，用于定义编程语言的代码分析集合。一个质量配置可以配置多个代码规则\n\n\n\n举个例子，我们看下质量配置/java下的代码规则详情，下图表示java语言的质量配置模板sonar way，共配置了452个激活的规则，187个未激活的规则，一共配置了639个规则。\n\n\n\n内置质量模板sonar way不允许修改，若用户想要自定义质量模板，必须拥有“质量配置管理员”的权限才可以进行操作。\n\n\n\n\n\n举个例子，新建一个java语言的质量模板\n\n\n\n\n\n在左边的卡片“规则”中，我们点击“更多激活规则”\n\n\n\n\n\n回到质量模板myjavarule，可以看到我们配置了一条代码规则。那么质量配置就介绍到这里了。\n\n\n\n什么情况下会使用到质量配置呢？一般使用官方内置的sonar way即可，如果有特殊需求的话，可以自己去定义质量模板。\n\n\n# 2.5 质量阈\n\n质量阈是一系列基于指标的布尔表达式，用户标准化质量，它可以帮助我们实时了解项目是否已经满足生产要求了。在集成进流水线的情况下，质量阈提供了质量卡点的能力，当存在质量项尚未达标的情况下，阻止发布流程进入到下一环节，流水线运行时会根据对应的质量红线对测试任务进行判断，是否能够通过红线，如果未通过红线，对应的任务将失败。但考虑在一些特殊的情况下，未通过质量红线的流程也需要继续往下执行，可以由管理员将红线跳过\n\n\n\n上图表示，所有项目默认的质量阈均为sonar way，指标解释：新代码分析时，若覆盖率小于80% 或者 重复行大于3% 或者…安全比率劣于a时，判定为质量阈失败。\n\n# 质量阈-自定义质量阈\n\n默认情况下，所有项目使用相同的质量阈，每个项目的质量阈状态都会展示在首页。质量阈值也可以进行自定义，设定不同等级的阈值，对于老项目，会使用最低等级的阈值：阻断性的错误数量要求为0，对于一些新的项目，则严格要求质量如严重性的错误要求为0等，只要无法通过质量阈值检查，那么项目是无法上线的。\n\n自定义质量阈，首先要有质量阈管理员的权限，可以参考下图设置（建议技术经理或者项目负责人设置此权限）\n\n\n\n\n\n新建一个自定义质量阈mysonarway，只添加一个条件，当阻断违规的问题大于0时，判定为质量阈失败。\n\n同时，还可以指定哪些项目使用此质量阈\n\n\n\n\n# 2.6 配置\n\n# 1. 用户与权限\n\n# 1.1 用户管理\n\n\n\n# 1.2 群组管理\n\n可以通过群组，来进行用户的统一授权\n\n\n\n# 2. 项目权限\n\n项目权限，用于设置公开或者私有，****公开项目所有人都可以访问，私有项目只有访问权限的人可以访问（推荐）\n\n\n\n设置项目权限范围，管理员等\n\n\n\n# 3. 用户与权限-最佳实践\n\n角色大致上可以分为三种：系统管理员、技术经理、开发人员\n\n（1）最佳实践-角色分工-系统管理员：\n\n系统管理员：只负责sonar平台的管理，不负责项目相关操作\n\n\n\n（2）最佳实践-角色分工-技术经理：\n\n技术经理：负责项目成员定义，项目组定义，权限分配，质量配置、质量阈等配置\n\n\n\n（3）最佳实践-角色分工-开发人员：\n\n开发人员：默认项目创建与项目执行分析，当开发人员创建项目时，该人员成为项目的管理者，拥有项目的所有权\n\n\n\n（4）最佳实践-权限模板：\n\n配置默认权限模板（default template），项目创建人拥有项目的所有权。\n\n\n\n若技术经理也需要同等权力的话，可以主动申请成为项目的管理员(详见下图)\n\n\n\n# 4. 提醒（邮件告警）\n\n# 4.1 系统邮件设置\n\n\n\n\n\n\n\n# 4.2 项目提醒设置\n\n只有订阅了项目提醒，用户才会收到项目推送的邮件。在管理员进行问题分配给用户时，特别有用。以下介绍如何进行项目提醒设置：\n\n（1）方式一：\n\n进入项目\n\n\n\n点击项目信息，设置提醒\n\n\n\n全部勾选\n\n\n\n（2）方式二（推荐）：\n\n一步到位，设置也简单。在个人账号设置自己的\n\n> 1、主要参考文章：\n> \n> https://blog.csdn.net/weixin_31257709/article/details/124566064\n> \n> 2、推荐阅读：\n> \n> 从code review 谈如何做技术\n> \n> code review中的几个提示",charsets:{cjk:!0},lastUpdated:"2023/03/10, 08:04:32",lastUpdatedTimestamp:1678406672e3},{title:"博客文章",frontmatter:{archivesPage:!0,title:"博客文章",permalink:"/blog/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-79cae889",path:"/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/27, 17:13:48",lastUpdatedTimestamp:1677489228e3},{title:"Home",frontmatter:{home:!0,heroImage:"https://chggx-typora.oss-cn-beijing.aliyuncs.com/typora/202302271042851.png",heroText:"chggx-knowledge",tagline:"👻==💲=====后端程序员【面向薪资编程】====💲==👻",actionText:"开始使用 →",actionLink:"/pages/ec1391/",bannerBg:"none",features:[{title:"知识管理",details:"日常学习笔记。"},{title:"问题",details:"记录开发过程中问题, 及解决方法。"},{title:"其他",details:"其他。"}],postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-2572d8b5",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/28, 18:23:46",lastUpdatedTimestamp:1677579826e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"语言",link:"/pages/ec1391/",items:[{text:"JAVA语言",items:[{text:"语言基础",link:"/pages/ec1391/"},{text:"JVM",link:"/pages/9faa36/"},{text:"并发&多线程",link:"/pages/"}]},{text:"C语言",items:[{text:"语言基础",link:"/pages/"}]},{text:"C++语言",items:[{text:"语言基础",link:"/pages/"}]},{text:"数据库",items:[{text:"MySQL基础",link:"/pages/29740f/"},{text:"MySQL高级",link:"/pages/"},{text:"Influxdb",link:"/pages/ff9a50/"}]}]},{text:"编程基础",link:"/pages/febdf1/",items:[{text:"数据结构和算法",items:[{text:"数据结构",link:"/pages/febdf1/"},{text:"算法",link:"/pages/"}]},{text:"计算机网络",link:"/pages/"},{text:"操作系统",link:"/pages/"},{text:"设计模式",link:"/pages/391852/"}]},{text:"开发工具",link:"/pages/3d8e99/",items:[{text:"集成开发环境",items:[{text:"IDEA",link:"/pages/6ad6ad/"},{text:"VSCode",link:"/pages/d486f7/"},{text:"数据库工具",link:"/pages/17afa5/"},{text:"接口测试工具",link:"/pages/5082de/"}]},{text:"Linux系统",link:"/pages/"},{text:"代码管理工具",items:[{text:"Svn",link:"/pages/00b1bb/"},{text:"Git",link:"/pages/d486f7/"}]},{text:"项目管理&构建工具",items:[{text:"Maven",link:"/pages/020d30/"},{text:"Gradle",link:"/pages/"}]}]},{text:"后端应用框架",link:"/pages/0705f0/",items:[{text:"Spring家族",items:[{text:"Spring",link:"/pages/0705f0/"},{text:"SpringMVC",link:"/pages/"},{text:"SpringBoot",link:"/pages/c71dea/"}]},{text:"服务器软件",items:[{text:"Web服务器",link:"/pages/"},{text:"应用服务器",link:"/pages/"}]},{text:"中间件",items:[{text:"缓存",link:"/pages/1db5d1/"},{text:"消息队列",link:"/pages/"},{text:"RPC架构",link:"/pages/"}]},{text:"数据库",items:[{text:"数据库",link:"/pages/"},{text:"ORM层框架",link:"/pages/"},{text:"连接池",link:"/pages/"},{text:"分库分表",link:"/pages/"}]},{text:"搜索引擎",items:[{text:"ElasticSearch",link:"/pages/6641bc/"},{text:"Solr",link:"/pages/"}]},{text:"分布式/微服务",items:[{text:"服务发现/注册",link:"/pages/"},{text:"网关",link:"/pages/"},{text:"服务调用（负载均衡）",link:"/pages/"},{text:"熔断/降级",link:"/pages/"},{text:"配置中心",link:"/pages/"},{text:"认证和鉴权",link:"/pages/"},{text:"分布式事务",link:"/pages/"},{text:"任务调度",link:"/pages/"},{text:"链路追踪与监控",link:"/pages/"},{text:"日志分析与监控",link:"/pages/"},{text:"虚拟化/容器化",link:"/pages/"}]}]},{text:"前端应用框架",link:"/pages/3ae290/",items:[{text:"基础套餐",items:[{text:"三大件",link:"/pages/3ae290/"},{text:"基础库",link:"/pages/"}]},{text:"模板框架",items:[{text:"JSP/JSTL",link:"/pages/"},{text:"Thymeleaf",link:"/pages/"},{text:"FreeMarker",link:"/pages/"}]},{text:"组件化框架",items:[{text:"Node",link:"/pages/abd7cf/"},{text:"VUE",link:"/pages/"},{text:"React",link:"/pages/"},{text:"Angular",link:"/pages/"}]}]},{text:"运维知识",link:"/pages/bcb9d3/",items:[{text:"Web服务器",link:"/pages/bcb9d3/"},{text:"应用服务器",link:"/pages/"},{text:"CDN加速",link:"/pages/"},{text:"持续集成/持续发布",link:"/pages/"},{text:"代码质量检查",link:"/pages/e8fc76/"},{text:"日志收集/分析",link:"/pages/"}]}],sidebarDepth:2,logo:"https://chggx-typora.oss-cn-beijing.aliyuncs.com/typora/202302271042851.png",repo:"https://github.com/ABirdFree",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/01.语言/":[{title:"JAVA语言",collapsable:!0,children:[{title:"语言基础",collapsable:!0,children:[["01.JAVA语言/01.语言基础/01.基础语法.md","基础语法","/pages/ec1391/"],["01.JAVA语言/01.语言基础/02.面向对象.md","面向对象","/pages/2876f0/"],["01.JAVA语言/01.语言基础/03.访问控制权限.md","访问控制权限","/pages/8e5736/"],["01.JAVA语言/01.语言基础/04.接口和抽象类.md","接口和抽象类","/pages/8ae350/"],["01.JAVA语言/01.语言基础/05.内部类.md","内部类","/pages/646bcb/"],["01.JAVA语言/01.语言基础/06.异常.md","异常","/pages/98887c/"],["01.JAVA语言/01.语言基础/07.集合.md","集合","/pages/27a8e1/"],["01.JAVA语言/01.语言基础/08.数组.md","数组","/pages/5a582f/"],["01.JAVA语言/01.语言基础/09.枚举.md","枚举","/pages/1ca5ad/"],["01.JAVA语言/01.语言基础/10.反射.md","反射","/pages/07d6bb/"],["01.JAVA语言/01.语言基础/11.IO流.md","IO","/pages/539c95/"],["01.JAVA语言/01.语言基础/12.IO流案例.md","IO流案例","/pages/2e167c/"],["01.JAVA语言/01.语言基础/13.注解.md","注解","/pages/704cf9/"],["01.JAVA语言/01.语言基础/20.Java8新特性.md","Java8新特性","/pages/e31263/"],["01.JAVA语言/01.语言基础/100.常用API.md","常用API","/pages/5d20e5/"]]},{title:"JVM",collapsable:!0,children:[["01.JAVA语言/02.JVM/1.JVM-JVM与Java体系结构.md","JVM-JVM与Java体系结构","/pages/9faa36/"],["01.JAVA语言/02.JVM/2.JVM-类加载子系统.md","JVM-类加载子系统","/pages/bac2fa/"],["01.JAVA语言/02.JVM/3.JVM-运行时数据区概述及线程.md","JVM-运行时数据区概述及线程","/pages/c15e11/"],["01.JAVA语言/02.JVM/4.JVM-程序计数器(PC寄存器).md","JVM-程序计数器(PC寄存器)","/pages/797fac/"],["01.JAVA语言/02.JVM/5.JVM-虚拟机栈.md","JVM-虚拟机栈","/pages/42fe7b/"],["01.JAVA语言/02.JVM/6.JVM-本地方法接口.md","JVM-本地方法接口","/pages/38174c/"],["01.JAVA语言/02.JVM/7.JVM-本地方法栈.md","JVM-本地方法栈","/pages/ba6197/"],["01.JAVA语言/02.JVM/8.JVM-堆.md","JVM-堆","/pages/32d7be/"],["01.JAVA语言/02.JVM/9.JVM-方法区.md","JVM-方法区","/pages/2f74c5/"],["01.JAVA语言/02.JVM/10.JVM-对象的实例化内存布局与访问定位.md","JVM-对象的实例化内存布局与访问定位","/pages/9fa953/"],["01.JAVA语言/02.JVM/12.JVM-执行引擎.md","JVM-执行引擎","/pages/64de09/"],["01.JAVA语言/02.JVM/13.JVM-StringTable.md","JVM-StringTable","/pages/6cfffc/"],["01.JAVA语言/02.JVM/14.JVM-垃圾回收概述.md","JVM-垃圾回收概述","/pages/a75cf5/"],["01.JAVA语言/02.JVM/15.JVM-垃圾回收相关算法.md","JVM-垃圾回收相关算法","/pages/c0a9b6/"],["01.JAVA语言/02.JVM/16.JVM-垃圾回收相关概念.md","JVM-垃圾回收相关概念","/pages/e20df8/"]]},{title:"并发&多线程",collapsable:!0,children:[]}]},{title:"C语言",collapsable:!0,children:[]},{title:"C++语言",collapsable:!0,children:[]},{title:"数据库",collapsable:!0,children:[{title:"MySQL基础",collapsable:!0,children:[["04.数据库/01.MySQL基础/01.MySQL基础-数据库概述.md","数据库概述","/pages/29740f/"],["04.数据库/01.MySQL基础/02.MySQL基础-MySQL环境搭建(windows版).md","MySQL环境搭建(windows版)","/pages/274d31/"],["04.数据库/01.MySQL基础/03.MySQL基础-SQL语句.md","SQL语句","/pages/10beff/"],["04.数据库/01.MySQL基础/04.MySQL基础-基础语句.md","基础语句","/pages/a5b5c4/"],["04.数据库/01.MySQL基础/05.MySQL基础-运算符.md","运算符","/pages/d5d2c6/"],["04.数据库/01.MySQL基础/06.MySQL基础-多表查询.md","多表查询","/pages/9ed39a/"],["04.数据库/01.MySQL基础/07.MySQL基础-单行函数.md","单行","/pages/333675/"]]},{title:"MySQL高级",collapsable:!0,children:[]},{title:"Influxdb",collapsable:!0,children:[["04.数据库/03.Influxdb/21.时序数据库-influxdb.md","时序数据库-influxdb","/pages/ff9a50/"]]}]}],catalogue:{},"/02.编程基础/":[{title:"数据结构和算法",collapsable:!0,children:[{title:"数据结构",collapsable:!0,children:[["01.数据结构和算法/01.数据结构/01.数据结构.md","数据结构","/pages/febdf1/"]]},{title:"算法",collapsable:!0,children:[]}]},{title:"计算机网络",collapsable:!0,children:[]},{title:"操作系统",collapsable:!0,children:[]},{title:"设计模式",collapsable:!0,children:[["04.设计模式/0.Java设计模式-内容介绍.md","Java设计模式-内容介绍","/pages/391852/"],["04.设计模式/1.Java设计模式-设计模式七大原则.md","Java设计模式-设计模式七大原则","/pages/f21426/"],["04.设计模式/2.Java设计模式-UML类图.md","Java设计模式-UML类图","/pages/5247a4/"],["04.设计模式/3.Java设计模式-设计模式概述.md","Java设计模式-设计模式概述","/pages/d2284f/"],["04.设计模式/4.Java设计模式-单例模式.md","Java设计模式-单例模式","/pages/4c822c/"],["04.设计模式/5.Java设计模式-工厂模式.md","Java设计模式-工厂模式","/pages/40d394/"],["04.设计模式/6.Java设计模式-原型模式.md","Java设计模式-原型模式","/pages/9814ac/"],["04.设计模式/7.Java设计模式-建造者模式.md","Java设计模式-建造者模式","/pages/85ff30/"]]}],"/03.开发工具/":[{title:"集成开发环境",collapsable:!0,children:[{title:"IDEA",collapsable:!0,children:[["01.集成开发环境/01.IDEA/01.IDEA配置.md","IDEA配置","/pages/6ad6ad/"],["01.集成开发环境/01.IDEA/02.IDEA快捷键(windows).md","IDEA快捷键(windows)","/pages/9f28c6/"],["01.集成开发环境/01.IDEA/03.IDEA必备插件.md","IDEA必备插件","/pages/17fe21/"]]},{title:"VSCode",collapsable:!0,children:[["01.集成开发环境/02.VSCode/01.VSCode.md","VSCode","/pages/e4d5d1/"]]},{title:"数据库工具",collapsable:!0,children:[["01.集成开发环境/03.数据库工具/01.MySQL图形化管理工具.md","MySQL图形化管理工具","/pages/17afa5/"]]},{title:"接口测试工具",collapsable:!0,children:[["01.集成开发环境/04.接口测试工具/01.接口测试工具.md","接口测试工具","/pages/5082de/"]]}]},{title:"Linux系统",collapsable:!0,children:[]},{title:"代码管理工具",collapsable:!0,children:[{title:"Svn",collapsable:!0,children:[["03.代码管理工具/01.Svn/1.SVN基础.md","SVN基础","/pages/00b1bb/"]]},{title:"Git",collapsable:!0,children:[["03.代码管理工具/02.Git/1.Git安装.md","Git安装","/pages/d486f7/"],["03.代码管理工具/02.Git/2.Git常用命令.md","Git常用命令","/pages/8e6be6/"],["03.代码管理工具/02.Git/3.Git配置用户信息和SSH免密.md","Git配置用户信息和SSH免密","/pages/502fb9/"]]}]},{title:"项目管理&构建工具",collapsable:!0,children:[{title:"Maven",collapsable:!0,children:[["04.项目管理&构建工具/01.Maven/01.Maven下载安装与配置.md","Maven下载安装与配置","/pages/020d30/"]]}]}],"/04.后端应用框架/":[{title:"Spring家族",collapsable:!0,children:[{title:"Spring",collapsable:!0,children:[["01.Spring家族/01.Spring/0.反射&注解.md","反射&注解","/pages/0705f0/"],["01.Spring家族/01.Spring/1.Spring基础.md","Spring基础","/pages/cb7d50/"]]},{title:"SpringMVC",collapsable:!0,children:[]},{title:"SpringBoot",collapsable:!0,children:[["01.Spring家族/03.SpringBoot/1.SpringBoot基础.md","SpringBoot基础","/pages/c71dea/"],["01.Spring家族/03.SpringBoot/2.SpringBoot整合RabbitMQ.md","SpringBoot整合RabbitMQ","/pages/9c9eda/"]]}]},{title:"服务器软件",collapsable:!0,children:[{title:"Web服务器",collapsable:!0,children:[]},{title:"应用服务器",collapsable:!0,children:[]}]},{title:"中间件",collapsable:!0,children:[{title:"缓存",collapsable:!0,children:[["03.中间件/01.缓存/1.Redis入门.md","Redis入门","/pages/1db5d1/"],["03.中间件/01.缓存/2.Redis数据类型.md","Redis数据类型","/pages/f64944/"],["03.中间件/01.缓存/3.Redis事务.md","Redis事务","/pages/83c6d3/"],["03.中间件/01.缓存/4.Redis实现乐观锁.md","Redis实现乐观锁","/pages/1d5ebe/"],["03.中间件/01.缓存/5.Redis-Jedis.md","Redis-Jedis","/pages/4fbc1c/"],["03.中间件/01.缓存/6.SpringBoot整合.md","SpringBoot整合","/pages/315078/"],["03.中间件/01.缓存/7.Redis的配置文件详解.md","Redis的配置文件详解","/pages/255a13/"]]},{title:"消息队列",collapsable:!0,children:[]},{title:"RPC架构",collapsable:!0,children:[]}]},{title:"数据库",collapsable:!0,children:[{title:"ORM层框架",collapsable:!0,children:[]},{title:"连接池",collapsable:!0,children:[]},{title:"分库分表",collapsable:!0,children:[]}]},{title:"搜索引擎",collapsable:!0,children:[{title:"ElasticSearch",collapsable:!0,children:[["05.搜索引擎/01.ElasticSearch/01.ElasticSearch7.6.1快速入门.md","ElasticSearch7.6.1快速入门","/pages/6641bc/"]]},{title:"Solr",collapsable:!0,children:[]}]},{title:"分布式或微服务",collapsable:!0,children:[{title:"服务发现或注册",collapsable:!0,children:[]},{title:"网关",collapsable:!0,children:[]},{title:"服务调用（负载均衡）",collapsable:!0,children:[]},{title:"熔断或降级",collapsable:!0,children:[]},{title:"配置中心",collapsable:!0,children:[]},{title:"认证和鉴权",collapsable:!0,children:[]},{title:"分布式事务",collapsable:!0,children:[]},{title:"任务调度",collapsable:!0,children:[]},{title:"链路追踪与监控",collapsable:!0,children:[]},{title:"日志分析与监控",collapsable:!0,children:[]},{title:"虚拟化或容器化",collapsable:!0,children:[]}]}],"/05.前端应用框架/":[{title:"基础套餐",collapsable:!0,children:[{title:"三大件",collapsable:!0,children:[["01.基础套餐/01.三大件/01.HTML.md","HTML","/pages/3ae290/"]]},{title:"基础库",collapsable:!0,children:[]}]},{title:"模板框架",collapsable:!0,children:[{title:"JSP或JSTL",collapsable:!0,children:[]},{title:"Thymeleaf",collapsable:!0,children:[]},{title:"FreeMarker",collapsable:!0,children:[]}]},{title:"组件化框架",collapsable:!0,children:[{title:"Node",collapsable:!0,children:[["03.组件化框架/01.Node/01.下载node.md","下载node","/pages/abd7cf/"],["03.组件化框架/01.Node/02.yarn常用命令.md","yarn常用命令","/pages/5ca64b/"]]},{title:"VUE",collapsable:!0,children:[]},{title:"React",collapsable:!0,children:[]},{title:"Angular",collapsable:!0,children:[]}]}],"/06.运维知识/":[{title:"Web服务器",collapsable:!0,children:[["01.Web服务器/01.Nginx.md","Nginx","/pages/bcb9d3/"]]},{title:"应用服务器",collapsable:!0,children:[]},{title:"CDN加速",collapsable:!0,children:[]},{title:"持续集成或持续发布",collapsable:!0,children:[]},{title:"代码质量检查",collapsable:!0,children:[["05.代码质量检查/01..代码质量检查平台-SonarQube.md","SonarQube","/pages/e8fc76/"]]},{title:"日志收集或分析",collapsable:!0,children:[]}]},updateBar:{showToArticle:!1},pageStyle:"line",category:!1,tag:!1,author:{name:"晨光-向",href:"https://github.com/ABirdFree"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:1348088236@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/ABirdFree"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2022,copyrightInfo:"晨光向 | MIT License"},htmlModules:{pageT:'\n    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>\n    <style>\n      .page-wwads{\n        width:100%!important;\n        min-height: 0;\n        margin: 0;\n      }\n      .page-wwads .wwads-img img{\n        width:80px!important;\n      }\n      .page-wwads .wwads-poweredby{\n        width: 40px;\n        position: absolute;\n        right: 25px;\n        bottom: 3px;\n      }\n      .wwads-content .wwads-text, .page-wwads .wwads-text{\n        height: 100%;\n        padding-top: 5px;\n        display: block;\n      }\n  </style>\n  '}}};var xo=t(94),wo=t(95),jo=t(11);var To={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(jo.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(jo.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(jo.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,i=n.length;a<i;a++){const{frontmatter:{categories:i,tags:r}}=n[a];"array"===Object(jo.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(jo.n)(r)&&r.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Ht.component(xo.default),Ht.component(wo.default);function _o(n){return n.toString().padStart(2,"0")}t(243);Ht.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94))),Ht.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95))),Ht.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,406)));t(244);var ko=[({Vue:n,options:e,router:t,siteData:a,isServer:i})=>{i||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://fastly.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".page-wwads");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${_o(n.getUTCMonth()+1)}-${_o(n.getUTCDate())} ${_o(n.getUTCHours())}:${_o(n.getUTCMinutes())}:${_o(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(To)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?01293bffa6c3962016c08ba685c79d78";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],Eo=[];class Io extends class{constructor(){this.store=new Ht({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Ht.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Io.prototype,{getPageAsyncComponent:rl,getLayoutAsyncComponent:sl,getAsyncComponent:ll,getVueComponent:ol});var zo={install(n){const e=new Io;n.$vuepress=e,n.prototype.$vuepress=e}};function Co(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Ao={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return pl("pageKey",e),Ht.component(e)||Ht.component(e,rl(e)),Ht.component(e)?n(e):n("")}},Lo={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Oo={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Do=(t(245),t(246),Object(bo.a)(Oo,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Mo={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Ht.config.productionTip=!1,Ht.use(Us),Ht.use(zo),Ht.mixin(function(n,e,t=Ht){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),r={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),r),{computed:r}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},So)),Ht.component("Content",Ao),Ht.component("ContentSlotsDistributor",Lo),Ht.component("OutboundLink",Do),Ht.component("ClientOnly",Mo),Ht.component("Layout",sl("Layout")),Ht.component("NotFound",sl("NotFound")),Ht.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"1aeea3a"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:So.routerBase||So.base,t=new Us({base:e,mode:"history",fallback:!1,routes:fo,scrollBehavior:(n,e,t)=>t||(n.hash?!Ht.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Co(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Co(n,t)?a(t):a()}else a();else{const t=e.path+"/",i=e.path+".html";Co(n,i)?a(i):Co(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(ko.filter(n=>"function"==typeof n).map(e=>e({Vue:Ht,options:a,router:t,siteData:So,isServer:n})))}catch(n){console.error(n)}return{app:new Ht(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Eo.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);